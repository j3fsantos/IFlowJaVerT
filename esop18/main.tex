\documentclass{llncs}
%

%External Packages
\usepackage{makeidx}  % allows for indexgeneration
\usepackage[table]{xcolor}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{xspace}
\usepackage{textcomp}
\usepackage{amssymb,amsfonts,latexsym,wasysym,mathrsfs,textcomp,stmaryrd}
\usepackage{mathpartir}
\usepackage{url}
\usepackage{upgreek}
\usepackage{xparse}
%\usepackage{algorithm}
%\usepackage{algpseudocode}

\usepackage{wrapfig}

%JavaScript 
\definecolor{SkyBlue}{rgb}{0.20,0.39,0.64}
\definecolor{Plum}{rgb}{0.46,0.31,0.48}
\definecolor{Chocolate}{rgb}{0.75,0.49,0.07}
\definecolor{Aluminium5}{rgb}{0.33,0.34,0.32}
\definecolor{DarkGreen}{rgb}{0.2,0.5,0.2}
\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkblue}{rgb}{0,0.2,0.7}
\definecolor{dkgreen}{rgb}{0,0.4,0}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}
\definecolor{dkred}{rgb}{0.6,0,0}
\definecolor{talkred}{rgb}{0.69,.20,0.22}
\definecolor{talkblue}{rgb}{0.04,0.40,0.80}
\definecolor{talkgreen}{rgb}{0.34,.81,0.10}
\definecolor{oldtalkblue}{rgb}{0.22,.20,0.69}
\definecolor{greenish}{rgb}{.0,.65,.0}

\lstdefinelanguage{JavaScript}{
  morekeywords=[1]{typeof, new, true, false, catch,
    function, return, null, catch, switch, var,
    if, in, while, do, else, case, break, continue},
  morekeywords=[2]{class, export, boolean, throw, implements, import, this},
  numbers=left,
  numbersep=4pt,
  numberstyle=\tiny\color{dkblue},
  columns=fullflexible,
  sensitive=false,
  comment=[l]{//},
  captionpos=b,   
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  basicstyle=\scriptsize\texttt,
  identifierstyle=\ttfamily\color{Aluminium5},
  keywordstyle=[1]\ttfamily\color{Plum},
  keywordstyle=[2]\ttfamily\color{SkyBlue},
  stringstyle=\ttfamily\color{DarkGreen},
  commentstyle=\ttfamily
}[keywords,comments,strings]

\lstdefinelanguage{Scheme}{
  morekeywords=[1]{define, define-syntax, define-macro, lambda, define-stream, stream-lambda},
  morekeywords=[2]{begin, call-with-current-continuation, call/cc,
    call-with-input-file, call-with-output-file, case, cond,
    do, else, for-each, if,
    let*, let, let-syntax, letrec, letrec-syntax,
    let-values, let*-values,
    and, or, not, delay, force,
    quasiquote, quote, unquote, unquote-splicing,
    map, fold, syntax, syntax-rules, eval, environment, query },
  morekeywords=[3]{import, export},
  alsodigit=!\$\%&*+-./:<=>?@^_~,
  sensitive=true,
  morecomment=[l]{;},
  morecomment=[s]{\#|}{|\#},
  morestring=[b]",
  basicstyle=\scriptsize\ttfamily,
  keywordstyle=\bf\ttfamily\color[rgb]{0,.3,.7},
  commentstyle=\color[rgb]{0.133,0.545,0.133},
  stringstyle={\color[rgb]{0.75,0.49,0.07}},
  upquote=true,
  breaklines=true,
  breakatwhitespace=true,
  literate=*{`}{{`}}{1}
}

\lstnewenvironment{lstjs}{\lstset{language=JavaScript,basicstyle=\fontsize{8}{8}\ttfamily,escapeinside={~}{~}}}{}
\def\jsinline{\lstinline[language=JavaScript, basicstyle=\small]}


% The Acronyms of the project and some other stuff
\newcommand{\jsil}{JSIL\xspace}
\newcommand{\jsverify}{JSVerify\xspace}
\newcommand{\JSComp}{JS-2-JSIL\xspace}
\newcommand{\jsilverify}{JSILVerify\xspace}


% Tikz 
\usepackage{tikz}
\usetikzlibrary{calc,positioning,arrows,shapes,decorations.pathmorphing}
\usetikzlibrary{arrows,positioning} 
\tikzset{
    %Define standard arrow tip
    >=stealth',
    % Define arrow style
    pil/.style={
           ->,
           shorten <=2pt,
           shorten >=2pt,}
}

\newcommand{\runpic}{\includegraphics[width=0.06\picwidth]{running.pdf}}
\newcommand{\tickpic}{\resizebox{0.06\picwidth}{!}{\(\color{greenish} \checkmark \)}}
\tikzset{
  box/.style = {rectangle, draw=black,align=center,font=\scriptsize},
  sbox/.style = {rectangle,draw=black,align=left,font=\scriptsize,text width=1.7cm},
  p/.style = {-latex},
  dp/.style = {latex-latex},
  sz/.style n args={2}{minimum width=#2, minimum height=#1},
  m/.style = {midway,inner sep=0pt,fill=white},
  ll/.style = {font=\scriptsize,anchor=south west}
}



% Polishing...
\newcommand{\polish}[1]{{\color{red}#1}}

% macros_js as for Jose Santos
\usepackage{macros_js}
\usepackage{gdshojs}

\newcommand{\jilette}{Jilette\xspace}

\newcommand{\myparagraph}[1]{\smallskip\noindent {\bf #1.}\hspace{1pt}}

% COMMENTS

\newcommand{\pginline}[1]{ {\color{red} *** PG : #1 ***} }
\newcommand{\pmaxinline}[1]{ {\color{blue} *** PM : #1 ***} }
\newcommand{\jfsinline}[1]{ {\color{green} *** JFS : #1 ***} }
\newcommand{\jdinline}[1]{ {\color{purple} *** JD : #1 ***} }

\newif\ifComments
\Commentstrue

\newcommand{\pg}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.95\textwidth} \color{red}
{\rm PG: \small #1}
\end{minipage}}
\end{center}
\fi}

\newcommand{\pmax}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.95\textwidth} \color{blue}
{\rm PM: \small #1}
\end{minipage}}
\end{center}
\fi}

\newcommand{\jfs}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.95\textwidth} \color{green}
{\rm JFS: \small #1}
\end{minipage}}
\end{center}
\fi}

\newcommand{\jd}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.95\textwidth} \color{purple}
{\rm JD: \small #1}
\end{minipage}}
\end{center}
\fi}

%
\title{\jilette: Symbolic Execution for JavaScript}

\author{}

\institute{}


\begin{document}
%

\maketitle 

\begin{abstract}
We present \jilette: a symbolic execution tool for JavaScript, which precisely follows the language standard. At the core of \jilette is a symbolic interpreter for \jsil, an intermediate language well-suited for verification and analysis. This interpreter is written in \underline{Rosette}, a symbolic virtual machine that enables the design of new solver-aided languages. 
\jilette works by first compiling JavaScript programs to \jsil using \underline{\JSComp}, a well-tested, standard-compliant compiler from JavaScript to \jsil, and then symbolically executing the compiled \jsil code in the \jsil symbolic interpreter. 
We study two complementary uses of \jilette. 
First, we show how \jilette can be used for symbolic testing of JavaScript programs by finding concrete executions that trigger assertion and test failures. 
Second, building on \jilette, we develop a tool for debugging separation logic specifications
by compiling them to symbolic tests in order to find witnesses for both specification
and code bugs. %\polish{sound, no false positives}
\end{abstract}


\section{Introduction}

JavaScript is the most widespread dynamic language: it is the de facto language for client-side Web applications (used by 94.8\% of websites \cite{JS948percent});
it is used for server-side scripting via Node.js; and it is even run on small embedded devices with limited 
memory. It is the most active language in both GitHub \cite{GithubActive} and StackOverflow \cite{SOActive}.
The dynamic nature of JavaScript and its complex semantics make it a difficult target for
symbolic analysis and logic-based verification. 
This paper presents \jilette, a symbolic execution tool for ES5 Strict. Jilette has the following benefits: 
\dtag{1} it is grounded on the real semantics of the language and does not simplify the memory model in any way; 
\dtag{2} it is provably sound, with no false positives;
\dtag{3} it has extensive coverage, supporting the entire core language and almost all built-in libraries; 
\dtag{4} it supports advanced string reasoning, critical for reasoning about \polish{everyday} JavaScript code; 
\dtag{5} it provides \polish{intuitive assertion/debugging mechanisms} accessible to the general JavaScript programmer, with minimal annotation overhead. 
%
We highlight two possible, relevant use cases for \jilette. First, we show how \jilette can be used as \dtag{i}~a tool for running symbolic tests for JavaScript programs; and \dtag{ii} a debugging tool for separation logic specifications of JavaScript programs. 

\myparagraph{Symbolic Testing} A commonly used 
approach to obtaining trust in JavaScript code is running it against 
adhoc test batteries---verifying that given concrete inputs, the code produces the expected
output. The main drawback of this approach is that tests, in general,
cannot guarantee exhaustiveness. We show how to use \jilette
for the symbolic testing of JavaScript programs: instead of using concrete 
inputs in tests, the developer uses symbolic inputs and states the 
constraints that the output needs to satisfy as simple, intuitive 
first-order assertions over these inputs. 
Furthermore, if a test fails, Jilette provides the concrete inputs that cause it 
to fail, immediately revealing bugs in the code being tested. The
symbolic execution of Jilette comes with a soundness proof that
guarantees the absence of false positives.

\pmax{This approach is not novel. Who else has done this?}

\pmax{This approach is not novel. Who else has done this?}


\myparagraph{Debugging Separation Logic Specifications}
We show how to use \jilette as an auxiliary mechanism for debugging 
separation logic specifications of JavaScript programs. Verification tools for  
JavaScript code \pmaxinline{Careful phrasing. Verification doesn't mean separation
logic. We must cite JaVerT here, we're the only ones doing this. It feels
like deliberate obfuscation.} are still 
very rare and often \pmaxinline{If they're rare, how can they do anything often?} 
require heavily annotating the 
original code for helping the solver prove entailments involving user-defined 
predicates, as well as coping with loops and recursion. Furthermore, when these 
tools cannot prove that a given function does not satisfy its specification, the 
user needs to go through a  proof trace and understand it in detail. 
Here, we demonstrate how to use \jilette to find errors in specifications by generating 
symbolic tests from these specifications and running the tests using \jilette. 
Then, if a symbolic test generated from a given specification fails, we can 
be sure that the code to be verified does not satisfy its specification. 
More importantly, in case of failure, \jilette generates a concrete counter-model that 
invalidates the specification. This information greatly simplifies the debugging of 
both specifications and code. 

\myparagraph{Architecture}
\jilette leverages on the \JSComp compiler and Rosette \cite{Rosette1}. 
\JSComp is a thoroughly tested compiler from JavaScript to \jsil, a simple 
intermediate language well suited for verification. Rosette is a 
solver-aided programming language with support for symbolic values 
and first-order assertions. The core of Jilette comprises a JSIL interpreter
written in Rosette. By piggybacking on Rosette and JS-2-JSIL, we 
are able to execute JavaScript programs on symbolic values, effectively 
obtaining a symbolic execution tool for JavaScript. 
This combination is non-trivial because \polish{many many things...} 

\myparagraph{Trustworthiness} \polish{formal development, trustworthiness, soundness}

\myparagraph{State of the Art}
Verification tools for JavaScript programs come few and far between. 
JaVerT~\cite{} targets the specialist developer wanting rich, 
mechanically verified specifications of critical JavaScript code.
It comes with 
Functional correctness, yes, and it works, but paid for by a heavy annotation burden.

\myparagraph{What's in the paper}

\bigskip
\polish{TO GO IN SOMEWHERE \\

Clarify ES5 Strict

JaVerT targets the specialist
developer wanting rich, mechanically verified specifications of critical JavaScript code.
Functional correctness, yes, and it works, but paid for by a heavy annotation burden.

K does a bit of functional correctness (but limited, since no proper abstractions). 
It does a bit of debugging, but you have to know where the bug is going to be. 
Annotations horrific, no built-in libraries, limited use. 

Jilette is so better, sweet spot, targets whom again? 
Facilitates exhaustive symbolic testing of JavaScript programs.}



%We show how  to use Jilette for writing symbolic tests for client side 
%JavaScript code calling Web APIs. In particular, we demonstrate how to 
%checking the conformance of Web API requests with their specified signatures. 
%The existing solutions for this problem are still imprecise due to the 
%dynamicity of JavaScript combined with the difficulty of reasoning about
%operations on symbolic strings \cite{Idontknow}. Jilette is an excellent fit for
%this task as it leverages on Rosette's back-end
%constraint solver, Z3, which supports reasoning on symbolic strings
%and regular expressions, whereas JS-2-JSIL successfully
%contains the complexity of JavaScript itself.

\section{Symbolic Execution for \jsil}\label{sec:jsil:symb:exec}
\input{sections/jilette}

\section{Debugging Separation Logic Specifications}
\input{sections/specs}

\section{Evaluation}
\input{sections/evaluation}


\section{Related Work} 

The existing literature covers a wide range of analysis techniques for JavaScript programs, including: 
type systems~\cite{thiemann:esop:2005,anderson:ecoop:2005,jensen:sas:2009,typescript:toot:2014,feldthaus:oopsla:2014,bierman:ecoop:2014,rastogi:popl:2015},
control flow analysis~\cite{feldthaus2013efficient}, pointer analysis~\cite{jang2009points,sridharan:ecoop:12} and abstract
interpretation~\cite{kashyap:fse:14,jensen:sas:2009,andreasen:oopsla:2014,park:ecoop:15}, among others. 
Here, we focused on the existing work on logic-based analysis and symbolic execution for JavaScript. 

\myparagraph{Symbolic Execution} 




\myparagraph{Logic-based Analysis} 
%
\cite{gardner:popl:2012} have developed a separation logic for a small fragment of ECMAScript 3, to reason about the variable store emulated in the JavaScript heap.
%
\cite{rosu-serbanuta-2010-jlap} have developed $\mathbb{K}$, a term-rewriting framework  for  formalising the operational
semantics of programming languages.
 In particular, they have developed KJS~\cite{Park:2015} which provides a $\mathbb{K}$-interpretation of the core language and part of the built-in libraries of the ES5 standard. KJS has been tested against the official ECMAScript Test262 test suite and passed all 2782 tests for the core language; the testing results for the built-in libraries are not reported. 
\cite{stefanescu-park-yuwen-li-rosu-2016-oopsla} introduce a language-independent verification infrastructure 
that can be instantiated with a $\mathbb{K}$-interpretation of a  language to automatically generate a symbolic verification tool for that language based on the $\mathbb{K}$ reachability logic. They apply this infrastructure to KJS to generate a verification tool for JavaScript, which they use to verify functional correctness properties of operations for manipulating data structures such as binary search trees, AVL trees, and lists.


\section{Conclusions}\label{conclusions}

\pmaxinline{Can we be more general, and say something like 'logic-based specifications'? It's all about translating to FOL, or even some version of PL. Also, we need to say at some point why we care about specifications written in separation logic.}

\newpage
\bibliographystyle{abbrv}
\bibliography{esop18}

\newpage
\appendix

\input{sections/appendix}


 

\end{document}