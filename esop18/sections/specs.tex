%!TEX root = ../main.tex

\subsection{\jsil Symbolic Execution with Separation Logic Assertions}

We show how to extend the \jsil symbolic execution with separation logic assertions.
To this end, we extend symbolic values with symbolic locations $\sloc \in \slocs$, and
we introduce the separation logic assertions for denoting spatial resource. 
Hence, we redefine $\svars$ to be the union of $\snumbers$, $\sstrings$, and $\slocs$, 
and continue to use $\svar$ to range over $\svars$. 
Below, we give the syntax and semantics of \jsil logic assertions. 

\begin{display}{\jsil Logic Assertions - Syntax}
%
{\scriptsize \begin{tabular}{lll}
  %%%% 
  $\quad \lexpr \triangleq$ & $\lit \mid \jvar \mid \svar \mid \unoper\ \lexpr \mid \lexpr \binoper \lexpr$ &   \text{ Logical Expressions} \\[3pt]
  %%%%
  $\quad P\triangleq$ & $\ltrue \mid \lfalse \mid  \neg P \mid P \land P \mid P \lor P  \mid \lexpr = \lexpr \mid \lexpr \leq \lexpr$ & \text{ Pure Assertions} \\
                                  & $\quad \mid \lemp \mid (\lexpr, \lexpr)\pointsto \lexpr \mid P \sep P  \mid \emptyfields{\lexpr}{\lexpr} $ &  \text{ Spatial Assertions} \\
\end{tabular}} \\ [7pt]
  %%%%%
  %%%%%
  
\quad 
{\scriptsize
\begin{tabular}{lll} 
     \begin{tabular}{ll}
    $\heap, \store, \senv \satisfies \truep$                  &  $\Leftrightarrow \text{always}$   \\
    %
    $\heap, \store, \senv \satisfies \falsep$                 &  $\Leftrightarrow \text{never}$   \\   
     %
    $\heap, \store, \senv \satisfies \neg P$                 &  $\Leftrightarrow \heap, \store, \env \not\satisfies P$ \\
     %  
     $\heap, \store, \senv \satisfies P \land Q$           &  $ \Leftrightarrow \heap, \store, \senv \satisfies P \land \heap, \store, \senv \satisfies Q $   \\
     %   
     $\heap, \store, \senv \satisfies  \exists \svar. P$  &  $\Leftrightarrow \exists \lit \in \lits. \, \heap, \store, \senv[\svar \mapsto \lit] \satisfies P$  \\ 
     %  
      $\heap, \store, \senv \satisfies \lexpr_1 = \lexpr_2$  &  $\Leftrightarrow \symbeval{\lexpr_1}{\store, \senv} = \symbeval{\lexpr_2}{\store, \senv}$   \\    
      %
      $\heap, \store, \senv \satisfies \lexpr_1 \leq \lexpr_2$  &  $\Leftrightarrow \symbeval{\lexpr_1}{\store, \senv} \leq \symbeval{\lexpr_2}{\store, \senv}$   
      \end{tabular}
      &
      $\phantom{x}$
      &
       \begin{tabular}{l}
           $\heap, \store, \senv  \satisfies  \lemp$ $\Leftrightarrow \heap = \hemp$  \\[2pt]
           %
	   $\heap, \store, \senv  \satisfies (\lexpr_1,\lexpr_2)\pointsto \lexpr_3$  \\
            $\ \Leftrightarrow \heap =  \hcell{\symbeval{\lexpr_1}{\store, \senv}}{\symbeval{\lexpr_2}{\store, \senv}}{\symbeval{\lexpr_3}{\store, \senv}}$  \\[2pt]
           % 
           $\heap, \store, \senv  \satisfies P \sep Q$ $\Leftrightarrow  \exists \heap_1, \heap_2.  \, \heap = \heap_1 \dunion \heap_2$  \\
                $\qquad \wedge \ \heap_1,  \store, \senv  \satisfies P \, \wedge \, \heap_2,  \store, \senv \satisfies Q$ \\[2pt]
           %
           $\heap, \store, \senv  \satisfies  \emptyfields{\lexpr_1}{\lexpr_2}$  \\
                $\ \Leftrightarrow \heap = \biguplus_{s \not\in \{ \symbeval{\lexpr_2}{\store, \senv} \}} ((\symbeval{\lexpr_1}{\store, \senv}, s) \pointsto \none)$
           
       \end{tabular}
\end{tabular}}
\end{display}

For convenience, we define: {\small $\sepmodels{P} = \left\{ (\heap, \store) \mid \exists \senv \, . \,  \heap, \store, \senv \satisfies P  \right\}$}. 
Given a symbolic heap $\sheap$, a symbolic store $\sstore$, a path condition $\pc$, and 
an assertion $P$, we say that  $(\sheap, \sstore, \pc)$ \emph{satisfies} $P$, 
written $\sheap, \sstore, \pc \satisfies P$ if and only if there are two symbolic heaps 
$\sheap'$ and $\sheap_f$ such that: $\sheap = \sheap' \dunion \sheap_f$ and 
$\smodels{\sheap', \sstore}{\pc} \subseteq \sepmodels{P}$. 
%
We can now extend \jsil symbolic execution with separation logic assertions. 
To this end, we introduce a new \emph{assert} command, $\sepassert(P)$ which checks
if the current symbolic state satisfies $P$. 
The formal semantics of $\sepassert(P)$ is as follows: 
{\small \begin{mathpar}
\inferrule[\textsc{Assert - True}]
  { 
     \sheap, \sstore, \pc \satisfies P
  }{\symbtrans{\sheap, \sstore, \sepassert(P), \pc}{\sheap, \sstore, \pc}} 
\and
\inferrule[\textsc{Assert - False}]
  { 
          \sheap, \sstore, \pc \not\satisfies P
  }{\symbtranserr{\sheap, \sstore, \sepassert(P), \pc}} 
\end{mathpar}}



\begin{figure}[t!]
{\scriptsize
\begin{mathpar} 
\inferrule[\textsc{New Existential}]
     { 
         \svar \in \existentials 
         \quad
         \svar \not\in \domain(\subst)
     }
     {\unification{\sexpr, \pc}{\svar}{\subst}{\existentials} = \optionsome{\subst[\svar \mapsto \sexpr]}}
\quad
\inferrule[\textsc{Matched Existential}]
     { 
         \subst(\svar) = \sexpr' 
         \quad 
         \pc \vdash \sexpr = \sexpr' 
     }
     {\unification{\sexpr, \pc}{\svar}{\subst}{\existentials} = \optionsome{\subst}}
\quad
\inferrule[\textsc{Existential - None}]
     { 
         \subst(\svar) = \sexpr' 
         \quad 
         \pc \not\vdash \sexpr = \sexpr' 
     }
     {\unification{\sexpr, \pc}{\svar}{\subst}{\existentials} = \optionnone}
\\
\inferrule[\textsc{Grounded Expression}]
     { 
         \fv(\subst(\sexpr')) \cap \existentials = \emptyset
         \quad 
          \pc \vdash  \sexpr = \subst(\sexpr') 
     }
     {\unification{\sexpr, \pc}{\sexpr'}{\subst}{\existentials} = \optionsome{\subst}}
\qquad
\inferrule[\textsc{Grounded Expression - Fail}]
     { 
         \fv(\subst(\sexpr')) \cap \existentials = \emptyset
         \quad 
          \pc  \not\vdash  \sexpr = \subst(\sexpr') 
     }
     {\unification{\sexpr, \pc}{\sexpr'}{\subst}{\existentials} = \optionnone}
%
\\
\inferrule[\textsc{Cell Assertion}]
	{  
	   \big(\loc = \symbeval{\lexpr_l}{\sstore} \ \vee \loc = \subst(\symbeval{\lexpr_l}{\sstore}) \big)
	   \\\\
	   \symbeval{\lexpr_p}{\sstore} = \sexprp'
	   \quad
	   \symbeval{\lexpr_v}{\sstore} = \sexprv' 
	   \quad
	    \sheap = \sheap_f \dunion ((l, \sexprp) \mapsto \sexprv) 
	   \\\\
	   \unification{\sexprp, \pc}{\sexprp'}{\subst}{\existentials} = \optionsome{\subst'} 
	   \quad
	   \unification{\sexprv, \pc}{\sexprv'}{\subst'}{\existentials} = \optionsome{\subst''} 
	}{ \unification{\sheap, \sstore, \pc}{(\lexpr_l,\lexpr_p)\pointsto \lexpr_v}{\subst}{\existentials} = (\subst'', \sheap_f)} 
\and
\inferrule[\textsc{EmptyFields Assertion}]
	{  
	   \big(\loc = \symbeval{\lexpr_l}{\sstore} \ \vee \loc = \subst(\symbeval{\lexpr_l}{\sstore}) \big)
	   \quad 
	     \symbeval{\lexpr_d}{\sstore} = \sexprv' 
	   \\\\
	     \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n   
              \quad
             (l, -) \not\in \domain(\sheap')
	    \quad 
	    \pc \vdash \big( \{ \sexprp_i \mid_{i = 0}^n   \} \subseteq \sexprv' \big)
	}{ \unification{\sheap, \sstore, \pc}{\emptyfields{\lexpr_l}{\lexpr_d}}{\subst}{\existentials} = (\subst, \sheap)} 
\end{mathpar}
\caption{Unification of spatial assertions:
 {\scriptsize$\unification{\sheap, \sstore, \pc}{\sass}{\subst}{\existentials} = (\subst', \sheap_f)$}\label{fig:unification}}}
\end{figure}


Determining whether or not a symbolic heap is consistent with a formula $P$ is, in general, 
undecidable. In the following, we present a partial decision procedure that we  
implement as part of the \jsil symbolic interpreter. 
We represent a formula $P$ as a triple 
$(\existentials, \sfs, \pfs)$, consisting of: 
\dtag{1} the set $\existentials$ of existentially quantified symbolic values, 
\dtag{2} the set $\sfs$ containing the spatial assertions in $P$, and 
\dtag{3} a pure assertion $\pfs$. 
Put formally we have that: 
\begin{equation}
P = \exists \svar_1, ..., \svar_k \, . \bigoast_{0 \leq i \leq n} \sass_i \ \wedge \ \pfs
\end{equation}
where $\existentials = \{ \svar_1, ..., \svar_k \}$ and $\sfs = \{ \sass_i \mid_{i = 0}^n \}$. 

Figure~\ref{fig:unification} shows the unification rules for spatial assertions and logical 
expressions. Given a set of existentially quantified variables $\existentials$, 
symbolic state $(\sheap, \sstore, \pc)$, a spatial assertion $\sass$, and a substitution 
$\subst$ mapping the existentially quantified variables that were already matched, 
the unification rules compute a new substitution $\subst'$ and a new symbolic 
heap $\sheap'$ coincides with $\sheap$ except that it does not contain the footprint 
of $\sass$. 

\begin{lemma}[Soundness of Unification for Spatial Assertions]
$$
\begin{array}{l}
\unification{\sheap, \sstore, \pc}{\sass}{\subst}{\existentials} = (\subst', \sheap_f) \\
	\qquad \implies 
		\exists \sheap' . \, \sheap = \sheap' \dunion \sheap_f  \, \wedge \, 
		\smodels{\sheap', \sstore}{\pc} \subseteq \sepmodels{\subst'(\sass)}  \, \wedge \, 
		\subst' \geq \subst 
\end{array}
$$
\end{lemma}

\begin{display}{Unification of \jsil assertions: $\unificationfull{\sheap, \sstore, \pc}{\existentials, \sfs, \pfs'}{\sheap_f}{\subst}$}
{\scriptsize
\begin{mathpar} 
\inferrule[\textsc{Spatial Assertion}]
	{  
	   \sfs = \{ \sass \} \dunion \sfs'
	   \and
            \unification{\sheap, \sstore, \pc}{\sass}{\subst}{\existentials} = (\subst', \sheap')
            \\\\
            \unificationfull{\sheap', \sstore, \pc}{\existentials, \sfs', \pfs'}{\sheap_f}{\subst'}
	}{\unificationfull{\sheap, \sstore, \pc}{\existentials, \sfs, \pfs'}{\sheap_f}{\subst}} 
\and 
\inferrule[\textsc{Pure Assertions}]
	{  
	   \pc \vdash \subst(\pfs')
	}{\unificationfull{\sheap, \sstore, \pc}{\existentials, \emptyset, \pfs'}{\sheap}{\subst}} 
\end{mathpar}}
\end{display}

\begin{theorem}[Soundness of Unification]
$$
\begin{array}{l}
P \equiv (\existentials, \sfs, \pfs') \ \wedge \ \unificationfull{\sheap, \sstore, \pc}{\existentials, \sfs, \pfs'}{\sheap_f}{\subst} \\ 
   \qquad \implies 
		\exists \sheap' . \, \sheap = \sheap' \dunion \sheap_f  \, \wedge \, 
		\smodels{\sheap', \sstore}{\pc} \subseteq \sepmodels{\subst'(P)}  \, \wedge \, 
		\subst' \geq \subst 
\end{array}
$$ 
\end{theorem}

\subsection{Compiling \jsil Specifications to Symbolic Tests}

\polish{Explain \jsil specs} 

\begin{definition}[Validity of \jsil Logic Specifications]
A \jsil logic specification $\lconf{P} \, \fid(\jvec{x}) \,  \lconf{Q}$ for return mode $\flag$ is valid with respect to a program 
$\prog$, written $\prog, \flag \vDash \lconf{P} \, \fid(\jvec{x}) \,  \lconf{Q}$,  if and only if, for all logical 
contexts $(\aheap, \store, \senv)$, heaps $\heap_f$, stores $\store_f$, and flags $\flag'$, it holds that: 
$$
\begin{array}{l}
    \aheap, \store, \senv \satisfies P \ \wedge \ \tuple{\deabstract{\aheap}, \store, \ctx[0]} \rightarrow^* \tuple{\heap_f, \store_f, \ctx[i_{\flag'}]} \\
       \quad \implies
            \flag' = \flag \ \wedge \ \exists \aheap_f \, . \, \aheap_f, \store_f, \senv \satisfies Q \ \wedge \ \deabstract{\aheap_f} = \heap_f
\end{array}
$$
\end{definition}

\noindent Given a \jsil program $\prog$ containing a procedure $\fid$ with spec {\small $\lconf{P} \, \fid(\jvec{x}) \,  \lconf{Q}$}, 
our goal is to construct a symbolic test for checking whether or not $\fid$ behaves as its specification mandates.
A symbolic test is a pair $(\prog', \sheap)$ consisting of a \jsil program and a symbolic heap. The new program $\prog'$ 
differs from $\prog$ in that it has a new \jsilmain procedure with the code of the test, and $\sheap$ is the initial 
symbolic heap on which to execute $\prog'$. 

\begin{display}{Concretisation of \jsil assertions: $\concretise{\sass}{\subst} = \sheap, \subst'$ and $\concretise{(\existentials, \sfs, \pfs)}{\subst} = \sheap, \pfs', \subst'$}
{\scriptsize
\begin{mathpar} 
\inferrule[\textsc{Spatial Assertion - Lit Loc}]
	{
	  \concretise{\lexpr_p}{\subst} = \sexpr_p, \subst' 
	  \quad 
	  \concretise{\lexpr_v}{\subst'} = \sexpr_v, \subst''
	}{\concretise{(\loc,\lexpr_p)\pointsto \lexpr_v}{\subst} = (\loc,\sexpr_p)\pointsto \sexpr_v, \subst''}  
\and 
\inferrule[\textsc{Spatial Assertion - Var Loc}]
	{
	  \concretise{\lexpr_p}{\subst[\sloc \mapsto \loc]} = \sexpr_p, \subst' 
	  \quad 
	  \concretise{\lexpr_v}{\subst'} = \sexpr_v, \subst''
	  	  \quad 
	  \loc \ \cfresh
	}{\concretise{(\sloc,\lexpr_p)\pointsto \lexpr_v}{\subst} = (\loc,\sexpr_p)\pointsto \sexpr_v, \subst''}  
\and 
\inferrule[\textsc{EmptyFileds}]
	{}{\concretise{\emptyfields{-}{-}}{\subst} = \hemp, \subst}  
\and 
\inferrule[\textsc{Spatial Assertion}]
	{
	    \sfs = \{ \sass \} \dunion \sfs'
	    \quad 
	    \concretise{\sass}{\subst} = \sheap, \subst' 
	    \\\\
	    \concretise{(-, \sfs', \pfs)}{\subst'} = \sheap', \pfs', \subst''
	}{\concretise{(-, \sfs, \pfs)}{\subst} = \sheap \dunion \sheap', \pfs', \subst''}  
\and 
\inferrule[\textsc{Spatial Assertion}]
	{
	}{\concretise{(-, \emptyset, \pfs)}{\subst} = \hemp, \subst(\pfs), \subst}  
\end{mathpar}}
\end{display}

%\begin{algorithm}
%\caption{Synthesising a symbolic test for: $\lconf{P} \, \fid(\jvec{x}) \,  \lconf{Q}$}\label{infer:specs:algo}
%\begin{algorithmic}[1]
%\State $(\existentials, \sfs, \pfs) := \normalise(P)$ 
%\State $\sheap_0, \pfs_0, \theta := \concretise{(\existentials, \sfs, \pfs)}{[ \ ]}$
%\State $\subst' := \subst\mid_{\domain(\subst) \backslash \existentials}$
%\State Return: 
%%\ForAll{$XXX$}
%%\If{$XXX$}
%  %\State $\{ P \} \, \pid() \, \{ Q \} = \ispecs(\pid, \_)$
%%\Else
%  %\State $P,Q :=$
%%\EndIf
%%\State $ := InferSpec, \ispecs', \pid, P) $
%%\ForAll{$(Q_f,,\flag) \in $}
%%\If{$Q_f \sep Q_M \vdash Q \sep \true$}
%  %\State $\ispecs' := \ispecs' \cup \{(\pid, \flag) \mapsto {P \sep _f \sep Q_M}{\pid(\jvec{\xivar})}{Q_f \sep Q_M}\}$
%%\EndIf
%%\EndFor
%%\EndFor
%\end{algorithmic}
%\end{algorithm}


\subsection{Example} 

In Figure~\ref{fig:map:example}, we define a \emph{map object predicate}, \jsinline|Map|, 
using the auxiliary predicate \jsinline|KVPairs|, which captures the resource of the key-value pairs in the map, 
and the \jsinline|validKey(k)| predicate, which holds if and only if the 
JavaScript function \jsinline|ValidKey(k)| returns \jsinline|true|\footnote{We treat the $\mathtt{ValidKey}$ predicate as a black box.}.
%
Intuitively, the \jsinline|Map(m, mp, kvs, keys)| predicate captures the resource 
of a map object \jsinline|m| with prototype \jsinline|mp|, keys \jsinline|keys| (a set of strings),
and key-value pairs \jsinline|kvs| (a set of string pairs\footnote{We model pairs as lists with two elements and, for clarity, use the pair notation.}). 
Observe that the definition of \jsinline|Map| does not include the resource of a map prototype, as
it is shared between all map objects, and therefore needs to be factored out.  
%
We write \jsinline|-u-| for set union and omit the brackets around singleton 
sets when the meaning is clear. % from the context. 

\begin{figure}[t!]
{\scriptsize
 \begin{verbatim}
Map (m, mp, kvs, keys) := JSObject(m, mp) * 
  DataProp(m, "_contents", c) * JSObject(c, Object.prototype) * KVPairs(c, kvs, keys) *
  (m, "get") -> None * (m, "put") ->  None * (m, "validKey") ->  None * 
  (c, "hasOwnProperty") ->  None *  emptyFields(c, keys -u- "hasOwnProperty")
  \end{verbatim}
  \vspace*{-0.3cm}
 \begin{verbatim}
KVPairs (o, kvs, keys) := 
  (kvs = { }) * (keys = { }),
  (kvs = (key, value) -u- kvs') * (keys = key -u- keys') * 
    ValidKey(key) * DataProp(o, key, value) * KVPairs(o, kvs', keys')
\end{verbatim}}
\caption{Map predicate \label{fig:map:example}}
\end{figure}

%In the following, we assume a \jsinline|MapProto| predicate specifying the resource of 
%a valid map prototype. In particular, the map prototype needs to define the methods 
%\jsinline|put|, \jsinline|get|, and \jsinline|validKey|. 


We are now in the position to specify the functions of the map library. In particular, below we show how to use 
the map object predicate to specify \jsinline|get(k)|.  
%
We consider the case in which the key whose value we  want to fetch is stored in the 
map.  The specification is given below. 
%
\begin{displaymath} 
{\footnotesize
\begin{array}{c}
\left\{ {\begin{array}{c}
 \text{\texttt{Map(this, mp, kvs -u- (k, v), ks) * ObjProtoF()}} \\ 
\end{array}} \right\} \\
%
\text{\bfseries \texttt{get(k)}} \\[0.2mm]
%
\left\{ {\begin{array}{c}
 \text{\texttt{Map(this, mp, kvs -u- (k, v), ks) * ObjProtoF() * (ret = v) }} \\
\end{array}} \right\}
\end{array}
} 
\end{displaymath}
%
The predicate \jsinline|ObjProtoF()| describes the resource captured by the \jsinline|Object.prototype| object. 
In particular, it is needed because \texttt{get} uses the \texttt{hasOwnProperty} function. .
