%!TEX root = ../main.tex

\begin{itemize}
  \item 2.0  - intro - explain the basic ideas of Jilette (use a diagram) - 
 
  \item 2.1 - describe the jsil language. give its formal syntax (extended with assert and solve). 
                   formally define symbolic execution for JSIL commands. soundness lemma. 
 
  \item 2.2 Implementation:  
               - encoding \jsil heaps in Rosette 
               - explain the \jsil interpreter implemented in Rosette and its connection to the \jsil semantics (as defined in appendix) 
               - give snippets of the interpreter 
               - discuss soundness, trust, and other issues
 
  \item 2.3 Symbolic execution for JavaScript 
              - explain that we have to extend the syntax of JavaScript with asserts  as well as constructs for creating symbolic values
              - give the example 
              - discuss challenges: abstraction level of the generated code needs to match the abstraction level of Rosette 
\end{itemize}

\subsection{Symbolic Execution for  \jsil}

\myparagraph{\jsil: Formal Semantics}
The basic memory model of \jsil is straightforward. 
\jsil values contain: numbers, $\jnumber$; booleans, $\jbool$; strings, $\jstring$;  the special values \jsinline|undefined| and \jsinline|null|; and object locations,  $\loc \in \locs$.
A \jsil heap, $\heap \in \heaps$, is a partial function mapping pairs of  object locations, and strings to heap values. 
 Given a heap $\heap$, we denote a heap cell by $\hcell{\loc}{\jstring}{\val}$ when $h(\loc,\jstring) = \val$, the union of two disjoint heaps by $\oheap_1 \dunion \oheap_2$,  a heap lookup by $\hread{\oheap}{\loc}{\jstring}$, and the empty heap by $\hemp$.
 Finally, a \jsil variable store, $\store \in \stores$, is a mapping from JSIL program variables $\jvar \in \jvars$ to JSIL values.

We introduce the \jsil semantic judgement for program behaviour; %needed to state our soundness result. 
the full \jsil semantics is given in the Appendix. 
The semantics of \jsil is defined in a small-step style. 
Transitions have the form:  $\semtrans{\heap, \store, \ctx[i]}{\heap', \store', \ctx'[j]}$, 
meaning that the evaluation of the $i$-th command of the current procedure in 
the heap $\heap$ and store $\store$ generates the heap $\heap'$ and store $\store'$ 
and $j$ is the next command to be evaluated. 
\polish{I have to talk about contexts here...} 


\myparagraph{\jsil: Symbolic Evaluation}
In order to symbolically execute \jsil programs, we extend the syntax of \jsil expressions with 
symbolic strings $\sstring \in \sstrings$ and symbolic numbers $\snumber \in \snumbers$. 
\polish{Heaps, stores, and contexts are extended accordingly, giving rise to symbolic 
heaps, stores, and contexts, respectively ranged by $\sheap$, $\sstore$, and $\sctx$.}
A \emph{symbolic state} $\sstate = (\sheap, \sstore, \pc)$ is a triple consisting of a 
symbolic heap $\sheap$, a symbolic store $\sstore$, and a path condition $\pc$. 
The path condition is a first order \polish{(quantifier free?)} formula over symbolic strings and 
numbers, which accumulates constraints on the given symbolic inputs that trigger 
the execution to follow the path that led to the current symbolic state. 

Figure~\ref{fig:symbexe:bcmds} presents the symbolic execution rules for \jsil basic commands. 
Rules have the form $\symbtrans{\sheap, \sstore, \pc, \bcmd}{\sheap', \sstore', \pc'}$, 
where: \dtag{1} $\sheap$ and $\sstore$ are the symbolic heap and store on which to evaluate $\bcmd$, 
\dtag{2} $\pc$ the current \emph{path condition}, and \dtag{3} $\sheap'$, $\sstore'$, and $\pc'$
the resulting symbolic heap, store, and path condition. 
Figure~\ref{fig:symbexe:cmds} presents the symbolic execution rules for \jsil commands. 
Rules have the form $\symbtrans{\sheap, \sstore, \pc, \sctx[i]}{\sheap, \sstore, \pc, \sctx'[j]}$; 
they differ from the rules for basic commands in that: \dtag{i} instead of the basic command to 
be executed on the left, they have the index of the command to be executed paired up 
with its associated execution context, and, \dtag{ii} on the right, they additionally have the 
index of the next command to be executed paired with the resulting execution context. 

%\begin{display}{}
\begin{figure}[ht!]
{\scriptsize
\begin{mathpar} 
%
\inferrule[\textsc{Skip}]{}
	{ \symbtrans{\sheap, \sstore, \pc, \jsilskip}{\sheap, \sstore, \pc}} 
 \and
 %
\inferrule[\textsc{Assignment}]
  {
      \symbeval{\jsilexpr}{\sstore} =  \sexpr
      \quad
      \sstore' = \sstore[\jvar \mapsto \sexpr]
  }{\symbtrans{\sheap, \sstore, \pc, \jvar := \jsilexpr}{\sheap, \sstore', \pc}} 
%
\and 
%
\inferrule[\textsc{Object Creation}]
  { 
    \sheap' = \sheap \dunion \hcell{\loc}{\protop}{\jsnull}
    \and (\loc,-) \notin \domain (\sheap)
  }{\symbtrans{\sheap, \sstore, \pc, \jvar := \jsilnew()}{\sheap', \sstore[\jvar \mapsto \loc], \pc}}
\\
%
\inferrule[\textsc{Property Access}]
  { 
 	\symbeval{\jsilexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p
        \quad
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
        \\\\
        \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \big)
  }{ \symbtrans{\sheap, \sstore, \pc, \jvar := [\jsilexpr_1, \jsilexpr_2]}{\sheap,  \sstore[\jvar \mapsto \sexprv_k], \pc'}}
 %
\\
%
\inferrule[\textsc{Property Assignment - Found}]
  {     \symbeval{\jsilexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p
        \quad
        \symbeval{\jsilexpr_3}{\sstore} =  \sexpr_v
       \quad 
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
        \\
          \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \big)
         \quad
         \sheap'' = \sheap' \, \uplus \,  \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n \, \uplus \,  (l, \sexpr_p) \mapsto \sexpr_v
  }{\symbtrans{\sheap, \sstore, \pc,  [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3}{\sheap'', \sstore, \pc'}} 
\\
%
\inferrule[\textsc{Property Assignment - Not Found}]
  {     \symbeval{\jsilexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p
        \quad
        \symbeval{\jsilexpr_3}{\sstore} =  \sexpr_v
       \quad 
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
        \\
          \pc' = \pc \ \wedge \, \bigwedge_{i = 0}^n (\sexprp_i \neq \sexpr_p)
         \quad
         \sheap' = \sheap \, \uplus \,  (l, \sexpr_p) \mapsto \sexpr_v
  }{\symbtrans{\sheap, \sstore, \pc,  [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3}{\sheap', \sstore, \pc'}}   
%
\\
%
\inferrule[\textsc{Property Deletion}]
  { 
        \symbeval{\jsilexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p
       \quad 
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
     \\ 
      \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \big)
     \quad 
      \sheap'' = \sheap' \, \uplus \,  \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n
   }{\symbtrans{\sheap, \sstore, \pc, \jsildelete(\jsilexpr_1, \jsilexpr_2)}{\sheap'', \sstore, \pc'}}
 \\
 %
\inferrule[\textsc{Member Check - True}]
  { 
      \symbeval{\jsilexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p
       \quad 
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
     \\ 
     \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \big)
  }{\symbtrans{\sheap, \sstore, \pc, \jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)}{\sheap, \sstore[\jvar \mapsto \jtrue], \pc'}}
%
\\
%
\inferrule[\textsc{Member Check - False}]
  { 
      \symbeval{\jsilexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p
       \quad 
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
     \\ 
     \pc' = \pc \ \wedge \,  \bigwedge_{i = 0}^n (\sexprp_i \neq \sexpr_p) \big)
  }{\symbtrans{\sheap, \sstore, \pc, \jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)}{\sheap, \sstore[\jvar \mapsto \jfalse], \pc'}}
\\
%
\inferrule[\textsc{Assert - True}]
  { 
      \symbeval{\jsilexpr}{\sstore} =  \sexpr
     \quad 
     \pc \vdash \sexpr 
  }{\symbtrans{\sheap, \sstore, \pc, \assert(\jsilexpr)}{\sheap, \sstore, \pc}} 
\quad
\inferrule[\textsc{Assert - False}]
  { 
      \symbeval{\jsilexpr}{\sstore} =  \sexpr
     \quad 
     \pc \not\vdash \sexpr 
  }{\symbtranserr{\sheap, \sstore, \pc, \assert(\jsilexpr)}} 
\end{mathpar}}
\caption{Symbolic Execution for Basic Commands: {\scriptsize$\symbtrans{\sheap, \sstore, \pc, \bcmd}{\sheap', \sstore', \pc'}$}\label{fig:symbexe:bcmds}}
\end{figure}
%\end{display}  


\begin{figure}[ht!]
{\scriptsize
\begin{mathpar} 
\inferrule[\textsc{Basic Command}]
   { 
     \prog_{\pid}(i) = \bcmd 
     \quad
     \symbtrans{\sheap, \sstore, \pc, \bcmd}{\sheap', \sstore', \pc'} 
   }{\symbtrans{\sheap, \sstore, \pc, \sctx[i]}{\sheap', \sstore', \pc', \sctx[i+1]}}
%
   \qquad
  %
  \inferrule[\textsc{Basic Command - Fail}]
   { 
     \prog_{\pid}(i) = \bcmd 
     \quad
     \symbtranserr{\sheap, \sstore, \pc, \bcmd} 
   }{\symbtranserr{\sheap, \sstore, \pc, \sctx[i]}}
 %
   \qquad
  %
  \inferrule[\textsc{Goto}]
   { \prog_{\pid}(i) = \goto \, j \quad}
   {\symbtrans{\sheap, \sstore, \pc, \sctx[i]}{\sheap, \sstore, \pc, \sctx[j]}}
  \\ 
  \inferrule[\textsc{Cond. Goto - True}]
   { \prog_{\pid}(i) =  \ifgoto{\jsilexpr}{j}{k} \quad
     \symbeval{\jsilexpr}{\sstore} =  \sexpr
   }
   {\symbtrans{\sheap, \sstore, \pc, \sctx[i]}{\sheap, \sstore, \pc \, \wedge \, \sexpr, \sctx[j]}}
  \and 
    \inferrule[\textsc{Cond. Goto - False}]
   { \prog_{\pid}(i) =  \ifgoto{\jsilexpr}{j}{k} \quad
     \symbeval{\jsilexpr}{\sstore} =  \sexpr
   }
   {\symbtrans{\sheap, \sstore, \pc, \sctx[i]}{\sheap, \sstore, \pc \, \wedge \, \neg\sexpr, \sctx[k]}}
   \\
    \inferrule[\textsc{Procedure Call}]
   { 
    \prog_{\pid}(i) =   \jsilcall{\jvar}{\jsilexpr}{\jsilexpr_i \mid_{i = 0}^{n}}{j}
     \quad
    \symbeval{\jsilexpr}{\sstore} =  \pid' 
    \quad
      \symbeval{\jsilexpr_i}{\sstore} =  \sexpr_i \mid_{i = 0}^{n} 
     \quad
     \args(\pid') = \jsillist{\jvar_1, ..., \jvar_{m}} 
     \quad 
      \sexpr_i = \jsundefined \mid_{i = n+1}^{m}  
   }
   {\symbtrans{\sheap, \sstore, \pc, \sctx[i]}{\sheap, [ \jvar_i \mapsto \sexpr_i \mid_{i = 0}^{m}] , \pc, ((\pid', \sstore, \jvar, i+1, j)::\sctx)[0]}}
    \\ 
  \inferrule[\textsc{Normal Return}]
   {
       \sctx = (-, \sstore', \jvar, i, -) :: \sctx' 
       \quad 
       \sstore(\procretvar) = \sexpr
   }  
   {\symbtrans{\sheap, \sstore, \pc, \sctx[\procretlab]}{\sheap, \sstore'[\jvar \mapsto \sexpr], \pc, \sctx'[i]}}
   \and 
     \inferrule[\textsc{Error Return}]
   {
       \sctx = (-, \sstore', \jvar, -, j) :: \sctx' 
       \quad 
       \sstore(\procerrvar) = \sexpr
   }  
   {\symbtrans{\sheap, \sstore, \pc, \sctx[\procerrlab]}{\sheap, \sstore'[\jvar \mapsto \sexpr], \pc, \sctx'[j]}}
 \end{mathpar}}
\caption{Symbolic Execution for Control Flow Commands: {\scriptsize$\symbtrans{\sheap, \sstore, \pc, \sctx[i]}{\sheap, \sstore, \pc, \sctx'[j]}$}\label{fig:symbexe:cmds}}
\end{figure}


\subsection{Implementation}

The point here is to explain how writing a correct concrete \jsil interpreter in Rosette
yields the symbolic execution presented in the previous subsection. 



\subsection{Symbolic Execution for JavaScript}


 \begin{figure}[th!]
 \begin{lstjs}[firstnumber=1]
function Map () { this._contents = {} }

Map.prototype.get = function (k) {
    if (this._contents.hasOwnProperty(k)) {  return this._contents[k] } 
    	else { return null }  
}

Map.prototype.put = function (k, v) {
   var contents = this._contents;
   if (this.validKey(k)) {  contents[k] = v   } 
   	else { throw new Error("Invalid Key") } 
} 

Map.prototype.validKey = function (k) { ... }
\end{lstjs}
\caption{Map Implementation in JavaScript}
\end{figure}

 \begin{figure}[th!]
 \begin{lstjs}[firstnumber=1]
var m = new Map();  m.put (__s1, __n1); var r = m.get(__s1);  
assert(__n1 = r)
\end{lstjs}
\caption{Symbolic Test for the Map Library}
\end{figure}

