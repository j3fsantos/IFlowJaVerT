%!TEX root = ../main.tex

\begin{itemize}
  \item 2.0  - intro - explain the basic ideas of Jilette (use a diagram) - 
 
  \item 2.1 - describe the jsil language. give its formal syntax (extended with assert and solve). 
                   formally define symbolic execution for JSIL commands. soundness lemma. 
 
  \item 2.2 Implementation:  
               - encoding \jsil heaps in Rosette 
               - explain the \jsil interpreter implemented in Rosette and its connection to the \jsil semantics (as defined in appendix) 
               - give snippets of the interpreter 
               - discuss soundness, trust, and other issues
 
  \item 2.3 Symbolic execution for JavaScript 
              - explain that we have to extend the syntax of JavaScript with asserts  as well as constructs for creating symbolic values
              - give the example 
              - discuss challenges: abstraction level of the generated code needs to match the abstraction level of Rosette 
\end{itemize}

\subsection{Symbolic Execution for  \jsil}

\myparagraph{\jsil: Formal Semantics}
The basic memory model of \jsil is straightforward. 
\jsil values contain: numbers, $\jnumber$; booleans, $\jbool$; strings, $\jstring$;  the special values \jsinline|undefined| and \jsinline|null|; and object locations,  $\loc \in \locs$.
A \jsil heap, $\heap \in \heaps$, is a partial function mapping pairs of  object locations, and strings to heap values. 
 Given a heap $\heap$, we denote a heap cell by $\hcell{\loc}{\jstring}{\val}$ when $h(\loc,\jstring) = \val$, the union of two disjoint heaps by $\oheap_1 \dunion \oheap_2$,  a heap lookup by $\hread{\oheap}{\loc}{\jstring}$, and the empty heap by $\hemp$.
 Finally, a \jsil variable store, $\store \in \stores$, is a mapping from JSIL program variables $\jvar \in \jvars$ to JSIL values.

We introduce the \jsil semantic judgement for program behaviour; %needed to state our soundness result. 
the full \jsil semantics is given in the Appendix. 
The semantics of \jsil is defined in a small-step style. 
Transitions have the form:  $\semtrans{\heap, \store, \ctx[i]}{\heap', \store', \ctx'[j]}$, 
meaning that the evaluation of the $i$-th command of the current procedure in 
the heap $\heap$ and store $\store$ generates the heap $\heap'$ and store $\store'$ 
and $j$ is the next command to be evaluated. 
\polish{I have to talk about contexts here...} 


\myparagraph{\jsil: Symbolic Evaluation}
In order to symbolically execute \jsil programs, we extend the syntax of \jsil expressions with 
symbolic strings $\sstring \in \sstrings$ and symbolic numbers $\snumber \in \snumbers$. 
For convenience, we use $\svars$ to denote the union of $\sstrings$ and $\snumbers$ 
and $\svar$ to range over $\svars$. 
A symbolic expression $\sexpr$ is a \jsil expression with no program variables. 
\begin{equation}
\jsilexpr \triangleq \lit \mid \jvar \mid \sstring \mid \snumber \mid \unoper\ \jsilexpr \mid \jsilexpr \binoper \jsilexpr
\qquad 
\sexpr \triangleq \lit \mid \sstring \mid \snumber \mid \unoper\ \sexpr \mid \sexpr \binoper \sexpr
\end{equation}

We extend heaps, stores, and contexts with symbolic values, obtaining symbolic 
heaps, stores, and contexts, respectively ranged by $\sheap$, $\sstore$, and $\sctx$. 
A symbolic heap, $\sheap \in \sheaps$, is a partial function mapping pairs of  
object locations, and symbolic expressions to symbolic expressions. 
A symbolic store, $\sstore \in \sstores$, is a mapping from program variables 
$\jvar \in \jvars$ to symbolic expressions.
%
A \emph{symbolic state} $\sstate = (\sheap, \sstore, \pc)$ is a triple consisting of a 
symbolic heap $\sheap$, a symbolic store $\sstore$, and a path condition $\pc$. 
The path condition is a first order quantifier free formula over symbolic strings and 
numbers, which accumulates constraints on the given symbolic inputs that trigger 
the execution to follow the path that led to the current symbolic state. 

Figure~\ref{fig:symbexe:bcmds} presents the symbolic execution rules for \jsil basic commands. 
Rules have the form $\symbtrans{\sheap, \sstore, \pc, \bcmd}{\sheap', \sstore', \pc'}$, 
where: \dtag{1} $\sheap$ and $\sstore$ are the symbolic heap and store on which to evaluate $\bcmd$, 
\dtag{2} $\pc$ the current \emph{path condition}, and \dtag{3} $\sheap'$, $\sstore'$, and $\pc'$
the resulting symbolic heap, store, and path condition. 
Figure~\ref{fig:symbexe:cmds} presents the symbolic execution rules for \jsil commands. 
Rules have the form $\symbtrans{\sheap, \sstore, \pc, \sctx[i]}{\sheap, \sstore, \pc, \sctx'[j]}$; 
they differ from the rules for basic commands in that: \dtag{i} instead of the basic command to 
be executed on the left, they have the index of the command to be executed paired up 
with its associated execution context, and, \dtag{ii} on the right, they additionally have the 
index of the next command to be executed paired with the resulting execution context. 

%\begin{display}{}
\begin{figure}[ht!]
{\scriptsize
\begin{mathpar} 
%
\inferrule[\textsc{Skip}]{}
	{ \symbtrans{\sheap, \sstore, \pc, \jsilskip}{\sheap, \sstore, \pc}} 
 \and
 %
\inferrule[\textsc{Assignment}]
  {
      \symbeval{\jsilexpr}{\sstore} =  \sexpr
      \quad
      \sstore' = \sstore[\jvar \mapsto \sexpr]
  }{\symbtrans{\sheap, \sstore, \pc, \jvar := \jsilexpr}{\sheap, \sstore', \pc}} 
%
\and 
%
\inferrule[\textsc{Object Creation}]
  { 
    \sheap' = \sheap \dunion \hcell{\loc}{\protop}{\jsnull}
    \and (\loc,-) \notin \domain (\sheap)
  }{\symbtrans{\sheap, \sstore, \pc, \jvar := \jsilnew()}{\sheap', \sstore[\jvar \mapsto \loc], \pc}}
\\
%
\inferrule[\textsc{Property Access}]
  { 
 	\symbeval{\jsilexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p
        \quad
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
        \\\\
        \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \big)
  }{ \symbtrans{\sheap, \sstore, \pc, \jvar := [\jsilexpr_1, \jsilexpr_2]}{\sheap,  \sstore[\jvar \mapsto \sexprv_k], \pc'}}
 %
\\
%
\inferrule[\textsc{Property Assignment - Found}]
  {     \symbeval{\jsilexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p
        \quad
        \symbeval{\jsilexpr_3}{\sstore} =  \sexpr_v
       \quad 
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
        \\
          \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \big)
         \quad
         \sheap'' = \sheap' \, \uplus \,  \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n \, \uplus \,  (l, \sexpr_p) \mapsto \sexpr_v
  }{\symbtrans{\sheap, \sstore, \pc,  [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3}{\sheap'', \sstore, \pc'}} 
\\
%
\inferrule[\textsc{Property Assignment - Not Found}]
  {     \symbeval{\jsilexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p
        \quad
        \symbeval{\jsilexpr_3}{\sstore} =  \sexpr_v
       \quad 
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
        \\
          \pc' = \pc \ \wedge \, \bigwedge_{i = 0}^n (\sexprp_i \neq \sexpr_p)
         \quad
         \sheap' = \sheap \, \uplus \,  (l, \sexpr_p) \mapsto \sexpr_v
  }{\symbtrans{\sheap, \sstore, \pc,  [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3}{\sheap', \sstore, \pc'}}   
%
\\
%
\inferrule[\textsc{Property Deletion}]
  { 
        \symbeval{\jsilexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p
       \quad 
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
     \\ 
      \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \big)
     \quad 
      \sheap'' = \sheap' \, \uplus \,  \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n
   }{\symbtrans{\sheap, \sstore, \pc, \jsildelete(\jsilexpr_1, \jsilexpr_2)}{\sheap'', \sstore, \pc'}}
 \\
 %
\inferrule[\textsc{Member Check - True}]
  { 
      \symbeval{\jsilexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p
       \quad 
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
     \\ 
     \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \big)
  }{\symbtrans{\sheap, \sstore, \pc, \jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)}{\sheap, \sstore[\jvar \mapsto \jtrue], \pc'}}
%
\\
%
\inferrule[\textsc{Member Check - False}]
  { 
      \symbeval{\jsilexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p
       \quad 
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
     \\ 
     \pc' = \pc \ \wedge \,  \bigwedge_{i = 0}^n (\sexprp_i \neq \sexpr_p) \big)
  }{\symbtrans{\sheap, \sstore, \pc, \jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)}{\sheap, \sstore[\jvar \mapsto \jfalse], \pc'}}
\\
%
\inferrule[\textsc{Assert - True}]
  { 
      \symbeval{\jsilexpr}{\sstore} =  \sexpr
     \quad 
     \pc \vdash \sexpr 
  }{\symbtrans{\sheap, \sstore, \pc, \assert(\jsilexpr)}{\sheap, \sstore, \pc}} 
\quad
\inferrule[\textsc{Assert - False}]
  { 
      \symbeval{\jsilexpr}{\sstore} =  \sexpr
     \quad 
     \pc \not\vdash \sexpr 
  }{\symbtranserr{\sheap, \sstore, \pc, \assert(\jsilexpr)}} 
\end{mathpar}}
\caption{Symbolic Execution for Basic Commands: {\scriptsize$\symbtrans{\sheap, \sstore, \pc, \bcmd}{\sheap', \sstore', \pc'}$}\label{fig:symbexe:bcmds}}
\end{figure}
%\end{display}  


\begin{figure}[ht!]
{\scriptsize
\begin{mathpar} 
\inferrule[\textsc{Basic Command}]
   { 
     \prog_{\pid}(i) = \bcmd 
     \quad
     \symbtrans{\sheap, \sstore, \pc, \bcmd}{\sheap', \sstore', \pc'} 
   }{\symbtrans{\sheap, \sstore, \pc, \sctx[i]}{\sheap', \sstore', \pc', \sctx[i+1]}}
%
   \qquad
  %
  \inferrule[\textsc{Basic Command - Fail}]
   { 
     \prog_{\pid}(i) = \bcmd 
     \quad
     \symbtranserr{\sheap, \sstore, \pc, \bcmd} 
   }{\symbtranserr{\sheap, \sstore, \pc, \sctx[i]}}
 %
   \qquad
  %
  \inferrule[\textsc{Goto}]
   { \prog_{\pid}(i) = \goto \, j \quad}
   {\symbtrans{\sheap, \sstore, \pc, \sctx[i]}{\sheap, \sstore, \pc, \sctx[j]}}
  \\ 
  \inferrule[\textsc{Cond. Goto - True}]
   { \prog_{\pid}(i) =  \ifgoto{\jsilexpr}{j}{k} \quad
     \symbeval{\jsilexpr}{\sstore} =  \sexpr
   }
   {\symbtrans{\sheap, \sstore, \pc, \sctx[i]}{\sheap, \sstore, \pc \, \wedge \, \sexpr, \sctx[j]}}
  \and 
    \inferrule[\textsc{Cond. Goto - False}]
   { \prog_{\pid}(i) =  \ifgoto{\jsilexpr}{j}{k} \quad
     \symbeval{\jsilexpr}{\sstore} =  \sexpr
   }
   {\symbtrans{\sheap, \sstore, \pc, \sctx[i]}{\sheap, \sstore, \pc \, \wedge \, \neg\sexpr, \sctx[k]}}
   \\
    \inferrule[\textsc{Procedure Call}]
   { 
    \prog_{\pid}(i) =   \jsilcall{\jvar}{\jsilexpr}{\jsilexpr_i \mid_{i = 0}^{n}}{j}
     \quad
    \symbeval{\jsilexpr}{\sstore} =  \pid' 
    \quad
      \symbeval{\jsilexpr_i}{\sstore} =  \sexpr_i \mid_{i = 0}^{n} 
     \quad
     \args(\pid') = \jsillist{\jvar_1, ..., \jvar_{m}} 
     \quad 
      \sexpr_i = \jsundefined \mid_{i = n+1}^{m}  
   }
   {\symbtrans{\sheap, \sstore, \pc, \sctx[i]}{\sheap, [ \jvar_i \mapsto \sexpr_i \mid_{i = 0}^{m}] , \pc, ((\pid', \sstore, \jvar, i+1, j)::\sctx)[0]}}
    \\ 
  \inferrule[\textsc{Normal Return}]
   {
       \sctx = (-, \sstore', \jvar, i, -) :: \sctx' 
       \quad 
       \sstore(\procretvar) = \sexpr
   }  
   {\symbtrans{\sheap, \sstore, \pc, \sctx[\procretlab]}{\sheap, \sstore'[\jvar \mapsto \sexpr], \pc, \sctx'[i]}}
   \and 
     \inferrule[\textsc{Error Return}]
   {
       \sctx = (-, \sstore', \jvar, -, j) :: \sctx' 
       \quad 
       \sstore(\procerrvar) = \sexpr
   }  
   {\symbtrans{\sheap, \sstore, \pc, \sctx[\procerrlab]}{\sheap, \sstore'[\jvar \mapsto \sexpr], \pc, \sctx'[j]}}
 \end{mathpar}}
\caption{Symbolic Execution for Control Flow Commands: {\scriptsize$\symbtrans{\sheap, \sstore, \pc, \sctx[i]}{\sheap, \sstore, \pc, \sctx'[j]}$}\label{fig:symbexe:cmds}}
\end{figure}


\myparagraph{Soundness} To establish the soundness of symbolic execution we need to relate 
symbolic states to concrete states. To this end, we make use of \emph{symbolic environments} 
$\senv : \svars \rightharpoonup \lits$ mapping symbolic values to \jsil literals. 
A symbolic environment is said to be \emph{consistent} if it maps symbolic 
values to concrete values of the appropriate type. In the following, we will always 
assume consistent symbolic environments. 
%
Given a symbolic environment $\senv$, we define the interpretation of a symbolic 
expression $\sexpr$ under $\senv$ as follows: 
\begin{equation}
\semexpr{\lit}{\senv} \semeq \lit
\quad 
\semexpr{\svar}{\senv} \semeq \senv(\svar)
\quad 
\semexpr{\unoper\ \sexpr}{\senv} \semeq \unoper (\semexpr{\sexpr}{\senv})
\quad 
\semexpr{\sexpr_1 \binoper \sexpr_2}{\senv} \semeq \binoper(\semexpr{\sexpr_1}{\senv}, \semexpr{\sexpr_2}{\senv}) 
\end{equation}
We extend the interpretation function to symbolic states as defined below. 

\begin{display}{Interpretation of Symbolic States}
{
\begin{tabular}{l}
$\quad${\bf Symbolic Heaps:}  \\
$
\quad
 \semexpr{\hemp}{\senv} \semeq \hemp
\quad
\semexpr{\hcell{\loc}{\sexpr_p}{\sexpr_v}}{\senv} \semeq  \hcell{\loc}{\semexpr{\sexpr_p}{\senv}}{\semexpr{\sexpr_v}{\senv}}
\quad
\semexpr{\sheap_1 \dunion \sheap_2}{\senv} \semeq  \semexpr{\sheap_1}{\senv} \dunion \semexpr{\sheap_2}{\senv}
$%
%%
%%
\\[3pt]
$\quad${\bf Symbolic Stores:}  \\
$
\quad
 \semexpr{\storeemp}{\senv} \semeq \storeemp
\quad 
 \semexpr{(\jvar: \sexpr) \dunion \sstore}{\senv} \semeq (\jvar: \semexpr{\sheap_1}{\senv}) \dunion \semexpr{\sstore}{\senv}
$%
\\[3pt]
$\quad$ {\bf Symbolic States:}  $\semexpr{(\sheap, \sstore, \sctx)}{\senv} \semeq (\semexpr{\sheap}{\senv}, \semexpr{\sstore}{\senv}, \semexpr{\sctx}{\senv})$
\end{tabular}
}
\end{display} 

In the following, we write $\senv \vdash \pc$  if and only if $\semexpr{\pc}{\senv} \Leftrightarrow \ltrue$. 
For convenience, we define: 
\begin{equation}
\smodels{\sheap, \sstore, \sctx}{\pc} = \left\{ (\heap, \store, \ctx) \mid \exists \senv \, . \,  \semexpr{(\sheap, \sstore, \sctx)}{\senv} = (\heap, \store, \ctx) \, \wedge \,  \senv \vdash \pc  \right\} 
\end{equation}

\begin{theorem}[Soundess]
$$
\begin{array}{l}
\symbtrans{\sheap, \sstore, \pc, \sctx[i]}{\sheap', \sstore', \pc', \sctx'[j]} 
   \ \wedge \ 
      (\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc'} \\ \quad \quad
      	 \ \Rightarrow \ \exists (\heap', \store', \ctx') \, . \, 
	 	 \semtrans{\heap, \store, \ctx[i]}{\heap', \store', \ctx'[j]}
		\, \wedge \, 
		(\heap', \store', \ctx') \in \smodels{\sheap', \sstore', \sctx'}{\pc'}  
\end{array}
$$
\end{theorem}



\subsection{Implementation}

The point here is to explain how writing a correct concrete \jsil interpreter in Rosette
yields the symbolic environments presented in the previous subsection. 




\subsection{Symbolic Execution for JavaScript}


 \begin{figure}[th!]
 \begin{lstjs}[firstnumber=1]
function Map () { this._contents = {} }

Map.prototype.get = function (k) {
    if (this._contents.hasOwnProperty(k)) {  return this._contents[k] } 
    	else { return null }  
}

Map.prototype.put = function (k, v) {
   var contents = this._contents;
   if (this.validKey(k)) {  contents[k] = v   } 
   	else { throw new Error("Invalid Key") } 
} 

Map.prototype.validKey = function (k) { ... }
\end{lstjs}
\caption{Map Implementation in JavaScript}
\end{figure}

 \begin{figure}[th!]
 \begin{lstjs}[firstnumber=1]
var m = new Map();  m.put (__s1, __n1); var r = m.get(__s1);  
assert(__n1 = r)
\end{lstjs}
\caption{Symbolic Test for the Map Library}
\end{figure}

