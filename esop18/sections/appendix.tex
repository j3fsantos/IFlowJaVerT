%!TEX root = ../main.tex

\newtheorem{lemmax}{}
\newtheorem{temax}{}
\newtheorem{cormax}{}

\section{\jsil Syntax and Semantics}


\begin{figure}[ht!]
{\scriptsize
\begin{mathpar} 
%
\inferrule[\textsc{Skip}]{}
	{ \semtrans{\heap, \store, \jsilskip}{\heap, \store}} 
 \qquad
 %
\inferrule[\textsc{Assignment}]
  {
      \symbeval{\jsilexpr}{\store} =  \val
      \quad
      \store' = \store[\jvar \mapsto \val]
  }{\semtrans{\heap, \store, \jvar := \jsilexpr}{\heap, \store'}} 
%
\qquad 
%
\inferrule[\textsc{Object Creation}]
  { 
    \heap = \heap \dunion \hcell{\loc}{\protop}{\jsnull}
    \quad (\loc,-) \notin \domain (\heap)
  }{\semtrans{\heap, \store, \jvar := \jsilnew()}{\heap, \store[\jvar \mapsto \loc]}}
\\
%
\inferrule[\textsc{Property Access}]
  { 
 	\symbeval{\jsilexpr_1}{\store} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\store} =  \jstring
        \quad
        \heap = - \dunion \hcell{\loc}{\jstring}{\val}
  }{ \semtrans{\heap, \store, \jvar := [\jsilexpr_1, \jsilexpr_2]}{\heap,  \store[\jvar \mapsto \val]}}
 \and 
 \inferrule[\textsc{Property Deletion}]
  { 
        \symbeval{\jsilexpr_1}{\store} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\store} =  \jstring
        \quad
        \heap = \heap' \dunion \hcell{\loc}{\jstring}{-}
  }{\semtrans{\heap, \store, \jsildelete(\jsilexpr_1, \jsilexpr_2)}{\heap', \store}}
 %
\\
%
\inferrule[\textsc{Property Assignment - Found}]
  {     \symbeval{\jsilexpr_1}{\store} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\store} =  \jstring
        \quad
        \symbeval{\jsilexpr_3}{\store} =  \val
       \\\\
        \heap = \heap' \dunion  \hcell{\loc}{\jstring}{-}
  }{\semtrans{\heap, \store, [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3}{\heap' \dunion  \hcell{\loc}{\jstring}{\val}, \store}} 
 \and 
 \inferrule[\textsc{Property Assignment - Not Found}]
  {     \symbeval{\jsilexpr_1}{\store} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\store} =  \jstring
        \quad
        \symbeval{\jsilexpr_3}{\store} =  \val
       \\\\
        \heap = \heap' 
        \quad 
        (\loc, \jstring) \not\in \domain(\heap)
  }{\semtrans{\heap, \store, [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3}{\heap \dunion  \hcell{\loc}{\jstring}{\val}, \store}} 
\\
%
\inferrule[\textsc{Member Check - True}]
  { 
      \symbeval{\jsilexpr_1}{\store} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\store} =  \jstring
       \quad 
   	(\loc, \jstring) \in \domain(\heap) 
  }{\semtrans{\heap, \store,\jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)}{\heap, \store[\jvar \mapsto \jtrue]}}
  \and 
 \inferrule[\textsc{Member Check - False}]
  { 
      \symbeval{\jsilexpr_1}{\store} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\store} =  \jstring
       \quad 
   	(\loc, \jstring) \not\in \domain(\heap) 
  }{\semtrans{\heap, \store,\jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)}{\heap, \store[\jvar \mapsto \jfalse]}}
%
\\
%
\inferrule[\textsc{Assert - True}]
  { 
      \symbeval{\jsilexpr}{\store} =  \jtrue
  }{\semtrans{\heap, \store, \assert(\jsilexpr)}{\heap, \store}} 
\and
\inferrule[\textsc{Assert - False}]
  { 
      \symbeval{\jsilexpr}{\store} \neq \jtrue
  }{\semtranserr{\heap, \store, \assert(\jsilexpr)}} 
\end{mathpar}}
\vspace*{-0.5cm}
\caption{Symbolic Execution for Basic Commands: {\scriptsize$\semtrans{\heap, \store, \bcmd}{\heap', \store'}$}\label{fig:sem:basic:commands}}
\end{figure}




\begin{figure}[ht!]
{\scriptsize
\begin{mathpar} 
\inferrule[\textsc{Basic Command}]
   { 
     \ccmd[\prog][\ctx]{i} = \bcmd 
     \quad
     \semtrans{\heap, \store, \bcmd}{\heap', \store'} 
   }{\semtrans[\prog]{\heap, \store, i}{\heap', \store', i+1}[C]}
%
   \qquad
  %
  \inferrule[\textsc{Basic Command - Fail}]
   { 
     \ccmd[\prog][\ctx]{i} = \bcmd 
     \quad
     \semtranserr{\heap, \store, \bcmd} 
   }{\semtranserr[\prog]{\heap, \store, i}[C]}
 %
   \qquad
  %
  \inferrule[\textsc{Goto}]
   { \ccmd[\prog][\ctx]{i} = \goto \, j \quad}
   {\semtrans[\prog]{\heap, \store, i}{\heap, \store, j}[C]}
  \\ 
  \inferrule[\textsc{Cond. Goto - True}]
   { \ccmd[\prog][\ctx]{i} =  \ifgoto{\jsilexpr}{j}{k} \quad
     \symbeval{\jsilexpr}{\store} =  \jtrue
   }
   {\semtrans[\prog]{\heap, \store, i}{\heap, \store, j}[C]}
  \and 
    \inferrule[\textsc{Cond. Goto - False}]
   { \ccmd[\prog][\ctx]{i} =  \ifgoto{\jsilexpr}{j}{k} \quad
     \symbeval{\jsilexpr}{\store} =  \jfalse
   }
   {\semtrans[\prog]{\heap, \store, i}{\heap, \store, k}[C]}
   \\
    \inferrule[\textsc{Procedure Call}]
   { 
    \ccmd[\prog][\ctx]{i} =   \jsilcall{\jvar}{\jsilexpr}{\jsilexpr_i \mid_{i = 0}^{n}}{j}
     \quad
    \symbeval{\jsilexpr}{\sstore} =  \pid' 
        \quad
     \args(\pid') = \jsillist{\jvar_1, ..., \jvar_{m}} 
      \quad
      \val_i = \symbeval{\jsilexpr_i}{\sstore} \mid_{i = 0}^{n} 
     \ 
      \val_i = \jsundefined \mid_{i = n+1}^{m}  
   }
   {\semtrans[\prog]{\heap, \store, i}{\heap, [ \jvar_i \mapsto \val_i \mid_{i = 0}^{m}] , 0}[C][(\pid', \store, \jvar, i+1, j) :: \ctx]}
    \\ 
  \inferrule[\textsc{Normal Return}]
   {
       \ctx = (-, \store', \jvar, i, -) :: \ctx' 
       \quad 
       \store(\procretvar) = \val
   }  
   {\semtrans[\prog]{\heap, \store, \procretlab}{\heap, \store'[\jvar \mapsto \val], i}[C][C']}
   \and 
     \inferrule[\textsc{Error Return}]
   {
       \ctx = (-, \store', \jvar, -, j) :: \ctx' 
       \quad 
       \store(\procerrvar) = \val
   }
   {\semtrans[\prog]{\heap, \store, \procerrlab}{\heap, \store'[\jvar \mapsto \val], j}[C][C']}
 \end{mathpar}}
% \pmax{What happens when we exit from main, how do we stop? Basically, cmd returns nothing and we can't reduce?}
 \vspace*{-0.4cm}
\caption{Symbolic Execution for Control Flow Commands: $\semtrans[\prog]{\heap, \store, i}{\heap', \store', j}[C][C']$}
\end{figure}
%
%\begin{figure}[ht!]
%{\scriptsize
%\begin{mathpar} 
%\inferrule[\textsc{Basic Command}]
%   { 
%     \ccmd{i} = \bcmd 
%     \quad
%     \semtrans{\heap, \store, \bcmd}{\heap', \store'} 
%   }{\semtrans{\heap, \store, i}{\heap', \store', i+1}}
%%
%   \qquad
%  %
%  \inferrule[\textsc{Basic Command - Fail}]
%   { 
%     \ccmd{i} = \bcmd 
%     \quad
%     \semtranserr{\heap, \store, \bcmd} 
%   }{\semtranserr{\heap, \store, i}}
% %
%   \qquad
%  %
%  \inferrule[\textsc{Goto}]
%   { \ccmd{i} = \goto \, j \quad}
%   {\semtrans{\heap, \store, i}{\heap, \store, j}}
%  \\ 
%  \inferrule[\textsc{Cond. Goto - True}]
%   { \ccmd{i} =  \ifgoto{\jsilexpr}{j}{k} \quad
%     \symbeval{\jsilexpr}{\store} =  \jtrue
%   }
%   {\semtrans{\heap, \store, i}{\heap, \store, j}}
%  \and 
%    \inferrule[\textsc{Cond. Goto - False}]
%   { \ccmd{i} =  \ifgoto{\jsilexpr}{j}{k} \quad
%     \symbeval{\jsilexpr}{\store} =  \jfalse
%   }
%   {\semtrans{\heap, \store, i}{\heap, \store, k}}
%   \\
%    \inferrule[\textsc{Procedure Call}]
%   { 
%    \ccmd{i} = \jsilcall{\jvar}{\jsilexpr}{\jsilexpr_i \mid_{i = 0}^{n}}{j}
%     \quad
%    \symbeval{\jsilexpr}{\sstore} =  \pid' 
%        \quad
%     \args(\pid') = \jsillist{\jvar_1, ..., \jvar_{m}} 
%      \quad
%      \val_i = \symbeval{\jsilexpr_i}{\sstore} \mid_{i = 0}^{n} 
%     \ 
%      \val_i = \jsundefined \mid_{i = n+1}^{m}  
%   }
%   {\semtrans{\heap, \store, i}{\heap, [ \jvar_i \mapsto \val_i \mid_{i = 0}^{m}] , 0}[\ctx][(\pid', \store, \jvar, i+1, j) :: \ctx]}
%    \\ 
%  \inferrule[\textsc{Normal Return}]
%   {
%       \ctx = (-, \store', \jvar, i, -) :: \ctx' 
%       \quad 
%       \store(\procretvar) = \val
%   }  
%   {\semtrans{\heap, \store, \procretlab}{\heap, \store'[\jvar \mapsto \val], i}[C][C']}
%   \and 
%     \inferrule[\textsc{Error Return}]
%   {
%       \ctx = (-, \store', \jvar, -, j) :: \ctx' 
%       \quad 
%       \store(\procerrvar) = \val
%   }
%   {\semtrans{\heap, \store, \procerrlab}{\heap, \store'[\jvar \mapsto \val], j}[C][C']}
% \end{mathpar}}
% \vspace*{-0.4cm}
%\caption{Symbolic Execution for Control Flow Commands: $\semtrans[\prog]{\heap, \store, i}{\heap', \store', j}[C][C']$}
%\end{figure}

\section{Proofs - Section~\ref{sec:jsil:symb:exec}}

\begin{lemma}[Soundness of symbolic execution for \jsil basic commands]\label{soundness:basic:commands}
$$
\begin{array}{l}
\forall \sheap, \sheap', \sstore, \sstore', \bcmd, \pc, \pc', \pc'' \, . \,  \\
\qquad \symbtrans{\sheap, \sstore, \bcmd, \pc}{\sheap', \sstore', \pc'}
   \ \wedge \ 
      (\heap, \store) \in \smodels{\sheap, \sstore}{\pc''} 
            \ \wedge \ \pc'' \vdash \pc' \\ \qquad \quad
      	 \ \implies \ \exists (\heap', \store') \, . \, 
	 	 \semtrans{\heap, \store, \bcmd}{\heap', \store'}
		\, \wedge \, 
		(\heap', \store') \in \smodels{\sheap', \sstore'}{\pc''}  
\end{array}
$$
\end{lemma}
\begin{proof}
We proceed by case analysis on $\symbtrans{\sheap, \sstore, \bcmd, \pc}{\sheap', \sstore', \pc'}$. 
\vspace{5pt}

\noindent\prooflab{Skip} 
We conclude that $\bcmd = \jsilskip$, and 
that $\sheap' = \sheap$, $\sstore' = \sstore$, and $\pc' = \pc$. 
By picking $\heap' = \heap$, $\store' = \store$, the result follows. 
\vspace{6pt}

\noindent\prooflab{Assignment} 
We conclude that $\bcmd = \jvar := \jsilexpr$, for some variable $\jvar$ and expression $\jsilexpr$, 
and that $\sheap' = \sheap$, $\sstore' = \sstore[\jvar \mapsto \symbeval{\jsilexpr}{\store}]$, and $\pc' = \pc$. 
From $(\heap, \store) \in \smodels{\sheap, \sstore}{\pc''}$, we conclude that there is a symbolic environment 
$\senv$ such that, $\senv \vdash \pc''$,  $\heap = \semexpr{\sheap}{\senv}$ and $\store = \semexpr{\sstore}{\senv}$. 
Noting that: 
$$
 \semtrans{\heap, \store, \jvar := \jsilexpr}{\heap, \store[\jvar \mapsto \symbeval{\jsilexpr}{\store}]}
% \qquad 
 %\semexpr{\sstore[\jvar \mapsto \symbeval{\jsilexpr}{\store}]}{\senv} = \semexpr{\sstore}{\senv}[\jvar \mapsto \symbeval{\jsilexpr}{\store, \senv}]
$$
we pick $\heap' = \heap$ and $\store' =  \store[\jvar \mapsto \symbeval{\jsilexpr}{\store}]$. We 
now have to prove that $(\heap', \store') \in \smodels{\sheap', \sstore'}{\pc''}$.
Observing that: 
$$
\heap' =  \semexpr{\sheap}{\senv} = \semexpr{\sheap'}{\senv} 
\quad 
\store' = \semexpr{\sstore}{\senv}[\jvar \mapsto \symbeval{\jsilexpr}{\semexpr{\sstore}{\senv}}]
   = \semexpr{\sstore[\jvar \mapsto \symbeval{\jsilexpr}{\store}]}{\senv} 
   = \semexpr{\sstore'}{\senv}
$$
%
the result follows. 
\vspace{6pt}

\noindent\prooflab{Object Creation}
We conclude that $\bcmd = \jvar := \jsilnew()$, for some variable $\jvar$, and that
$\sheap' = \sheap \dunion \hcell{\loc}{\protop}{\jsnull}$, $\sstore' = \sstore[\jvar \mapsto \loc]$, and $\pc' = \pc$, 
 where  $(\loc,-) \notin \domain (\sheap)$. 
 From $(\heap, \store) \in \smodels{\sheap, \sstore}{\pc''}$, we conclude that there is a symbolic environment
$\senv$ such that $\senv \vdash \pc''$, $\heap = \semexpr{\sheap}{\senv}$ and $\store = \semexpr{\sstore}{\senv}$. 
Noting that: 
$$
\semtrans{\heap, \store, \jvar := \jsilnew()}{\heap \dunion \hcell{\loc}{\protop}{\jsnull}, \store[\jvar \mapsto \loc]}
$$
where: $(\loc,-) \notin \domain (\heap)$, we pick $\heap' = \semexpr{\sheap}{\senv} \dunion \hcell{\loc}{\protop}{\jsnull}$ 
and $\store' = \semexpr{\sstore}{\senv}[\jvar \mapsto \loc]$. 
We now have to prove that $(\heap', \store') \in \smodels{\sheap', \sstore'}{\pc''}$.
Noting that: 
$$
\begin{array}{l}
\heap' = \semexpr{\sheap}{\senv} \dunion \hcell{\loc}{\protop}{\jsnull} = \semexpr{\sheap \dunion \hcell{\loc}{\protop}{\jsnull}}{\senv}   
     = \semexpr{\sheap'}{\senv}  \\
%
\store' = \semexpr{\sstore}{\senv}[\jvar \mapsto \loc] = \semexpr{\sstore}{\senv}[\jvar \mapsto \symbeval{\loc}{\senv}] = 
      \semexpr{\sstore[\jvar \mapsto \loc]}{\senv} = \semexpr{\sstore'}{\senv} 
\end{array}
$$
the result follows. 
\vspace{6pt}

\noindent\prooflab{Property Access}
We conclude that $\bcmd = \jvar := [\jsilexpr_1, \jsilexpr_2]$, for some variable $\jvar$, and expressions $\jsilexpr_1$ and $\jsilexpr_2$, 
and that $\sheap' = \sheap$, $\sstore' = \sstore[\jvar \mapsto \sexprv_k]$, and: 
 $$\pc' =  \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \big)$$
 where:
 $\symbeval{\jsilexpr_1}{\sstore} =  \loc$, $\symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p$, 
 $\sheap = \sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n$, 
 $(l, -) \not\in \domain(\sheap')$, and $0 \leq k \leq n$. 
%
From $(\heap, \store) \in \smodels{\sheap, \sstore}{\pc''}$, we conclude that there is a symbolic environment
$\senv$ such that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. 
We now have to prove that we can apply the \prooflab{Property Access} rule in the concrete state.
To this end, we have to show that there is a concrete heap $\heap''$ such that:
$\heap = \heap'' \dunion \hcell{\symbeval{\jsilexpr_1}{\store}}{\symbeval{\jsilexpr_2}{\store}}{\symbeval{\jsilexpr_3}{\store}}$. 
Note that: 
$$
\begin{array}{l}
%
\senv \vdash \pc'' \ \wedge \ \pc'' \vdash \pc' \ \wedge \ \pc' \vdash \sexprp_k = \sexpr_p \implies \senv \vdash \sexprp_k = \sexpr_p \\
%
 \symbeval{\jsilexpr_1}{\store} = \symbeval{\jsilexpr_1}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\jsilexpr_1}{\sstore}}{\senv} 
    = \symbeval{\loc}{\senv} = \loc \\ 
 %
  \symbeval{\jsilexpr_2}{\store}  = \symbeval{\jsilexpr_2}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\jsilexpr_2}{\sstore}}{\senv}
   =  \symbeval{\sexpr_p}{\senv} = \symbeval{\sexprp_k}{\senv}  \text{ (because $\senv \vdash \sexprp_k = \sexpr_p$)} \\
 %
 \heap = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n}{\senv} 
       =  \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion \semexpr{(l, \sexprp_k) \mapsto \sexprv_k}{\senv} \\
         \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (l, \semexpr{\sexprp_k}{\senv}) \mapsto \semexpr{\sexprv_k}{\senv}  \\ 
         \qquad =  \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \semexpr{\sexprv_k}{\senv}
\end{array}
$$
We can now apply the \prooflab{Property Access} rule of \jsil semantics, concluding: 
$$
   \semtrans{\heap, \store, \jvar := [\jsilexpr_1, \jsilexpr_2]}{\heap,  \store[\jvar \mapsto \semexpr{\sexprv_k}{\senv}]}
$$
meaning that: $\heap' = \heap$ and $\store' = \store[\jvar \mapsto \semexpr{\sexprv_k}{\senv}]$.
We have now to prove that $(\heap', \store') \in \smodels{\sheap', \sstore'}{\pc''}$.
Observe that: 
$$
\begin{array}{l}
\heap' = \heap = \semexpr{\sheap}{\senv}   = \semexpr{\sheap'}{\senv}  \text{ (because $\heap' = \heap$ and $ \sheap = \sheap'$)}
\\
 \store' =  \semexpr{\sstore}{\senv}[\jvar \mapsto \symbeval{\sexprv_k}{\senv}] 
    =  \semexpr{\sstore[\jvar \mapsto \sexprv_k]}{\senv} 
    =  \semexpr{\sstore'}{\senv}
\end{array}
$$
 which concludes the proof. 
\vspace{6pt}

\noindent\prooflab{Property Deletion}
We conclude that $\bcmd = \jsildelete(\jsilexpr_1, \jsilexpr_2)$, for some expressions $\jsilexpr_1$ and $\jsilexpr_2$
and that: 
$$
\begin{array}{l}
\sheap' = \sheap'' \, \uplus \,  \big((\loc, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n
\\ 
\sstore' = \sstore
\\ 
 \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \big)
\end{array}
$$
where $\loc = \symbeval{\jsilexpr_1}{\sstore}$ and $\sexpr_p = \symbeval{\jsilexpr_2}{\sstore}$.
From $(\heap, \store) \in \smodels{\sheap, \sstore}{\pc''}$, we conclude that there is a symbolic environment
$\senv$ such that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. 
Now, we have to prove that we can apply the \prooflab{Property Deletion} rule in the concrete state.
To this end, we have to show that:
$\heap = \heap' \dunion \hcell{\symbeval{\jsilexpr_1}{\store}}{\symbeval{\jsilexpr_2}{\store}}{-}$. 
Note that: 
$$
\begin{array}{l}
%
\senv \vdash \pc'' \ \wedge \ \pc'' \vdash \pc' \ \wedge \ \pc' \vdash \sexprp_k = \sexpr_p \implies \senv \vdash \sexprp_k = \sexpr_p \\
%
 \symbeval{\jsilexpr_1}{\store} = \symbeval{\jsilexpr_1}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\jsilexpr_1}{\sstore}}{\senv} 
    = \symbeval{\loc}{\senv} = \loc \\ 
 %
  \symbeval{\jsilexpr_2}{\store}  = \symbeval{\jsilexpr_2}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\jsilexpr_2}{\sstore}}{\senv}
   =  \symbeval{\sexpr_p}{\senv} = \symbeval{\sexprp_k}{\senv}  \text{ (because $$ and $\senv \vdash \sexprp_k = \sexpr_p$)} \\
 %
 \heap = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n}{\senv} 
       =  \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion \semexpr{(l, \sexprp_k) \mapsto \sexprv_k}{\senv} \\
         \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (l, \semexpr{\sexprp_k}{\senv}) \mapsto \semexpr{\sexprv_k}{\senv}  \\ 
         \qquad =  \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \semexpr{\sexprv_k}{\senv} \\ 
         \qquad = \semexpr{\sheap'}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto -
\end{array}
$$
We can now apply the \prooflab{Property Deletion} rule of \jsil semantics, concluding: 
$$
   \semtrans{\heap, \store, \jsildelete(\jsilexpr_1, \jsilexpr_2)}{\semexpr{\sheap'}{\senv},  \store}
$$
meaning that: $\heap' = \semexpr{\sheap'}{\senv}$ and $\store' = \store$.
Now, we have to prove that $(\heap', \store') \in \smodels{\sheap', \sstore'}{\pc''}$.
Noting that $\heap' = \semexpr{\sheap'}{\senv}$ and $\store' = \store = \semexpr{\sstore}{\senv} = \semexpr{\sstore'}{\senv}$, 
the result follows. 
\vspace{6pt}

\noindent\prooflab{Property Assignment - Found}
We conclude that  $\bcmd = [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3$ for some expressions $\jsilexpr_1$, $\jsilexpr_2$, 
and $\jsilexpr_3$, and that: 
$$
\begin{array}{l}
  \sheap =  \sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n    \\
  %
  \sheap' = \sheap'' \, \uplus \,  \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n \, \uplus \,  (l, \sexpr_p) \mapsto \sexpr_v  \\
  %
  \sstore' = \sstore \\ 
  %
  \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p)
\end{array}
$$ 
where $\symbeval{\jsilexpr_1}{\sstore} =  \loc$, $\symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p$, 
$\symbeval{\jsilexpr_3}{\sstore} =  \sexpr_v$.
From $(\heap, \store) \in \smodels{\sheap, \sstore}{\pc'}$, we conclude that there is a symbolic environment
$\senv$ such that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. 
Now, we have to prove that we can apply the \prooflab{Property Assignment - Found} rule in the concrete state.
To this end, we have to show that there is a concrete heap $\heap''$ such that:
$\heap = \heap'' \dunion \hcell{\symbeval{\jsilexpr_1}{\store}}{\symbeval{\jsilexpr_2}{\store}}{-}$. 
Note that: 
$$
\begin{array}{l}
%
\senv \vdash \pc'' \ \wedge \ \pc'' \vdash \pc' \ \wedge \ \pc' \vdash \sexprp_k = \sexpr_p \implies \senv \vdash \sexprp_k = \sexpr_p \\
%
 \symbeval{\jsilexpr_1}{\store} = \symbeval{\jsilexpr_1}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\jsilexpr_1}{\sstore}}{\senv} 
    = \symbeval{\loc}{\senv} = \loc \\ 
 %
  \symbeval{\jsilexpr_2}{\store}  = \symbeval{\jsilexpr_2}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\jsilexpr_2}{\sstore}}{\senv}
   =  \symbeval{\sexpr_p}{\senv} = \symbeval{\sexprp_k}{\senv}  \text{ (because $\senv \vdash \sexprp_k = \sexpr_p$)} \\
 %
  \symbeval{\jsilexpr_3}{\store}  = \symbeval{\jsilexpr_3}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\jsilexpr_3}{\sstore}}{\senv}
   =  \symbeval{\sexpr_v}{\senv} \\
 %
 \heap = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n}{\senv} 
       =  \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion \semexpr{(l, \sexprp_k) \mapsto \sexprv_k}{\senv} \\
         \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (l, \semexpr{\sexprp_k}{\senv}) \mapsto \semexpr{\sexprv_k}{\senv}  \\ 
         \qquad =  \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \semexpr{\sexprv_k}{\senv} \\ 
\end{array}
$$
We can now apply the \prooflab{Property Assignment - Found} rule of \jsil semantics, concluding: 
$$
   \semtrans{\heap, \store, [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3}
     {\semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \symbeval{\jsilexpr_3}{\store},  \store}
$$
meaning that: 
$\heap' = \symbeval{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \symbeval{\jsilexpr_3}{\store}$ and 
$\store' = \store$.
Now we have to prove that $(\heap', \store') \in \smodels{\sheap', \sstore'}{\pc''}$.
Noting that:
$$
\begin{array}{l}
\heap' = \symbeval{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \symbeval{\jsilexpr_3}{\store} \\ 
  \qquad = \symbeval{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (\loc, \symbeval{\sexpr_p}{\senv}) \mapsto \symbeval{\sexpr_v}{\senv}  \\
    \qquad = \symbeval{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n \dunion (\loc, \sexpr_p) \mapsto \sexpr_v}{\senv}  \\
    \qquad = \symbeval{\sheap'}{\senv} \\[2pt]
 %
 \store' = \store = \symbeval{\sstore}{\senv} = \symbeval{\sstore'}{\senv} 
\end{array}
$$
the result follows. 
\vspace{6pt}

\noindent\prooflab{Property Assignment - Not Found}
We conclude that  $\bcmd = [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3$ for some expressions $\jsilexpr_1$, $\jsilexpr_2$, 
and $\jsilexpr_3$, and that: 
$$
\begin{array}{l}
  \sheap =   \sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n     \\
  %
  \sheap' =  \sheap \, \uplus \,  (l, \sexpr_p) \mapsto \sexpr_v  \\
  %
  \sstore' = \sstore \\ 
  %
    \pc' = \pc \ \wedge \, \bigwedge_{i = 0}^n (\sexprp_i \neq \sexpr_p)
\end{array}
$$ 
where: $\symbeval{\jsilexpr_1}{\sstore} =  \loc$, $\symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p$, 
$\symbeval{\jsilexpr_3}{\sstore} =  \sexpr_v$,  $(\loc, -) \not\in \domain(\sheap'')$, 
and $0 \leq k \leq n$. 
From $(\heap, \store) \in \smodels{\sheap, \sstore}{\pc'}$, we conclude that there is a symbolic environment
$\senv$ such that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. 
We have to prove that we can apply the \prooflab{Property Assignment - Found} rule in the concrete state.
To this end, we have to show that:
$(\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \not\in \domain(\heap)$. 
Note that: 
$$
\begin{array}{l}
%
\senv \vdash \pc'' \ \wedge \ \pc'' \vdash \pc' \ \wedge \ \forall_{0 \leq i \leq n}  \, \pc' \vdash \sexprp_i \neq \sexpr_p  
      \implies \forall_{0 \leq i \leq n}  \, \senv \vdash \sexprp_i \neq \sexpr_p  \\
%
 \symbeval{\jsilexpr_1}{\store} = \symbeval{\jsilexpr_1}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\jsilexpr_1}{\sstore}}{\senv} 
    = \symbeval{\loc}{\senv} = \loc \\ 
 %
  \symbeval{\jsilexpr_2}{\store}  = \symbeval{\jsilexpr_2}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\jsilexpr_2}{\sstore}}{\senv}
   =  \symbeval{\sexpr_p}{\senv} \\
 %
  \symbeval{\jsilexpr_3}{\store}  = \symbeval{\jsilexpr_3}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\jsilexpr_3}{\sstore}}{\senv}
   =  \symbeval{\sexpr_v}{\senv} \\
 %
 \heap = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n}{\senv} 
     = \semexpr{\sheap''}{\senv} \dunion \biguplus_{0 \leq i \leq n} ((l, \symbeval{\sexprp_i}{\senv}) \mapsto \symbeval{\sexprv_i}{\senv})
\end{array}
$$
From  $(\loc, -) \not\in \domain(\sheap'')$, we conclude that $(\loc, -) \not\in \domain(\semexpr{\sheap''}{\senv})$. 
Since  for $0 \leq i \leq n$, it holds that $\senv \vdash \senv \vdash \sexprp_i \neq \sexpr_p$, 
we additionally conclude that: 
$$
  \forall_{0 \leq i \leq n}  \, \symbeval{\sexprp_i}{\senv} \neq \symbeval{\sexpr_p}{\senv} 
$$
Recalling that $\symbeval{\jsilexpr_2}{\store} = \symbeval{\sexpr_p}{\senv}$, we conclude that  
$
  \forall_{0 \leq i \leq n}  \, \symbeval{\sexprp_i}{\senv} \neq \symbeval{\jsilexpr_2}{\store}
$, from which it follows (together with $(\loc, -) \not\in \domain(\semexpr{\sheap''}{\senv})$) that 
$(\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \not\in \domain(\heap)$.
We can now apply the \prooflab{Property Assignment - Not Found} rule of \jsil semantics, concluding: 
$$
   \semtrans{\heap, \store, [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3}
     {\heap \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \symbeval{\jsilexpr_3}{\store},  \store}
$$
meaning that $\heap' = \heap \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \symbeval{\jsilexpr_3}{\store}$ 
and $\store' = \store$. 
%
Now, we have to prove that $(\heap', \store') \in \smodels{\sheap', \sstore'}{\pc''}$.
Noting that:
$$
\begin{array}{l}
\heap' = \symbeval{\sheap}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \symbeval{\jsilexpr_3}{\store} \\ 
  \qquad = \symbeval{\sheap}{\senv} \dunion (\loc, \symbeval{\sexpr_p}{\senv}) \mapsto \symbeval{\sexpr_v}{\senv}  \\
    \qquad = \symbeval{\sheap \dunion (\loc, \sexpr_p) \mapsto \sexpr_v}{\senv}  \\
    \qquad = \symbeval{\sheap'}{\senv} \\[2pt]
 %
 \store' = \store = \symbeval{\sstore}{\senv} = \symbeval{\sstore'}{\senv} 
\end{array}
$$
the result follows. 
\vspace{6pt}



\noindent\prooflab{Member Check - True}
We conclude that  $\bcmd = \jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)$ for some variable $\jvar$ and expressions $\jsilexpr_1$ and $\jsilexpr_2$, and that: 
$$
\begin{array}{l}
  \sheap =   \sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n     \\
  %
  \sheap' =  \sheap \\
  %
  \sstore' = \sstore[\jvar \mapsto \jtrue] \\ 
  %
    \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \big)
\end{array}
$$ 
where $\symbeval{\jsilexpr_1}{\sstore} =  \loc$, $\symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p$, 
$(\loc, -) \not\in \domain(\sheap'')$, and $0 \leq k \leq n$. 
%
From $(\heap, \store) \in \smodels{\sheap, \sstore}{\pc''}$, we conclude that there is a symbolic environment
$\senv$ such that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. 
Now we have to prove that we can apply the \prooflab{Member Check - True} rule in the concrete state.
To this end, we have to show that:
$\heap = \heap'' \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto -$, for 
some concrete heap $\heap''$. 
Note that: 
$$
\begin{array}{l}
%
\senv \vdash \pc'' \ \wedge \ \pc'' \vdash \pc' \ \wedge \ \pc' \vdash \sexprp_k = \sexpr_p \implies \senv \vdash \sexprp_k = \sexpr_p \\
%
 \symbeval{\jsilexpr_1}{\store} = \symbeval{\jsilexpr_1}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\jsilexpr_1}{\sstore}}{\senv} 
    = \symbeval{\loc}{\senv} = \loc \\ 
 %
  \symbeval{\jsilexpr_2}{\store}  = \symbeval{\jsilexpr_2}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\jsilexpr_2}{\sstore}}{\senv}
   =  \symbeval{\sexpr_p}{\senv} \\
 %
 \heap = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n}{\senv} \\
    \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i\neq k}^n \dunion (l, \sexprp_k) \mapsto \sexprv_k}{\senv} \\
    \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i\neq k}^n}{\senv} \dunion \semexpr{(l, \sexprp_k) \mapsto \sexprv_k}{\senv} \\
    \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i\neq k}^n}{\senv} \dunion (l, \semexpr{\sexprp_k}{\senv}) \mapsto \semexpr{\sexprv_k}{\senv} \\ 
     \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i\neq k}^n}{\senv} \dunion (l, \semexpr{\sexpr_p}{\senv}) \mapsto \semexpr{\sexprv_k}{\senv}
      			\text{ (using $\senv \vdash \sexprp_k = \sexpr_p$)} \\ 
     \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i\neq k}^n}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto - \\
\end{array}
$$
We can now apply the \prooflab{Member Check - True} rule of \jsil semantics, concluding that:  
$$
   \semtrans{\heap, \store, \jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)}{\heap,  \store[\jvar \mapsto \jtrue]}
$$
which means that $\heap' = \heap$ and $\store' = \store[\jvar \mapsto \jtrue]$. 
%
We now have to prove that $(\heap', \store') \in \smodels{\sheap', \sstore'}{\pc''}$.
Noting that:
$$
\begin{array}{l}
\heap' = \heap = \semexpr{\sheap}{\senv} = \semexpr{\sheap'}{\senv} \\
 %
 \store' = \store[\jvar \mapsto \jtrue] = \symbeval{\sstore}{\senv}[\jvar \mapsto \jtrue]  = \symbeval{\sstore[\jvar \mapsto \jtrue]}{\senv} = \symbeval{\sstore'}{\senv} 
\end{array}
$$
the result follows. 
\vspace{6pt}


\noindent\prooflab{Member Check - False}
We conclude that  $\bcmd = \jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)$ for some variable $\jvar$ and expressions $\jsilexpr_1$ and $\jsilexpr_2$, and that: 
$$
\begin{array}{l}
  \sheap =  \sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n      \\
  %
  \sheap' =  \sheap \\
  %
  \sstore' = \sstore[\jvar \mapsto \jfalse] \\ 
  %
     \pc' = \pc \ \wedge \,  \bigwedge_{i = 0}^n (\sexprp_i \neq \sexpr_p) 
\end{array}
$$ 
where $\symbeval{\jsilexpr_1}{\sstore} =  \loc$, $\symbeval{\jsilexpr_2}{\sstore} =  \sexpr_p$, 
$(\loc, -) \not\in \domain(\sheap'')$, and $0 \leq k \leq n$. 
%
From $(\heap, \store) \in \smodels{\sheap, \sstore}{\pc'}$, we conclude that there is a symbolic environment
$\senv$ such that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. 
We now have to prove that we can apply the \prooflab{Member Check - False} rule in the concrete state.
To this end, we have to show that: $(\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \not\in \domain(\heap)$. 
Note that: 
$$
\begin{array}{l}
%
\senv \vdash \pc'' \ \wedge \ \pc'' \vdash \pc' \ \wedge \ \forall_{0 \leq i \leq n}  \, \pc' \vdash \sexprp_i \neq \sexpr_p  
      \implies \forall_{0 \leq i \leq n}  \, \senv \vdash \sexprp_i \neq \sexpr_p  \\
%
 \symbeval{\jsilexpr_1}{\store} = \symbeval{\jsilexpr_1}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\jsilexpr_1}{\sstore}}{\senv} 
    = \symbeval{\loc}{\senv} = \loc \\ 
 %
  \symbeval{\jsilexpr_2}{\store}  = \symbeval{\jsilexpr_2}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\jsilexpr_2}{\sstore}}{\senv}
   =  \symbeval{\sexpr_p}{\senv} \\
 %
 \heap = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n}{\senv} \\
    \qquad = \semexpr{\sheap''}{\senv} \dunion \biguplus_{0 \leq i \leq n} (l, \semexpr{\sexprp_i}{\senv}) \mapsto \semexpr{\sexprv_i}{\senv}
\end{array}
$$
Since $(\loc, -) \not\in \domain(\sheap'')$, we conclude that $(\loc, -) \not\in \semexpr{\sheap''}{\senv}$. 
%
Since for all ${0 \leq i \leq n}$, it holds that $\senv \vdash \sexprp_i \neq \sexpr_p$, we additionally conclude that: 
$$
  \forall_{0 \leq i \leq n}  \, \symbeval{\sexprp_i}{\senv} \neq \symbeval{\sexpr_p}{\senv} 
$$
Recalling that $\symbeval{\jsilexpr_2}{\store} = \symbeval{\sexpr_p}{\senv}$, we conclude that  
$
  \forall_{0 \leq i \leq n}  \, \symbeval{\sexprp_i}{\senv} \neq \symbeval{\jsilexpr_2}{\store}
$, from which it follows (together with $(\loc, -) \not\in \domain(\semexpr{\sheap''}{\senv})$) that 
$(\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \not\in \domain(\heap)$.
%
We can now apply the \prooflab{Member Check - False} rule of \jsil semantics, concluding: 
$$
   \semtrans{\heap, \store, \jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)}{\heap,  \store[\jvar \mapsto \jfalse]}
$$
meaning that $\heap' = \heap$ and $\store' = \store[\jvar \mapsto \jfalse]$. 
%
Now we have to prove that $(\heap', \store') \in \smodels{\sheap', \sstore'}{\pc''}$.
Noting that:
$$
\begin{array}{l}
\heap' = \heap = \semexpr{\sheap}{\senv} = \semexpr{\sheap'}{\senv} \\
 %
 \store' = \store[\jvar \mapsto \jfalse] = \symbeval{\sstore}{\senv}[\jvar \mapsto \jfalse]] = \symbeval{\sstore[\jvar \mapsto \jfalse]}{\senv} = \symbeval{\sstore'}{\senv} 
\end{array}
$$
the result follows. 
\vspace{6pt}


\noindent\prooflab{Assert - True}
We conclude that  $\bcmd = \assert(\jsilexpr)$ for some expression $\jsilexpr$, and that: 
$$
  \sheap' = \sheap 
  \quad
  \sstore' =  \sstore 
  \quad
  \pc' = \pc
  \quad
  \pc \vdash  \symbeval{\jsilexpr}{\sstore}
$$ 
From $(\heap, \store) \in \smodels{\sheap, \sstore}{\pc''}$, we conclude that there is a symbolic environment
$\senv$ such that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. Because $\pc'' \vdash \pc' = \pc$, we conclude that $\senv \vdash \pc$. 
We now have to prove that we can apply the \prooflab{Assert - True} rule in the concrete state.
To this end, we have to show that: $\symbeval{\jsilexpr}{\store} = \jtrue$. 
Noting that:
$
  \symbeval{\jsilexpr}{\store} = \symbeval{\jsilexpr}{\symbeval{\sstore}{\senv}} 
         = \symbeval{\symbeval{\jsilexpr}{\sstore}}{\senv} 
$, we conclude (using $\senv \vdash \pc$ and $\pc \vdash  \symbeval{\jsilexpr}{\sstore}$) that 
$\symbeval{\jsilexpr}{\store} = \jtrue$. 
We can now apply the \prooflab{Assert - True} rule of \jsil semantics, concluding: 
$$
   \semtrans{\heap, \store, \assert(\jsilexpr)}{\heap,  \store}
$$
meaning that $\heap' = \heap$ and $\store' = \store$. 
%
Now we have to prove that $(\heap', \store') \in \smodels{\sheap', \sstore'}{\pc''}$.
Noting that:
$$
\begin{array}{l}
\heap' = \heap = \semexpr{\sheap}{\senv} = \semexpr{\sheap'}{\senv}
 %
 \quad 
 %
 \store' = \store = \symbeval{\sstore}{\senv} = \symbeval{\sstore}{\senv} = \symbeval{\sstore'}{\senv} 
\end{array}
$$
the result follows. 
\vspace{6pt}

\noindent\prooflab{Assert - False}
We conclude that  $\bcmd = \assert(\jsilexpr)$ for some expression $\jsilexpr$, and that: 
$\pc \vdash \neg\symbeval{\jsilexpr}{\sstore}$ and $\pc' = \pc$. 
From $(\heap, \store) \in \smodels{\sheap, \sstore}{\pc''}$, we conclude that there is a symbolic environment
$\senv$ such that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. Since $\pc'' \vdash \pc' = \pc$ and  $\pc \vdash \neg\symbeval{\jsilexpr}{\sstore}$, 
we conclude that $\pc'' \vdash \neg\symbeval{\jsilexpr}{\sstore}$.
We now have to prove that we can apply the \prooflab{Assert - False} rule in the concrete state.
To this end, we have to show that: $\symbeval{\jsilexpr}{\store} = \jfalse$. 
Noting that:
$
  \symbeval{\jsilexpr}{\store} = \symbeval{\jsilexpr}{\symbeval{\sstore}{\senv}} 
         = \symbeval{\symbeval{\jsilexpr}{\sstore}}{\senv} 
$, we conclude (using $\senv \vdash \pc''$ and $\pc'' \vdash  \neg\symbeval{\jsilexpr}{\sstore}$) that 
$\symbeval{\jsilexpr}{\store} = \jfalse$, from which the result follows. 
\end{proof}


\begin{lemma}[Soundness of \jsil symbolic execution - Single Step]\label{lemma:soundness:single:step}
$$
\begin{array}{l}
\forall \, \sheap, \sheap', \heap, \sstore, \sstore', \store, i, j, \sctx, \sctx', \ctx, \pc, \pc', \pc'' \, . \,  \\ 
\quad \symbtrans{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx'] 
   \ \wedge \ 
      (\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''} 
            \ \wedge \ \pc'' \vdash \pc' \\ \quad \quad 
      	 \ \implies \ \exists (\heap', \store', \ctx') \, . \, 
	 	 \semtrans{\heap, \store, i}{\heap', \store', j}[\ctx][\ctx']
		\, \wedge \, 
		(\heap', \store', \ctx') \in \smodels{\sheap', \sstore', \sctx'}{\pc''}  
\end{array}
$$
\end{lemma}
%
\begin{proof}
We proceed by case analysis on $\symbtrans{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx']$. 
\vspace{5pt}

\noindent\prooflab{Basic Command} 
We conclude that $\ccmd{i} = \bcmd$ for some basic command $\bcmd$,  
$\symbtrans{\sheap, \sstore, \bcmd, \pc}{\sheap', \sstore', \pc'}$, 
$\sctx' = \sctx$, and $j = i + 1$. 
Since $(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''}$, we conclude 
that $(\heap, \store) \in \smodels{\sheap, \sstore}{\pc''}$. 
Applying Lemma~\ref{soundness:basic:commands} to: 
$$ 
\symbtrans{\sheap, \sstore, \bcmd, \pc}{\sheap', \sstore', \pc'} 
\qquad 
(\heap, \store) \in \smodels{\sheap, \sstore}{\pc''}
\qquad 
\pc'' \vdash \pc'
$$
we conclude that there is a concrete heap $\heap'$ and store $\store'$ such 
that: 
$$
\semtrans{\heap, \store, \bcmd}{\heap', \store'}
\qquad 
(\heap', \store') \in \smodels{\sheap', \sstore'}{\pc''}  
$$
Using $\ccmd{i} = \bcmd$ and $\semtrans{\heap, \store, \bcmd}{\heap', \store'}$, 
we can apply the \prooflab{Basic Command} rule of \jsil semantics to conclude 
that: $\semtrans{\heap, \store, i}{\heap', \store', i+1}[\ctx][\ctx']$. 
From $\sctx' = \sctx$, $(\heap', \store') \in \smodels{\sheap', \sstore'}{\pc''}$, 
and $(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''}$, it follows
that $(\heap', \store', \ctx') \in \smodels{\sheap, \sstore, \sctx}{\pc''}$, 
which concludes the proof. 
\vspace{6pt}


\noindent\prooflab{Goto} 
We conclude that $\ccmd{i} = \goto \, k$ for some program index $k$ and 
that $\symbtrans{\sheap, \sstore, i, \pc}{\sheap, \sstore, k, \pc}[\sctx][\sctx]$, 
meaning that $\sheap' = \sheap$, $\sstore' = \sstore$, $\sctx' = \sctx$, $j = k$, 
and $\pc' = \pc$. 
From $\ccmd{i} = \goto \, k$, we conclude that 
$\semtrans{\heap, \store, i}{\heap, \store, k}[\ctx][\ctx]$. 
Noting that: 
$$
(\heap', \store', \ctx') = (\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''}  = \smodels{\sheap', \sstore', \sctx'}{\pc''}
$$
the result follows. 
\vspace{6pt}


\noindent\prooflab{Cond. Goto - True} 
We conclude that $\ccmd{i} = \ifgoto{\jsilexpr}{k_1}{k_2}$ for some expression 
$\jsilexpr$ and indexes $k_1$ and $k_2$ and 
that $\symbtrans{\sheap, \sstore, i, \pc}{\sheap, \sstore, k_1, \pc \, \wedge \, \sexpr}[\sctx][\sctx]$, 
meaning that $\sheap' = \sheap$, $\sstore' = \sstore$, $\sctx' = \sctx$, $j = k$, 
and $\pc' = \pc \, \wedge \, \sexpr$, where $\semexpr{\jsilexpr}{\sstore} = \sexpr$. 
Since $(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''}$, we conclude that 
there is a symbolic environment $\senv$ such that: $\senv \vdash \pc''$, 
$\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, 
and $\ctx = \semexpr{\sctx}{\senv}$.
Since $\pc'' \vdash \pc'$ and $\senv \vdash \pc''$, we conclude that $\senv \vdash \pc'$. 
From  $\senv \vdash \pc' = (\pc \ \wedge \ \sexpr)$, it follows that $\senv \vdash \sexpr$, 
implying that $\symbeval{\sexpr}{\senv} = \jtrue$. 
Noting that: 
$$
\semexpr{\jsilexpr}{\store} = \semexpr{\jsilexpr}{\semexpr{\sstore}{\senv}} 
    = \semexpr{\semexpr{\jsilexpr}{\sstore}}{\senv} 
    = \semexpr{\sexpr}{\senv}
    = \jtrue
$$
we conclude that $\semtrans{\heap, \store, i}{\heap, \store, k_1}[\ctx][\ctx]$. 
Noting that: 
$$
(\heap', \store', \ctx') = (\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''}  = \smodels{\sheap', \sstore', \sctx'}{\pc''}
$$
the result follows. 
\vspace{6pt}


\noindent\prooflab{Procedure Call} 
We conclude that $\ccmd{i} =   \jsilcall{\jvar}{\jsilexpr}{\jsilexpr_i \mid_{i = 0}^{n}}{j}$
for some variable $\jvar$, expressions $\jsilexpr$, $\jsilexpr_0$, ..., $\jsilexpr_n$, and 
index $j$, and $\symbtrans{\sheap, \sstore, i, \pc}{\sheap, \sstore', 0, \pc}[\sctx][\sctx']$
where: 
$$
\begin{array}{l}
\sheap' = \sheap
%
\qquad
% 
\sstore' = [ \jvar_i \mapsto \sexpr_i \mid_{i = 0}^{m}] 
%
\qquad 
%
\ctx' = ((\pid', \sstore, \jvar, i+1, j)::\sctx
\\
%
\pid' = \symbeval{\jsilexpr}{\sstore}
%
\qquad 
%
\jsillist{\jvar_1, ..., \jvar_{m}} = \args(\pid')
%
\qquad
%
\sexpr_i = \left\lbrace{\begin{array}{ll}
\symbeval{\jsilexpr_i}{\sstore} & \text{if } 0 \leq i \leq n \\
\jsundefined                            & \text{otherwise}
\end{array}}\right.
\end{array}
$$
Since $(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''}$, we conclude that 
there is a symbolic environment $\senv$ such that: $\senv \vdash \pc''$, 
$\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, 
and $\ctx = \semexpr{\sctx}{\senv}$.
Noting that: 
$$
%\begin{array}{l}
\semexpr{\jsilexpr}{\store} = \semexpr{\jsilexpr}{\semexpr{\sstore}{\senv}} 
    = \semexpr{\semexpr{\jsilexpr}{\sstore}}{\senv} 
    = \semexpr{\pid'}{\senv}
    = \pid'   
 \qquad
\semexpr{\jsilexpr_i}{\store} = \semexpr{\jsilexpr_i}{\semexpr{\sstore}{\senv}}
    = \semexpr{\semexpr{\jsilexpr_i}{\sstore}}{\senv}
    = \semexpr{\sexpr_i}{\senv}
%\end{array}
$$
we conclude that 
$\semtrans{\heap, \store, i}{\heap, [ \jvar_i \mapsto \semexpr{\sexpr_i}{\senv} \mid_{i = 0}^{m}] , 0}[\ctx][(\pid', \store, \jvar, i+1, j) :: \ctx]$. 
From: 
$$
\begin{array}{l}
\heap' = \heap = \semexpr{\sheap}{\senv} = \semexpr{\sheap'}{\senv} \\
%
\store' =  [ \jvar_i \mapsto \semexpr{\sexpr_i}{\senv} \mid_{i = 0}^{m}] = \semexpr{[ \jvar_i \mapsto \sexpr_i \mid_{i = 0}^{m}]}{\senv} = \semexpr{\sstore'}{\senv} \\
%
\ctx' = (\pid', \store, \jvar, i+1, j) :: \ctx = (\pid', \semexpr{\sstore}{\senv}, \jvar, i+1, j) :: \semexpr{\sctx}{\senv} = \semexpr{\sctx'}{\senv} 
\end{array}
$$
the result follows. 
\vspace{6pt}


\noindent\prooflab{Normal Return} 
We conclude that $i =  \procretlab$, and 
$$\symbtrans{\sheap, \sstore, \procretlab, \pc}{\sheap, \sstore''[\jvar \mapsto \sexpr], i, \pc}[\sctx][\sctx'']$$
where: 
$\sctx = (-, \sstore'', \jvar, i, -) :: \sctx''$ and $\sexpr = \sstore(\procretvar)$. 
Since $(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''}$ and $\pc' = \pc$, we conclude that 
there is a symbolic environment $\senv$ such that: $\senv \vdash \pc''$, 
$\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, 
and $\ctx = \semexpr{\sctx}{\senv}$.
From $\ctx = \semexpr{\sctx}{\senv}$ and $\sctx = (-, \sstore'', \jvar, i, -) :: \sctx''$, we conclude 
that: $\ctx =  (-, \semexpr{\sstore''}{\senv}, \jvar, i, -) :: \semexpr{\sctx''}{\senv}$.
Hence, since $i =  \procretlab$, 
we conclude that: $\semtrans{\heap, \store, \procretlab}{\heap, \semexpr{\sstore''}{\senv}[\jvar \mapsto \val], i}[C][\semexpr{\sctx''}{\senv}]$, 
where $\val =  \store(\procretvar) = \semexpr{\sstore}{\senv}(\procretvar)$.
Noting that: 
$$ 
 \begin{array}{l}
  \heap' = \heap = \semexpr{\sheap}{\senv} = \semexpr{\sheap'}{\senv} \\ 
  %
  \store' = \semexpr{\sstore''}{\senv}[\jvar \mapsto \val] = 
       \semexpr{\sstore''}{\senv}[\jvar \mapsto \semexpr{\sstore}{\senv}(\procretvar)] = 
        \semexpr{\sstore''}{\senv}[\jvar \mapsto \semexpr{\sstore(\procretvar)}{\senv}] = \\
       \qquad  \semexpr{\sstore''[\jvar \mapsto \sstore(\procretvar)]}{\senv}  = 
       \semexpr{\sstore''[\jvar \mapsto \sexpr]}{\senv}  = 
       \semexpr{\sstore'}{\senv}  \\ 
 %
 \ctx' = \semexpr{\sctx''}{\senv} = \semexpr{\sctx'}{\senv} 
\end{array}
$$
the result follows. 
\vspace{6pt}

\noindent\prooflab{Error Return} 
We conclude that $i =  \procerrlab$, and 
$$\symbtrans{\sheap, \sstore, \procerrlab, \pc}{\sheap, \sstore''[\jvar \mapsto \sexpr], j, \pc}[\sctx][\sctx']$$
where: 
$\sctx = (-, \sstore'', \jvar, -, j) :: \sctx''$ and $\sexpr = \sstore(\procerrvar)$. 
Since $(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''}$ and $\pc' = \pc$, we conclude that 
there is a symbolic environment $\senv$ such that: $\senv \vdash \pc$, 
$\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, 
and $\ctx = \semexpr{\sctx}{\senv}$.
From $\ctx = \semexpr{\sctx}{\senv}$ and $\sctx = (-, \sstore'', \jvar, -, j) :: \sctx''$, we conclude 
that: $\ctx =  (-, \semexpr{\sstore''}{\senv}, \jvar, -, j) :: \semexpr{\sctx''}{\senv}$.
Hence, since $i =  \procerrlab$, 
we conclude that: $\semtrans{\heap, \store, \procerrlab}{\heap, \semexpr{\sstore''}{\senv}[\jvar \mapsto \val], i}[C][\semexpr{\sctx''}{\senv}]$, 
where $\val =  \store(\procerrvar) = \semexpr{\sstore}{\senv}(\procerrvar)$.
Noting that: 
$$ 
 \begin{array}{l}
  \heap' = \heap = \semexpr{\sheap}{\senv} = \semexpr{\sheap'}{\senv} \\ 
  %
  \store' = \semexpr{\sstore''}{\senv}[\jvar \mapsto \val] = 
       \semexpr{\sstore''}{\senv}[\jvar \mapsto \semexpr{\sstore}{\senv}(\procerrvar)] = 
        \semexpr{\sstore''}{\senv}[\jvar \mapsto \semexpr{\sstore(\procerrvar)}{\senv}] = \\
       \qquad  \semexpr{\sstore''[\jvar \mapsto \sstore(\procerrvar)]}{\senv}  = 
       \semexpr{\sstore''[\jvar \mapsto \sexpr]}{\senv}  = 
       \semexpr{\sstore'}{\senv}  \\ 
 %
 \ctx' = \semexpr{\sctx''}{\senv} = \semexpr{\sctx'}{\senv} 
\end{array}
$$
the result follows. 
\end{proof}

\begin{lemma}[Monotonicity of Path Condition]\label{lemma:pc:monotonocity}
$$
\begin{array}{l}
\forall \, \sheap, \sheap', \sstore, \sstore', i, j, \sctx, \sctx', \pc, \pc' \, . \,  \\ 
\qquad \symbtranstrans{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx']  
   \implies \pc' \vdash \pc
\end{array}
$$
\end{lemma}
\begin{proof}
By induction on the length of the symbolic trace $$\symbtranstrans{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx']$$ 
using case analysis for each step. 
\end{proof}


\begin{lemma}[Soundness of \jsil symbolic execution]\label{lemma:full:soundness}
$$
\begin{array}{l}
\forall \, \sheap, \sheap', \heap, \sstore, \sstore', \store, i, j, \sctx, \sctx', \ctx, \pc, \pc', \pc'' \, . \,  \\ 
%
\quad \symbtranstrans{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx'] 
   \ \wedge \ 
      (\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''}  
           \ \wedge \  \pc'' \vdash \pc'   \\ \quad \quad
      	 \ \implies \exists (\heap', \store', \ctx') \, . \, 
	 	 \semtranstrans{\heap, \store, i}{\heap', \store', j}[\ctx][\ctx']
		\, \wedge \, 
		(\heap', \store', \ctx') \in \smodels{\sheap', \sstore', \sctx'}{\pc''}  
\end{array}
$$
\end{lemma}
\begin{proof}
Suppose $\symbtranstrans{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx']$ (\hyp{1}) 
and $(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''}$ (\hyp{2}). 
We have to prove that there is a concrete heap $\heap'$, store $\store'$, and context 
$\ctx'$ such that $\semtranstrans{\heap, \store, i}{\heap', \store', j}[\ctx][\ctx']$
and $(\heap', \store', \ctx') \in \smodels{\sheap', \sstore', \sctx'}{\pc''}$. 
We proceed by induction on the length of the symbolic trace 
$$\symbtranstrans{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx']$$ 
using case analysis for each step. Suppose the symbolic trace has length $n$. 
\vspace{6pt}

\prooflab{Base} $n = 0$. It follows that $\sheap' = \sheap$, $\sstore' = \sstore$, 
$\sctx' = \sctx$, $\pc' = \pc$, and $j = i$. Noting that: 
$\semtranstrans{\heap, \store, i}{\heap, \store, i}[\ctx][\ctx]$
and 
$(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''} = \smodels{\sheap', \sstore', \sctx'}{\pc''}$, 
the result follows. 
\vspace{6pt}

\prooflab{Inductive Case} $n = m + 1$. It follows that there is a symbolic heap $\sheap''$, 
store $\sstore''$, context $\sctx''$, and path condition $\pc'''$ such that: 
$$
\symbtranstrans{\sheap, \sstore, i, \pc}{\sheap'', \sstore'', k, \pc'''}[\sctx][\sctx''] \ (\ieq{1})
\qquad 
\symbtrans{\sheap'', \sstore'', k, \pc'''}{\sheap', \sstore', j, \pc'}[\sctx''][\sctx'] \ (\ieq{2})
$$
Applying Lemma~\ref{lemma:pc:monotonocity} to \ieq{2}, we conclude that $\pc' \vdash \pc'''$ (\ieq{3}), 
from which it follows (recalling that $\pc'' \vdash \pc'$) that $\pc'' \vdash \pc'''$ (\ieq{4}).
%
Applying the induction hypothesis to \ieq{1}, \hyp{2}, and \ieq{4}, and, we conclude that 
there is a heap $\heap''$, store $\store''$, and context $\ctx''$, such that: 
$$
 \semtranstrans{\heap, \store, i}{\heap'', \store'', k}[\ctx][\ctx''] \ (\ieq{5})
 \quad 
(\heap'', \store'', \ctx'') \in \smodels{\sheap'', \sstore'', \sctx''}{\pc''}  \ (\ieq{6})
$$
Applying Lemma~\ref{lemma:soundness:single:step} to \ieq{2}, \ieq{6}, 
and $\pc'' \vdash \pc'$, we conclude that there is 
a heap $\heap'$, store $\store'$, and context $\ctx'$, such that: 
$$
 \semtranstrans{\heap'', \store'', k}{\heap', \store', j}[\ctx''][\ctx'] \ (\ieq{7})
 \quad 
(\heap', \store', \ctx') \in \smodels{\sheap', \sstore', \sctx'}{\pc''} \ (\ieq{8})
$$
Combining \ieq{5} and \ieq{7}, we conclude that $\semtranstrans{\heap, \store, i}{\heap', \store', j}[\ctx][\ctx']$ (\ieq{9}). 
Equations \ieq{8} and \ieq{9} conclude the proof. 
\end{proof}



\begin{temax}[Theorem~\ref{teo:soundness:jsil:symb:exe} - Soundness of the \jsil symbolic execution]
$$
\begin{array}{l}
\forall \, \sheap, \sheap', \heap, \sstore, \sstore', \store, i, i', \sctx, \sctx', \ctx, \pc, \pc' \, . \,  \\  
\quad \symbtranstrans{\sheap, \sstore, i, \pc}{\sheap', \sstore', i', \pc'}[\sctx][\sctx'] 
   \ \wedge \ 
      (\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc'} \\ \quad \quad
      	 \ \Rightarrow \ \exists (\heap', \store', \ctx') \, . \, 
	 	 \semtranstrans{\heap, \store, i}{\heap', \store', i'}[\ctx][\ctx']
		\, \wedge \, 
		(\heap', \store', \ctx') \in \smodels{\sheap', \sstore', \sctx'}{\pc'}  
\end{array}
$$
\end{temax}
\begin{proof}
It follows immediately from Lemma~\ref{lemma:soundness:single:step} noting that $\pc' \vdash \pc'$. 
\end{proof}


\begin{cormax}[Corollary~\ref{bug:finding} - Bug-finding]
$$
\begin{array}{l}
\forall \, \sheap, \sstore, \sctx, i, \pc, \pc' \, . \,  
 \symbtranstranserr{\sheap, \sstore, i, \pc}{\sctx}{\pc'}  \ \wedge \  \pc' \text{ is satisfiable} \\ 
   \quad \implies 
     \exists \heap, \store, \ctx \, . \, \semtranstranserr{\heap, \store, i}[\ctx]
\end{array}
$$
\end{cormax}
\begin{proof}
Since $\pc'$ is satisfiable we conclude that there there exist a concrete heap $\heap$, 
store $\store$, and context $\ctx$, such that $(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc'}$ 
\end{proof}


\begin{cormax}[Corollary~\ref{corollary:verification} - Verification]
$$
\begin{array}{l}
\forall \, \sheap, \sheap_1, ..., \sheap_k, \sstore, \sstore_1, ..., \sstore_k, \sctx, \sctx_1, ..., \sctx_k, i, j_1, ..., j_k, \pc, \pc_1, ..., \pc_k \, . \,  \\
  \quad \symbtranstrans{\sheap, \sstore, i, \pc}{\sheap_k, \sstore_k, j_k, \pc_k}[\sctx][\sctx_k]\mid_{k = 1}^n
      \ \wedge \ \pc \vdash \bigvee_{k=1}^n \pc_k \\ 
      \quad \quad \implies 
         \forall \heap, \store, \ctx \, . \, (\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc} \\
          \quad \qquad \implies \exists \heap', \store', \ctx' \, . \, 
                  \semtranstrans{\heap, \store, i}{\heap', \store', j_k}[\ctx][\ctx'] \ \wedge \ 
                  (\heap', \store', \ctx') \in \smodels{\sheap_k, \sstore_k, \sctx_k}{\pc_k}
\end{array}
$$
\end{cormax}
\begin{proof}
Suppose $(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc}$. Then, since $\pc \vdash \bigvee_{k=1}^n \pc_k$, 
we conclude that there is $1 \leq k \leq n$ such that:
 $(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc_k}$. 
 Observing that $\symbtranstrans{\sheap, \sstore, i, \pc}{\sheap_k, \sstore_k, j_k, \pc_k}[\sctx][\sctx_k]$, we can 
 apply Theorem~\ref{teo:soundness:jsil:symb:exe} and conclude the result. 
 \end{proof}



