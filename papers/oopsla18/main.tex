\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{CONF} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2018}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

\setcopyright{none}

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}  

\usepackage{enumitem}
\setlist[description]{leftmargin=\parindent,labelindent=\parindent}

\usepackage{xcolor}
%\usepackage{amsmath}
\usepackage{listingsutf8}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{xspace}
\usepackage{textcomp}
\usepackage{wasysym,stmaryrd}
\usepackage{mathpartir}
\usepackage{url}
%\usepackage{upgreek}
\usepackage{xparse}
\usepackage{booktabs}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage{stix}

%\usepackage{algorithm}
%\usepackage{algpseudocode}

\usepackage{wrapfig}
\usepackage{fancyvrb}

\makeatletter
\newif\ifFV@bgcolor
\newbox\FV@bgbox
\define@key{FV}{bgcolor}{\FV@bgcolortrue\def\FV@bgcolor{#1}}

\def\FV@BeginVBox{%
  \leavevmode\ifFV@bgcolor\setbox\FV@bgbox=\fi
  \hbox\ifx\FV@boxwidth\relax\else to\FV@boxwidth\fi\bgroup
  \ifcase\FV@baseline\vbox\or\vtop\or$\vcenter\fi\bgroup}
\def\FV@EndVBox{\egroup\ifmmode$\fi\hfil\egroup
  \ifFV@bgcolor\colorbox{\FV@bgcolor}{\box\FV@bgbox}\fi}
\makeatother

\newcommand{\shat}{\^{s}}

%JavaScript 
\definecolor{SkyBlue}{rgb}{0.20,0.39,0.64}
\definecolor{Plum}{rgb}{0.46,0.31,0.48}
\definecolor{Chocolate}{rgb}{0.75,0.49,0.07}
\definecolor{Aluminium5}{rgb}{0.33,0.34,0.32}
\definecolor{DarkGreen}{rgb}{0.2,0.5,0.2}
\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkblue}{rgb}{0,0.2,0.7}
\definecolor{dkgreen}{rgb}{0,0.4,0}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}
\definecolor{dkred}{rgb}{0.6,0,0}
\definecolor{talkred}{rgb}{0.69,.20,0.22}
\definecolor{talkblue}{rgb}{0.04,0.40,0.80}
\definecolor{talkgreen}{rgb}{0.34,.81,0.10}
\definecolor{oldtalkblue}{rgb}{0.22,.20,0.69}
\definecolor{greenish}{rgb}{.0,.65,.0}
\definecolor{mygray}{gray}{0.9}

\lstset{
	showstringspaces=false
}

\lstdefinelanguage{JavaScript}{
  morekeywords=[1]{typeof, new, true, false, catch,
    function, return, null, catch, switch, var,
    if, in, while, do, else, case, break, continue},
  morekeywords=[2]{class, export, boolean, throw, implements, import, this},
  numbers=left,
  numbersep=4pt,
  numberstyle=\tiny\color{dkblue},
  columns=fullflexible,
  sensitive=false,
  comment=[l]{//},
  captionpos=b,   
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  basicstyle=\scriptsize\texttt,
  identifierstyle=\ttfamily\color{Aluminium5},
  keywordstyle=[1]\ttfamily\color{Plum},
  keywordstyle=[2]\ttfamily\color{SkyBlue},
  stringstyle=\ttfamily\color{DarkGreen},
  commentstyle=\ttfamily, 
%  commandchars=\$\{\}
}[keywords,comments,strings]

\lstdefinelanguage{Scheme}{
  morekeywords=[1]{define, define-syntax, define-macro, lambda, define-stream, stream-lambda},
  morekeywords=[2]{begin, call-with-current-continuation, call/cc,
    call-with-input-file, call-with-output-file, case, cond,
    do, else, for-each, if,
    let*, let, let-syntax, letrec, letrec-syntax,
    let-values, let*-values,
    and, or, not, delay, force,
    quasiquote, quote, unquote, unquote-splicing,
    map, fold, syntax, syntax-rules, eval, environment, query },
  morekeywords=[3]{import, export},
  alsodigit=!\$\%&*+-./:<=>?@^_~,
  sensitive=true,
  morecomment=[l]{;},
  morecomment=[s]{\#|}{|\#},
  morestring=[b]",
  basicstyle=\scriptsize\ttfamily,
  keywordstyle=\bf\ttfamily\color[rgb]{0,.3,.7},
  commentstyle=\color[rgb]{0.133,0.545,0.133},
  stringstyle={\color[rgb]{0.75,0.49,0.07}},
  upquote=true,
  breaklines=true,
  breakatwhitespace=true,
  literate=*{`}{{`}}{1}
}

\def\schemeinline{\lstinline[language=Scheme, basicstyle=\small\ttfamily]}

\lstnewenvironment{lstjs}{\lstset{language=JavaScript,basicstyle=\fontsize{8}{8}\ttfamily,escapeinside={~}{~}}}{}
\def\jsinline{\lstinline[language=JavaScript, basicstyle=\small]}


% The Acronyms of the project and some other stuff
\newcommand{\jsil}{JSIL\xspace}
\newcommand{\jsverify}{JSVerify\xspace}
\newcommand{\JSComp}{JS-2-JSIL\xspace}
\newcommand{\jsilverify}{JSILVerify\xspace}


% Tikz 
\usepackage{tikz}
\usetikzlibrary{calc,positioning,arrows,shapes,decorations.pathmorphing}
\usetikzlibrary{arrows,positioning} 
\tikzset{
    %Define standard arrow tip
    >=stealth',
    % Define arrow style
    pil/.style={
           ->,
           shorten <=2pt,
           shorten >=2pt,}
}

\newcommand{\runpic}{\includegraphics[width=0.06\picwidth]{running.pdf}}
\newcommand{\tickpic}{\resizebox{0.06\picwidth}{!}{\(\color{greenish} \checkmark \)}}
\tikzset{
  box/.style = {rectangle, draw=black,align=center,font=\scriptsize},
  sbox/.style = {rectangle,draw=black,align=left,font=\scriptsize,text width=1.7cm},
  p/.style = {-latex},
  dp/.style = {latex-latex},
  sz/.style n args={2}{minimum width=#2, minimum height=#1},
  m/.style = {midway,inner sep=0pt,fill=white},
  ll/.style = {font=\scriptsize,anchor=south west}
}



% Polishing...
\newcommand{\polish}[1]{{\color{red}#1}}


\usepackage{cosette_macros}


% macros_js as for Jose Santos
%\usepackage{macros_js}
%\usepackage{gdshojs}

\newcommand{\jilette}{Cosette\xspace}
\newcommand{\rosette}{Rosette\xspace}

\newcommand{\myparagraph}[1]{\smallskip\noindent {\bf #1.}\hspace{1pt}}
\newcommand{\myparagraphq}[1]{\smallskip\noindent {\bf #1?}\hspace{1pt}}

% COMMENTS

\newcommand{\pginline}[1]{ {\color{red} *** PG : #1 ***} }
\newcommand{\pmaxinline}[1]{ {\color{blue} *** PM : #1 ***} }
\newcommand{\jfsinline}[1]{ {\color{green} *** JFS : #1 ***} }
\newcommand{\jdinline}[1]{ {\color{purple} *** JD : #1 ***} }

\newif\ifComments
\Commentstrue

\newcommand{\pg}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.95\textwidth} \color{red}
{\rm PG: \small #1}
\end{minipage}}
\end{center}
\fi}

\newcommand{\pmax}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.95\textwidth} \color{blue}
{\rm PM: \small #1}
\end{minipage}}
\end{center}
\fi}

\newcommand{\jfs}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.95\textwidth} \color{SkyBlue}
{\rm JFS: \small #1}
\end{minipage}}
\end{center}
\fi}

\newcommand{\jd}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.95\textwidth} \color{purple}
{\rm JD: \small #1}
\end{minipage}}
\end{center}
\fi}

%% Title information
\title[Short Title]{\jilette:~Compositional Symbolic Execution for JavaScript}         
%\titlenote{with title note}           
%\subtitle{Subtitle}                     
%\subtitlenote{with subtitle note}   

%% Author with single affiliation.
\author{First1 Last1}
\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position1}
  \department{Department1}              %% \department is recommended
  \institution{Institution1}            %% \institution is required
  \streetaddress{Street1 Address1}
  \city{City1}
  \state{State1}
  \postcode{Post-Code1}
  \country{Country1}                    %% \country is recommended
}
\email{first1.last1@inst1.edu}          %% \email is recommended

%% Author with two affiliations and emails.
\author{First2 Last2}
\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position2a}
  \department{Department2a}             %% \department is recommended
  \institution{Institution2a}           %% \institution is required
  \streetaddress{Street2a Address2a}
  \city{City2a}
  \state{State2a}
  \postcode{Post-Code2a}
  \country{Country2a}                   %% \country is recommended
}
\email{first2.last2@inst2a.com}         %% \email is recommended
\affiliation{
  \position{Position2b}
  \department{Department2b}             %% \department is recommended
  \institution{Institution2b}           %% \institution is required
  \streetaddress{Street3b Address2b}
  \city{City2b}
  \state{State2b}
  \postcode{Post-Code2b}
  \country{Country2b}                   %% \country is recommended
}
\email{first2.last2@inst2b.org}         %% \email is recommended

%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
We present \jilette, a framework for trustworthy, compositional symbolic execution of JavaScript programs.
\jilette is the first symbolic analysis tool for JavaScript that precisely models the semantics of the language.
Its aim is to assist the general programmer in debugging their code; the programmer writes symbolic tests for which \jilette provides concrete counter-models.
We prove that the symbolic execution underpinning \jilette is sound and that it does not generate false positives. Moreover, this symbolic execution is compositional, which allows us to use \jilette to find bugs in separation logic specifications of JavaScript programs that are not detectable by standard symbolic execution techniques.
%\pmaxinline{Now compositionality.}
%
We evaluate \jilette on an array of examples, including tests from the official JavaScript Test262 test suite and real-world Node.js libraries. These examples involve JavaScript-specific features, such as prototype inheritance, function closures, the for-in statement, and dynamic dispatch. We highlight the range of \jilette by using it to find bugs in a number of non-trivial separation logic specifications of JavaScript programs.


%
%It works by compiling JavaScript programs to \jsil using \JSComp, a well-tested, standard-compliant compiler from JavaScript to \jsil, and then symbolically executing the obtained \jsil code using a novel symbolic interpreter for \jsil. We prove that the \jsil symbolic interpreter is \emph{sound} and that it does not generate false positives.
%
%\bigskip
%We present \jilette, a symbolic execution tool for JavaScript (ECMAScript 5, ES5), which precisely follows the language standard. At the core of \jilette is a sound symbolic interpreter for \jsil, an intermediate language well-suited for verification and analysis. This interpreter is written in \underline{Rosette}, %~\cite{Rosette2,Rosette1}, 
%a symbolic virtual machine that enables the design of new solver-aided languages. 
%\jilette works by first compiling JavaScript programs to \jsil using \underline{\JSComp}, %~\cite{javert}, 
%a well-tested, standard-compliant compiler from JavaScript to \jsil, and then symbolically executing the compiled \jsil code in the \jsil symbolic interpreter. 
%We study two complementary uses of \jilette. 
%First, we show how \jilette can be used for symbolic testing of JavaScript programs by finding concrete executions that trigger assertion and test failures. 
%We highlight the range of \jilette by giving examples using strings, regular expressions, and the notorious \jsinline|eval| statement.
%Second, building on \jilette, we develop a tool for debugging separation logic specifications by compiling them to symbolic tests in order to find 
%witnesses for bugs in both specification and code.
%
%\bigskip
%We present \jilette, a framework for bounded symbolic execution of JavaScript (JS) code (ECMAScript 5, ES5). 
%\jilette is the first symbolic execution tool for JS that models the language semantics precisely.  
%It works by first compiling JS programs to \jsil using \JSComp, a well-tested, standard-compliant compiler from 
%JS to \jsil, and then symbolically executing the obtained \jsil code using a novel symbolic interpreter for \jsil. 
%We prove that the \jsil symbolic interpreter is \emph{sound} and that it does not to generate false positives. 
%%every time the tool reports a bug, it provides a concrete model that triggers that bug. 
%
%We demonstrate how \jilette can be used for the symbolic testing of JS programs by 
%finding concrete executions that trigger assertion and test failures. We highlight the range of \jilette 
%by giving examples involving JS-specific features, such as: prototype-based inheritance, 
%the for-in statement, and JS arrays. Finally, we thoroughly evaluate \jilette against a 
%representative fragment of test262 adapted to include symbolic~values.
%
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
%\keywords{keyword1, keyword2, keyword3}  %% \keywords are mandatory in final camera-ready submission

%\usepackage{amsmath, amssymb, amscd,mathrsfs}
%\DeclareMathAlphabet{\mathbbm}{U}{bbm}{m}{n}


\begin{document}
%

\maketitle 

\section{Introduction}


In current program analysis research, there exists a gap between bug-finding techniques and verification techniques. In bug-finding, the aim is to discover concrete executions that cause a given program to behave incorrectly, and the emphasis is on precision, that is, the absence of false positive bug reports. In verification, the aim is to produce a proof that a given program always behaves correctly, and the emphasis is on soundness, which mandates adherence to the language standard and the exploration of all possible paths. 
%
Soundness, however, comes at a cost: verification techniques are often too conservative, rejecting many programs that are safe, and have prohibitive scalability issues.
%
There is a growing consensus among experts that soundness is, in fact, not a necessity for most modern analysis applications~\cite{.}. Instead, the property they advocate and observe in the  majority of tools is \emph{soundiness}---maintaining soundness as much as possible, but without detrimental effects to precision and/or scalability.

The main issue with most bug-finding tools is not that they are soundy, but that they are not \emph{trustworthy}: their soundiness and precision are not formally characterised. They are usually not justified with respect to the semantics of the targeted language, often relying on unstated simplifying assumptions, if not explicitly departing from the semantics of the language. Consequentially, the fact that a bug-finding tool cannot find a bug carries no guarantees with respect to the correctness of the input program. We trust these tools because they appear to work empirically.

Another difference between bug-finding and verification is that bug-finding tools are often based on whole-program analysis, whereas verification techniques are normally \emph{compositional}, meaning that the results of an analysis for a part of a program can be re-used when analysing the entire program. Compositionality is essential for tools that need to run regularly on large codebases. For instance, it would not be possible for Infer, a bug-finding tool based on separation logic, to be part of the continuous integration system at Facebook if it were not compositional. 

We present \jilette, the first trustworthy, compositional symbolic execution framework for JavaScript (ECMAScript 5 Strict~\cite{ecma}) analysis. \jilette precisely follows the ES5 English standard, without introducing any simplifications. 
It aims at the sweet spot between bug-finding and verification, 
%It is not done directly on JavaScript, but instead on \jsil, an intermediate representation previously introduced for JavaScript verification~\cite{javert}. \jsil comes with a trusted infrastructure that allows us to provably lift the results of symbolic analyses on compiled \jsil code back up to JavaScript. 
in that it comes with formal correctness guarantees and a precise result stating the conditions under which symbolic execution gives soundness. 

%Additionally, its compositionality allows us to catch a broader class of bugs than the current symbolic execution tools and also allows us to state the conditions under which the soundiness of \jilette becomes soundness, that is, when the absence of found bugs implies verification.

%However, compositionality is not trivial to achieve when the targeted programming language does not exhibit the frame property, as is the case for most dynamic languages including JavaScript.




%JavaScript is the most widespread dynamic language: it is the de facto language for client-side Web applications, used by 94.8\% of websites\footnote{\url{https://w3techs.com/technologies/details/cp-javascript/all/all}}; it is used for server-side scripting via Node.js; and it is even run on small embedded devices with limited memory. 
%It is the most active language in both GitHub and StackOverflow.\footnote{\url{http://githut.info}; \url{https://exploratory.io/viz/Hidetaka-Ko/94368d12800a?cb=1469037012628}}
%Due to its dynamic nature and complex semantics, JavaScript remains a difficult target for symbolic analysis and logic-based verification. 

%\pmax{Now, sth about the state-of-the-art}

% TO RELATED WORK
%Currently, several symbolic analysis tools for JavaScript are available, such as \pmaxinline{list them, cite them - are we doing static or dynamic also?}. \pmaxinline{Say something positive, don't know what, mention bug-finding}. However, there exists a gap that needs to be addressed. The symbolic analysis engines of these tools are not formalised and do not come with correctness guarantees \pmaxinline{check, especially Jalangi}. Their analyses are also not compositional \pmaxinline{We don't know what this means yet, also check, but possibly omit}. Moreover, each of these tools is tailored for catching a specific category of bugs, rather than targeting bug-finding in general \pmaxinline{give evidence - also, why do we care?}.



%We evaluate \jilette on an array of examples, including tests from the official JavaScript Test262 test suite and real-world Node.js libraries. These examples involve JavaScript-specific features, such as prototype inheritance, function closures, the for-in statement, and dynamic dispatch. We highlight the range of \jilette by using it to find bugs in a number of non-trivial separation logic specifications of JavaScript programs.



%In \S\ref{???}, we give an abstract semantics of \jsil, which we instantiate to obtain the concrete %, instrumented (discussed shortly), 
%and symbolic semantics, connected via a {\em soundness result}. Moreover, we prove that, when used for symbolic testing (discussed shortly), \jilette never produces false counter-models. 
%These theoretical results, combined with the correctness of \JSComp, allows us to lift the results of analyses done on compiled \jsil code back up to JavaScript. 

%To our knowledge, this is the first formalisation of a symbolic execution used for JavaScript analysis, and is the first symbolic execution that precisely follows the semantics of the language.

\myparagraph{Architecture} Something.

\myparagraph{Novelty: Trustworthiness} Designing a tractable symbolic analysis for JavaScript that is faithful to the language standard and providing correctness results for such an analysis is known to be a difficult task, due to the complexity of the language. The current approaches \pmaxinline{cite stuff} normally do not give a formal account of the analysis and/or simplify the language semantics. Our approach to designing \jilette is grounded on adherence to the standard and establishing trust. 
To contain the complexity of JavaScript, we move the analysis to \jsil, an intermediate representation for logic-based analysis of JavaScript~\cite{javert}. 
\jsil comes with a trusted compiler, \JSComp, which has been extensively tested against the official test suite, Test262,\footnote{\url{https://github.com/tc39/test262}} and produces \jsil code that corresponds line-by-line to the standard. 
In \S\ref{???}, we give a novel abstract semantics of \jsil, which we instantiate to obtain the concrete %, instrumented (discussed shortly), 
and symbolic semantics, connected via a {\em soundness result}. Moreover, we prove that, when used for symbolic testing (discussed shortly), \jilette never produces false counter-models. 
These theoretical results, combined with the correctness of \JSComp and the fact that the memory models of JavaScript and \jsil are the same by design, allow us to  provably lift the results of analyses done on compiled \jsil code back up to JavaScript. To our knowledge, this is the first formalisation of a symbolic execution used for JavaScript analysis, and is the first symbolic execution for JavaScript that precisely follows the semantics of the language. 

\myparagraph{Novelty: Compositionality} 
Static languages, such as C, C++, or Java, observe the so-called \emph{frame property}, first introduced formally for separation logic~\cite{???}, but intuitively known to language designers and programmers. 
What the frame property means, in a nutshell, that if a program produces a given output when run from a given state, then we can extend this state arbitrarily, run the program from this extended state, and the program will produce the same output. This also means that we can analyse parts of the program separately and then compose the obtained results to obtain the analysis of the entire program. For static languages, this \emph{compositionality} is a property of the language semantics and symbolic analysis tools for such languages leverage on it for free.
%
On the other hand, dynamic languages, such as JavaScript and \jsil, do not observe the frame property. 
This means that the behaviour of a JavaScript/\jsil program may change if the state in which it is run is extended; such extensions may introduce bugs, to which we refer as \emph{frame bugs}. 
%
Current symbolic execution tools for JavaScript~\cite{???} are not compositional. They employ \emph{whole-program analyses}, that is, they assume access to the entire program, meaning that the results they obtain when analysing functions in isolation cannot be reused, as they would not account for the interaction between the function and all of its possible frames.
%
In contrast, the symbolic execution of \jilette is compositional. \jilette can analyse a fragment of a program at a time, and the obtained results can be re-used in the analysis of the entire program. This has two important benefits.
%
First, it allows us to apply function summaries~\cite{???} instead of symbolically executing function bodies at each call site, speeding up execution time. This benefit is independent of the analysed language.
%
Second, it allows us to catch frame bugs, which are not reachable by non-compositional symbolic execution tools. This benefit is specific to dynamic languages.
%
We achieve compositionality by instrumenting the concrete semantics to keep track of properties that we know are {\em not present} in a given object. This we describe in detail in \S\ref{???}. To our knowledge, \jilette is the first compositional symbolic execution tool for dynamic languages.



%dynamic languages: they feature extensible objects, dynamic property access, and dynamic function calls. In terms of separation logic, they do not have the frame property~\cite{???}. What this effectively means is that is possible to introduce bugs into a JS/\jsil program by only extending the state for which it behaved correctly. We refer to such bugs as {\em frame bugs}.  This benefit is independent of the analysed language. Second, it allows us to catch frame bugs, which are not reachable by non-compositional symbolic execution tools. This benefit is specific to dynamic languages. We achieve compositionality by keeping track of properties that we know are {\em not present} in a given object. This we describe in detail in \S\ref{???}. To our knowledge, \jilette is the first compositional symbolic execution tool for dynamic languages.


\myparagraph{Application: Symbolic Testing} A commonly used 
approach to obtaining trust in JavaScript code is running it against 
adhoc test batteries---verifying that, given some concrete inputs, the code produces the expected
outputs. The main drawback of this approach is that manually created test suites often have a high degree of incompleteness that is not properly characterised. % we also cant guarantee exhaustiveness 
In \S\ref{???}, we show how to use \jilette
for symbolic testing of JavaScript code: instead of 
tests with concrete 
inputs, the developer uses symbolic inputs and states the 
constraints that the output needs to satisfy as simple, intuitive 
first-order assertions over these inputs. 
Then, if a test fails, \jilette provides the concrete inputs that cause it 
to fail, exposing bugs in the tested code. 
%We give a {\em proof} that \jilette does not produce false positives. 
Moreover, the compositionality of \jilette allows us to catch bugs that are not reachable by standard symbolic execution tools.
We illustrate the capabilities of \jilette on an array of examples, which include tests from the Test262 test suite and real-world Node.js libraries, and which make use of JavaScript-specific features, such as prototype inheritance, function closures, the for-in statement, and dynamic dispatch. \pmaxinline{Revisit after evaluation.}

\myparagraph{Application: Specification-directed Bug-finding} \pmaxinline{Very stuck here.} Due to the complexity of JavaScript semantics, functional correctness 
specifications of JavaScript programs are highly intricate. 
There are only a few tools (for example, \javert \cite{javert} and KJS \cite{Park:2015,stefanescu-park-yuwen-li-rosu-2016-oopsla}) that support such expressivity. They target the specialist developer wanting rich, 
mechanically verified specifications of critical JavaScript code.
However, when these 
tools cannot prove that a given function satisfies a specification, to discover the error, 
the developer needs to understand in detail a complicated proof trace (\javert), or  act with essentially no feedback~(KJS). In \S\ref{???}, we show how \jilette can be used as an auxiliary mechanism for debugging 
separation logic specifications of JavaScript programs in \javert. 
Our approach consists of translating the separation logic specifications 
into symbolic tests 
and running these tests using \jilette. 
Then, if a symbolic test generated from a given specification fails, we can 
be sure that the code to be verified does not satisfy its specification. 
More importantly, \jilette then generates a concrete witness that 
invalidates the specification. This information greatly simplifies the debugging of 
both specifications and code.

%\pmax{Say more clearly what the novelty is. Say in a very pretty way the connection between seplogic and non-seplogic, verification and symbolic execution, etc.}

%We highlight two relevant use cases for \jilette. First, we show how \jilette can be used as \dtag{i}~a tool for running symbolic tests for JavaScript programs; and \dtag{ii} a debugging tool for separation logic specifications of JavaScript programs.

%\myparagraph{Architecture}
%The core of \jilette consists of a symbolic interpreter for
%\jsil~\cite{javert}, a simple intermediate goto language. 
%We obtain this symbolic interpreter \emph{for free}, 
%by implementing a concrete \jsil interpreter in Rosette~\cite{Rosette2,Rosette1},~a 
%symbolic virtual machine that facilitates generation of solver-aided languages.
%We design the concrete interpreter so that all of Rosette's natively supported solver-aided features, such as advanced string and regular-expression reasoning, 
%are lifted to the \jsil symbolic interpreter. 
%In~\S\ref{sec:jsil:symb:exec}, we give a formalisation of the \jsil concrete and symbolic executions, linking them together with a {\em soundness result}. We also provide insights on how to correctly design the concrete \jsil interpreter in Rosette.

%The second component that \jilette uses is \JSComp~\cite{javert}, 
%a well-tested, standard-compliant compiler from JavaScript to \jsil. We extend
%\JSComp with support for the non-strict mode of ES5, as well as
%regular expressions and the entire \jsinline|String| built-in library.
%\JSComp allows us to lift the \jsil symbolic execution to JavaScript by first compiling JavaScript code to \jsil code, and
%then symbolically executing the compiled code in the 
%\jsil symbolic interpreter. This process, described in \S\ref{symb:exec:comp},
%involves extending JavaScript syntax and the \JSComp compiler to support symbolic values and 
%constructs for reasoning about them. These constructs are intuitive
%and allow the general developer to easily write assertions about the behaviour
%of their program. 
%Moreover, we adjust the \jsil symbolic interpreter so that the abstraction level 
%of the generated \jsil code precisely matches the abstraction level of Rosette, 
% maximising the use of Rosette's native reasoning capabilities.

%\myparagraph{Application: Symbolic Testing} A commonly used 
%approach to obtaining trust in JavaScript code is running it against 
%adhoc test batteries---verifying that given concrete inputs, the code produces the expected
%output. The main drawback of this approach is that tests, in general,
%cannot guarantee exhaustiveness. % we also cant guarantee exhaustiveness 
%In \S\ref{symbolic:testing}, we show how to use \jilette
%for symbolic testing of JavaScript code: instead of 
%tests with concrete 
%inputs, the developer uses symbolic inputs and states the 
%constraints that the output needs to satisfy as simple, intuitive 
%first-order assertions over these inputs. 
%Furthermore, if a test fails, \jilette provides the concrete inputs that cause it 
%to fail, exposing bugs in the tested code. 
%We highlight the capabilities of \jilette through examples that showcase
%challenging reasoning on strings, regular expressions, and the \jsinline|eval|
%statement.

%\myparagraph{Application: Debugging Separation Logic Specifications}
%Due to the complexity of JavaScript semantics, functional correctness 
%specifications of JS programs are highly intricate. 
%There are only a few tools (for example, \javert \cite{javert} and KJS \cite{Park:2015,stefanescu-park-yuwen-li-rosu-2016-oopsla}) that support such expressivity. They target the specialist developer wanting rich, 
%mechanically verified specifications of critical JavaScript code.
%However, when these 
%tools cannot prove that a given function satisfies a specification, to discover the error, 
%the developer needs to understand in detail a complicated proof trace (\javert), or even act with almost no feedback~(KJS). 
%
%In \S\ref{sec:specs}, we show how \jilette can be used as an auxiliary mechanism for debugging 
%separation logic specifications of JavaScript programs in \javert. 
%Our approach consists of: translating the separation logic specifications 
%into symbolic tests 
%and running these tests using \jilette. 
%Then, if a symbolic test generated from a given specification fails, we can 
%be sure that the code to be verified does not satisfy its specification. 
%More importantly, \jilette then generates a concrete witness that 
%invalidates the specification. This information greatly simplifies the debugging of 
%both specifications and code. 

%Jilette has the following benefits: 
%
%\dtag{1} it is \emph{useful}, in that it has tangible applications:
%	it can report bugs in JavaScript programs, producing concrete witnesses that trigger these  bugs; 
%	%
%	it can be used as a helper tool for developers of logic-based functional correctness specifications of JavaScript code; 
%	%
%	and it has support for advanced string reasoning, critical for reasoning about commonly used JavaScript code;
%
%\dtag{2} it is \emph{accessible}, in that it can easily be used by a general JavaScript developer: 
%	the annotation burden of \jilette is minimal; 
%	%
%	and the assertion language is simple and intuitive;
%\dtag{3} it is \emph{trustworthy}, in that its components come with correctness guarantees: 
%	the correctness of the \JSComp compiler ensures full adherence to the real semantics of JavaScript;
%	%
%	the soundness result for the symbolic execution used in \jilette guarantees absence of false positives;
%	and \polish{sentence about unification;}
%and \dtag{4} it is \emph{extensible}, in that its coverage can easily be extended in a modular way, allowing support for: 
%	built-in libraries not covered by \JSComp; 
%	%
%	and widely used runtime libraries that are not part of the standard, such as the DOM.

%\pmax{What's the story?
%\begin{enumerate}
%\setlength{\itemsep}{0.5em}
%\item 
%	{\bfseries Slogan}: Symbolic execution for JavaScript that precisely follows the language standard. \\ 
%	{\bfseries Goal}: Symbolic testing, bug-finding, concrete counter-models. \\
%	{\bfseries Novelty}: The precision wrt semantics, formal correctness guarantees. \\ 
%	{\bfseries Benefits}: Trustworthy, sound analysis. \\
%	{\bfseries Limitations}: No loop invariants, bounded. No eval.
%
%\item 
%	{\bfseries Slogan}: Compositional execution for dynamic languages in general, and JavaScript in particular. \\ 
%	{\bfseries Novelty}: Compositionality. \\ 
%	{\bfseries Benefits}: summaries, frame-related bugs.   
%	
%\item 
%	{\bfseries Application}: Symbolic testing of JavaScript programs. \\
%	{\bfseries Novelty}: None? \\ 
%	{\bfseries Evaluation}: Tests for the symbolic execution rules; JS programs using prototype inheritance, arrays, function closures, for-in, dynamic dispatch, etc.; test262 tests; node.js libraries for data structures
%	
%\item 
%	{\bfseries Application}: Debugging of separation logic specifications. \\ 
%	{\bfseries Novelty}: Counter-models for separation logic assertions. \\
%	{\bfseries Evaluation}: JaVerT specifications of this and that.
%\end{enumerate}}




%
%\myparagraphq{Why \jilette} 
%\jilette is \emph{useful}: it has tangible applications. 
%It can report bugs in JavaScript programs, producing concrete witnesses triggering the bugs. It can also be used as a helper tool for developers of logic-based functional correctness specifications of JavaScript code.
%\jilette is \emph{approachable}: it can easily be used by a general JavaScript developer. The annotation burden of \jilette is minimal and the assertion language is simple and intuitive. \polish{Sweet spot?}
%\jilette is \emph{trustworthy}: its components come with correctness guarantees. 
%The correctness of the \JSComp compiler ensures full adherence to the real semantics of JavaScript. The \jilette symbolic execution engine is based on a sound symbolic
%analysis for \jsil, guaranteeing the absence of false positives. \polish{Sentence about unification.}
%Finally, \jilette is \emph{extensible}: its coverage can easily be extended in a modular way. This gives us the mechanism for supporting built-in libraries not covered by \JSComp, or adding support for standard-external runtime libraries, such as the DOM.

\newpage

%\newpage
%
%\myparagraph{What's in the paper}
%
%\bigskip
%\polish{TO GO IN SOMEWHERE \\
%
%Clarify ES5 Strict
%
%JaVerT targets the specialist
%developer wanting rich, mechanically verified specifications of critical JavaScript code.
%Functional correctness, yes, and it works, but paid for by a heavy annotation burden.
%}



%We show how  to use Jilette for writing symbolic tests for client side 
%JavaScript code calling Web APIs. In particular, we demonstrate how to 
%checking the conformance of Web API requests with their specified signatures. 
%The existing solutions for this problem are still imprecise due to the 
%dynamicity of JavaScript combined with the difficulty of reasoning about
%operations on symbolic strings \cite{Idontknow}. Jilette is an excellent fit for
%this task as it leverages on Rosette's back-end
%constraint solver, Z3, which supports reasoning on symbolic strings
%and regular expressions, whereas JS-2-JSIL successfully
%contains the complexity of JavaScript itself.

\newpage
\section{Overview}\label{sec:overview}
\input{sections/overview}


\newpage
\section{Symbolic Execution for \jsil}\label{sec:jsil:symb:exec}
\input{sections/jsil_symb_exec}

\section{Debugging Separation Logic Specifications}\label{sec:specs}
%\input{sections/specs}

\newpage
\section{Evaluation}\label{sec:evaluation}
%\input{sections/evaluation}

\newpage
\section{Related Work} 

The existing literature covers a wide range of analysis techniques for JavaScript programs, including: 
type systems~\cite{thiemann:esop:2005,anderson:ecoop:2005,jensen:sas:2009,typescript:toot:2014,feldthaus:oopsla:2014,bierman:ecoop:2014,rastogi:popl:2015},
control flow analysis~\cite{feldthaus2013efficient}, pointer analysis~\cite{jang2009points,sridharan:ecoop:12} and abstract
interpretation~\cite{kashyap:fse:14,jensen:sas:2009,andreasen:oopsla:2014,park:ecoop:15}, among others. 
Here, we focus on the existing work on logic-based analysis and symbolic execution for JavaScript. 

\myparagraph{Symbolic Execution} Ooga. Booga. Boo.




\myparagraph{Logic-based Analysis} 
%
\cite{gardner:popl:2012} have developed a separation logic for a small fragment of ECMAScript 3, to reason about the variable store emulated in the JavaScript heap.
%
\cite{rosu-serbanuta-2010-jlap} have developed $\mathbb{K}$, a term-rewriting framework  for  formalising the operational
semantics of programming languages.
 In particular, they have developed KJS~\cite{Park:2015} which provides a $\mathbb{K}$-interpretation of the core language and part of the built-in libraries of the ES5 standard. KJS has been tested against the official ECMAScript Test262 test suite and passed all 2782 tests for the core language; the testing results for the built-in libraries are not reported. 
\cite{stefanescu-park-yuwen-li-rosu-2016-oopsla} introduce a language-independent verification infrastructure 
that can be instantiated with a $\mathbb{K}$-interpretation of a  language to automatically generate a symbolic verification tool for that language based on the $\mathbb{K}$ reachability logic. They apply this infrastructure to KJS to generate a verification tool for JavaScript, which they use to verify functional correctness properties of operations for manipulating data structures such as binary search trees, AVL trees, and lists.


\section{Conclusions}\label{conclusions}

\pmaxinline{Can we be more general, and say something like 'logic-based specifications'? It's all about translating to FOL, or even some version of PL. Also, we need to say at some point why we care about specifications written in separation logic.}

\newpage
\bibliography{oopsla18}

\newpage
\appendix

\input{sections/appendix}

\end{document}
