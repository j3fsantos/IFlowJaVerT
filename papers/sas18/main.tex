\documentclass{llncs}


\usepackage{amsmath}
\usepackage{listingsutf8}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{xspace}
\usepackage{textcomp}

\usepackage{amssymb,amsfonts,textcomp,stmaryrd}
\usepackage{mathpartir}
\usepackage{url}
\usepackage{upgreek}
\usepackage{xparse}
\usepackage{booktabs}
\usepackage[utf8]{inputenc}
\usepackage{wrapfig}

\usepackage{xcolor}
\usepackage{macros_js}
\usepackage{gdshojs}

\usepackage{fancyvrb}


\makeatletter
\newif\ifFV@bgcolor
\newbox\FV@bgbox
\define@key{FV}{bgcolor}{\FV@bgcolortrue\def\FV@bgcolor{#1}}

\def\FV@BeginVBox{%
  \leavevmode\ifFV@bgcolor\setbox\FV@bgbox=\fi
  \hbox\ifx\FV@boxwidth\relax\else to\FV@boxwidth\fi\bgroup
  \ifcase\FV@baseline\vbox\or\vtop\or$\vcenter\fi\bgroup}
\def\FV@EndVBox{\egroup\ifmmode$\fi\hfil\egroup
  \ifFV@bgcolor\colorbox{\FV@bgcolor}{\box\FV@bgbox}\fi}
\makeatother


%\acmBadgeL[http://ctuning.org/ae/ppopp2016.html]{ae-logo}
%\acmBadgeR[http://ctuning.org/ae/ppopp2016.html]{ae-logo}

\newcommand{\shat}{\^{s}}

%JavaScript 
\definecolor{SkyBlue}{rgb}{0.20,0.39,0.64}
\definecolor{Plum}{rgb}{0.46,0.31,0.48}
\definecolor{Chocolate}{rgb}{0.75,0.49,0.07}
\definecolor{Aluminium5}{rgb}{0.33,0.34,0.32}
\definecolor{DarkGreen}{rgb}{0.2,0.5,0.2}
\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkblue}{rgb}{0,0.2,0.7}
\definecolor{dkgreen}{rgb}{0,0.4,0}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}
\definecolor{dkred}{rgb}{0.6,0,0}
\definecolor{talkred}{rgb}{0.69,.20,0.22}
\definecolor{talkblue}{rgb}{0.04,0.40,0.80}
\definecolor{talkgreen}{rgb}{0.34,.81,0.10}
\definecolor{oldtalkblue}{rgb}{0.22,.20,0.69}
\definecolor{greenish}{rgb}{.0,.65,.0}
\definecolor{mygray}{gray}{0.9}

\lstset{
	showstringspaces=false
}

\lstdefinelanguage{Scheme}{
  morekeywords=[1]{define, define-syntax, define-macro, lambda, define-stream, stream-lambda},
  morekeywords=[2]{begin, call-with-current-continuation, call/cc,
    call-with-input-file, call-with-output-file, case, cond,
    do, else, for-each, if,
    let*, let, let-syntax, letrec, letrec-syntax,
    let-values, let*-values,
    and, or, not, delay, force,
    quasiquote, quote, unquote, unquote-splicing,
    map, fold, syntax, syntax-rules, eval, environment, query },
  morekeywords=[3]{import, export},
  alsodigit=!\$\%&*+-./:<=>?@^_~,
  sensitive=true,
  morecomment=[l]{;},
  morecomment=[s]{\#|}{|\#},
  morestring=[b]",
  basicstyle=\scriptsize\ttfamily,
  keywordstyle=\bf\ttfamily\color[rgb]{0,.3,.7},
  commentstyle=\color[rgb]{0.133,0.545,0.133},
  stringstyle={\color[rgb]{0.75,0.49,0.07}},
  upquote=true,
  breaklines=true,
  breakatwhitespace=true,
  literate=*{`}{{`}}{1}
}

\def\schemeinline{\lstinline[language=Scheme, basicstyle=\small\ttfamily]}

\lstdefinelanguage{JavaScript}{
  morekeywords=[1]{typeof, new, true, false, catch,
    function, return, null, catch, switch, var,
    if, in, while, do, else, case, break, continue},
  morekeywords=[2]{class, export, boolean, throw, implements, import, this},
  numbers=left,
  numbersep=4pt,
  numberstyle=\tiny\color{dkblue},
  columns=fullflexible,
  sensitive=false,
  comment=[l]{//},
  captionpos=b,   
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  basicstyle=\scriptsize\texttt,
  identifierstyle=\ttfamily\color{Aluminium5},
  keywordstyle=[1]\ttfamily\color{Plum},
  keywordstyle=[2]\ttfamily\color{SkyBlue},
  stringstyle=\ttfamily\color{DarkGreen},
  commentstyle=\ttfamily, 
%  commandchars=\$\{\}
}[keywords,comments,strings]

\lstnewenvironment{lstjs}{\lstset{language=JavaScript,basicstyle=\fontsize{8}{8}\ttfamily,escapeinside={~}{~}}}{}
\def\jsinline{\lstinline[language=JavaScript, basicstyle=\small]}


% The Acronyms of the project and some other stuff
\newcommand{\jsil}{JSIL\xspace}
\newcommand{\jsverify}{JSVerify\xspace}
\newcommand{\JSComp}{JS-2-JSIL\xspace}
\newcommand{\jsilverify}{JSILVerify\xspace}

\newcommand{\cosette}{Cosette\xspace}
\newcommand{\rosette}{Rosette\xspace}

\newcommand{\myparagraph}[1]{\smallskip\noindent {\bf #1.}\hspace{1pt}}
\newcommand{\myparagraphq}[1]{\smallskip\noindent {\bf #1?}\hspace{1pt}}

% COMMENTS

\newcommand{\polish}[1]{{\color{red}#1}}

\newcommand{\pginline}[1]{ {\color{red} *** PG : #1 ***} }
\newcommand{\pmaxinline}[1]{ {\color{blue} *** PM : #1 ***} }
\newcommand{\jfsinline}[1]{ {\color{green} *** JFS : #1 ***} }
\newcommand{\jdinline}[1]{ {\color{purple} *** JD : #1 ***} }

\newif\ifComments
\Commentstrue

\newcommand{\pg}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.95\textwidth} \color{red}
{\rm PG: \small #1}
\end{minipage}}
\end{center}
\fi}

\newcommand{\pmax}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.95\textwidth} \color{blue}
{\rm PM: \small #1}
\end{minipage}}
\end{center}
\fi}

\newcommand{\jfs}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.95\textwidth} \color{green}
{\rm JFS: \small #1}
\end{minipage}}
\end{center}
\fi}

\newcommand{\jd}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.95\textwidth} \color{purple}
{\rm JD: \small #1}
\end{minipage}}
\end{center}
\fi}

\begin{document}
\title{\cosette: A Symbolic Framework for Testing JavaScript Programs}

\maketitle

\begin{abstract}
We present \cosette, a framework for bounded symbolic execution of JavaScript (JS) code (ECMAScript 5, ES5). 
\cosette is the first symbolic execution tool for JS that models the language semantics precisely.  
It works by first compiling JS programs to \jsil using \JSComp, a well-tested, standard-compliant compiler from 
JS to \jsil, and then symbolically executing the obtained \jsil code using a novel symbolic interpreter for \jsil. 
We prove that the \jsil symbolic interpreter is \emph{sound} and that it does not to generate false positives. 
%every time the tool reports a bug, it provides a concrete model that triggers that bug. 

We demonstrate how \cosette can be used for the symbolic testing of JS programs by 
finding concrete executions that trigger assertion and test failures. We highlight the range of \cosette 
by giving examples involving JS-specific features, such as: prototype-based inheritance, 
the for-in statement, and JS arrays. Finally, we thoroughly evaluate \cosette against a 
representative fragment of test262 adapted to include symbolic~values. 

%At the core of \cosette is a sound symbolic interpreter for \jsil, an intermediate language well-suited for verification and analysis. 
%This interpreter is written in \underline{Rosette}, a symbolic virtual machine that enables the design of new solver-aided languages. 

\end{abstract}

\section{Introduction}
\input{sections/introduction}

\section{Symbolic Execution for \jsil}\label{sec:jsil:symb:exec}
\input{sections/jilette}


\newpage
\section{Evaluation}\label{sec:evaluation}
\input{sections/evaluation}

\bibliographystyle{abbrv}
\bibliography{biblio}

\end{document}
