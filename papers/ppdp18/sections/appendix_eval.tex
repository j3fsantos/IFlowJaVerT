%!TEX root = ../main.tex

\lstnewenvironment{lstjshere}{\lstset{language=JavaScript,basicstyle=\fontsize{7}{7}\ttfamily,escapeinside={~}{~}}}{}

\section{Evaluation}

\subsection{Challenging JavaScript Features}

\cosette is able to verify JavaScript programs that use nontrivial parts of the JavaScript semantics, such as dynamic dispatch and property enumeration (via \jsinline{for-in} loops), in the symbolic world.

\myparagraph{Dynamic dispatch}
The following example demonstrates that \cosette is able to bring together complex symbolic string and mathematical reasoning with JavaScript's memory model.

\begin{lstjshere}
var o = Object.create(null);

o.plusOne = function(x) { return x + 1 };
o.minusOne = function(x) { return x - 1 };

var s1 = symb_string(), s2 = symb_string();
var n1 = symb_number(), n2 = symb_number();

Assume(not (n1 = n2));

var total1 = o[s1](n1)
var total2 = o[s2](n2);

Assert(total1 = total2);
\end{lstjshere}

In this example, we create an object \jsinline{o} that contains two functions, \jsinline{o.plusOne} and \jsinline{o.minusOne}, which respectively add and subtract $1$ from their argument.
We create two symbolic strings \jsinline{s1} and \jsinline{s2}, and two distinct symbolic numbers \jsinline{n1} and {n2}.
Then, we compute the result of applying function \jsinline{o[s1]} to \jsinline{n1}, and \jsinline{o[s2]} to \jsinline{n2}, stating with the \jsinline{Assert} statement that we want both these values to be equal.

According to the different values that the strings \jsinline{s1} and \jsinline{s2} take,  different outcomes can happen.
If \jsinline{s1} (or \jsinline{s2}) is not a valid property name of \jsinline{o}, the program will give a runtime error, because \jsinline{o[s1]} (or \jsinline{o[s2]}) evaluates to \jsinline{undefined}, which is not a function, and cannot be applied; when running the program with \cosette, we indeed get a concrete model for this failing case.

If both \jsinline{s1} and \jsinline{s2} are valid property names for \jsinline{o}, the program is always executed until its end.
In that case, \cosette is able to present us with a model for the final assertion to hold (for example, \jsinline{s1 = "minusOne", s2 = "plusOne", n1 = 0}, and \jsinline{n2 = -2}), as well as a model that invalidates the final assertion (e.g.~\jsinline{s1 = "minusOne"}, \jsinline{s2 = "minusOne", n1 = 0} and \jsinline{n2 = 1}).

This example demonstrates that \cosette has a fine understanding of the mechanics that underly the dynamic dispatch system in JavaScript, and is able to not only infer possible dynamic function names for a property function call to work, but is also able to relate the dynamic name to the function output.


\myparagraph{Property enumeration}
The following example demonstrates that \cosette is able to reason about the interplay of static and dynamic properties of JavaScript objects.

\begin{lstjshere}
function nbProp(o) {
  var count = 0;
  for (var p in o) { count++ }
  return count;
}

var o = {a: 1, b: 2, c: 3};

var s = symb_string();

o[s] = 4;
var res = nbProp(o);
var expectedRes = 3;

Assert(res = expectedRes);
\end{lstjshere}

In this example, we create a JavaScript object \jsinline{o} that has three properties \jsinline{a, b}, and \jsinline{c}.
Then, we create a symbolic string \jsinline{s} and assign a value to the property of \jsinline{o} corresponding to {s}.
Finally, we count the actual number of properties in \jsinline{o}.
There are two possible cases here: either \jsinline{s} is equal to one of the concrete property names of \jsinline{o}, and the assignment actually overwrites the value associated with that property, or \jsinline{s} is a fresh string and the assignment creates a new concrete property.

\cosette is able to reason about both cases, and finds a model for the assertion; either shadowing the property if \jsinline{expectedRes = 3}, giving a fresh string if \jsinline{expectedRes = 4}, or saying that the assertiong is unsatisfiable if \jsinline{expectedRes} is different from these two values.

%This shows that \cosette is able to reason about the interplay between static and dynamic properties of JavaScript objects.

\subsection{JSIL Statement Tests}

\myparagraph{Property Access}
This example tests the symbolic behavior of the \jsil statement \mbox{\prooflab{Property Access}} in \cosette, in the case where the property exists.
First, we create a new empty object \jsinline{o}.
Then, we assign symbolic values \jsinline{n1} and \jsinline{n2} to properties \jsinline{s1} and \jsinline{s2} respectively, which we assume to be different in order to avoid aliasing.
Finally, we read property \jsinline{s3} of \jsinline{o}, which we assume to be either \jsinline{s1} or \jsinline{s2}, and we assert that, in each case, the corresponding value was read.

\begin{lstjshere}
proc main () {
    (* Setup properties *)
    s1 := symb_string();
    s2 := symb_string();
    s3 := symb_string();

    (* Setup values *)
    n1 := symb_number();
    n2 := symb_number();

    (* Initial assumption *)
    assume(not (s1 = s2));
    assume((s3 = s1) or (s3 = s2));

    (* Setup heap *)
    o := new ();
    [o, s1] := n1;
    [o, s2] := n2;

    (* RULE: Property Access *)
    ret1 := [o, s3];

    assert (
        ((s3 = s1) and (ret1 = n1)) or 
        ((s3 = s2) and (ret1 = n2))
    );

    rlab:    xret := $$t
}
with
{
    ret:    xret, rlab;
};
\end{lstjshere}


\myparagraph{Delete}
This example tests the symbolic behavior of the \jsil statement \prooflab{Delete} in \cosette, which in the case where the property to delete is present.
As before, we begin by creating a new empty object \jsinline{o}, and assign values \jsinline{n1} and \jsinline{n2} to non-overlapping properties \jsinline{s1} and \jsinline{s2}.
Then, we delete property \jsinline{s1} from \jsinline{o}.
Finally, we call the \jsinline{hasField} primitive on both properties, and we assert that \jsinline{s1} is not present anymore while \jsinline{s2} still is.

\begin{lstjshere}
proc main () {
    (* Setup properties *)
    s1 := symb_string();
    s2 := symb_string();

    (* Setup values *)
    n1 := symb_number();
    n2 := symb_number();

    (* Initial assumption *)
    assume(not (s1 = s2));

    (* Setup heap *)
    o := new ();
    [o, s1] := n1;
    [o, s2] := n2;

    (* RULE: Assignment - Not Found *)
    delete(o, s1);

    (* Assert *)
    ret1 := hasField(o, s1);
    ret2 := hasField(o, s2);

    assert (
        (ret1 = $$f) and (ret2 = $$t)
    );

    rlab:   xret := $$t
}
with
{
    ret:    xret, rlab;
};
\end{lstjshere}
 
\subsection{Bug: Multi-dictionary in Buckets.js}

The Buckets.js multi-dictionary is a dictionary that holds an array of distinct values for each key, instead of a single value.
Its implementation essentially consists in the following methods: \jsinline{set(k, v)}, \jsinline{get(k)}, and \jsinline{remove(k, v)}.

The \jsinline{set(k, v)} method adds a new value \jsinline{v} to the array held by key \jsinline{k}.
The \jsinline{get(k)} method returns the array associated with key \jsinline{k} in the dictionary if present, and an empty array otherwise.
The \jsinline{remove(k, v)} function removes \jsinline{v} from the array held by \jsinline{k}.
More precisely, \jsinline{v} can either be \jsinline{undefined}, in which case the key and associated array are completely removed from the dictionary, or it can be an actual value, in which case it is removed from the array (if present).
However, the library does not consider the case where there is no array associated with \jsinline{k} (for example, if all elements associated with \jsinline{k} have already been removed, or none have been inserted yet).
In that case, the library tries to remove an element from \jsinline{undefined}, and this raises an error.

A simplified version of the failing code is shown below.
The \jsinline{parent} variable is an internal variable of the \jsinline{multidict} object that holds a Buckets.js dictionary from keys to arrays of values.
The \jsinline{arrays.remove} function is part of the Buckets.js array manipulation library, and removes a given value from a JavaScript array.

\begin{lstjshere}
multidict.remove = function (key, value) {
    if (value === undefined) { ... }
    var array = parent.get(key);
    if (arrays.remove(array, value)) { ... }
    return false;
}
\end{lstjshere}
We were able to expose the bug with the following symbolic test:

\begin{lstjshere}
var dict = new buckets.multidict();
var s = symb_string();
var x1 = symb_number();
var x2 = symb_number();

dict.set(s, x1);
dict.set(s, x2);
dict.remove(s, x1);
var didRemove = dict.remove(s, x2);
assert((x1 != x2 && didRemove) || (x1 == x2 && !didRemove));
\end{lstjshere}

In this test, we create a new multi-dictionary \jsinline{dict}, and insert two symbolic values \jsinline{x1} and \jsinline{x2} at key \jsinline{s}, then remove them in order.
Note that, if \jsinline{x1} is actually equal to \jsinline{x2}, the implementation does not store this value two times in the array.
This means that the key in the second call to \jsinline{remove} on line 6 is not present in the multi-dictionary any more, and this triggers the bug.

When running \cosette on this test, we obtain the counter-model \jsinline{x1 = x2 = 0} (any value of \jsinline{s} works), and running the concrete instantiation of the test in Node raises an error.
We were able to fix the bug by adding a check for \jsinline{undefined} after line 3 in the code of \jsinline{remove}, after which \cosette was successfully able to discharge the assertion.

\subsection{Bug: Priority Queue Insertion in queue-pri}

The queue-pri library implements a priority queue that stores data with an optional priority value.
This priority can either be a number (the lower the value, the higher the priority) or a default value of \jsinline{null} if no priority is provided, in which case the associated element is put at the end of the queue.

The relevant part of the code of the \jsinline{enqueue} function is as follows.
It creates a \jsinline{payload} objects holding the data along with its priority, and inserts it at the right place (according to its priority) in an internal linked list.

\begin{lstjshere}
PriorityQueue.prototype = {
    enqueue: function (data, pri) {
        var payload = {
            data: data,
            priority: pri || null
        };
        ...
    };
};
\end{lstjshere}

Again, we were able to expose the bug with the following symbolic example:

\begin{lstjshere}
var x1 = symb_number(x1), x2 = symb_number(x2);
var s1 = symb_string(s1), s2 = symb_string(s2);

queue.enqueue(s1, x1);
queue.enqueue(s2, x2);

var y1 = queue.dequeue().data;
var y2 = queue.dequeue().data;

assert((x1 <  x2 && y1 == s1 && y2 == s2) 
    || (x1 == x2 && y1 == s1 && y2 == s2)
    || (x1 >  x2 && y1 == s2 && y2 == s1));
\end{lstjshere}

We generate two symbolic strings \jsinline{s1} and \jsinline{s2}, which represent arbitrary data to be put in the queue, and two symbolic numbers \jsinline{x1} and \jsinline{x2} which represent their priority values.
Then, we first enqueue string \jsinline{s1} with priority \jsinline{x1}, then string \jsinline{s2} with priority \jsinline{x2}.
Finally, we dequeue the two strings into variables \jsinline{y1} and \jsinline{y2}, and we make sure that their ordering is consistent: either \jsinline{x1} $\leq$ \jsinline{x2}, in which case \jsinline{y1} $=$ \jsinline{s1} and \jsinline{y2} $=$ \jsinline{s2} (remember that lower priority number means higher priority), or \jsinline{x1} $>$ \jsinline{x2} and then \jsinline{y1} $=$ \jsinline{s2} and \jsinline{y2} $=$ \jsinline{s1}.


However, when running this example with \cosette, we get the following countermodel, which invalidates the assertion: \jsinline{x1 = 1}, \jsinline{x2 = 0}, \jsinline{s1 = "!0!"}, and \jsinline{s2 = "!1!"}.
When running the test with these concrete values, we obtain \jsinline{y1 = "!0!" = s1}, and \jsinline{y2 = "!1!" = s2}, which contradicts the assertion.

The bug comes from the developer misunderstanding the semantics of the JavaScript operator \jsinline{||}.
When inserting an object with priority value \jsinline{pri} of 0, the \jsinline{pri || null} expression evaluates to \jsinline{null} instead of the expected 0, effectively disregarding the priority value.
This bug was not detected by the test suite provided with the library, even though it has a line coverage of 100\%, because all of the tests either use \jsinline{null} directly or strictly positive priority values, but never 0.
We replaced the buggy line (line 5 in the \jsinline{enqueue} method above) with an expression that correctly evaluates to 0 when \jsinline{pri} is equal to 0, and ran the symbolic test again.
With that correction, \cosette certifies that the final assertion always holds, and that the fixed code is indeed correct, for all possible insertions of two objects with explicit priority values.


\subsection{Specification-driven Bug-finding: JaVerT Data-Structure Libraries}


\noindent{\bfseries E.5.1. Priority Queue}

\begin{lstjshere}
/**
  @pred Node(+n, pri, val, next, np) :
      JSObjWithProto(n, np) * DataProp(n, "pri",  pri) * 
      (0 <# pri) * DataProp(n, "val",  val) *
      DataProp(n, "next", next) * ((n, "insert") -> none);
	
  @pred NodePrototype(np) :
      JSObject(np) * DataProp(np, "insert", #insert_loc) *
      JSFunctionObject(#insert_loc, "insert", _, _, _) *
      ((np, "pri") -> none) * ((np, "val") -> none) * 
      ((np, "next") -> none);
	
  @pred NodeList(+nl, np, max_pri, length) :
      (nl == null) * (max_pri == 0) * (length == 0),
      
      Node(nl, max_pri, #val, #next, np) * (0 <# max_pri) *
      NodeList(#next, np, #pri, #len_nl) * (#pri <=# max_pri) *
      (length == #len_nl + 1);
	
	
  @pred Queue(+pq, qp, np, max_pri : Num, length : Num) :
      JSObjWithProto(pq, qp) * DataProp(pq, "_head",  #head) *
      NodeList(#head, np, max_pri, length) * 
      ((pq, "enqueue") -> none) * ((pq, "dequeue") -> none);
	
	
  @pred QueuePrototype(+qp, np, c : Num, enq_sc):
      JSObject(qp) * DataProp(qp, "enqueue", #enqueue_loc) * 
      JSFunctionObject(#enqueue_loc, "enqueue", enq_sc, _, _) *
      DataProp(qp, "dequeue", #dequeue_loc) * 
      JSFunctionObject(#dequeue_loc, "dequeue", #dequeue_sc, _, _) *
      JSFunctionObject(#n, "Node", #node_sc, _, np)
      ((qp, "_head") -> none) * NodePrototype(np) * 
      closure(Node : #n, counter : c; Node : #node_sc, 
        enqueue: enq_sc, dequeue: #dequeue_sc, PQLib: #pq_sc);
	
  @pred PriorityQueueModule(pq) :
      QueuePrototype(#pqp, #np, 0, #sc) *
      JSFunctionObject(pq, "PriorityQueue", #pq_sc, _, #pqp) *
      o_chains(PriorityQueue: #pq_sc, enqueue: #sc);
*/

/** 
  @id PQLib
  @pre  ObjectPrototype()
  @post ObjectPrototype() * PriorityQueueModule (ret)
*/
var PriorityQueue = (function () {

  var counter = 0;

  /**
    @id  Node

    @pre (
      (pri == #pri) * (0 <# #pri) * (val == #val) *
      ((this, "pri")  -> none) * ((this, "val")    -> none) * 
      ((this, "next") -> none) * ((this, "insert") -> none) *
      JSObjWithProto(this, #np) * NodePrototype(#np) *
      scope(counter : #c) * types(#c : Num) * ObjectPrototype()
    )
    @post (
      Node(this, #pri, #val, null, #np) * NodePrototype(#np) * 
      scope(counter : #c + 1) * ObjectPrototype()
    )
  */
  var Node = function (pri, val) {
      this.pri = pri; this.val = val; this.next = null;	counter++
  }

  /**
    @id insert
		
    @pre (
      (nl == #nl) * NodeList(#nl, #np, #pri_nl, #length) *
      Node(this, #npri, #nval, null, #np) * NodePrototype(#np) *
      (#pri_nl <# #npri)
    )
    @post (
      NodeList(this, #np, #npri, #length + 1) *
      NodePrototype(#np) * (ret == this)
    )

    @pre (
      (nl == #nl) * NodeList(#nl, #np, #pri_nl, #length) *
      Node(this, #npri, #nval, null, #np) * NodePrototype(#np) *
      (#npri <=# #pri_nl)
    )
    @post (
      types(#nl : Obj) * NodeList(#nl, #np, #pri_nl, #length + 1) *
      NodePrototype(#np) * (ret == #nl) 
    )
  */
  Node.prototype.insert = function (nl) {
    if (nl === null) { return this }
    
    if (this.pri > nl.pri) { this.next = nl; return this }
    
    var tmp = this.insert (nl.next);
    nl.next = tmp;
    return nl
  }

  /**
    @id  PriorityQueue
	
    @pre (
      ObjectPrototype() * ((this, "_head") -> none) *
      ((this, "enqueue") -> none) * ((this, "dequeue") -> none) *
      JSObjWithProto(this, #pqp) * QueuePrototype(#pqp, #np, #c, #sc) *
      o_chains(enqueue: #sc, PQLib: $$scope) 
    )
    @post (
      Queue(this, #pqp, #np, 0, 0) *
      QueuePrototype(#pqp, #np, #c, #sc) * ObjectPrototype()
    )
  */
  var PQ = function () {
    this._head = null;
  };

  /**
    @id enqueue
				
    @pre (
      (pri == #pri) * (0 <# #pri) * (val == #val) * 
      Queue(this, #pqp, #np, #pri_q, #length) *
      QueuePrototype(#pqp, #np, #c, #sc) *
      o_chains(enqueue: #sc, PQLib: $$scope) *
      (#pri <=# #pri_q) * ObjectPrototype()
    )
    @post (
      Queue(this, #pqp, #np, #pri_q, #length + 1) *
      QueuePrototype(#pqp, #np, #c + 1, #sc) * ObjectPrototype()
    )
		
    @pre (
      (pri == #pri) * (0 <# #pri) * (val == #val) * 
      Queue(this, #pqp, #np, #pri_q, #length) *
      QueuePrototype(#pqp, #np, #c, #sc) *
      o_chains(enqueue: #sc, PQLib: $$scope) *
      (#pri_q <# #pri) * ObjectPrototype()
    )
    @post (
      Queue(this, #pqp, #np, #pri, #length + 1) *
      QueuePrototype(#pqp, #np, #c + 1, #sc) *
      ObjectPrototype()
    )
  */
  PQ.prototype.enqueue = function(pri, val) {
    var n = new Node(pri, val);
    this._head = n.insert(this._head);
  };

  /**
    @id dequeue
     
    @pre (
      Queue(this, #pqp, #np, #pri_q, #length) * 
      QueuePrototype(#pqp, #np, #c, #sc) *
      o_chains(enqueue: #sc, dequeue: $$scope) * (0 <# #length)
    )
    @post (
      Queue(this, #pqp, #np, #new_pri_q, #length - 1) *
      QueuePrototype(#pqp, #np, #c - 1, #sc) *
      (ret == #r) * JSObject(#r) * 
      DataProp(#r, "pri", #pri_q) * DataProp(#r, "val", #some_val)
    )
     
    @pre (
      Queue(this, #pqp, #np, 0, 0) *
      QueuePrototype(#pqp, #np, #c, #sc) *
      o_chains(enqueue: #sc, dequeue: $$scope) *
      GlobalObject() * BI_ErrorObject()
    )
    @posterr (
      Queue(this, #pqp, #np, 0, 0) *
      QueuePrototype(#pqp, #np, #c, #sc) *
      (err == #e) * ErrorObjectWithMessage(#e, "Queue is empty") *
      GlobalObject() * BI_ErrorObject()
    )
  */
  PQ.prototype.dequeue = function () {
    if (this._head === null) {
      throw new Error("Queue is empty");
    }

    counter--;
    var first = this._head;
    this._head = this._head.next;
    return {pri: first.pri, val: first.val};
  };

  return PQ;
})();
\end{lstjshere}

\noindent{\bfseries E.5.2. Binary Search Tree}

\begin{lstjshere}
/**
  @pred NullableObject(o) :  types(o : Obj), types (o : Null);
  
  @pred Node(+n : Obj, val : Num, left, right) :
    JSObject(n) * DataProp(n, "value", val) * 
    DataProp(n, "left",  left) * DataProp(n, "right", right);

  @pred BST(+n, K : Set) :
    (n == null) * (K == -{ }-) * types (n : Null, K : Set),
    
    Node(n, #val, #left, #right) * BST(#left, #KL) * BST(#right, #KR) * 
    (K == -u- (#KL, -{ #val }-, #KR)) *
    (forall #x : Num. ((! (#x --e-- #KL)) \/ (#x <# #val))) *
    (forall #x : Num. ((! (#x --e-- #KR)) \/ (#val <# #x))) *
    types(#val : Num, #KL : Set, #KR : Set);
*/

/**
  @id makeNode
  
  @pre (
    (v == #v) * types (#v : Num)
  )		
  @post (
    Node(#r, #v, null, null) * types (#r : Obj) * (ret == #r)
  )
*/
function make_node(v) {
  return { value : v, left  : null, right : null }
}

/**
  @id insert
  
  @pre (
    GlobalObject() * ObjectPrototype() * (t == #t) * BST(#t, #K) * 
    (v == #v) * types (#v : Num) * scope(make_node : #makeNode) *
    JSFunctionObject(#makeNode, "makeNode", _, _, _) *
    scope(insert : #insert) * JSFunctionObject(#insert, "insert", _, _, _)
  )	
  @post 
    GlobalObject() * ObjectPrototype() * BST(#t_new, -u- (#K, -{ #v }-)) * 
    (ret == #t_new) * types (#t_new : Obj) * 
    scope(make_node : #makeNode) * scope(insert : #insert) * 
    JSFunctionObject(#makeNode, "makeNode", _, _, _) *
    JSFunctionObject(#insert, "insert", _, _, _)
  )
*/
function insert(v, t)
{  
  if (t === null) { return make_node(v) }

  if (v < t.value)
    t.left = insert(v, t.left);
  else if (v > t.value) 
    t.right = insert(v, t.right);

  return t;
}

/**
  @id find
  
  @pre (
    (t == #t) * BST(#t, #K) * (v == #v) * types (#v : Num) * 
    scope(find : #find) * JSFunctionObject(#find, "find", _, _, _) *
    GlobalObject() * ObjectPrototype()
  )
  @post (
    BST(#t, #K) * (ret == (#v -e- #K)) * types(#r : Bool) *
    scope(find : #find) * JSFunctionObject(#find, "find", _, _, _) * 
    GlobalObject() * ObjectPrototype()
  )
*/
function find (v, t)
{
  var result;

  if (t === null) { return false }
  else if (v === t.value) { return true }
       else if (v < t.value) { return find(v, t.left) }
            else { return find(v, t.right) }
}

/**
  @id findMin
	
  @pre (
    initialHeapPostWeak() * (t == #t) * BST(#t, #K) * 
    types(#t : Obj) * scope(find_min : #findMin) * 
    JSFunctionObject(#findMin, "findMin", _, _, _)
  )
  @post (
    initialHeapPostWeak() * BST(#t, #K) * (ret == #r) * 
    types(#r : Num) * (#r --e-- #K) * scope(find_min : #findMin) *
    (forall #x : Num. ((! (#x --e-- #K)) \/ (#r <=# #x))) *
    JSFunctionObject(#findMin, "findMin", _, _, _)
  )
*/
function find_min(t)
{
  var result;
  
  if (t.left === null) { return t.value }
	else { return find_min(t.left) }
}

/**
  @id remove
  
  @pre (
    initialHeapPostWeak() * 
    (t == #t) * BST(#t, #K) * (v == #v) * types (#v : Num) *
    scope(remove : #remove) * scope(find_min : #findMin) *
    JSFunctionObject(#remove, "remove", _, _, _) *
    JSFunctionObject(#findMin, "findMin", _, _, _)
  )
  @post (
    initialHeapPostWeak() * 
    (ret == #t_new) * BST(#t_new, #K_new) * 
    (#K_new == #K -d- -{ #v }-) * NullableObject(#t_new) *
    scope(remove : #remove) * scope(find_min : #findMin) * 
    JSFunctionObject(#remove, "remove", _, _, _) *
    JSFunctionObject(#findMin, "findMin", _, _, _)
  )
*/
function remove(v, t)
{
  if (t === null) return null;

  if (v === t.value) {
    /* The branching on t.left is the 
       reason why we need two unfoldings
       to get full coverage */
    if (t.left === null) { return t.right }
    else if (t.right === null) { return t.left }
    else {
      var min = find_min(t.right);
      t.right = remove(min, t.right);
      t.value = min;
    }
  }
  else if (v < t.value)
    t.left = remove(v, t.left);
  else
    t.right = remove(v, t.right);	
  
  return t;
}
\end{lstjshere}


\noindent{\bfseries E.5.3. Sorted List}

\begin{lstjshere}
/**
  @pred nullableObject(o) : types(o : Obj), (o == null);

  @pred Node(+n:Obj, v:Num, t):
    JSObject(n) * DataProp(n, "value", v) * DataProp(n, "next", t);
  
  @pred NDList(+nl, E:Set):
    (l == null) * (E == -{ }-),

    Node(nl, #v, #t) * NDList(#t, #tE) *
    (E == -u- (#tE, -{ #v }-)) * (! (#v --e-- #tE));

  @pred SOList(+nl, E:Set):
    (nl == null) * (E == -{ }-),

    Node(nl, #v, #t) * SOList(#t, #tE) * (E == -u- (#tE, -{ #v }-)) *
    (forall #x:Num. ((! (#x --e-- #tE)) \/ (#v <# #x)));
*/
 
/**
  @id insert

  @pre (
    JSObject($lg) * (node == #n) * (value == #v) * 
    SOList(#n, #E) * types(#v: Num) * scope(insert: #insert_fun) * 
    JSFunctionObject(#insert_fun, "insert", #insert_sc, _, _)
  )
  @post (
    JSObject ($lg) * (ret == #ret) * SOList(#ret, -u- (-{ #v }-, #E)) * 
    types(#ret: Obj) * scope(insert: #insert_fun) * 
    JSFunctionObject(#insert_fun, "insert", #insert_sc, _, #_)
  )
*/
function insert(node, value) {
  if (node === null) {
      return { next: null, value: value }
  } else if (node.value === value) {
      return node;
  } else if (node.value < value) {
      var rec = insert(node.next, value);
      return { next: rec, value: node.value }
  } else {
      return { next: node, value: value }
  }
}

/**
  @id sort

  @pre (
    JSObject($lg) * (head == #h) * NDList(#h, #E) * 
    scope(sort: #sort_fun) * scope(insert: #insert_fun) *
    JSFunctionObject(#sort_fun, "sort", #sort_sc, _, _) * 
    JSFunctionObject(#insert_fun, "insert", #insert_sc, _, _)
  )
  @post (
    JSObject($lg) * SOList(ret, #E) * nullableObject(ret) * 
    scope(sort: #sort_fun) * scope(insert: #insert_fun) * 
    JSFunctionObject(#sort_fun, "sort", #sort_sc, _, _) * 
    JSFunctionObject(#insert_fun, "insert", #insert_sc, _, _)
  )
*/
function sort(head) {
  if (head === null) { return null }
  else {
    var rec = sort(head.next);
    return insert(rec, head.value)
  }
}
\end{lstjshere}
