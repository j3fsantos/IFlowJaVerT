%!TEX root = ../main.tex

\section{Evaluation}

\subsection{Challenging JavaScript examples}

\cosette is able to verify JavaScript programs that use nontrivial parts of the JavaScript semantics, such as dynamic dispatch and property enumeration (via \jsinline{for-in} loops), in the symbolic world.

\myparagraph{Dynamic dispatch}
The following example demonstrates that \cosette is able to bring together complex symbolic string and mathematical reasoning with JavaScript's memory model.

\begin{lstjs}
var o = Object.create(null);

o.plusOne = function(x) { return x + 1 };
o.minusOne = function(x) { return x - 1 };

var s1 = symb_string(s1), s2 = symb_string(s2);
var n1 = symb_number(n1), n2 = symb_number(n2);

Assume(not (n1 = n2));

var total1 = o[s1](n1);
var total2 = o[s2](n2);

Assert(total1 = total2);
\end{lstjs}

In this example, we create an object \jsinline{o} that contains two functions, \jsinline{o.plusOne} and \jsinline{o.minusOne}, which respectively add and subtract $1$ from their argument.
We create two symbolic strings \jsinline{s1} and \jsinline{s2}, and two distinct symbolic numbers \jsinline{n1} and {n2}.
Then, we compute the result of applying function \jsinline{o[s1]} to \jsinline{n1}, and \jsinline{o[s2]} to \jsinline{n2}, stating with the \jsinline{Assert} statement that we want both these values to be equal.

According to the different values that the strings \jsinline{s1} and \jsinline{s2} take, quite different things can happen.
If \jsinline{s1} (or \jsinline{s2}) is not a valid property name of \jsinline{o}, the program will give a runtime error, because \jsinline{o[s1]} (or \jsinline{o[s2]}) evaluates to \jsinline{undefined}, which is not a function, and cannot be applied; when running the program with \cosette, we indeed get a concrete model for this failing case.

If both \jsinline{s1} and \jsinline{s2} are valid property names for \jsinline{o}, the program is always executed until its end.
In that case, \cosette is able to present us with a model for the final assertion to hold (for example, \jsinline{s1 = "minusOne", s2 = "plusOne", n1 = 0}, and \jsinline{n2 = -2}), as well as a model that invalidates the final assertion (for example, \jsinline{s1 = "minusOne", s2 = "minusOne", n1 = 0} and \jsinline{n2 = 1}).

This example demonstrates that \cosette has a fine understanding of the mechanics that underly the dynamic dispatch system in JavaScript, and is able to not only infer possible dynamic function names for a property function call to work, but is also able to relate the dynamic name to the function output.


\myparagraph{Property enumeration}
The following example demonstrates that \cosette is able to reason about the interplay of static and dynamic properties of JavaScript objects.

\begin{lstjs}

function nbProp(o) {
  var count = 0;
  for (var p in o) {
    count += 1;
  }
  return count;
}

var o = {a: 1, b: 2, c: 3};

var s1 = symb_string(s1);

o[s1] = 4;
var res = nbProp(o);
var expectedRes = 3;

Assert(res = expectedRes);
\end{lstjs}

In this example, we create a JavaScript object \jsinline{o} that has three properties \jsinline{a, b}, and \jsinline{c}.
Then, we create a symbolic string \jsinline{s1} and assign a value to the property of \jsinline{o} corresponding to {s1}.
Finally, we count the actual number of properties in \jsinline{o}.
There are two possible cases here: either \jsinline{s1} is equal to one of the concrete property names of \jsinline{o}, and the assignment actually overwrites the value associated with that property, or \jsinline{s1} is a fresh string and the assignment creates a new concrete property.

\cosette is able to reason about both cases, and finds a model for the assertion; either shadowing the property if \jsinline{expectedRes = 3}, giving a fresh string if \jsinline{expectedRes = 4}, or saying that the assertiong is unsatisfiable if \jsinline{expectedRes} is different from these two values.

This shows that \cosette is able to reason about the interplay between static and dynamic properties of JavaScript objects.
 


\subsection{1234}