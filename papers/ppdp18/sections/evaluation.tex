%!TEX root = ../main.tex

We demonstrate the practical validity of \cosette as a tool for bug-finding in JavaScript.
We wrote symbolic tests fully covering the code of real-world Node.js libraries, and found several  implementation bugs.
Moreover, we measured evaluation times, including solver times, to assess the performance of \cosette.

Throughout this section, we will be using the Buckets.js~\cite{buckets} (which has around 65k downloads on npm) data structure library as a running example.
It implements most common data structures, comes with unit tests, and has no external dependencies, which is necessary for the whole-program analysis of \cosette.

\subsection{Making Concrete Tests Symbolic}

When writing libraries, developers more and more often include extensive test suites, called unit tests, along with actual code (JavaScript has several well-known unit test libraries, such as Jasmine~\cite{jasmine}, Ava~\cite{ava}, or Mocha~\cite{mocha}).
These test suites allow the developer to have reasonable confidence in the well-behavedness of their code, up to the level of detail of the tests.
However, being concrete by nature, these tests might miss corner cases or code paths that the developer hasn't reasoned about.

With \cosette, we can write symbolic tests, in which some of the concrete values of the program are replaced with symbolic values.
Symbolic tests improve on concrete tests for two main reasons.
First, symbolic tests are by construction more comprehensive than concrete tests, because they can account for the whole range of values that a variable can take, instead of focusing on a few specific examples.
Second, when \cosette finds a failing assertion inside a symbolic test, it can concretize the symbolic value into a counter-model that the developer can actually run, in order to make debugging easier.

The example code on the right shows the expressiveness of symbolic testing.
We adapted this code from one of the tests bundled with the array library in Buckets.js.
The snippet tests the \jsinline{swap} function, which swaps two elements of a JavaScript array, and returns \jsinline{true} if the swap was successful (the two index arguments were within the bounds of the array), or \jsinline{false} if the indices were out of bounds.
In the original test code, the developer had to write several examples, each reflecting one of these particular cases.
With the help of symbolic values, we are able to reduce this to a single example which encompasses all possible cases.
We take \jsinline{ar} to be a JS array with some values, and \jsinline{i} is a symbolic number that we use as an index (for simplicity, we only make one of the two indices symbolic here).
The assertion on line 7 accurately describes all the possible cases that can happen, \jsinline{i} being either inside the bounds or outside.
Running \cosette on this code tells us that the assertion always holds, which means that \jsinline{swap} behaves as expected.

Writing symbolic tests with \cosette therefore allows the developer to reduce the burden of test writing and maintenance, by increasing the expressive power of tests without losing their simplicity.

\begin{lstjs}
var n1 = symb_number(n1); % 0
var n2 = symb_number(n2);
var i = symb_number(i);
var ar = [n1, n1, n2, n2];
var res = buckets.arrays.swap(ar, 0, i);
var len = ar.length;
assert((i >= 0 && i < len && res) || ((i < 0 || i >= len) && !res));
\end{lstjs}

\subsection{Bug-finding}

Writing tests helps the developer to have more confidence in their code, but it can also reveal bugs.
With the help of \cosette, we were able to find a bug in the implementation of the Buckets.js \jsinline{multidictionary} (a key-value map in which a single key might hold several values), as well as a bug in \jsinline{queue-pri}, a JS priority queue implementation~(\cite{priq}). 

\myparagraph{\jsinline{multidictionary}} The implementation of the Buckets.js \jsinline{multidictionary} essentially comprises the \jsinline{get(key)} (which returns an array of values), \jsinline{set(key, value)}, and \jsinline{remove(key, value)} methods.
In the \jsinline{remove} function, the \jsinline{value} argument can either be \jsinline{undefined}, in which case the key is completely removed from the dictionary, or it can be an actual value.
In that case, the array associated with the key is retrieved, and, if the value is indeed present in the array, it is removed.
However, the library does not consider the case where this array is not found; in that case, the library tries to remove an element from \jsinline{undefined}, which raises an error.
\begin{lstjs}
multiDict.remove = function (key, value) {
    if (value === undefined) { ... }
    var array = parent.get(key);
    if (buckets.arrays.remove(array, value, equalsF)) { ... }
    return false;
}
\end{lstjs}
We were able to expose this behavior with the following symbolic test:

\begin{lstjs}
var dict = new buckets.MultiDictionary()
var s = symb_string(s);
var x1 = symb_number(x1), x2 = symb_number(x2);
dict.set(s, x1); dict.set(s, x2);
dict.remove(s, x1);
var res = dict.remove(s, x2);
assert((x1 != x2 && res) || (x1 == x2 && !res));
\end{lstjs}

In this test, we create a new dictionary \jsinline{dict}, and insert two symbolic values \jsinline{x1} and \jsinline{x2} at key \jsinline{s}, then remove them in order.
However, if \jsinline{x1} is actually equal to \jsinline{x2}, the implementation does not store it twice.
This means that the key in the second call to \jsinline{remove} on line 6 is not in the dictionary any more, which triggers the bug.

When running \cosette on this test, we indeed obtain the counter-model \jsinline{x1 = x2 = 0}, and running the instantiation of the test in Node triggers an error.
Moreover, we were able to easily fix the bug by adding a check for \jsinline{undefined} after line 3 in the code of \jsinline{remove}, after which \cosette was successfully able to discharge the assertion.

\myparagraph{\jsinline{queue-pri}} The \jsinline{queue-pri} library implements a priority queue, storing data with an optional priority value.
The priority value is either an integer (the lower the value, the higher the priority) or the default \jsinline{null} value if no priority is provided, which puts the associated element at the end of the queue.
With symbolic tests of the \jsinline{enqueue} and \jsinline{dequeue} methods of the library, we found that elements enqueued with a priority value of \jsinline{0} were actually being enqueued at the end of the queue, when they should have had the highest priority instead.

We identified the bug to come from the following part of the code: \jsinline!enqueue: function (data, pri) {var payload = { data: data, priority: pri || null }; ... }!
Indeed, in JavaScript, the expressionÂ \jsinline{0 || null} actually evaluates to \jsinline{null}, whereas the developer thought that it reduced to 0.
Even though the developer wrote tests, they never used a priority value of 0 and therefore never triggered the bug.
This shows that \cosette is a useful tool for debugging JavaScript code, because it analyses all possible code paths, and does not make any assumptions about the sometimes subtle semantics of the language.

\subsection{Performance}

We evaluate the performance of \cosette as a practical debugging tool by writing comprehensive (100\% line coverage) symbolic tests for all of the data structures in the Buckets.js library.
Since \cosette discharges assertions by calling the Z3 SMT solver, we not only measure the running time of \cosette but also the solver time.

The results are presented in table~\ref{cosette:res}.
For each file in the library, we report the total number of JavaScript lines (including whitespace and comments), the number of executable JavaScript lines (lines that include a statement), the number of JSIL lines produced by the translation, the running time of \cosette on the example, as well as the solver time when relevant.

it's slow because running in an interpreted environment, solver times are in most cases negligible

\begin{table}[h]
{
\small
%\begin{center}
\begin{tabular}{lrrrrr}
\toprule
File Name & JS loc & JS exec. loc & JSIL loc & \# Tests & Avg. time (s)\\
\cmidrule{1-5}
\texttt{arrays.js} & 172 & 44 & 1251 & 0 & 0 \\
\texttt{bag.js} & 227 & 69 & 2041 & 0 & 0\\
\texttt{bstree.js} & 421 & 143 & 3819 & 0 & 0\\
\texttt{dictionary.js} & 210 & 57 & 1683 & 0 & 0\\
\texttt{heap.js} & 237 & 57 & 2059 & 0 & 0\\
\texttt{linkedlist.js} & 374 & 126 & 2447 & 0 & 0\\
\texttt{multidictionary.js} & 218 & 56 & 1871 & 0 & 0\\
\texttt{priorityqueue.js} & 162 & 26 & 1066 & 0 & 0\\
\texttt{queue.js} & 157 & 30 & 1095 & 0 & 0\\
\texttt{set.js} & 188 & 40 & 1528 & 0 & 0\\
\texttt{stack.js} & 153 & 23 & 941 & 0 & 0\\
\bottomrule
%\end{center}
\end{tabular}
}
\caption{Coverage analysis for the Buckets.js library}
\label{cosette:res}
\end{table}
