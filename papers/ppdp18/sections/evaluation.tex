%!TEX root = ../main.tex

We demonstrate the practical validity of \cosette as a tool for bug-finding in JavaScript.
We wrote symbolic tests fully covering the code of real-world Node.js libraries, and found several  implementation bugs.
Moreover, we measured evaluation times, including solver times, to assess the performance of \cosette.

\subsection{Making Concrete Tests Symbolic}

When writing libraries, developers more and more often include extensive test suites, called unit tests, along with actual code (JavaScript has several well-known unit test libraries, such as Jasmine~\ref{jasmine}, AVA~ref{ava}, or Mocha~\ref{Mocha}).
These test suites allow the developer to have reasonable confidence in the well-behavedness of their code, up to the level of detail of the tests.
However, being concrete by nature, these tests might miss corner cases or code paths that the developer hasn't thought about.

With \cosette, we can write symbolic tests, in which some of the concrete values of the program are replaced with symbolic values, that improve on concrete tests for two main reasons.
First, symbolic tests are by construction more comprehensive that concrete tests, because they can account for the whole range of values that a variable can take, instead of focusing on a few specific examples.
Second, when \cosette finds a failing assertion inside a symbolic test, it can concretize the symbolic value into a counter-model that the developer can actually run, in order to make debugging easier.

The example code on the right shows the expressiveness of symbolic testing.
We adapted this code from one of the tests bundled with the Buckets.js~\ref{buckets} library, a JavaScript data structure library that we will use throughout the section.
The code snippets tests the \jsinline{swap} function of the library, which swaps two elements of a JavaScript array, and returns either \jsinline{true} if the swap was successful (meaning that the two index arguments are within the bounds of the array), or \jsinline{false} if the indices were out of bounds.
In the original test code, the developer had to write several examples, each reflecting one of these particular cases.
With the help of symbolic values, we are able to reduce this to a single example which encompasses all possible cases.
We take \jsinline{ar} to be a JavaScript array filled with some values, and \jsinline{i} is a symbolic number that we use as an index (for simplicity, we only make one of the two indexes symbolic in this example).
The assertion on line 7 accurately describes all the possible cases that can happen, \jsinline{i} being either inside the bounds or outside.

Writing symbolic tests with \cosette therefore allows the developer to reduce the burden of test writing and maintenance, by increasing the expressive power of tests, without losing on ease of understanding.

\begin{lstjs}
var n1 = symb_number(n1); % 0
var n2 = symb_number(n2);
var i = symb_number(i);
var ar = [n1, n1, n2, n2];
var res = buckets.arrays.swap(ar, 0, i);
var len = ar.length;
assert((i >= 0 && i < len && res) || ((i < 0 || i >= len) && !res));
\end{lstjs}


\subsection{Bug-finding}

\subsection{Performance}

\begin{table}[h]
{
\small
%\begin{center}
\begin{tabular}{lrrrr}
\toprule
File Name & JS Lines & JS Exec. lines & JSIL lines & Time (s)\\
\cmidrule{1-5}
\texttt{arrays.js} & 172 & 44 & 1251 & 0 \\
\texttt{bag.js} & 227 & 69 & 2041 & 0\\
\texttt{bstree.js} & 421 & 143 & 3819 & 0\\
\texttt{dictionary.js} & 210 & 57 & 1683 & 0\\
\texttt{heap.js} & 237 & 57 & 2059 & 0\\
\texttt{linkedlist.js} & 374 & 126 & 2447 & 0\\
\texttt{multidictionary.js} & 218 & 56 & 1871 & 0\\
\texttt{priorityqueue.js} & 162 & 26 & 1066 & 0\\
\texttt{queue.js} & 157 & 30 & 1095 & 0\\
\texttt{set.js} & 188 & 40 & 1528 & 0\\
\texttt{stack.js} & 153 & 23 & 941 & 0\\
\bottomrule
%\end{center}
\end{tabular}
}
\caption{Coverage analysis for the Buckets.js library}
\end{table}
