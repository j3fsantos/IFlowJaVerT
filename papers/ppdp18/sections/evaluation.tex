%!TEX root = ../main.tex

We discuss the trustworthiness of \cosette and demonstrate that~our implementation, despite being  a proof-of-concept, has already proven useful for the debugging of real-world JavaScript code.
We elaborate on the results presented below in more detail in the Appendix. 

\myparagraph{Trustworthiness: JavaScript Semantics}
To ensure that Cosette follows the semantics of JavaScript without any simplifications, we tested \JSComp and our instrumented \jsil interpreter implemented in Rosette using Test262, the JavaScript official test suite~\cite{test262}. 
Out of the 10469 tests for ES5 Strict, we have identified 8330 tests appropriate for our coverage, of which we pass 100\%.

\myparagraph{Trustworthiness: Symbolic Interpreter} To make certain that the symbolic \jsil interpreter obtained by the Rosette lifting of the implemented instrumented interpreter is consistent with the symbolic semantics of \S\ref{subsec:symb:semantics}, we systematically constructed and successfully ran symbolic unit tests for each \jsil command, assuming the premises and asserting the conclusion of the appropriate rule of the symbolic semantics.

%With \cosette, we can write symbolic tests, in which some of the concrete values of the program are replaced with symbolic values.
%Symbolic tests improve on concrete tests for two main reasons.
%First, they are by construction more comprehensive than concrete tests, because symbolic tests can account for the whole range of values that a variable can take, instead of focusing on a few specific examples.
%Second, when \cosette finds a failing assertion inside a symbolic test, it can concretize the symbolic values into a counter-model that the developer can actually run in node, making debugging much easier compared to (the other things that we mention before).

\myparagraph{Whole-program Symbolic Testing: JS-Specific Features}
We created a number of symbolic tests to demonstrate that Cosette can reason about essential JavaScript features, such as prototype inheritance, function closures, arrays, strings, as well as the substantially more challenging for-in statement and dynamic dispatch. 

\myparagraph{Whole-program Symbolic Testing: Real-World Libraries}
We used \cosette to analyse the code of two JavaScript data structure libraries: Buckets.js~\cite{buckets}, and queue-pri~\cite{priq}.
We chose these libraries because reasoning about data structure code requires a precise description of the control flow features of JavaScript, because they come equipped with unit test suites, and because they do not have external dependencies (\cosette is a whole-program analysis); Buckets.js has over 65k downloads on npm.

For these two libraries, we wrote symbolic tests with the aim of obtaining a line coverage of 100\%, in order to compare them with the concrete unit tests that ship with the libraries.
In both cases, we were able to reduce the length of the tests by up to an average factor of 3, while increasing line coverage from around 90\% to a full 100\%.
We also discovered one bug in the Buckets.js library, as well as one in the queue-pri library.


The results are presented in table~\ref{cosette:res}.
For each file in the library, we report the number of JS executable lines in the code itself and including dependencies (slash-separated), the corresponding numbers of JSIL lines, the number of symbolic and concrete test cases, the number of JS lines in the symbolic and concrete tests, the coverage measured as percentage of lines and the average \cosette run time for the symbolic tests.
The files in Buckets.js are separated by a line from the unique file in queue-pri.

We used a MacBookPro with ... GHz to run the tests and measured the time of 1 execution for each symbolic test, and took for each file the average of the run times of the symbolic tests for that file.
Execution times are rather poor for JavaScript, but tractable for a proof-of-concept tool being run on real-world code.
\cosette is currently implemented using Rosette~\cite{Rosette1}, an off-the-shelf symbolic execution engine; we aim at implementing our own symbolic execution tool in the future, which should drastically reduce execution times.

\begin{table}[h]
{
\small
%\begin{center}
\setlength\tabcolsep{4pt}
\begin{tabular*}{\linewidth}{l@{\;\;}rrrrrr}
\toprule
% Name || JS Loc/loc* || JSIL Loc/loc* || #tests || symb/conc loc || symb/conc cov || time
Name & \makecell{JS lines} & \makecell{JSIL lines} & \# Tests & \makecell{Test lines} & \makecell{Line\\Cov.~(\%)} & \makecell{Avg.\\time} \\
\midrule
\texttt{arrays} & 44/71 & 1251/1942 & 9/24 & 166/329 & 100/100 & 20s \\
\texttt{bag} & 69/237 & 2041/7194 & 7/18 & 78/265 & 100/76.8 & 74s \\
\texttt{bstree} & 143/326 & 3819/8052 & 11/31 & 216/759 & 100/98.6 & 5m27s \\
\texttt{dict} & 57/84 & 1683/2374 & 7/14 & 116/170 & 100/80.7 & 15s \\
\texttt{heap} & 57/128 & 2059/4001 & 4/15 & 92/626 & 100/96.5 & 5m29s \\
\texttt{llist} & 126/153 & 2447/3138 & 9/21 & 149/370 & 100/94.4 & 24s \\
\texttt{multidict} & 56/184 & 1871/5496 & 6/16 & 118/189 & 100/74.1 & 1m15s \\
\texttt{pqueue} & 26/154 & 1066/5067 & 5/12 & 70/283 & 100/96.2 & 5m49s \\
\texttt{queue} & 30/183 & 1095/4233 & 6/9 & 111/146 & 100/96.7 & 20s \\
\texttt{set} & 40/124 & 1528/3902 & 6/12 & 86/271 & 100/70.0 & 1m01s \\
\texttt{stack} & 23/176 & 941/4079 & 4/7 & 91/104 & 100/87.0 & 26s \\
\midrule 
\texttt{queue-pri} & 19/164 & 872/5086 & 2/9 & 26/80 & 100/100 & xy.z \\
\bottomrule
%\end{center}
\end{tabular*}
}
\caption{Tests for the Buckets.js and queue-pri libraries}
\vspace*{-0.95cm}
\label{cosette:res}
\end{table}

\pmax{Say something about how bugs work - sometimes coverage, sometimes semantics.}

\smallskip
\noindent \emph{Bug: MultiDictionary in Buckets.js.}
We have discovered a bug in the implementation of the Buckets.js multi-dictionary library.
A multi-dictionary is a key-value map in which a single key holds an array of distinct values. 
Our symbolic tests for the \jsinline|remove(key, value)| function, which removes a given key-value pair from the multi-dictionary, have revealed that the library wrongly treats the case in which we try to remove a key-value pair for a key with no associated values.
Concretely, a runtime error is thrown instead of \jsinline|remove| returning \jsinline|false|. 
This bug was not detected by the concrete unit tests associated with the library due to their incomplete coverage;
we have fixed it and submitted an appropriate pull request.




\smallskip
\noindent \emph{Bug: queue-pri.}

%\myparagraph{\jsinline{queue-pri}}
The other bug that we found is in the \jsinline{queue-pri} library, which implements a priority queue that stores data with an optional priority value.
The priority value is either an integer (the lower the value, the higher the priority) or the default \jsinline{null} value if no priority is provided, which puts the associated element at the end of the queue.
With symbolic tests of the \jsinline{enqueue} and \jsinline{dequeue} methods of the library, we found that elements enqueued with a priority value of \jsinline{0} were actually being enqueued at the end of the queue, when they should have had the highest priority instead.

We identified the bug to come from the following part of the \jsinline{enqueue} function: \jsinline!var payload = { data: data, priority: pri || null }!
Indeed, in JavaScript, the expression \jsinline{0 || null} actually evaluates to \jsinline{null}, and not to 0.
This shows that symbolic execution with \cosette is a useful tool for testing, because symbolic tests are more comprehensive by construction and can analyse all possible code paths, even the ones that the developer has not considered.
In this case, even though the developer wrote concrete tests for the library, they never used a priority value of 0 when inserting values.
They therefore never triggered the bug, which we were able to find with a simple symbolic test.

\myparagraph{Specification-directed Bug-finding}