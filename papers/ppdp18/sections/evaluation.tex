%!TEX root = ../main.tex

We discuss the coverage of \cosette and demonstrate that~our implementation, despite being  a proof-of-concept, has already proven useful for the debugging of real-world JavaScript code.
We elaborate on the results presented below in more detail in the Appendix. 


%\pmax{We need to talk about JS-2-JSIL coverage somewhere.}

%\myparagraph{Trustworthiness: Symbolic Interpreter} To make certain that the symbolic \jsil interpreter obtained by the Rosette lifting of the implemented instrumented interpreter is consistent with the symbolic semantics of \S\ref{subsec:symb:semantics}, we systematically constructed and successfully ran symbolic unit tests for each \jsil command, assuming the premises and asserting the conclusion of the appropriate rule of the symbolic semantics.

%With \cosette, we can write symbolic tests, in which some of the concrete values of the program are replaced with symbolic values.
%Symbolic tests improve on concrete tests for two main reasons.
%First, they are by construction more comprehensive than concrete tests, because symbolic tests can account for the whole range of values that a variable can take, instead of focusing on a few specific examples.
%Second, when \cosette finds a failing assertion inside a symbolic test, it can concretize the symbolic values into a counter-model that the developer can actually run in node, making debugging much easier compared to (the other things that we mention before).

\myparagraph{Compiler Coverage} 
The coverage of \cosette is dependent on the coverage of \JSComp.
Currently, \JSComp covers the entire core of ES5 Strict and the majority of the built-in libraries.
Several libraries orthogonal to the core, such as the Date, RegExp, and JSON libraries, are not supported.
Extending \JSComp to the non-strict mode of the language and implementing the remaining built-in libraries is straightforward and is a technical exercise.
A more substantial engineering effort would be required for moving to the later extensions and revisions of the standard, such as ES6, but this effort would ultimately amount to extending \JSComp rather than re-designing it, as these versions all have ES5 as a common core.
    
\myparagraph{Reasoning limitations} Due to the limitations of Rosette, \cosette does not support reasoning about the \jsinline|eval| statement. Also, we support the \jsinline|for-in| statement with a fixed property enumeration. This is not an issue, because if a bug is found for a particular enumeration order, that bug still exists for an arbitrary enumeration order.

\myparagraph{Whole-program Symbolic Testing: JS-Specific Features}
We created a number of symbolic tests to demonstrate that Cosette can reason about essential JavaScript features, such as prototype inheritance, function closures, arrays, strings, as well as the substantially more challenging for-in statement and dynamic dispatch. 

\myparagraph{Whole-program Symbolic Testing: Real-World Libraries}
We used \cosette to analyse the code of two JavaScript data structure libraries: Buckets.js~\cite{buckets}, and queue-pri~\cite{priq}.
We chose these two libraries because they exercise many essential JavaScript features, because they come equipped with unit test suites, and because they do not have external dependencies. In addition, Buckets.js is widely used by developers, having over 65k downloads on npm~\cite{npm}.

For both libraries, we wrote comprehensive symbolic unit tests for all functions and compared them with the concrete unit tests that ship with the libraries. The results are presented in Table~\ref{cosette:res}.
For each file in the libraries, we report the number of JS executable lines in the code itself and including dependencies (slash-separated), the corresponding numbers of JSIL lines, the number of symbolic unit tests created by us and the number of concrete unit tests created by the library developers, the number of JS lines in the symbolic and concrete tests, their coverage measured as percentage of lines, and the average \cosette run time for the symbolic tests.
%The files in Buckets.js are separated by a line from the unique file in queue-pri.

The results we obtained clearly demonstrate the benefits of symbolic testing using \cosette.
In both cases, we were able to \emph{obtain 100\% line coverage}, improving the coverage of the Buckets.js library by 12\%.
We achieved this using a total of \emph{60\% fewer tests}, and each test had on average \emph{10\% fewer lines of code}.
We also discovered one bug in the Buckets.js library, as well as one in the queue-pri library. 


For the testing, we used a machine with an Intel Core i7-4980HQ CPU 2.80 GHz and DDR3 RAM 16GB. We measured the execution time of each symbolic test and averaged the times across tests for each library file. The times we obtain reflect the fact that Rosette code is interpreted, rather than running natively. We aim at implementing our own symbolic execution tool from scratch in the future, which, given our experience with JaVerT, should reduce execution times by at least an order of magnitude.

\begin{table}[!t]
{
\small
%\begin{center}
\setlength\tabcolsep{4pt}
\begin{tabular*}{\linewidth}{l@{\;\;}rrrrrr}
\toprule
% Name || JS Loc/loc* || JSIL Loc/loc* || #tests || symb/conc loc || symb/conc cov || time
Name & \makecell{JS lines} & \makecell{JSIL lines} & \# Tests & \makecell{Test lines} & \makecell{Line\\Cov.~(\%)} & \makecell{Avg.\\time} \\
\midrule
\texttt{arrays} & 44/71 & 1251/1942 & 9/24 & 166/329 & 100/100 & 20s \\
\texttt{bag} & 69/237 & 2041/7194 & 7/18 & 78/265 & 100/76.8 & 74s \\
\texttt{bstree} & 143/326 & 3819/8052 & 11/31 & 216/759 & 100/98.6 & 5m27s \\
\texttt{dict} & 57/84 & 1683/2374 & 7/14 & 116/170 & 100/80.7 & 15s \\
\texttt{heap} & 57/128 & 2059/4001 & 4/15 & 92/626 & 100/96.5 & 5m29s \\
\texttt{llist} & 126/153 & 2447/3138 & 9/21 & 149/370 & 100/94.4 & 24s \\
\texttt{multidict} & 56/184 & 1871/5496 & 6/16 & 118/189 & 100/74.1 & 1m15s \\
\texttt{pqueue} & 26/154 & 1066/5067 & 5/12 & 70/283 & 100/96.2 & 5m49s \\
\texttt{queue} & 30/183 & 1095/4233 & 6/9 & 111/146 & 100/96.7 & 20s \\
\texttt{set} & 40/124 & 1528/3902 & 6/12 & 86/271 & 100/70.0 & 1m01s \\
\texttt{stack} & 23/176 & 941/4079 & 4/7 & 91/104 & 100/87.0 & 26s \\
\midrule 
\texttt{queue-pri} & 19/164 & 872/5086 & 2/9 & 26/80 & 100/100 & 1m18s \\
\bottomrule
%\end{center}
\end{tabular*}
}
\caption{Tests for the Buckets.js and queue-pri libraries}
\vspace*{-0.95cm}
\label{cosette:res}
\end{table}

%\pmax{Say something about how bugs work - sometimes coverage, sometimes semantics.}

\smallskip
\noindent \emph{Bug: MultiDictionary in Buckets.js.}
We discovered a bug in the implementation of the Buckets.js multi-dictionary library.
A multi-dictionary is a key-value map in which a single key holds an array of distinct values. 
Our symbolic tests for the \jsinline|remove(key, value)| function, which removes a given key-value pair from the multi-dictionary, have revealed that the library wrongly treats the case in which we try to remove a key-value pair for a key with no associated values.
In practice, a runtime error is thrown instead of \jsinline|remove| returning \jsinline|false|. 
This bug was not detected by the concrete unit tests associated with the library due to their incomplete coverage;
we have fixed it and submitted an appropriate pull request.




\smallskip
\noindent \emph{Bug: queue-pri.} This library implements a priority queue that stores data with an optional priority value.
This priority can either be a number (the lower the value, the higher the priority) or a default value of \jsinline{null} if no priority is provided, in which case the associated element is put at the end of the queue.
Our symbolic tests of the \jsinline{enqueue(data, pri)} method of the library show that that elements enqueued with priority \jsinline{0} were wrongly being always enqueued at the end of the queue. We traced the bug to the way in which priority was calculated inside \jsinline{enqueue}: \jsinline{priority = pri || null}, which evaluates to \jsinline|null| if the priority is not supplied, but also, due to the semantics of JavaScript, if it is equal to 0. This bug was not caught by the unit tests of the library, even though their line coverage was 100\%, because the developer had not considered inserting nodes with priority 0. This shows that \cosette is a useful tool for symbolic testing, because it fully follows the semantics of JavaScript and will expose corner cases that a developer may not be aware of.

\myparagraph{Specification-driven Bug-finding} For this part of the evaluation, we required  JavaScript code that was specified. As \cosette does not infer specifications, we revisited the JaVerT full functional correctness specifications of simple data structure libraries: key-value maps (cf.~\S\ref{subsec:sdbf}); priority queues; binary search trees (BSTs), and sorted lists~\cite{javert}. Expectedly, these libraries are substantially smaller than real-world JS libraries; their code is given in the Appendix.

For these libraries, we first investigated the relationship between the unfolding depth for recursive predicates and the code coverage of the resulting symbolic tests. We have observed that very few unfoldings are sufficient for achieving full coverage. In particular, the tests generated for the key-value map, priority queue, and the sorted list have full coverage already for unfold depth set to 1, while those for the BST reach full coverage for unfold depth set to 2. 

%\pmax{This unfolding bit is not worth a table. What it shows is that BST is somehow "more recursive" than the others---is there an official way of saying that?}

To test the compositionality of \cosette, we crippled the specifications of the key-value map and the priority queue, exposing various frame-related bugs, such as the ones shown in~\S\ref{subsec:sdbf}. \cosette was already able to detect all bugs with the unfold depth set to 1, which shows that it can successfully reason given partial state information, in contrast to standard symbolic execution tools for JavaScript.
