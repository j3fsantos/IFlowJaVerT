%!TEX root = ../main.tex

\section{Full Unification Algorithm}

\myparagraph{Unification Plan}
When solving $\unificationfun(\sstate, \pass)$, the symbolic variables of $\pass$ that are not 
in $\sstate$ are assumed to be existentially quantified. 
To find the appropriate bindings for these variables, we 
introduce \emph{unification plans} (Def.~\ref{def:up}).
Informally, a unification plan is an ordering of the simple assertions in $\pass$ that 
guarantees that the unification algorithm does not have to backtrack at unification~time. 

\begin{table}[!h]
{\small \begin{tabular}{@{}c@{}ccc@{}c@{}}\toprule
\emph{Argument} & & \textbf{IN}  & & \textbf{OUT}  \\
\cmidrule{1-1} \cmidrule{3-3} \cmidrule{5-5}

$\svar$                                                       & & $\{ \svar \}$                                                          & & $\{ \svar \}$    \\
$\jsillist{\lexpr_1, ..., \lexpr_n}$                     & & $\upin(\lexpr_1) \cup ... \cup \upin(\lexpr_n)$      & & $\upout(\lexpr_1) \cup ... \cup \upout(\lexpr_n)$ \\
$\lexpr_1 + \lexpr_2$                                    & & $\upin(\lexpr_1) \cup \upin(\lexpr_2)$                  & & $\emptyset$ \\
$\cdots$ & & $\cdots$ & & $\cdots$ \\[1pt]
%%
$(\lexpr_1, \lexpr_2)\pointsto \lexpr_3$   & & $\upin(\lexpr_1) \cup \upin(\lexpr_2)$ & & $\upout(\lexpr_3)$  \\
%
$\emptyfields{\lexpr_1}{\lexpr_2}$           &  & $\upin(\lexpr_1) \cup \upin(\lexpr_2)$ & & $\emptyset$ \\
%
$\lexpr_1 = \lexpr_2$                               & & $\upin(\lexpr_1)$/$\upin(\lexpr_2)$      & & $\upout(\lexpr_2)$/$\upout(\lexpr_1)$ \\
%
$\sass$                                                    & & $\fv(\sass)$                                           & & $\emptyset$ \\
\bottomrule
\end{tabular}}
%\caption{\emph{in} and \emph{out} sets for assertions and logical expressions}
%\label{tab:insouts}
%\vspace{-0.3cm}
\end{table}

To construct unification plans, we define an \emph{in} set and an \emph{out} set for each assertion and logical expression, illustrated above. These 
sets are reminiscent of the predicate parameter modes in~\cite{nguyen:vmcai:2008}).
Intuitively, the variables in the \emph{out} set of an assertion are those that can be computed 
using the variables in the \emph{in} set, together with the current state (e.g.~given the assertion $(\svar_1, \svar_2) \pointsto \svar_3$, if we know the bindings
for $\svar_1$ and $\svar_2$, we can compute the bindings for $\svar_3$, given 
the current symbolic state). 
%
For logical expressions, the variables in the \emph{out} set are those that can be computed
given the value of the whole expression, whereas the variables in the \emph{in} set 
are those that we need to know to compute the value of the whole expression.  
Finally, the definition of a unification plan is given below. 

\begin{definition}[Unification Plan]\label{def:up}
A \emph{unification plan} $\up$ is a sequence of simple assertions $\sqass_i \mid_{i=0}^n$ such that
for all $0 \leq i \leq n$, it holds that:
$
 \upin(\sqass_i) \subseteq \big(\cup_{j = 0}^{i-1} \upout(\sqass_j)\big) \cup \upin_0
$,
where $\upin_0$ is the set of \underline{non}-existentially quantified logical variables. 
\end{definition}

\vspace{-3pt}
\noindent It is not always possible to generate a unification plan for an SL-assertion. We only 
consider assertions that admit a unification plan. 


\myparagraph{Unification Algorithm}
Given a symbolic state $\sstate$ and an assertion $\pass$, $\unificationfun(\sstate, \pass)$: 
\dtag{1} replaces all occurrences of program variables in $\pass$ with their bindings 
given by $\sstate.\stosel$;
\dtag{2} computes an initial substitution $\subst_0$, mapping all the non-existentially quantified symbolic 
variables in $\pass$ to themselves (formally: $\subst_0 = \identity_{\fv(\sstate) \cap \fv(\pass)}$); 
\dtag{3} creates a unification plan $\up$ for $\pass$; and, 
\dtag{4} calls Algorithm~\ref{fip:symb:states:up}. 

{\begin{algorithm}[h!]
\algblock[Name]{match}{end}
\caption{Frame Inference for Symbolic States}\label{fip:symb:states:up}
\begin{algorithmic}[1]
\Function{Unification}{$\sstate$, $\up$, $\subst$}
    \State $\textbf{match}$ $\up$ $\textbf{with}$
    \State $\mid~\lstemp:$ \Return $\success{\subst, \sstate}$
   % Cell ASS
    \State $\mid~(\sloc, \sexprp) \pointsto \sexprv \lstcons \up' :$ 
    \State $\qquad \textbf{match} \ \GetCellV{\sstate, \subst(\sloc), \subst(\sexprp)}$ $\textbf{with}$
    \State $\qquad \mid~\success{\sexprv', \sstate'}:$
    \State $\qquad \qquad \textbf{match} \ \unifylexpr(\sexprv, \sexprv', \subst, \sstate.\pcsel)$ $\textbf{with}$
     \State $\qquad \qquad \mid~ \success{\subst'}:$ \Return \Call{Unification}{$\sstate'$, $\up'$, $\subst'$}
      \State $\qquad \qquad \mid~ \fail{\pc_f} \ \, :$ \Return $\fail{\pc_f}$
      \State $\qquad \mid~\fail{\pc_f}:$ \Return $\fail{\pc_f}$
      % EF ASS
     \State $\mid~\emptyfields{\sloc}{\sexprv} \lstcons \up' :$  
       \State $\qquad \textbf{match} \ \GetDomainV{\sstate, \subst(\sloc)}$ $\textbf{with}$
       \State $\qquad \mid~\success{\sexprv', \sstate'}:$ $\textbf{if} \,(\sstate.\pcsel \vdash \sexprv \backslash \sexprv' = \{ \sexprp_1, ..., \sexprp_n \})$
         \State $\qquad \quad \ ~  \textbf{then}$ \Return \Call{{\small Unification}}{{\scriptsize $\sstate'\!\dunion\!(\sloc, \sexprp_i)\!\pointsto\!\none\!\mid_{i = 1}^n$}, {\small $\up'$}, {\small $\subst$}}
            \State $\qquad \quad \  ~  \textbf{else}$ \Return $\fail{\sexprv' \not\subseteq \sexprv }$
%        \State $\qquad \qquad \mid~ \success{\subst'}:$ \Return \Call{Unification}{$\sstate'$, $\up'$, $\subst'$}
 %      \State $\qquad \qquad \mid~ \fail{\pc_f} \ \, :$ \Return $\fail{\pc_f}$
       \State $\qquad \mid~\fail{\pc_f}:$ \Return $\fail{\pc_f}$
     % Logical Equality  
     \State $\mid~(\sexprv = \sexprv') \lstcons \up' :$  
        \State $\qquad \textbf{match} \ \unifylexpr(\sexprv', \sexprv, \subst, \sstate.\pcsel)$ $\textbf{with}$
         \State $\qquad \qquad \mid~ \success{\subst'}:$ \Return \Call{Unification}{$\sstate$, $\up'$, $\subst'$}
       \State $\qquad \qquad \mid~ \fail{\pc_f} \ \, :$ \Return $\fail{\pc_f}$
     % OTHER PURE ASS
     \State $\mid~\sass \lstcons \up' :$   
      \State $\qquad \textbf{if} \,(\sstate.\pcsel \vdash \subst(\sass))$
       \State $\qquad \qquad \textbf{then}$ \Return  \Call{Unification}{$\sstate$, $\up'$, $\subst$}
      \State $\qquad \qquad \textbf{else}$  \Return $\fail{\subst(\sass)}$
\EndFunction
\end{algorithmic}
\end{algorithm}}



      % \State $\qquad \mid~\success{\sexprv', \sstate'}:$ $\textbf{if} \,(\sstate.\pcsel \vdash \sexprv \backslash \sexprv' = \{ \sexprp_1, ..., \sexprp_n \})$
%        \State $\qquad \qquad \qquad ~  \textbf{then}$ \Return \Call{Unification}{$\sstate' \dunion (\sloc, \sexprp_i) \pointsto \none \mid_{i = 1}^n$, $\jvec{\sqass}$}
%       \State $\qquad \qquad \qquad ~  \textbf{else}$ \Return $\fail{\sexprv' \not\subseteq \sexprv }$
%       \State $\qquad \mid~\fail{\pc_f}:$ \Return $\fail{\pc_f}$


\newpage
\section{Proofs --- Section~\ref{sec:specs}}

%In order to prove the results from~\S\ref{sec:specs}, we need to instrument 
%Algorithm~\ref{fip:symb:states} to keep track of additional information. 

\newcommand{\unificationfunction}{\textsc{Unification}}
\newcommand{\extendedunificationfunction}{\underline{\textsc{Unification}}}
\newcommand{\emptystate}{\emptyset}
\newcommand{\stateequiv}{\sim}
\newcommand{\stateequivrel}[3]{#1 \sim_{#3} #2}


In the following, we use $\stateequivrel{\sstate}{\sstate'}{\pc}$ to mean 
that $\interpret{\symbconc}{}(\sstate \, \wedge \, \pc) = \interpret{\symbconc}{}(\sstate')$. 

\begin{lemma}[GetCell - FIP Success]\label{lemma:getcell:fip}
$$
\begin{array}{l}
\GetCellV{\sstate, \sloc, \sexprp} = \success{\sexprv', \sstate'} 
    \implies 
        \stateequivrel{\sstate}{\sstate' \statecompose \normaliser((\sloc, \sexprp) \pointsto \sexprv')}{}
\end{array}
$$
\end{lemma}
\begin{proof}
Follows immediately from the definition of $\GetCellVFun$. 
\end{proof}

\begin{lemma}[GetDomain - FIP Success]\label{lemma:getdomain:fip}
$$
\begin{array}{l}
\GetDomainV{\sstate, \sloc, \sexprp} = \success{\sexprv', \sstate'} 
    \implies 
        \stateequivrel{\sstate}{\sstate' \statecompose \normaliser(\emptyfields{\sloc}{\sexprv'})}{}
\end{array}
$$
\end{lemma}
\begin{proof}
Follows immediately from the definition of $\GetDomainVFun$. 
\end{proof}

\begin{lemma}[Soundness of Unification - Success]\label{lemma:soundness:unification:success}
$$
\begin{array}{l}
\unificationfun(\sstate, \jvec{\spass}) = \success{\sstate_f} \\ \quad \quad
  \implies 
   \exists \, \sstate_m \, . \, 
   \sstate = \sstate_m \statecompose \sstate_f 
   \, \wedge \, 
    \stateequivrel{\sstate_m}{\normaliser(\jvec{\spass})}{\sstate.\pcsel}
\end{array}
$$
\end{lemma}
\begin{proof}
We proceed by induction on the length of $\jvec{\spass}$. The base case corresponds to the empty unification plan $\jvec{\spass} = \lstemp$, 
whereas the inductive case corresponds to $\jvec{\spass} = \sqass \lstcons \jvec{\spass}'$, where $\sqass$ is a simple 
assertion. For clarity, we consider each possible inductive case separately. 
\vspace{3pt}

\noindent \prooflab{Empty Assertion List} $\jvec{\spass} = \lstemp$. It follows that
$\sstate_f = \sstate$. Letting  $\sstate_m = \emptystate$, 
and noting that $\emptystate \statecompose \sstate = \sstate$ and $\emptystate \stateequiv \normaliser([])$, the result follows. 
 \vspace{5pt}

\noindent \prooflab{Cell Assertion} 
$\jvec{\spass} = (\sloc, \sexprp) \pointsto \sexprv \lstcons \jvec{\spass}'$ (\ieq{1}). 
From \ieq{1}, we conclude that there exists a symbolic state $\sstate'$, 
and a symbolic value $\sexprv'$, such that: 
$\GetCellV{\sstate, \sloc, \sexprp} = \success{\sexprv', \sstate'}$ (\ieq{2}),
$\sstate.\pcsel \vdash \sexprv' = \sexprv$ (\ieq{3}), and:
$$
\unificationfunction(\sstate', \jvec{\spass}') = \success{\sstate_f} \text{ (\ieq{4})}
$$ 
Applying the induction hypothesis to \ieq{4}, we conclude that there is a symbolic state 
$\sstate_m'$ such that  $\sstate' = \sstate_m' \statecompose \sstate_f$ (\ieq{5}) and 
$\stateequivrel{\sstate_m'}{\normaliser(\jvec{\spass}')}{\sstate'.\pcsel}$ (\ieq{6}). 
Applying Lemma~\ref{lemma:getcell:fip} to \ieq{2}, we conclude that:
$$\sstate = \sstate' \statecompose \normaliser((\sloc, \sexprp) \pointsto \sexprv') \text{ (\ieq{7})}$$   
Combining \ieq{5} and \ieq{7}, we conclude that: 
$$
\sstate = (\sstate_m' \statecompose \normaliser((\sloc, \sexprp) \pointsto \sexprv')) \statecompose \sstate_f  \text{ (\ieq{8})}
$$
From \ieq{3}, it follows that: 
$$
\stateequivrel{\normaliser((\sloc, \sexprp) \pointsto \sexprv')}{\normaliser((\sloc, \sexprp) \pointsto \sexprv)}{\sstate.\pcsel} \text{ (\ieq{9})}
$$
From \ieq{1}, \ieq{6}, and \ieq{9}, we conclude that: 
$$
\stateequivrel{\sstate_m' \statecompose \normaliser((\sloc, \sexprp) \pointsto \sexprv')}{\normaliser(\jvec{\spass})}{\sstate.\pcsel} \text{ (\ieq{10})}
$$
Letting $\sstate_m = \sstate_m' \statecompose \normaliser((\sloc, \sexprp) \pointsto \sexprv')$, the result follows 
from \ieq{8} and \ieq{10}. 
\vspace{5pt}

\noindent \prooflab{Domain Assertion} The unification plan is as follows: 
$\jvec{\spass} = \emptyfields{\sloc}{\sexprv} \lstcons \jvec{\spass}'$ (\ieq{1}). 
From \ieq{1}, it follows that there exists a symbolic state $\sstate'$,
and symbolic value $\sexprv'$, $\sexprp_1$, ..., $\sexprp_n$, such that: 
$\GetDomainV{\sstate, \sloc} = \success{\sexprv', \sstate'}$ (\ieq{2}), 
$
\sstate.\pcsel \vdash \sexprv \backslash \sexprv' = \{ \sexprp_1, ..., \sexprp_n \})
$ (\ieq{3}) and: 
$$
\unificationfunction(\sstate', \jvec{\spass}') = \success{\sstate_f} \text{ (\ieq{4})}
$$
Applying the induction hypothesis to \ieq{4}, we conclude that there is a symbolic state 
$\sstate_m'$ such that  $\sstate' = \sstate_m' \statecompose \sstate_f$ (\ieq{5}) and
$\stateequivrel{\sstate_m'}{\normaliser(\subst'(\up'))}{\sstate'.\pcsel}$ (\ieq{6}). 
%
Applying Lemma~\ref{lemma:getdomain:fip} to \ieq{2}, we conclude that 
$\sstate = \sstate' \statecompose \normaliser(\emptyfields{\subst(\sloc)}{\sexprv'})$ (\ieq{7}). 
%
Combining \ieq{5} and \ieq{7}, we conclude that: 
$$
\sstate = (\sstate_m' \statecompose \normaliser(\emptyfields{\sloc}{\sexprv'})) \statecompose \sstate_f  \text{ (\ieq{8})}
$$
From  \ieq{3}, it follows that: 
$$
\stateequivrel{\normaliser(\emptyfields{\sloc}{\sexprv'})}{\normaliser(\emptyfields{\sloc}{\sexprv})}{\sstate.\pcsel} \text{ (\ieq{9})}
$$
From \ieq{1}, \ieq{6}, and \ieq{9}, it follows that: 
$$
\stateequivrel{\sstate_m' \statecompose \normaliser(\emptyfields{\sloc}{\sexprv'})}{\normaliser(\jvec{\spass}}{\sstate.\pcsel} \text{ (\ieq{10})}
$$
Letting $\sstate_m = \sstate_m' \statecompose \normaliser(\emptyfields{\sloc}{\sexprv'})$, the result follows 
from \ieq{8} and \ieq{10}. 
\vspace{5pt}


\noindent \prooflab{Pure Assertion}
$\jvec{\spass} = \sass \lstcons \jvec{\spass}'$ (\ieq{1}). 
From \ieq{1}, it follows that: 
$\sstate.\pcsel \vdash \sass$ (\ieq{2}) and 
and:
$$
\unificationfunction(\sstate, \jvec{\spass}') = \success{\sstate_f} \text{ (\ieq{3})}
$$
%
Applying the induction hypothesis to \ieq{3}, we conclude that there is a symbolic state 
$\sstate_m'$ such that  $\sstate = \sstate_m' \, \statecompose  \, \sstate_f$ (\ieq{4}) and
$\stateequivrel{\sstate_m'}{\normaliser(\jvec{\spass}')}{\sstate'.\pcsel}$ (\ieq{5}). 
From \ieq{2}, we conclude that: 
$$
\stateequivrel{\emptystate}{\sass}{\sstate.\pcsel} \text{ (\ieq{6})}
$$
From \ieq{1}, \ieq{5}, and \ieq{6}, it follows that: 
$$
\stateequivrel{\sstate_m'}{\normaliser(\jvec{\spass})}{\sstate.\pcsel} \text{ (\ieq{7})}
$$
Letting $\sstate_m = \sstate_m'$, the result follows 
from \ieq{4} and \ieq{7}.
\end{proof}
 
 \begin{lemma}[GetCell - FIP Fail]\label{lemma:getcell:fip:fail}
$$
\begin{array}{l}
\GetCellV{\sstate, \sloc, \sexprp} = \fail{\pc_f} \\ \quad \quad
    \implies 
        \neg \exists \sstate', \sexprv' \, . \, \stateequivrel{\sstate \, \wedge \, \pc_f}{\sstate' \statecompose \normaliser((\sloc, \sexprp) \pointsto \sexprv)}{}
\end{array}
$$
\end{lemma}
\begin{proof}
Follows immediately from the definition of $\GetCellVFun$. 
\end{proof}

\begin{lemma}[GetDomain - FIP Fail]\label{lemma:getdomain:fip:fail}
$$
\begin{array}{l}
\GetDomainV{\sstate, \sloc, \sexprp} = \fail{\pc_f} \\ \quad \quad 
    \implies 
         \neg \exists \sstate', \sexprv' \, . \, \stateequivrel{\sstate \, \wedge \, \pc_f}{\sstate' \statecompose \normaliser(\emptyfields{\sloc}{\sexprv'})}{}
\end{array}
$$
\end{lemma}
 \begin{proof}
Follows immediately from the definition of $\GetDomainVFun$. 
\end{proof}
 
 
 \begin{lemma}[Soundness of Unification - Failure]\label{lemma:soundness:unification:failure}
$$
\begin{array}{l}
\unificationfun(\sstate, \jvec{\spass}) = \fail{\pc_f} \\ \quad \quad
  \implies 
   \neg \exists \, \sstate_m \, . \, 
   \sstate = \sstate_m \statecompose \sstate_f 
   \, \wedge \, 
    \stateequivrel{\sstate_m}{\normaliser(\jvec{\spass})}{\sstate.\pcsel}
\end{array}
$$
\end{lemma}
  \begin{proof}
By induction on the length of $\jvec{\spass}$ as in~\ref{lemma:soundness:unification:success}, using 
Lemmas~\ref{lemma:getcell:fip:fail} and~\ref{lemma:getdomain:fip:fail}. 
\end{proof}
 
 \begin{temax}[Soundness of FIP - Theorem~\ref{teo:fip:soundness}]
The following hold: 
\begin{enumerate}%[leftmargin=*]
\setlength{\itemsep}{0.1cm}
\item $\unificationfun(\sstate, \pass) = \success{\sstate_f}
        \implies 
        \interpret{}{}(\sstate) \subseteq \interpret{}{}(\sstate_f \statecompose \normaliser(\pass))$
 \item  $\unificationfun(\sstate, \pass) = \fail{\pc_f} 
   \implies
   \interpret{}{}(\sstate \, \wedge \, \pc_f) \cap \interpret{}{}(\pass) = \emptyset$
\end{enumerate}
 \end{temax}
 \begin{proof}
 Follows from Lemmas~\ref{lemma:soundness:unification:success} and~\ref{lemma:soundness:unification:failure}. 
 \end{proof}
 
 
 \begin{temax}[Bug-finding for \jsil SL Specifications - Theorem~\ref{teo:bug:finding:sl}]
$$
\begin{array}{l}
\testify{}(\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag})  = (\proc, \sstate) \, \wedge \\
\quad
  \prog[\jsilmain \mapsto \proc] :  \transabssemrule{\sstate, \csmain, 0}{-, -, -}{\top}{\bot}{\symbolic} \\ \quad \qquad 
    \implies  
         \prog \not\satisfies \specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}
\end{array}
$$
\end{temax}
 \begin{proof}
 Suppose that $\testify{}(\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag})  = (\proc, \sstate)$ (\hyp{1}) 
 and $\prog[\jsilmain \mapsto \proc] :  \transabssemrule{\sstate, \csmain, 0}{-, -, -}{\top}{\bot}{\symbolic}$ (\hyp{2}). 
 We have to consider two separate cases: $\flag = \fnormal$ and $\flag = \ferror$. 
We do the proof for $\flag = \fnormal$ (\hyp{3}). The other case is analogous. 
Form \hyp{1} and \hyp{3}, we conclude that: 
$$
\begin{array}{l}
\proc = \darkmath{\sf proc} \jsilmain () \{ \\ 
\qquad 0_{\phantom{\sf nm}}: \jsilcall{\jvar}{\pid}{\svar_0, ..., \svar_n}{\errlab} \\ 
 \qquad \retlab \, : \sepassert(\sstore(Q)[\jvar/\retvar])  \\
 \qquad \errlab \, \, \, : \jassert(\jfalse)   \\
\quad \}  
\end{array} 
\qquad \text{ (\ieq{4})}
$$
where: $\sstore =  [ \jvar_i \mapsto \svar_i|_{i=0}^n]$ (\ieq{5}) and $\sstate = \normaliser(\sstore(\pass))$ (\ieq{6}). 
%
We observe that $\stateequivrel{\sstate}{\normaliser(\pass)}{}$ (\ieq{7}). 
%
From \hyp{2}, and given that there are no asserts in the code of $\pid$, we conclude that the assertion failure must have been 
cause either by $\retlab \, : \sepassert(\sstore(Q)[\jvar/\retvar])$ or by $\jassert(\jfalse)$. We treat the two cases separately. 
\vspace{3pt}

\noindent \prooflab{Assert False} If the command $\jassert(\jfalse)$ is executed, then it must be the case that 
$\pid$ returned in error mode. From \ieq{7}, we conclude that all the concrete states in the interpretation of 
$\sstate$ are also in the interpretation of $\pass$. As the specification mandates that $\pid$ must return in 
$\fnormal$ mode, any concretisation of this symbolic execution invalidates the specification. 
\vspace{5pt}

\noindent \prooflab{SL-Assert} If the command $\retlab \, : \sepassert(\sstore(Q)[\jvar/\retvar])$ is executed, 
it must be the case that there is a constraint $\pc_f$ such that 
$\unificationfun(\sstate', \sstore(Q)[\jvar/\retvar]) = \fail{\pc_f}$ (\ieq{8}), where $\sstate'$ is the symbolic 
state after the return of $\pid$. 
Applying Theorem~\ref{teo:bug:finding:sl} to \ieq{8}, we conclude that 
$\interpret{}{}(\sstate \, \wedge \, \pc_f) \cap \interpret{}{}(\sstore(Q)[\jvar/\retvar]) = \emptyset$, 
which establishes the result.
 \end{proof}
 
 

 
%
%  \State $\qquad \textbf{if} \,(\sstate.\pcsel \vdash \subst(\sass))$
%       \State $\qquad \qquad \textbf{then}$ \Return  \Call{Unification}{$\sstate$, $\up'$, $\subst$}


