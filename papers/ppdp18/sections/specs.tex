%!TEX root = ../main.tex

\pmax{Pull up the messages, mention JS.}

\noindent We show how to use \cosette for debugging \jsil code annotated with 
separation logic (SL) specifications. Tools that support SL-reasoning about
functional correctness properties of programs often require of the user to 
analyse long, complex proof traces whenever
verification fails. 
\cosette substantially simplifies this process by providing
concrete counter-models that invalidate the input specification. 


We extend the 
 \jsil symbolic interpreter with a mechanism for asserting
SL-assertions (\S\ref{subsec:sep:assertions}) and show how to 
implement this mechanism by giving a sound decision procedure 
for solving the frame inference problem (FIP)~\cite{}
in the context of symbolic execution (\S\ref{subsec:fip}).
%
%Unlike verification tools, our emphasis is in the generation of counter-models for failing cases. 
%
We present an algorithm  
for generating symbolic tests from SL-specifications, which guarantees 
that whenever a symbolic test fails, \cosette produces a concrete 
counter-model that invalidates the corresponding specification (\S\ref{specs:to:symbolic:tests}). 
All definitions and proofs are given in full in the Appendix.

\vspace{-5pt}
\subsection{Symbolic Execution with SL-Assertions}\label{subsec:sep:assertions}

\jsil Logic assertions~\cite{javert} provide a way of describing \emph{partial} symbolic states.
They include boolean and comparison operations on \jsil expressions; the separating conjunction; 
and assertions for describing heaps. The $\lemp$ assertion describes 
an empty heap. The cell assertion, $(\jsilexpr_1,\jsilexpr_2) \pointsto \jsilexpr_3$,  describes that an object 
at the location denoted by $\jsilexpr_1$ has the property denoted by $\jsilexpr_2$ with value 
denoted by $\jsilexpr_3$. The object domain assertion $\emptyfields{\jsilexpr_1}{\jsilexpr_2}$ states that the object at 
the location denoted by $\jsilexpr_1$ has no properties other than possibly those included in the
set denoted by $\jsilexpr_2$. Additionally, we refer to assertions that do not contain $\lemp$ or 
the separating conjunction as \emph{simple assertions}, and use $\spass$, $\sqass$ 
to range over them.

%\pmaxinline{Mention sth about Es being the same.} %The syntax of assertions is given below. 
%We refer to assertions different from $- \sep -$ and $\lemp$ as \emph{simple assertions}
%and use $\spass$ and $\sqass$ to range over them.

\vspace{2pt}
\begin{display}{\jsil Logic Assertions}
%
{\small
\begin{tabular}{r@{\ }c@{\ }lr}
  %%%%
  %$\lexpr$ & $\triangleq$ & $\val \mid \jvar \mid \svar \mid \unoper\ \lexpr \mid \lexpr \binoper \lexpr$ & Logical Exprs. \\
  $\rass, \sass$ & $\triangleq$ & $\jtrue \mid \jfalse \mid  \neg \rass \mid \rass \land \sass \mid \rass \lor \sass \mid \jsilexpr = \jsilexpr \mid \jsilexpr \leq \jsilexpr$ & Pure Asrts. \\
  $\pass, \qass$ & $\triangleq$ & $\rass \mid \lemp \mid (\jsilexpr, \jsilexpr)\pointsto \jsilexpr \mid \pass \sep \qass \mid \emptyfields{\jsilexpr}{\jsilexpr}$ & Asrts.
\end{tabular}}
\end{display}

\noindent Without loss of generality, we implicitly assume that different symbolic locations 
denote different concrete locations.\footnote{To express aliasing, the user has to write multiple assertions.}
 Furthermore, given a cell assertion $(\jsilexpr,-) \pointsto -$, we always assume 
 $\jsilexpr$ to denote either a concrete location $\loc$ or a symbolic location $\sloc$. 
%
Note that 
a symbolic state $\sstate = (\sheap, \sdom, \sstore, \pc)$ corresponds to the assertion 
\begin{equation*}
{\small \begin{array}{l}
\big(\varoast_{(\sloc, \sexprp) \in \domain(\sheap)} (\sloc, \sexprp) \mapsto \sheap(\sloc, \sexprp)\big) 
  \sep \big(\varoast_{\sloc \in \domain(\sdom)} \, \emptyfields{\sloc}{\idom(\sloc)}\big)  \\
 %
 \qquad \sep \big(\bigwedge_{\jvar \in \domain(\sstore)} \, \jvar = \sstore(\jvar)\big) \sep \pc
\end{array}}
\end{equation*}

\noindent where $\varoast$ denotes the iterated separating conjunction~\cite{citeme}. 

\pmax{Describe this and do better on the below}

Analogously, an assertion can be normalised into a symbolic state: 
 cell assertions form the heap; 
object domain assertions form the domain table;
 equalities involving program variables form the store; and 
 pure assertions form the path condition. 
Finally,  all occurrences of program variables in the heap, domain table, and path condition 
are replaced with their corresponding symbolic expressions from the store. 
We refer to the normalised symbolic state corresponding 
to $\pass$ by $\normaliser(\pass)$. 
%
We also use $\interpret{}{}(\sstate)$ for denoting the set 
$\{ (\jstate, \heap_f) \mid \exists \senv \, . \, (\jstate, \heap_f) \in \interpret{\symbconc}{\senv}(\sstate) \}$ 
and $\interpret{}{}(\pass)$ for denoting $\interpret{}{}(\normaliser(\pass))$. 

\myparagraph{Inductive Predicates}
\cosette does not support symbolic execution over inductive predicates, which are commonplace 
in SL-style specifications~\cite{smallf, berdine:aplas:2005}. 
As in~\cite{korat}, we deal with user-defined inductive predicates by \emph{unfolding} 
those predicates up to a fixed, user-defined bound. We omit this unfolding mechanism 
as it is routine. 

\myparagraph{Asserting SL-Assertions}
We extend \jsil commands with a special construct, $\sepassert(P)$, for stating that 
 the SL-assertion $P$ must hold whenever that command is evaluated. 
The corresponding symbolic semantics rules are given below. 

\vspace*{-0.2cm}
{\footnotesize
\begin{mathpar}
\inferrule[\textsc{SL-Assert - True}]
  { 
     \ccmd{i}  = \sepassert(\pass)  \\\\
     %
     \unificationfun(\sstate, \pass) = \success{\subst, \sstate_f}
  }{
    \abssemrule{\sstate, \scs, i}{\sstate, \scs, i{+}1}{\top}{\top}{\symbolic}
}
\qquad
\inferrule[\textsc{SL-Assert - False}]
  { 
     \ccmd{i}  = \sepassert(\pass)  \\\\
     %
    \unificationfun(\sstate, \pass) = \fail{\pc_f}  \quad
    %
     (\sstate.\pcsel \wedge \pc_f) \text{ SAT}
  }{
    \abssemrule{\sstate, \scs, i}{\sstate, \scs, i}{\top}{\bot}{\symbolic}
}
\end{mathpar}}

\vspace*{-0.2cm}
\noindent The rules use a partial decision procedure (PDP), $\unificationfun(\sstate, \pass)$, for 
determining if a given symbolic state $\sstate$ satisfies an assertion $P$, 
which is undecidable in general \cite{citemeplease}. 
There are two important criteria that $\unificationfun(\sstate, \pass)$ must satisfy:
\begin{enumerate}[leftmargin=*]
\setlength{\itemsep}{0.1cm}
%
\item {\bfseries Soundness}: If $\unificationfun(\sstate, \pass) = \success{\subst, \sstate_f}$, where $\subst$ is a substitution and $\sstate_f$ is a symbolic state frame, then it must hold that $\interpret{}{}(\sstate) \subseteq \interpret{}{}(\sstate_f \statecompose \normaliser(\subst(\pass)))$;\footnote{We use $\statecompose$ for the composition of two symbolic states, defined component-wise as disjoint union for the  heaps/domains/stores, and conjunction for the path conditions.}
%
\item {\bfseries Bug-Finding}: If $\unificationfun(\sstate, \pass) = \fail{\pc_f}$, then it must hold that $\interpret{}{}(\sstate \, \wedge \, \pc_f) \cap \interpret{}{}(\pass) = \emptyset$. Observe that every concrete state and heap frame in $\interpret{}{}(\sstate \, \wedge \, \pc_f)$ are counter-models for $P$. 
Also note that, in the \textsc{SL-Assert - False} rule, by explicitly requiring that $(\sstate.\pcsel \wedge \, \pc_f)$ is satisfiable, the semantics triggers an assertion failure only when it finds a concrete witness for the failure.
\end{enumerate}



\subsection{The Frame Inference Problem}\label{subsec:fip}

We describe the $\unificationfun(\sstate, \pass)$ PDP that we
use as part of the \jsil sym-bolic interpreter, for proving entailments 
between symbolic states \underline{and} finding counter 
models in case of failure.  
As is customary~\cite{javert,jacobs2011verifast,sepwithsmt}, this PDP first uses \emph{pattern-matching} 
on the spatial part of the symbolic state, and then discharges the pure part of the 
entailment to an external constraint solver (in our case, \rosette). 



When solving $\unificationfun(\sstate, \pass)$, the symbolic variables of $\pass$ that are not 
in $\sstate$ are assumed to be existentially quantified. 
As in~\cite{nguyen:vmcai:2008}, we 
topologically sort the simple assertions in $\pass$ to find the appropriate bindings 
for such variables. Here, for lack of space, we describe the frame inference 
algorithm for the setting without existentially quantified variables. 
The full version is given in the Appendix.  

Given a symbolic state $\sstate$ and an assertion $\pass$, $\unificationfun(\sstate, \pass)$ 
 replaces the program variables in $\pass$ with their bindings 
from $\sstate.\stosel$ and then calls the Frame Inference Algorithm (Algorithm~\ref{fip:symb:states}) 
 on the list of all simple assertions in $\pass$. This algorithm uses two~functions: 

\begin{description}
\setlength{\itemsep}{0.2em}
  \item[FIP GetCell.] In case of success, $\GetCellV{\sstate, \sloc, \sexprp}$ returns 
          the symbolic expression $\sexprv$ associated with 
          $(\sloc, \sexprp)$ in the heap component of $\sstate$ \underline{and} 
          the state obtained by removing that cell from $\sstate.\hpsel$.
  
  \item[FIP GetDomain.] In case of success, $\GetDomainV{\sstate, \sloc}$ returns 
          the symbolic expression $\sexprv_d$, denoting the potential domain 
          of the object at location $\sloc$ in $\sstate$, \underline{and} 
          the state obtained by removing all the negative resource associated with 
          $\sloc$ from $\sstate$.  
%  
%  \item[Expression Unification.]  In case of success, $\unifylexpr(\sexprv, \sexprv', \subst, \pc)$ 
%          returns a substitution $\subst'$ that extends $\subst$ such that $\pc \vdash \sexprv = \subst'(\sexprv')$. 
\end{description}

\noindent We give selected rules for these functions, analogous to those in \S\ref{subsec:symb:semantics}, except that: \dtag{1} both functions return a new symbolic state 
from which the matched resource is removed and \dtag{2} their corresponding constraints are lifted to the premise (highlighted in blue). 
Also, in case of failure, both functions return a constraint $\pc_f$, under which the inspected resource is guaranteed not to exist (highlighted in~red). 

\smallskip
\begin{display}{Selected FIP Rules}
\text{
{\scriptsize
\begin{mathpar} 
  \inferrule[\textsc{GetDomain}]
   { 
       \sheap = \sheap' \, \uplus \, \big((\sloc, \sexprp_i) \mapsto \sexprv_i \big)\mid_{i = 0}^m  
         \quad 
          (\sloc,-) \notin \domain (\sheap')  
         \quad
        \forall_{0 \leq i \leq n} \,  \sexprv_i \neq \none 
         \quad
           \forall_{n < i \leq m} \, \sexprv_i = \none
           \\\\ 
           \sexprv =  \{ \sexprp_i \mid_{i = n{+}1}^m\}
           \and
           \sheap'' = (\sloc, \sexprp_i) \mapsto \sexprv_i  \mid_{i=0}^n
           \and
           \sdom = \sdom' \dunion (\sloc \mapsto \sexprv')
   }{  \GetDomainV{(\sheap, \sdom, \sstore, \pc), \sloc} \semeq \success{(\sexprv' \backslash \sexprv}, (\sheap' \, \uplus \,  \sheap'', \sdom', \sstore, \pc))}
  \\
      \inferrule[\textsc{GetCell - Found}]
   { 
      (\sheap, \sdom, \sstore, \pc) = \sstate    
       \quad
       \sheap = \sheap' \, \uplus \, (\sloc, \sexprp') \mapsto \sexprv 
       \\\\
       {\color{blue} \pc \vdash (\sexprp = \sexprp')}
       \quad
       \sstate' = (\sheap', \sdom, \sstore, \pc)
   }{  \GetCellV{\sstate, \sloc, \sexprp} \semeq \success{ \sexprv, \sstate'}}
\quad
     \inferrule[\textsc{GetCell - Not Found}]
   { 
     (\sheap, \sdom, \sstore, \pc) = \sstate  
     \quad 
        { \color{blue} \pc \vdash \sexprp \not\in \sdom(\sloc)}
        \\\\
        \sstate' = (\sheap, \sdom[\sloc \mapsto \sdom(\sloc) \cup \jsilset{\sexprp}], \sstore,  \pc)
   }{  \GetCellV{\sstate, \sloc, \sexprp} \semeq \success{\none, \sstate'}}
\\
     \inferrule[\textsc{GetCell - Fail with Domain Info}]
   { 
       \sheap = \sheap'' \, \uplus \, \big((\sloc, \sexprp_i) \mapsto \sexprv_i \big)\mid_{i = 0}^m
      \qquad
       (\sloc,-) \notin \domain (\sheap'')
       \qquad
        { \color{blue} \pc \not\vdash \sexprp \not\in \sdom(\sloc)}
        \qquad
          { \color{blue} \pc \not\vdash \sexprp = \sexprp_i \mid_{i=0}^m}
   }{  \GetCellV{(\sheap, \sdom, \sstore, \pc), \sloc, \sexprp} \semeq \fail{{\color{red} (\sexprp \in \sdom(\sloc)) \, \wedge \, (\wedge_{i=0}^m (\sexprp_i \neq \sexprp))}}}
 \\
     \inferrule[\textsc{GetCell - Fail without Domain Info}]
   { 
       \sheap = \sheap'' \, \uplus \, \big((\sloc, \sexprp_i) \mapsto \sexprv_i \big)\mid_{i = 0}^m
      \qquad
       (\sloc,-) \notin \domain (\sheap'')
       \qquad
       \sloc \not\in \domain(\sdom)
        \qquad
          { \color{blue} \pc \not\vdash \sexprp = \sexprp_i \mid_{i=0}^m}
   }{  \GetCellV{(\sheap, \sdom, \sstore, \pc), \sloc, \sexprp} \semeq \fail{{\color{red} \wedge_{i=0}^m (\sexprp_i \neq \sexprp)}}}
 \end{mathpar}}}
 \end{display}

\smallskip
The Frame Inference Algorithm has four possible cases: 
\begin{itemize}[leftmargin=*]
\setlength{\itemsep}{0.1cm}
\item  $\jvec{\spass}=\lstemp$~: there is nothing left to unify; we 
            return the current symbolic state, which constitutes the frame. 
   
   \item $\jvec{\spass} = (\sloc, \sexprp) \pointsto \sexprv \lstcons -$~:
            using $\GetCellVFun$, we obtain the symbolic value~$\sexprv'$
            associated with $(\sloc, \sexprp)$ in the current symbolic state and
            check that $\sexprv' = \sexprv$ under the current path condition. 
            If the entailment holds, we proceed. Otherwise, we generate
            the \emph{failing constraint} $\sexprv' \neq \sexprv$. 
  
   \item $\jvec{\spass} = \emptyfields{\sloc}{\sexprv} \lstcons -$~:
            using $\GetDomainVFun$, we obtain the domain $\sexprv'$
            of $\sloc$ in the current symbolic state and 
            check that $\sexprv' \subseteq \sexprv$ under the current path condition. 
            %\polish{For instance, the assertion $\emptyfields{\sloc}{\jsilset{p_1, p_2}}$ states that $\sloc$ has \emph{at most} the properties $p_1$ and $p_2$. It might only have one of them, or none at all. But it cannot have more.}
            If the entailment holds, we extend the current symbolic state with the negative 
            resource in $\sloc$ not captured by $\emptyfields{\sloc}{\sexprv}$ and  proceed. 
            Otherwise, we generate the \emph{failing constraint} $\sexprv' \not\subseteq \sexprv$. 
            
   \item $\jvec{\spass} = \sass \lstcons -$~:  
            we check that $\sass$ is entailed by the current path condition. 
             If it is, we proceed. Otherwise, we generate
             the \emph{failing constraint} $\neg \sass$. 
\end{itemize}

%{\footnotesize \begin{algorithm}[t!]
%\algblock[Name]{match}{end}
%\caption{Frame Inference for Symbolic States}\label{fip:symb:states}
%\begin{algorithmic}[1]
%\Function{Unification}{$\sstate$, $\jvec{\spass}$}
%    \State $\textbf{match}$ $\jvec{\spass}$ $\textbf{with}$
%    \State $\mid~\lstemp:$ \Return $\success{\sstate}$
%   % Cell ASS
%    \State $\mid~(\sloc, \sexprp) \pointsto \sexprv \lstcons \jvec{\sqass} :$ 
%    \State $\qquad \textbf{match} \ \GetCellV{\sstate, \sloc, \sexprp}$ $\textbf{with}$
%    \State $\qquad \mid~\success{\sexprv', \sstate'}:$ $\textbf{if} \,(\sstate.\pcsel \vdash \sexprv = \sexprv')$
%     \State $\qquad \qquad \qquad ~  \textbf{then}$ \Return  \Call{Unification}{$\sstate'$, $\jvec{\sqass}$}
%     \State $\qquad \qquad \qquad ~  \textbf{else}$ \Return $\fail{\sexprv \neq \sexprv'}$
%      \State $\qquad \mid~\fail{\pc_f}:$ \Return $\fail{\pc_f}$
%      % EF ASS
%     \State $\mid~\emptyfields{\sloc}{\sexprv} \lstcons \jvec{\sqass} :$  
%       \State $\qquad \textbf{match} \ \GetDomainV{\sstate, \sloc}$ $\textbf{with}$
%       \State $\qquad \mid~\success{\sexprv', \sstate'}:$ $\textbf{if} \,(\sstate.\pcsel \vdash \sexprv \backslash \sexprv' = \{ \sexprp_1, ..., \sexprp_n \})$
%        \State $\qquad \qquad \qquad ~  \textbf{then}$ \Return \Call{Unification}{$\sstate' \dunion (\sloc, \sexprp_i) \pointsto \none \mid_{i = 1}^n$, $\jvec{\sqass}$}
%       \State $\qquad \qquad \qquad ~  \textbf{else}$ \Return $\fail{\sexprv' \not\subseteq \sexprv }$
%       \State $\qquad \mid~\fail{\pc_f}:$ \Return $\fail{\pc_f}$
%     % OTHER PURE ASS
%     \State $\mid~\sass \lstcons \jvec{\sqass} :$  $ \textbf{if} \,(\sstate.\pcsel \vdash \sass)$
%       \State $\qquad \qquad \textbf{then}$ \Return  \Call{Unification}{$\sstate$, $\jvec{\sqass}$}
%      \State $\qquad \qquad \textbf{else}$  \Return $\fail{\neg \sass}$
%\EndFunction
%\end{algorithmic}
%\end{algorithm}}

\begin{figure}
%\includegraphics[width=0.48\textwidth]{figures/algorithm.png}
\vspace*{-1cm}
\end{figure}

%\vspace*{-0.8cm}


\myparagraph{Formal Guarantees} Both our simplified $\unificationfun(\sstate, \pass)$ PDP, presented here, and its full version, given in the Appendix, satisfy the criteria outlined in \S\ref{subsec:sep:assertions}. 


\subsection{From Specifications to Symbolic Tests}\label{specs:to:symbolic:tests}

\jsil Logic specifications have the form $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$, where $\pass$ and $\qass$ are the 
pre- and postconditions of the procedure with identifier $\pid$ and formal parameters $\jvec{x}$. 
Each specification is associated with a return mode $\flag \in \{ \fnormal, \ferror \}$, indicating if the function
 returns normally or with an error. 
 %If it returns normally, then its return value can be accessed  via a dedicated variable 
% $\retvar$, and $\errvar$ otherwise. 
 Intuitively, a specification $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$ is 
valid for a given \jsil program $\prog$, if $\prog$ contains a procedure with identifier 
$\pid$ and ``whenever $\pid$ is executed in a state satisfying $P$, then, 
if it terminates, it does so in a state satisfying $Q$, with return mode~$\flag$''.
The formal definition is given below. 


\begin{definition}[Validity of \jsil Logic Specifications]
A \jsil logic specification $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$ is valid w.r.t.~a program 
$\prog$, written $\prog \satisfies \specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$, if and only if it holds that: 
$$
\begin{array}{l}
   (\jstate, \heap_f) \in \interpret{}{}(P) 
   \ \wedge \ 
    \abssemrule{\jstate \dunion \heap_f, \polish{\cs}, 0}{\jstate', \polish{\cs'}, i_{\flag'}}{\top}{\top}{\concrete} \\ \quad \
   \implies
      \flag' = \flag \ \wedge \ \exists \jstate'' \, . \, \jstate' = \jstate'' \dunion \heap_f
          \ \wedge \   (\jstate'', \heap_f) \in \interpret{}{}(Q) 
\end{array}
$$
\end{definition}

\pmax{Should that concrete transition have a star?}

\begin{figure}
{\footnotesize
$$
\begin{array}{lll}
\testify{}(\specsig{P}{\pid(\jvar_0, ..., \jvar_n)}{Q}{\flag}) \ \semeq                           &  \testify{\fnormal}(\pid, \svar_i|_{i=0}^n, Q) \ \semeq \\
%
\quad  \mathbf{let} \ \sstore =  [ \jvar_i \mapsto \svar_i|_{i=0}^n] \ \mathbf{in}        &  \quad \darkmath{\sf proc} \jsilmain () \{    \\
%
\quad  \mathbf{let} \ \sstate = \normaliser(\sstore(P)) \ \mathbf{in}                               &   \qquad 0_{\phantom{\sf nm}}: \jsilcall{\jvar}{\pid}{\svar_0, ..., \svar_n}{\errlab} \\
 %
\quad  \mathbf{let} \ Q' = \sstore(Q) \ \mathbf{in}                                                           &  \qquad \retlab \, : \sepassert(Q[\jvar/\retvar])  \\
 %
\quad  \mathbf{let} \ \proc = \testify{\flag}(\pid, \svar_i|_{i=0}^n, Q')  \ \mathbf{in}  &    \qquad \errlab \, \, \, : \jassert(\jfalse)   \\
 %
\qquad (\proc, \sstate)                                                                                                 &  \quad \}  
\end{array}
$$}
\vspace*{-0.4cm}
\caption{\small Symbolic Test Generation Algorithm~\label{fig:test:generation}}
\vspace*{-0.2cm}
\end{figure}

Given a \jsil program $\prog$ containing a procedure $\pid$ with specification {\small $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$}, 
our goal is to construct a symbolic test for checking if $\pid$ behaves as its specification mandates.
A symbolic test is a pair $(\proc, \sheap)$ consisting of a \jsil procedure with the code of the test and the initial 
symbolic heap on which to execute the test. 
%
Figure~\ref{fig:test:generation} presents the test generation procedure. 
%Intuitively, $\testify{}(\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag})$ 
%returns the symbolic test for $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$. 
The test generation function $\testifyfun{} \ $ is defined in terms 
of two auxiliary functions, $\testifyfun{\fnormal}$ and $\testifyfun{\ferror}$, for generating tests for $\fnormal$-mode and 
$\ferror$-mode specifications, respectively. 
For space reasons, we only present $\testifyfun{\fnormal}$ ($\testifyfun{\ferror}$ is equivalent). 
The test program $\prog'$, denoted by $\prog[\jsilmain \mapsto \proc]$, is obtained from the original program $\prog$ and the test procedure $\proc$ by replacing the 
$\jsilmain$ of $\prog$ with the new test procedure, $\proc$. 

\myparagraph{Formal Guarantees}
Theorem~\ref{teo:bug:finding:sl} states that if the symbolic execution of the 
test generated for $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$ finds a bug, then the specification 
is not~valid.

\begin{theorem}[Bug-finding for SL Specifications]\label{teo:bug:finding:sl}
$$
\begin{array}{l}
\testify{}(\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag})  = (\proc, \sstate) \, \wedge \\
\quad
  \prog[\jsilmain \mapsto \proc] :  \transabssemrule{\sstate, \csmain, 0}{-, -, -}{\top}{\bot}{\symbolic} \\ \quad \qquad 
    \implies  
         \prog \not\satisfies \specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}
\end{array}
$$
\noindent where  $\csmain = [ \jsilmain, -, -, -, - ]$.
\end{theorem}


\subsection{Lifting the results to JavaScript}

\javert specifications of JS functions are analogous to \jsil specifications of \jsil procedures.
%, and are of the form $\specsig{P_{\jssubscript}}{\pid(\jvec{x})}{Q_{\jssubscript}}{\flag}$. 
As for \jsil, a \javert~\cite{javert} specification $\specsig{P_{\jssubscript}}{\pid(\jvec{x})}{Q_{\jssubscript}}{\flag}$
is valid for a JavaScript program $\jstmt$, written $\jstmt \satisfies \specsig{P_{\jssubscript}}{\pid(\jvec{x})}{Q_{\jssubscript}}{\flag}$, 
if and only if $\jstmt$ contains a function literal with identifier $\pid$ and ``whenever $\pid$ is executed in a state satisfying $P_\jssubscript$, then, 
if it terminates, it does so in a state satisfying $Q_\jssubscript$, with return mode $\flag$''. 
%The assertion language used by \javert is very similar to the assertion language of \jsil and is described in detail in~\cite{javert}.
\javert comes with a proven correct compiler from \javert specifications to \jsil specifications, denoted by $\jsspeccomp$. 

\myparagraph{Testing \javert Specifications}
We generate symbolic tests from JavaScript programs and their \javert specifications in the following way. 
First, we convert the JavaScript program and its \javert specifications to a \jsil program with \jsil specifications, 
using \jstojsil and $\jsspeccomp$. Next, we generate a set of symbolic tests from the obtained 
\jsil program and \jsil specifications, as described in \S\ref{specs:to:symbolic:tests}. 
Finally, we run the generated \jsil symbolic tests using the \jsil symbolic semantics described on \S\ref{subsec:symb:semantics}. 
If \cosette finds a bug while running these tests, we will obtain a concrete counter-example triggering that bug.

\myparagraph{Formal Guarantees}
The correctness proof ensures that the verification of \jsil programs can be lifted to the verification of JavaScript programs.
%
More concretely, a \javert  specification $\specsig{P_{\jssubscript}}{\pid(\jvec{x})}{Q_{\jssubscript}}{\flag}$
is valid for a given JavaScript program $\jstmt$ if and only if the translated specification 
$\jsspeccomp(\specsig{P_{\jssubscript}}{\pid(\jvec{x})}{Q_{\jssubscript}}{\flag})$ is valid 
for the compilation of $\jstmt$ by a correct compiler $\compile$. 



%Put formally:  
%\begin{equation}
%   \jstmt \vDash  \specsig{P_{\jssuffix}}{\fid(\jvec{x})}{Q_{\jssuffix}}{\flag} 
%      \iff
%           \compile(\jstmt) \vDash \ltr(\specsig{P_{\jssuffix}}{\fid(\jvec{x})}{Q_{\jssuffix}}{\flag}).
%\end{equation}



%if and only if $\jstmt$ contains a function literal with identifier $\fid$ and ``whenever $\fid$ is executed in a state satisfying $P_\jssuffix$, then, 
%if it terminates, it does so in a state satisfying $Q_\jssuffix$, with return mode $\flag$''. The assertion language used by \javert is very similar to the assertion language of \jsil Logic and is described in detail in~\cite{javert}.
%There, the authors present 
%a compiler from \javert specifications to \jsil Logic specifications, denoted by $\ltr$, and prove the soundness 
%of that compiler, assuming a correct compiler $\compile$ from JavaScript to~\jsil.
%This theoretical result ensures that the verification of \jsil programs can be lifted to   the verification of JavaScript programs. More concretely, a \javert  specification $\specsig{P_{\jssuffix}}{\fid(\jvec{x})}{Q_{\jssuffix}}{\flag}$
%is valid for a given JavaScript program $\jstmt$ if and only if the translated specification 
%$\ltr(\specsig{P_{\jssuffix}}{\fid(\jvec{x})}{Q_{\jssuffix}}{\flag})$ is valid for the compilation 
%of $\jstmt$ by a correct compiler $\compile$. Put formally:  
%\begin{equation}
%   \jstmt \vDash  \specsig{P_{\jssuffix}}{\fid(\jvec{x})}{Q_{\jssuffix}}{\flag} 
%      \iff
%           \compile(\jstmt) \vDash \ltr(\specsig{P_{\jssuffix}}{\fid(\jvec{x})}{Q_{\jssuffix}}{\flag}).
%\end{equation}
%
%
%



