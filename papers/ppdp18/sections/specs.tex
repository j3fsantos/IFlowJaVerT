%!TEX root = ../main.tex

We show how to use \cosette for debugging \jsil code annotated with 
separation logic (SL) specifications. Tools that allow for SL-reasoning about
functional correctness properties in general, and those targeting 
JavaScript in particular, require the user to have substantial expertise 
and to go through a long and complex proof trace, whenever verification
is not successful. \cosette substantially simplifies this process by providing
concrete counter-models that invalidate the input specifications.

In \S\ref{subsec:sep:assertions}, we extend the 
 \jsil symbolic interpreter with a mechanism for asserting
SL-assertions. 
%
In \S\ref{subsec:fip}, we show how to implement this mechanism by giving 
a sound decision procedure for solving the frame inference problem (FIP)~\cite{}
in the context of symbolic execution.
%
Unlike verification tools, our emphasis is in the generation of counter-models 
for failing cases. 
%
Finally, in \S\ref{specs:to:symbolic:tests}, we present an algorithm  
for generating symbolic tests from SL-specifications, which guarantees 
that whenever a symbolic test fails, \cosette produces a concrete 
counter-model that invalidates the corresponding specification.

\vspace{-5pt}
\subsection{Symbolic Execution with SL-Assertions}\label{subsec:sep:assertions}

\jsil Logic assertions~\cite{javert}
provide a compositional way of describing \emph{partial} symbolic states. 
\jsil assertions include: boolean operations; the separating conjunction; 
and assertions for describing heaps. The $\lemp$ assertion describes 
an empty heap. The cell assertion, $(\lexpr_1,\lexpr_2) \pointsto \lexpr_3$,  describes an object 
at the location denoted by $\lexpr_1$ with a property denoted by $\lexpr_2$ that has the value 
denoted by $\lexpr_3$. The object domain assertion $\emptyfields{\lexpr_1}{\lexpr_2}$ states that the object at 
the location denoted by $\lexpr_1$ has no properties other than possibly those included in the
set denoted by $\lexpr_2$. The syntax of assertions is given below. 
We refer to assertions different from $- \sep -$ and $\lemp$ as \emph{simple assertions}
and use $\spass$ and $\sqass$ to range over them.

\vspace{2pt}
\begin{display}{\jsil Logic Assertions}
%
{\small
\begin{tabular}{l}
  %%%%
  $\lexpr \quad \ \triangleq \val \mid \jvar \mid \svar \mid \unoper\ \lexpr \mid \lexpr \binoper \lexpr \quad \quad \quad \quad \quad \quad \quad \ \ $   \text{ Logical Expressions} \\
  $\rass, \sass \ \triangleq \jtrue \mid \jfalse \mid  \neg \rass \mid \rass \land \sass \mid \rass \lor \sass  \mid \lexpr = \lexpr \mid \lexpr \leq \lexpr$  \quad \text{\hfill{Pure Asrts.}} \\
  $\pass, \qass \triangleq \sass \mid \lemp \mid (\lexpr, \lexpr)\pointsto \lexpr \mid \pass \sep \qass  \mid \emptyfields{\lexpr}{\lexpr} $ \quad \quad \quad \quad \ \  \text{\hfill Asrts.} \\
\end{tabular}}
\end{display}

\noindent Without loss of generality, we implicitly assume that different symbolic locations 
denote different concrete locations.\footnote{In order to express aliasing, the user has to write multiple assertions.}
 Furthermore, given a cell assertion $(\lexpr_1,\lexpr_2) \pointsto \lexpr_3$, we always assume 
 $\lexpr_1$ to be either a concrete location $\loc$ or a symbolic location $\sloc$. 
%
Unsurprisingly, every symbolic state can be thought of as an assertion. In particular, 
the symbolic state $\sstate = (\sheap, \sdom, \sstore, \pc)$ corresponds to the assertion: 
\begin{equation*}
{\small \begin{array}{l}
\big(\varoast_{(\sloc, \sexprp) \in \domain(\sheap)} (\sloc, \sexprp) \mapsto \sheap(\sloc, \sexprp)\big) 
  \sep \big(\varoast_{\sloc \in \domain(\sdom)} \, \emptyfields{\sloc}{\idom(\sloc)}\big)  \\
 %
 \qquad \sep \big(\bigwedge_{\jvar \in \domain(\sstore)} \, \jvar = \sstore(\jvar)\big) \sep \pc
\end{array}}
\end{equation*}

\noindent where $\varoast$ denotes the iterated separating conjunction~\cite{}. 
Analogously, every assertion can be trivially re-organised into a symbolic state: 
\dtag{1} cell assertions form the heap part of the state, 
\dtag{2} object domain assertions form the domain part,
\dtag{3} equalities involving program variables form the store, and 
\dtag{4} pure assertions form the path condition. 
Finally,  all the occurrences of program variables in the heap, domain, and path condition 
are replaced with their corresponding symbolic expressions given by the store. 
We use $\normaliser(\pass)$ to refer to the symbolic state corresponding 
to $\pass$. 
%
In the following, we use $\interpret{}{}(\sstate)$ for denoting the set 
$\{ (\jstate, \heap_f) \mid \exists \senv \, . \, (\jstate, \heap_f) \in \interpret{\symbconc}{\senv}(\sstate) \}$ 
and $\interpret{}{}(\pass)$ for denoting $\interpret{}{}(\normaliser(\pass))$. 

\myparagraph{Inductive Predicates}
\cosette does not support symbolic execution over inductive predicates, which are commonplace 
in SL-style specifications~\cite{smallf, berdine:aplas:2005}. 
As in~\cite{korat}, we deal with user-defined inductive predicates by \emph{unfolding} 
those predicates up to a fixed bound, given by the user. This unfolding mechanism 
is routine and is, therefore, omitted from the paper. 

\myparagraph{Asserting SL-Assertions}
We extend \jsil with a special construct, $\sepassert(P)$, for stating that 
the assertion $P$ must hold whenever that command is evaluated. 
The symbolic semantics is given below. 
\begin{mathpar}
\inferrule[\textsc{SL-Assert - True}]
  { 
     \ccmd{i}  = \sepassert(\pass)  \\\\
     %
     \unificationfun(\sstate, \pass) = \success{\subst, \sstate_f}
  }{
    \abssemrule{\sstate, \scs, i}{\sstate, \scs, i{+}1}{\top}{\top}{\symbolic}
}
\qquad
\inferrule[\textsc{SL-Assert - False}]
  { 
     \ccmd{i}  = \sepassert(\pass)  \\\\
     %
    \unificationfun(\sstate, \pass) = \fail{\pc_f}  \\\\ 
    %
     (\sstate.\pcsel \wedge \pc_f) \text{ SAT}
  }{
    \abssemrule{\sstate, \scs, i}{\sstate, \scs, i}{\top}{\bot}{\symbolic}
}
\end{mathpar}

\vspace{-3pt}
\noindent The rules make use of a partial decision procedure $\unificationfun(\sstate, \pass)$ for 
determining whether or not a given symbolic state $\sstate$ satisfies an assertion $P$, 
which is in general undecidable \cite{citemeplease}. More concretely, 
the decision procedure outputs: 
\dtag{1} $\success{\subst, \sstate_f}$ when it finds a substitution $\subst$ and 
a symbolic state frame $\sstate_f$ for which it holds that $\interpret{}{}(\sstate) \subseteq \interpret{}{}(\sstate_f \statecompose \normaliser(\subst(\pass)))$, 
where we use $\statecompose$ for the composition of two symbolic states, 
and \dtag{2} $\fail{\pc_f}$ when it finds a first order formula $\pc_f$ such that 
$\interpret{}{}(\sstate \, \wedge \, \pc_f) \cap \interpret{}{}(\pass) = \emptyset$. 
Note that every concrete state and heap frame in $\interpret{}{}(\sstate \, \wedge \, \pc_f)$ are counter models 
for $P$. By requiring that $(\sstate.\pcsel \, \wedge \, \pc_f)$ be satisfiable, 
the semantics only triggers an assertion failure when it finds a concrete witness for the failure ---
any instantiation of $(\sstate \, \wedge \, \pc_f)$. 



\subsection{Frame Inference Problem}\label{subsec:fip}

We describe a partial decision procedure, which we  
implement as part of the \jsil symbolic interpreter, for proving entailments 
between symbolic states \underline{and} finding counter 
models in case of failure.  
As it is customary~\cite{javert,jacobs2011verifast,sepwithsmt}, the decision procedure works by first using \emph{pattern-matching} 
on the spatial part of the symbolic state, and then discharging the pure part of the 
entailment to an external constraint solver (in our case, \rosette). 

\begin{table} 
{\small \begin{tabular}{@{}c@{}ccc@{}c@{}}\toprule
\emph{Argument} & & \textbf{IN}  & & \textbf{OUT}  \\
\cmidrule{1-1} \cmidrule{3-3} \cmidrule{5-5}

$\svar$                                                       & & $\{ \svar \}$                                                          & & $\{ \svar \}$    \\
$\jsillist{\lexpr_1, ..., \lexpr_n}$                     & & $\upin(\lexpr_1) \cup ... \cup \upin(\lexpr_n)$      & & $\upout(\lexpr_1) \cup ... \cup \upout(\lexpr_n)$ \\
$\lexpr_1 + \lexpr_2$                                    & & $\upin(\lexpr_1) \cup \upin(\lexpr_2)$                  & & $\emptyset$ \\
$\cdots$ & & $\cdots$ & & $\cdots$ \\[1pt]
%%
$(\lexpr_1, \lexpr_2)\pointsto \lexpr_3$   & & $\upin(\lexpr_1) \cup \upin(\lexpr_2)$ & & $\upout(\lexpr_3)$  \\
%
$\emptyfields{\lexpr_1}{\lexpr_2}$           &  & $\upin(\lexpr_1) \cup \upin(\lexpr_2)$ & & $\emptyset$ \\
%
$\lexpr_1 = \lexpr_2$                               & & $\upin(\lexpr_1)$/$\upin(\lexpr_2)$      & & $\upout(\lexpr_2)$/$\upout(\lexpr_1)$ \\
%
$\sass$                                                    & & $\fv(\sass)$                                           & & $\emptyset$ \\
\bottomrule
\end{tabular}}
\caption{\emph{in} and \emph{out} sets for assertions and logical expressions}
\vspace{-25pt}
\end{table}

\myparagraph{Unification Plan}
When solving $\unificationfun(\sstate, \pass)$, the symbolic variables of $\pass$ that are not 
in $\sstate$ are assumed to be existentially quantified. 
In order to find the appropriate bindings for these variables, we 
introduce the notion of \emph{unification plan} (Definition~\ref{def:up}).
Informally, a unification plan is an ordering of the simple assertions in $\pass$ that 
guarantees that the unification algorithm does not have to backtrack at unification~time. 

We define for each assertion an \emph{in} set and an \emph{out} set (these 
sets are reminiscent of the predicate parameter modes in~\cite{nguyen:vmcai:2008}).
Intuitively, the variables in the \emph{out} set of an assertion are those that can be computed 
using the variables in the \emph{in} set, together with the current state. 
For instance, given the assertion $(\svar_1, \svar_2) \pointsto \svar_3$, if we know the bindings
for $\svar_1$ and $\svar_2$, we can compute the bindings for $\svar_3$, given 
the current symbolic state. 
%
Analogously, we define \emph{in} and \emph{out} sets for logical expressions. 
The variables in the \emph{out} set of a logical expression are those that can be computed
given the value of the whole expression, whereas the variables in the \emph{in} set 
are those that need to be known for us to compute the value of the whole expression.  
Finally, the definition of unification plan is given below. 

\begin{definition}[Unification Plan]\label{def:up}
A \emph{unification plan} $\up$ is a sequence of simple assertions $\sqass_i \mid_{i=0}^n$ such that: 
$$
 \forall 0 \leq i \leq n \, . \, \upin(\sqass_i) \subseteq \big(\cup_{j = 0}^{i-1} \upout(\sqass_j)\big) \cup \upin_0
$$
where $\upin_0$ is the set of \underline{non}-existentially quantified logical variables. 
\end{definition}

\vspace{-3pt}
\noindent It is not always possible to generate a unification plan for an SL-assertion. We only 
consider assertions that admit a unification plan. 


\myparagraph{Unification Algorithm}
Given a symbolic state $\sstate$ and an assertion $\pass$, $\unificationfun(\sstate, \pass)$: 
\dtag{1} replaces all the occurrences of program variables in $\pass$ with their bindings 
given by $\sstate.\stosel$;
\dtag{2} computes an initial substitution $\subst_0$ mapping all the non-existentially quantified symbolic 
variables in $\pass$ to themselves (put formally: $\subst_0 = \identity_{\fv(\sstate) \cap \fv(\pass)}$); 
\dtag{3} creates a unification plan $\up$ for $\pass$; and, 
\dtag{4} calls Algorithm~\ref{fip:symb:states}. 
%
Algorithm~\ref{fip:symb:states} makes use of the following auxiliary functions: 

\begin{description}
\setlength{\itemsep}{0.2em}
  \item[FIP GetCell.] In case of success, $\GetCellV{\sstate, \sloc, \sexprp}$ returns 
          a pair consisting of the symbolic expression $\sexprv$ associated with 
          $(\sloc, \sexprp)$ in the heap component of $\sstate$ \underline{and} 
          the state obtained by removing that cell from $\sstate.\hpsel$.
  
  \item[FIP GetDomain.] In case of success, $\GetDomainV{\sstate, \sloc}$ returns 
          a pair consisting of the symbolic expression $\sexprv_d$ denoting the domain 
          of the object at location $\sloc$ in $\sstate$ \underline{and} 
          the state obtained by removing all the negative resource associated with 
          $\sloc$ from $\sstate$.  
  
  \item[Expression Unification.]  In case of success, $\unifylexpr(\sexprv, \sexprv', \subst, \pc)$ 
          returns a substitution $\subst'$ that extends $\subst$ such that $\pc \vdash \sexprv = \subst'(\sexprv')$. 
\end{description}
In case of failure, all auxiliary functions return a constraint $\pc_f$ under which 
the unification is guaranteed not to be possible. 
Below, we give selected rules for $\GetCellV{\sstate, \sloc, \sexprp}$ and $\GetDomainV{\sstate, \sloc}$.  

{\small \begin{algorithm}[t!]
\algblock[Name]{match}{end}
\caption{Frame Inference for Symbolic States}\label{fip:symb:states}
\begin{algorithmic}[1]
\Function{Unification}{$\sstate$, $\up$, $\subst$}
    \State $\textbf{match}$ $\up$ $\textbf{with}$
    \State $\mid~\lstemp:$ \Return $\success{\subst, \sstate}$
   % Cell ASS
    \State $\mid~(\sloc, \sexprp) \pointsto \sexprv \lstcons \up' :$ 
    \State $\qquad \textbf{match} \ \GetCellV{\sstate, \subst(\sloc), \subst(\sexprp)}$ $\textbf{with}$
    \State $\qquad \mid~\success{\sexprv', \sstate'}:$
    \State $\qquad \qquad \textbf{match} \ \unifylexpr(\sexprv, \sexprv', \subst, \sstate.\pcsel)$ $\textbf{with}$
     \State $\qquad \qquad \mid~ \success{\subst'}:$ \Return \Call{Unification}{$\sstate'$, $\up'$, $\subst'$}
      \State $\qquad \qquad \mid~ \fail{\pc_f} \ \, :$ \Return $\fail{\pc_f}$
      \State $\qquad \mid~\fail{\pc_f}:$ \Return $\fail{\pc_f}$
      % EF ASS
     \State $\mid~\emptyfields{\sloc}{\sexprv} \lstcons \up' :$  
       \State $\qquad \textbf{match} \ \GetDomainV{\sstate, \subst(\sloc)}$ $\textbf{with}$
       \State $\qquad \mid~\success{\sexprv', \sstate'}:$
         \State $\qquad \qquad \textbf{match} \ \unifylexpr(\sexprv, \sexprv', \subst, \sstate.\pcsel)$ $\textbf{with}$
       \State $\qquad \qquad \mid~ \success{\subst'}:$ \Return \Call{Unification}{$\sstate'$, $\up'$, $\subst'$}
       \State $\qquad \qquad \mid~ \fail{\pc_f} \ \, :$ \Return $\fail{\pc_f}$
       \State $\qquad \mid~\fail{\pc_f}:$ \Return $\fail{\pc_f}$
     % Logical Equality  
     \State $\mid~(\sexprv = \sexprv') \lstcons \up' :$  
        \State $\qquad \textbf{match} \ \unifylexpr(\sexprv, \sexprv', \subst, \sstate.\pcsel)$ $\textbf{with}$
         \State $\qquad \qquad \mid~ \success{\subst'}:$ \Return \Call{Unification}{$\sstate$, $\up'$, $\subst'$}
       \State $\qquad \qquad \mid~ \fail{\pc_f} \ \, :$ \Return $\fail{\pc_f}$
     % OTHER PURE ASS
     \State $\mid~\sass \lstcons \up' :$   
      \State $\qquad \textbf{if} \,(\sstate.\pcsel \vdash \subst(\sass))$
       \State $\qquad \qquad \textbf{then}$ \Return  \Call{Unification}{$\sstate$, $\up'$, $\subst$}
      \State $\qquad \qquad \textbf{else}$  \Return $\fail{\subst(\sass)}$
\EndFunction
\end{algorithmic}
\end{algorithm}}


\vspace{2pt}
\begin{display}{Selected FIP Rules}
\text{
{\scriptsize
\begin{mathpar} 
  \inferrule[\textsc{GetDomain}]
   { 
       \sheap = \sheap' \, \uplus \, \big((\sloc, \sexprp_i) \mapsto \sexprv_i \big)\mid_{i = 0}^m  
         \quad 
          (\sloc,-) \notin \domain (\sheap')  
         \quad
        \forall_{0 \leq i \leq n} \,  \sexprv_i \neq \none 
         \quad
           \forall_{n < i \leq m} \, \sexprv_i = \none
           \\\\ 
           \sexprv =  \{ \sexprp_i \mid_{i = n{+}1}^m\}
           \and
           \sheap'' = (\sloc, \sexprp_i) \mapsto \sexprv_i  \mid_{i=0}^n
           \and
           \sdom = \sdom' \dunion (\sloc \mapsto \sexprv')
   }{  \GetDomainV{(\sheap, \sdom, \sstore, \pc), \sloc} \semeq \success{(\sheap' \, \uplus \,  \sheap'', \sdom', \sstore, \pc), \sexprv' \backslash \sexprv}}
  \\
      \inferrule[\textsc{GetCell - Found}]
   { 
      (\sheap, \sdom, \sstore, \pc) = \sstate    
       \quad
       \sheap = \sheap' \, \uplus \, (\sloc, \sexprp') \mapsto \sexprv 
       \\\\
       {\color{blue} \pc \vdash (\sexprp = \sexprp')}
       \quad
       \sstate' = (\sheap', \sdom, \sstore, \pc)
   }{  \GetCellV{\sstate, \sloc, \sexprp} \semeq \success{\sstate', \sexprv}}
\quad
     \inferrule[\textsc{GetCell - Not Found}]
   { 
     (\sheap, \sdom, \sstore, \pc) = \sstate  
     \quad 
        { \color{blue} \pc \vdash \sexprp \not\in \sdom(\sloc)}
        \\\\
        \sstate' = (\sheap, \sdom[\sloc \mapsto \sdom(\sloc) \cup \jsilset{\sexprp}], \sstore,  \pc)
   }{  \GetCellV{\sstate, \sloc, \sexprp} \semeq \success{\sstate', \none}}
\\
     \inferrule[\textsc{GetCell - Fail with Domain Info}]
   { 
       \sheap = \sheap'' \, \uplus \, \big((\sloc, \sexprp_i) \mapsto \sexprv_i \big)\mid_{i = 0}^m
      \qquad
       (\sloc,-) \notin \domain (\sheap'')
       \qquad
        { \color{blue} \pc \not\vdash \sexprp \not\in \sdom(\sloc)}
        \qquad
          { \color{blue} \pc \not\vdash \sexprp = \sexprp_i \mid_{i=0}^m}
   }{  \GetCellV{(\sheap, \sdom, \sstore, \pc), \sloc, \sexprp} \semeq \fail{{\color{red} (\sexprp \in \sdom(\sloc)) \, \wedge \, \wedge_{i=0}^m (\sexprp_i \neq \sexprp)}}}
 \\
 \\
     \inferrule[\textsc{GetCell - Fail without Domain Info}]
   { 
       \sheap = \sheap'' \, \uplus \, \big((\sloc, \sexprp_i) \mapsto \sexprv_i \big)\mid_{i = 0}^m
      \qquad
       (\sloc,-) \notin \domain (\sheap'')
       \qquad
       \sloc \not\in \domain(\sdom)
        \qquad
          { \color{blue} \pc \not\vdash \sexprp = \sexprp_i \mid_{i=0}^m}
   }{  \GetCellV{(\sheap, \sdom, \sstore, \pc), \sloc, \sexprp} \semeq \fail{{\color{red} (\wedge_{i=0}^m (\sexprp_i \neq \sexprp)}}}
 \end{mathpar}}}
 \end{display}

The rules are analogous to the rules in \S\ref{subsec:symb:semantics} except that they return a new symbolic state 
from which the matched resource is removed and their corresponding constraints are lifted to the premise. 

\myparagraph{Formal Guarantees}
Theorem~\ref{teo:fip:soundness} states that the unification algorithm is sound: 
given an SL-assertion $\pass$ and a symbolic state $\sstate$, if
$\unificationfun(\sstate, \pass) = \success{\subst, \sstate_f}$, then there is a symbolic state
$\sstate'$ such that $\sstate = \sstate' \statecompose \sstate_f$ and $\sstate'$ satisfies $\pass$. 
The bug-finding theorem, Theorem~\ref{teo:fip:bugfinding}, is more subtle. It states that, 
in case of failure, to find a counter-model for $\pass$, one has to pick a concretisation of the 
symbolic state that is consistent with the failing constraint generated by the unification algorithm.


\begin{theorem}[Soundness of FIP]\label{teo:fip:soundness}
$$
\begin{array}{l}
	\unificationfun(\sstate, \pass) = \success{\subst, \sstate_f}
        \implies 
        \interpret{}{}(\sstate) \subseteq \interpret{}{}(\sstate_f \statecompose \normaliser(\subst(\pass)))
\end{array}
$$ 
\end{theorem}

\begin{theorem}[Bug-finding for SL]\label{teo:fip:bugfinding}
$$
\begin{array}{l}
\unificationfun(\sstate, \pass) = \fail{\pc_f} 
   \implies
   \interpret{}{}(\sstate \, \wedge \, \pc_f) \cap \interpret{}{}(\pass) = \emptyset
\end{array}
$$ 
\end{theorem}



\subsection{From Specifications to Symbolic Tests}\label{specs:to:symbolic:tests}

\jsil Logic specifications have the form $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$, where $\pass$ and $\qass$ are the 
pre- and postconditions of the procedure with identifier $\pid$ and formal parameters $\jvec{x}$. 
Each specification is associated with a return mode $\flag \in \{ \fnormal, \ferror \}$, indicating if the function
 returns normally or with an error. 
 %If it returns normally, then its return value can be accessed  via a dedicated variable 
% $\retvar$, and $\errvar$ otherwise. 
 Intuitively, a specification $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$ is 
valid for a given \jsil program $\prog$, if $\prog$ contains a procedure with identifier 
$\pid$ and ``whenever $\pid$ is executed in a state satisfying $P$, then, 
if it terminates, it does so in a state satisfying $Q$, with return mode $\flag$''.
The formal definition is given below. 


\begin{definition}[Validity of \jsil Logic Specifications]
A \jsil logic specification $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$ is valid with respect to a program 
$\prog$, written $\prog \satisfies \specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$, if and only if, for all logical 
contexts $(\iheap, \store, \senv)$, heaps $\heap_f$, stores $\store_f$, and flags $\flag'$, it holds that: 
$$
\begin{array}{l}
   (\jstate, \heap_f, \cs) \in \interpret{}{}(P) 
   \ \wedge \ 
    \abssemrule{\jstate \dunion \heap_f, \cs, 0}{\jstate', \cs', i_{\flag'}}{\top}{\top}{\concrete} \\ \quad \
   \implies
      \flag' = \flag \ \wedge \ \exists \jstate'' \, . \, \jstate' = \jstate'' \dunion \heap_f
          \ \wedge \   (\jstate'', \heap_f, \cs') \in \interpret{}{}(Q) 
\end{array}
$$
\end{definition}

\begin{figure}
{\small
$$
\begin{array}{lll}
\testify{}(\specsig{P}{\pid(\jvar_1, ..., \jvar_n)}{Q}{\flag}) \ \semeq                           &  \testify{\fnormal}(\pid, \svar_i\mid_{i=0}^n, Q) \ \semeq \\
%
\ \  \mathbf{let} \ \sstore =  [ \jvar_i \mapsto \svar_i \mid_{i=0}^n] \ \mathbf{in}        &  \ \  \darkmath{\sf proc} \jsilmain () \{    \\
%
 \ \  \mathbf{let} \ \sstate = \normaliser(\sstore(P)) \ \mathbf{in}                               &   \ \ \ \ 0_{\phantom{\sf nm}}: \jsilcall{\jvar}{\pid}{\svar_0, ..., \svar_n}{\errlab} \\
 %
\ \  \mathbf{let} \ Q' = \sstore(Q) \ \mathbf{in}                                                           &    \ \ \ \ \retlab \, : \sepassert(Q[\jvar/\retvar])  \\
 %
 \ \  \mathbf{let} \ \proc = \testify{\flag}(\pid, \svar_i\mid_{i=0}^n, Q')  \ \mathbf{in}  &    \ \ \ \ \errlab \, \, \, : \jassert(\jfalse)   \\
 %
 \ \ \ \ (\proc, \sstate)                                                                                                 &    \ \ \}  
\end{array}
$$}
\vspace*{-0.2cm}
\caption{Symbolic Test Generation Algorithm~\label{fig:test:generation}}
\vspace*{-0.2cm}
\end{figure}

Given a \jsil program $\prog$ containing a procedure $\pid$ with spec {\small $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$}, 
our goal is to construct a symbolic test for checking whether or not $\pid$ behaves as its specification mandates.
A symbolic test is a pair $(\proc, \sheap)$ consisting of a \jsil procedure with the code of the test and the initial 
symbolic heap on which to execute the test. 
%
Figure~\ref{fig:test:generation} presents the test generation procedure. Intuitively, $\testify{}(\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag})$ 
returns the symbolic test for $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$. The test generation function $\testifyfun{} \ $ is defined in terms 
of two auxiliary functions, $\testifyfun{\fnormal}$ and $\testifyfun{\ferror}$, for generating tests for $\fnormal$-mode and 
$\ferror$-mode specifications, respectively. 
For space reasons, we only present $\testifyfun{\fnormal}$, $\testifyfun{\ferror}$ is equivalent. 
The test program $\prog'$, denoted by $\prog[\jsilmain \mapsto \proc]$, is obtained from the original program $\prog$ and the test procedure $\proc$ by replacing the 
$\jsilmain$ of $\prog$ with the new test procedure, $\proc$. 

Finally, Theorem~\ref{teo:bug:finding:sl} states that if the symbolic execution of the 
test generated for $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$ finds a bug, then the specification 
is not~valid.

\begin{theorem}[Bug-finding for SL Specifications]\label{teo:bug:finding:sl}
$$
\begin{array}{l}
\testify{}(\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag})  = (\proc, \sstate) \, \wedge \, 
  \prog' :  \transabssemrule{\sstate, \csmain, 0}{-}{\top}{\bot}{\symbolic} \\ \quad \quad 
    \implies  
         \prog \not\satisfies \specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}
\end{array}
$$
\noindent where:  $\csmain = [ (\jsilmain, -, -, -) ]$ 
and $\prog' = \prog[\jsilmain \mapsto \proc]$.
\end{theorem}



