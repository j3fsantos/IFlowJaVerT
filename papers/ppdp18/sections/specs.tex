%!TEX root = ../main.tex

\pmax{Pull up the messages, mention JS.}

\noindent We show how to use \cosette for debugging \jsil code annotated with 
separation logic (SL) specifications. Tools that support SL-reasoning about
functional correctness properties of programs often require of the user to 
analyse long, complex proof traces whenever
verification fails. 
\cosette substantially simplifies this process by providing
concrete counter-models that invalidate the input specification. 


We extend the 
 \jsil symbolic interpreter with a mechanism for asserting
SL-assertions (\S\ref{subsec:sep:assertions}) and show how to 
implement this mechanism by giving a sound decision procedure 
for solving the frame inference problem (FIP)~\cite{}
in the context of symbolic execution (\S\ref{subsec:fip}).
%
%Unlike verification tools, our emphasis is in the generation of counter-models for failing cases. 
%
We present an algorithm  
for generating symbolic tests from SL-specifications, which guarantees 
that whenever a symbolic test fails, \cosette produces a concrete 
counter-model that invalidates the corresponding specification (\S\ref{specs:to:symbolic:tests}).

\vspace{-5pt}
\subsection{Symbolic Execution with SL-Assertions}\label{subsec:sep:assertions}

\jsil Logic assertions~\cite{javert} provide a way of describing \emph{partial} symbolic states.
They are built on top of \jsil expressions, and include boolean operations; the separating conjunction; 
and assertions for describing heaps. The $\lemp$ assertion describes 
an empty heap. The cell assertion, $(\jsilexpr_1,\jsilexpr_2) \pointsto \jsilexpr_3$,  describes an object 
at the location denoted by $\jsilexpr_1$ with a property denoted by $\jsilexpr_2$ that has the value 
denoted by $\jsilexpr_3$. The object domain assertion $\emptyfields{\jsilexpr_1}{\jsilexpr_2}$ states that the object at 
the location denoted by $\jsilexpr_1$ has no properties other than possibly those included in the
set denoted by $\jsilexpr_2$. %\pmaxinline{Mention sth about Es being the same.} %The syntax of assertions is given below. 
%We refer to assertions different from $- \sep -$ and $\lemp$ as \emph{simple assertions}
%and use $\spass$ and $\sqass$ to range over them.

\vspace{2pt}
\begin{display}{\jsil Logic Assertions}
%
{\small
\begin{tabular}{r@{\ }c@{\ }lr}
  %%%%
  %$\lexpr$ & $\triangleq$ & $\val \mid \jvar \mid \svar \mid \unoper\ \lexpr \mid \lexpr \binoper \lexpr$ & Logical Exprs. \\
  $\rass, \sass$ & $\triangleq$ & $\jtrue \mid \jfalse \mid  \neg \rass \mid \rass \land \sass \mid \rass \lor \sass \mid \lexpr = \jsilexpr \mid \jsilexpr \leq \jsilexpr$ & Pure Asrts. \\
  $\pass, \qass$ & $\triangleq$ & $\sass \mid \lemp \mid (\jsilexpr, \jsilexpr)\pointsto \jsilexpr \mid \pass \sep \qass  \mid \emptyfields{\jsilexpr}{\jsilexpr}$ & Asrts. \\
\end{tabular}}
\end{display}

\noindent Without loss of generality, we implicitly assume that different symbolic locations 
denote different concrete locations.\footnote{To express aliasing, the user has to write multiple assertions.}
 Furthermore, given a cell assertion $(\jsilexpr,\jsilexpr) \pointsto \jsilexpr$, we always assume 
 $\lexpr_1$ to be either a concrete location $\loc$ or a symbolic location $\sloc$. 
%
Note that 
a symbolic state $\sstate = (\sheap, \sdom, \sstore, \pc)$ corresponds to the assertion 
\begin{equation*}
{\small \begin{array}{l}
\big(\varoast_{(\sloc, \sexprp) \in \domain(\sheap)} (\sloc, \sexprp) \mapsto \sheap(\sloc, \sexprp)\big) 
  \sep \big(\varoast_{\sloc \in \domain(\sdom)} \, \emptyfields{\sloc}{\idom(\sloc)}\big)  \\
 %
 \qquad \sep \big(\bigwedge_{\jvar \in \domain(\sstore)} \, \jvar = \sstore(\jvar)\big) \sep \pc
\end{array}}
\end{equation*}

\noindent where $\varoast$ denotes the iterated separating conjunction~\cite{citeme}. 
Analogously, an assertion can be normalised into a symbolic state: 
 cell assertions form the heap; 
object domain assertions form the domain table;
 equalities involving program variables form the store; and 
 pure assertions form the path condition. 
Finally,  all occurrences of program variables in the heap, domain table, and path condition 
are replaced with their corresponding symbolic expressions from the store. 
We refer to the normalised symbolic state corresponding 
to $\pass$ by $\normaliser(\pass)$. 
%
We also use $\interpret{}{}(\sstate)$ for denoting the set 
$\{ (\jstate, \heap_f) \mid \exists \senv \, . \, (\jstate, \heap_f) \in \interpret{\symbconc}{\senv}(\sstate) \}$ 
and $\interpret{}{}(\pass)$ for denoting $\interpret{}{}(\normaliser(\pass))$. 

\myparagraph{Inductive Predicates}
\cosette does not support symbolic execution over inductive predicates, which are commonplace 
in SL-style specifications~\cite{smallf, berdine:aplas:2005}. 
As in~\cite{korat}, we deal with user-defined inductive predicates by \emph{unfolding} 
those predicates up to a fixed, user-defined bound. We omit this unfolding mechanism 
as it is routine. 

\myparagraph{Asserting SL-Assertions}
We extend \jsil commands with a special construct, $\sepassert(P)$, for stating that 
 the SL-assertion $P$ must hold whenever that command is evaluated. 
The corresponding symbolic semantics rules are given below. 

\vspace*{-0.2cm}
{\footnotesize
\begin{mathpar}
\inferrule[\textsc{SL-Assert - True}]
  { 
     \ccmd{i}  = \sepassert(\pass)  \\\\
     %
     \unificationfun(\sstate, \pass) = \success{\subst, \sstate_f}
  }{
    \abssemrule{\sstate, \scs, i}{\sstate, \scs, i{+}1}{\top}{\top}{\symbolic}
}
\qquad
\inferrule[\textsc{SL-Assert - False}]
  { 
     \ccmd{i}  = \sepassert(\pass)  \\\\
     %
    \unificationfun(\sstate, \pass) = \fail{\pc_f}  \quad
    %
     (\sstate.\pcsel \wedge \pc_f) \text{ SAT}
  }{
    \abssemrule{\sstate, \scs, i}{\sstate, \scs, i}{\top}{\bot}{\symbolic}
}
\end{mathpar}}

\vspace*{-0.2cm}
\noindent The rules use a partial decision procedure $\unificationfun(\sstate, \pass)$, for 
determining if a given symbolic state $\sstate$ satisfies an assertion $P$, 
which is undecidable in general \cite{citemeplease}. More concretely, 
the decision procedure outputs: 
 $\success{\subst, \sstate_f}$ when it finds a substitution $\subst$ and 
a symbolic state frame $\sstate_f$ such that $\interpret{}{}(\sstate) \subseteq \interpret{}{}(\sstate_f \statecompose \normaliser(\subst(\pass)))$ holds;\footnote{ 
We use $\statecompose$ for the composition of two symbolic states.}
and $\fail{\pc_f}$ when it finds a first-order formula $\pc_f$, such that 
$\interpret{}{}(\sstate \, \wedge \, \pc_f) \cap \interpret{}{}(\pass) = \emptyset$. 
Note that every concrete state and heap frame in $\interpret{}{}(\sstate \, \wedge \, \pc_f)$ are counter-models 
for $P$. By requiring that $(\sstate.\pcsel \, \wedge \, \pc_f)$ is satisfiable, 
the semantics only triggers an assertion failure when it finds a concrete witness for the failure---any instantiation of $(\sstate \, \wedge \, \pc_f)$. \pmaxinline{Make clearer.}

\subsection{The Frame Inference Problem}\label{subsec:fip}

{\footnotesize \begin{algorithm}[t!]
\algblock[Name]{match}{end}
\caption{Frame Inference for Symbolic States}\label{fip:symb:states}
\begin{algorithmic}[1]
\Function{Unification}{$\sstate$, $\jvec{\spass}$}
    \State $\textbf{match}$ $\jvec{\spass}$ $\textbf{with}$
    \State $\mid~\lstemp:$ \Return $\success{\sstate}$
   % Cell ASS
    \State $\mid~(\sloc, \sexprp) \pointsto \sexprv \lstcons \jvec{\sqass} :$ 
    \State $\qquad \textbf{match} \ \GetCellV{\sstate, \sloc, \sexprp}$ $\textbf{with}$
    \State $\qquad \mid~\success{\sexprv', \sstate'}:$ $\textbf{if} \,(\sstate.\pcsel \vdash \sexprv = \sexprv')$
     \State $\qquad \qquad \qquad ~  \textbf{then}$ \Return  \Call{Unification}{$\sstate'$, $\jvec{\sqass}$}
     \State $\qquad \qquad \qquad ~  \textbf{else}$ \Return $\fail{\sexprv \neq \sexprv'}$
      \State $\qquad \mid~\fail{\pc_f}:$ \Return $\fail{\pc_f}$
      % EF ASS
     \State $\mid~\emptyfields{\sloc}{\sexprv} \lstcons \jvec{\sqass} :$  
       \State $\qquad \textbf{match} \ \GetDomainV{\sstate, \sloc}$ $\textbf{with}$
       \State $\qquad \mid~\success{\sexprv', \sstate'}:$ $\textbf{if} \,(\sstate.\pcsel \vdash \sexprv \backslash \sexprv' = \{ \sexprp_1, ..., \sexprp_n \})$
        \State $\qquad \qquad \qquad ~  \textbf{then}$ \Return \Call{Unification}{$\sstate' \dunion (\sloc, \sexprp_i) \pointsto \none \mid_{i = 1}^n$, $\jvec{\sqass}$}
       \State $\qquad \qquad \qquad ~  \textbf{else}$ \Return $\fail{\sexprv' \not\subseteq \sexprv }$
       \State $\qquad \mid~\fail{\pc_f}:$ \Return $\fail{\pc_f}$
     % OTHER PURE ASS
     \State $\mid~\sass \lstcons \jvec{\sqass} :$  $ \textbf{if} \,(\sstate.\pcsel \vdash \sass)$
       \State $\qquad \qquad \textbf{then}$ \Return  \Call{Unification}{$\sstate$, $\jvec{\sqass}$}
      \State $\qquad \qquad \textbf{else}$  \Return $\fail{\neg \sass}$
\EndFunction
\end{algorithmic}
\end{algorithm}}

We describe a partial decision procedure, which we  
implement as part of the \jsil symbolic interpreter, for proving entailments 
between symbolic states \underline{and} finding counter 
models in case of failure.  
As it is customary~\cite{javert,jacobs2011verifast,sepwithsmt}, the decision procedure works by first using \emph{pattern-matching} 
on the spatial part of the symbolic state, and then discharging the pure part of the 
entailment to an external constraint solver (in our case, \rosette). 

When solving $\unificationfun(\sstate, \pass)$, the symbolic variables of $\pass$ that are not 
in $\sstate$ are assumed to be existentially quantified. 
As in~\cite{nguyen:vmcai:2008}, we make 
use of a topological ordering of the simple assertions in $\pass$ to find the appropriate bindings 
for existentially quantified variables. Here, for lack of space, we describe the frame inference 
algorithm for the setting in which there are no existentially quantified variables. 
The full version of the algorithm is given in the appendix.  

Given a symbolic state $\sstate$ and an assertion $\pass$, $\unificationfun(\sstate, \pass)$ 
 replaces all occurrences of program variables in $\pass$ with their bindings 
given by $\sstate.\stosel$ and then calls Algorithm~\ref{fip:symb:states} 
on a list containing all the simple assertions in $\pass$. The algorithm makes use of the
functions: 

\begin{description}
\setlength{\itemsep}{0.2em}
  \item[FIP GetCell.] In case of success, $\GetCellV{\sstate, \sloc, \sexprp}$ returns 
          the symbolic expression $\sexprv$ associated with 
          $(\sloc, \sexprp)$ in the heap component of $\sstate$ \underline{and} 
          the state obtained by removing that cell from $\sstate.\hpsel$.
  
  \item[FIP GetDomain.] In case of success, $\GetDomainV{\sstate, \sloc}$ returns 
          the symbolic expression $\sexprv_d$, denoting the potential domain 
          of the object at location $\sloc$ in $\sstate$, \underline{and} 
          the state obtained by removing all the negative resource associated with 
          $\sloc$ from $\sstate$.  
%  
%  \item[Expression Unification.]  In case of success, $\unifylexpr(\sexprv, \sexprv', \subst, \pc)$ 
%          returns a substitution $\subst'$ that extends $\subst$ such that $\pc \vdash \sexprv = \subst'(\sexprv')$. 
\end{description}


Algorithm~\ref{fip:symb:states} has four cases: 
\begin{itemize}
   \item $\jvec{\spass}=\lstemp$ --- there is nothing left to unify; the algorithm 
            returns the current symbolic state, which constitutes the frame. 
   
   \item $\jvec{\spass} = (\sloc, \sexprp) \pointsto \sexprv \lstcons \jvec{\sqass}$ ---
            the algorithm uses $\GetCellVFun$ to obtain the symbolic value 
            $\sexprv'$ associated with $(\sloc, \sexprp)$ in the current symbolic state and
            checks that $\sexprv' = \sexprv$ under the current path condition. 
            If the entailment holds, the unification proceeds. If not, the algorithm generates 
            the \emph{failing constraint} $\sexprv' \neq \sexprv$. 
  
   \item $\emptyfields{\sloc}{\sexprv} \lstcons \jvec{\sqass}$ ---
            the algorithm uses $\GetDomainVFun$ to obtain the domain $\sexprv'$
            of $\sloc$ in the current symbolic state and 
            checks that $\sexprv' \subseteq \sexprv$ under the current path condition. 
            \polish{
              For instance, 
              the assertion $\emptyfields{\sloc}{\jsilset{p_1, p_2}}$ states that $\sloc$ has \emph{at most}
              the properties $p_1$ and $p_2$. It might only have one of them, or none at all. 
              But it cannot have more.
            }
            If the entailment holds, the algorithm extends the current symbolic state with the negative 
            resource in $\sloc$ not captured by $\emptyfields{\sloc}{\sexprv}$ and the unification proceeds. 
            If not, the algorithm generates the \emph{failing constraint} $\sexprv' \not\subseteq \sexprv$. 
            
   \item $\jvec{\spass} = \sass \lstcons \jvec{\sqass}$ --- 
            the algorithm checks that $\sass$ is entailed by the current path condition. 
             If it is, the unification proceeds. If not, the algorithm generates 
             the \emph{failing constraint} $\neg \sass$. 
\end{itemize}


%\vspace*{-0.8cm}
We give selected rules for $\GetCellV{\sstate, \sloc, \sexprp}$ and $\GetDomainV{\sstate, \sloc}$. 
There rules are analogous to those in \S\ref{subsec:symb:semantics}, except that: \dtag{1} they return a new symbolic state 
from which the matched resource is removed and \dtag{2} their corresponding constraints are lifted to the premise (highlighted in blue). 
Also, in case of failure, all auxiliary functions return a constraint $\pc_f$ under which the inspected resource is guaranteed not 
to exist (highlighted in red). 


\vspace{2pt}
\begin{display}{Selected FIP Rules}
\text{
{\scriptsize
\begin{mathpar} 
  \inferrule[\textsc{GetDomain}]
   { 
       \sheap = \sheap' \, \uplus \, \big((\sloc, \sexprp_i) \mapsto \sexprv_i \big)\mid_{i = 0}^m  
         \quad 
          (\sloc,-) \notin \domain (\sheap')  
         \quad
        \forall_{0 \leq i \leq n} \,  \sexprv_i \neq \none 
         \quad
           \forall_{n < i \leq m} \, \sexprv_i = \none
           \\\\ 
           \sexprv =  \{ \sexprp_i \mid_{i = n{+}1}^m\}
           \and
           \sheap'' = (\sloc, \sexprp_i) \mapsto \sexprv_i  \mid_{i=0}^n
           \and
           \sdom = \sdom' \dunion (\sloc \mapsto \sexprv')
   }{  \GetDomainV{(\sheap, \sdom, \sstore, \pc), \sloc} \semeq \success{(\sheap' \, \uplus \,  \sheap'', \sdom', \sstore, \pc), \sexprv' \backslash \sexprv}}
  \\
      \inferrule[\textsc{GetCell - Found}]
   { 
      (\sheap, \sdom, \sstore, \pc) = \sstate    
       \quad
       \sheap = \sheap' \, \uplus \, (\sloc, \sexprp') \mapsto \sexprv 
       \\\\
       {\color{blue} \pc \vdash (\sexprp = \sexprp')}
       \quad
       \sstate' = (\sheap', \sdom, \sstore, \pc)
   }{  \GetCellV{\sstate, \sloc, \sexprp} \semeq \success{\sstate', \sexprv}}
\quad
     \inferrule[\textsc{GetCell - Not Found}]
   { 
     (\sheap, \sdom, \sstore, \pc) = \sstate  
     \quad 
        { \color{blue} \pc \vdash \sexprp \not\in \sdom(\sloc)}
        \\\\
        \sstate' = (\sheap, \sdom[\sloc \mapsto \sdom(\sloc) \cup \jsilset{\sexprp}], \sstore,  \pc)
   }{  \GetCellV{\sstate, \sloc, \sexprp} \semeq \success{\sstate', \none}}
\\
     \inferrule[\textsc{GetCell - Fail with Domain Info}]
   { 
       \sheap = \sheap'' \, \uplus \, \big((\sloc, \sexprp_i) \mapsto \sexprv_i \big)\mid_{i = 0}^m
      \qquad
       (\sloc,-) \notin \domain (\sheap'')
       \qquad
        { \color{blue} \pc \not\vdash \sexprp \not\in \sdom(\sloc)}
        \qquad
          { \color{blue} \pc \not\vdash \sexprp = \sexprp_i \mid_{i=0}^m}
   }{  \GetCellV{(\sheap, \sdom, \sstore, \pc), \sloc, \sexprp} \semeq \fail{{\color{red} (\sexprp \in \sdom(\sloc)) \, \wedge \, (\wedge_{i=0}^m (\sexprp_i \neq \sexprp))}}}
 \\
 \\
     \inferrule[\textsc{GetCell - Fail without Domain Info}]
   { 
       \sheap = \sheap'' \, \uplus \, \big((\sloc, \sexprp_i) \mapsto \sexprv_i \big)\mid_{i = 0}^m
      \qquad
       (\sloc,-) \notin \domain (\sheap'')
       \qquad
       \sloc \not\in \domain(\sdom)
        \qquad
          { \color{blue} \pc \not\vdash \sexprp = \sexprp_i \mid_{i=0}^m}
   }{  \GetCellV{(\sheap, \sdom, \sstore, \pc), \sloc, \sexprp} \semeq \fail{{\color{red} \wedge_{i=0}^m (\sexprp_i \neq \sexprp)}}}
 \end{mathpar}}}
 \end{display}

\myparagraph{Formal Guarantees}
The unification algorithm is sound: 
given an SL-assertion $\pass$ and a symbolic state $\sstate$, if
$\unificationfun(\sstate, \pass) = \success{\sstate_f}$, then there is a symbolic state
$\sstate'$ such that $\sstate = \sstate' \statecompose \sstate_f$ and $\sstate'$ satisfies $\pass$ (Theorem~\ref{teo:fip:soundness}). 
The bug-finding theorem, Theorem~\ref{teo:fip:bugfinding}, is more subtle. It states that, 
in case of failure, to find a counter-model for $\pass$, one has to pick a concretisation of the 
symbolic state consistent with the failing constraint generated by the unification.% algorithm.


\begin{theorem}[Soundness of FIP]\label{teo:fip:soundness}
$$
\begin{array}{l}
	\unificationfun(\sstate, \pass) = \success{\sstate_f}
        \implies 
        \interpret{}{}(\sstate) \subseteq \interpret{}{}(\sstate_f \statecompose \normaliser(\pass))
\end{array}
$$ 
\end{theorem}

\begin{theorem}[Bug-finding for SL]\label{teo:fip:bugfinding}
$$
\begin{array}{l}
\unificationfun(\sstate, \pass) = \fail{\pc_f} 
   \implies
   \interpret{}{}(\sstate \, \wedge \, \pc_f) \cap \interpret{}{}(\pass) = \emptyset
\end{array}
$$ 
\end{theorem}



\subsection{From Specifications to Symbolic Tests}\label{specs:to:symbolic:tests}

\jsil Logic specifications have the form $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$, where $\pass$ and $\qass$ are the 
pre- and postconditions of the procedure with identifier $\pid$ and formal parameters $\jvec{x}$. 
Each specification is associated with a return mode $\flag \in \{ \fnormal, \ferror \}$, indicating if the function
 returns normally or with an error. 
 %If it returns normally, then its return value can be accessed  via a dedicated variable 
% $\retvar$, and $\errvar$ otherwise. 
 Intuitively, a specification $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$ is 
valid for a given \jsil program $\prog$, if $\prog$ contains a procedure with identifier 
$\pid$ and ``whenever $\pid$ is executed in a state satisfying $P$, then, 
if it terminates, it does so in a state satisfying $Q$, with return mode $\flag$''.
The formal definition is given below. 


\begin{definition}[Validity of \jsil Logic Specifications]
A \jsil logic specification $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$ is valid with respect to a program 
$\prog$, written $\prog \satisfies \specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$, if and only if, for all logical 
contexts $(\iheap, \store, \senv)$, heaps $\heap_f$, stores $\store_f$, and flags $\flag'$, it holds that: 
$$
\begin{array}{l}
   (\jstate, \heap_f, \cs) \in \interpret{}{}(P) 
   \ \wedge \ 
    \abssemrule{\jstate \dunion \heap_f, \cs, 0}{\jstate', \cs', i_{\flag'}}{\top}{\top}{\concrete} \\ \quad \
   \implies
      \flag' = \flag \ \wedge \ \exists \jstate'' \, . \, \jstate' = \jstate'' \dunion \heap_f
          \ \wedge \   (\jstate'', \heap_f, \cs') \in \interpret{}{}(Q) 
\end{array}
$$
\end{definition}

\begin{figure}
{\footnotesize
$$
\begin{array}{lll}
\testify{}(\specsig{P}{\pid(\jvar_0, ..., \jvar_n)}{Q}{\flag}) \ \semeq                           &  \testify{\fnormal}(\pid, \svar_i|_{i=0}^n, Q) \ \semeq \\
%
\quad  \mathbf{let} \ \sstore =  [ \jvar_i \mapsto \svar_i|_{i=0}^n] \ \mathbf{in}        &  \quad \darkmath{\sf proc} \jsilmain () \{    \\
%
\quad  \mathbf{let} \ \sstate = \normaliser(\sstore(P)) \ \mathbf{in}                               &   \qquad 0_{\phantom{\sf nm}}: \jsilcall{\jvar}{\pid}{\svar_0, ..., \svar_n}{\errlab} \\
 %
\quad  \mathbf{let} \ Q' = \sstore(Q) \ \mathbf{in}                                                           &  \qquad \retlab \, : \sepassert(Q[\jvar/\retvar])  \\
 %
\quad  \mathbf{let} \ \proc = \testify{\flag}(\pid, \svar_i|_{i=0}^n, Q')  \ \mathbf{in}  &    \qquad \errlab \, \, \, : \jassert(\jfalse)   \\
 %
\qquad (\proc, \sstate)                                                                                                 &  \quad \}  
\end{array}
$$}
\vspace*{-0.4cm}
\caption{Symbolic Test Generation Algorithm~\label{fig:test:generation}}
\vspace*{-0.2cm}
\end{figure}

Given a \jsil program $\prog$ containing a procedure $\pid$ with spec {\small $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$}, 
our goal is to construct a symbolic test for checking whether or not $\pid$ behaves as its specification mandates.
A symbolic test is a pair $(\proc, \sheap)$ consisting of a \jsil procedure with the code of the test and the initial 
symbolic heap on which to execute the test. 
%
Figure~\ref{fig:test:generation} presents the test generation procedure. Intuitively, $\testify{}(\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag})$ 
returns the symbolic test for $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$. The test generation function $\testifyfun{} \ $ is defined in terms 
of two auxiliary functions, $\testifyfun{\fnormal}$ and $\testifyfun{\ferror}$, for generating tests for $\fnormal$-mode and 
$\ferror$-mode specifications, respectively. 
For space reasons, we only present $\testifyfun{\fnormal}$ ($\testifyfun{\ferror}$ is equivalent). 
The test program $\prog'$, denoted by $\prog[\jsilmain \mapsto \proc]$, is obtained from the original program $\prog$ and the test procedure $\proc$ by replacing the 
$\jsilmain$ of $\prog$ with the new test procedure, $\proc$. 

Finally, Theorem~\ref{teo:bug:finding:sl} states that if the symbolic execution of the 
test generated for $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$ finds a bug, then the specification 
is not~valid.

\begin{theorem}[Bug-finding for SL Specifications]\label{teo:bug:finding:sl}
$$
\begin{array}{l}
\testify{}(\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag})  = (\proc, \sstate) \, \wedge \, 
  \prog' :  \transabssemrule{\sstate, \csmain, 0}{-}{\top}{\bot}{\symbolic} \\ \quad \quad 
    \implies  
         \prog \not\satisfies \specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}
\end{array}
$$
\noindent where  $\csmain = [ (\jsilmain, -, -, -, -) ]$ 
and $\prog' = \prog[\jsilmain \mapsto \proc]$.
\end{theorem}



