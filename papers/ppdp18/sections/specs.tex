%!TEX root = ../main.tex

We show how to use \cosette for debugging \jsil code annotated with 
separation logic (SL) specifications. Tools that support SL-reasoning about
functional correctness properties of programs often require of the user to 
analyse long, complex proof traces whenever
verification fails. 
\cosette substantially simplifies this process by providing
concrete counter-models that invalidate the input specification. 


We extend the 
 \jsil symbolic interpreter with a mechanism for asserting
SL-assertions (\S\ref{subsec:sep:assertions}) and show how to 
implement this mechanism by giving a sound decision procedure 
for solving the frame inference problem (FIP)~\cite{}
in the context of symbolic execution (\S\ref{subsec:fip}).
%
%Unlike verification tools, our emphasis is in the generation of counter-models for failing cases. 
%
We present an algorithm  
for generating symbolic tests from SL-specifications, which guarantees 
that whenever a symbolic test fails, \cosette produces a concrete 
counter-model that invalidates the corresponding specification (\S\ref{specs:to:symbolic:tests}).

\vspace{-5pt}
\subsection{Symbolic Execution with SL-Assertions}\label{subsec:sep:assertions}

\jsil Logic assertions~\cite{javert}
provide a compositional way of describing \emph{partial} symbolic states. 
They include: boolean operations; the separating conjunction; 
and assertions for describing heaps. The $\lemp$ assertion describes 
an empty heap. The cell assertion, $(\lexpr_1,\lexpr_2) \pointsto \lexpr_3$,  describes an object 
at the location denoted by $\lexpr_1$ with a property denoted by $\lexpr_2$ that has the value 
denoted by $\lexpr_3$. The object domain assertion $\emptyfields{\lexpr_1}{\lexpr_2}$ states that the object at 
the location denoted by $\lexpr_1$ has no properties other than possibly those included in the
set denoted by $\lexpr_2$. %The syntax of assertions is given below. 
We refer to assertions different from $- \sep -$ and $\lemp$ as \emph{simple assertions}
and use $\spass$ and $\sqass$ to range over them.

\vspace{2pt}
\begin{display}{\jsil Logic Assertions}
%
{\small
\begin{tabular}{l}
  %%%%
  $\lexpr \quad \ \triangleq \val \mid \jvar \mid \svar \mid \unoper\ \lexpr \mid \lexpr \binoper \lexpr \quad \quad \quad \quad \quad \quad \quad \ \ $   \text{ Logical Expressions} \\
  $\rass, \sass \ \triangleq \jtrue \mid \jfalse \mid  \neg \rass \mid \rass \land \sass \mid \rass \lor \sass  \mid \lexpr = \lexpr \mid \lexpr \leq \lexpr$  \quad \text{\hfill{Pure Asrts.}} \\
  $\pass, \qass \triangleq \sass \mid \lemp \mid (\lexpr, \lexpr)\pointsto \lexpr \mid \pass \sep \qass  \mid \emptyfields{\lexpr}{\lexpr} $ \quad \quad \quad \quad \ \  \text{\hfill Asrts.} \\
\end{tabular}}
\end{display}

\noindent Without loss of generality, we implicitly assume that different symbolic locations 
denote different concrete locations.\footnote{To express aliasing, the user has to write multiple assertions.}
 Furthermore, given a cell assertion $(\lexpr_1,\lexpr_2) \pointsto \lexpr_3$, we always assume 
 $\lexpr_1$ to be either a concrete location $\loc$ or a symbolic location $\sloc$. 
%
Note that 
a symbolic state $\sstate = (\sheap, \sdom, \sstore, \pc)$ corresponds to the assertion 
\begin{equation*}
{\small \begin{array}{l}
\big(\varoast_{(\sloc, \sexprp) \in \domain(\sheap)} (\sloc, \sexprp) \mapsto \sheap(\sloc, \sexprp)\big) 
  \sep \big(\varoast_{\sloc \in \domain(\sdom)} \, \emptyfields{\sloc}{\idom(\sloc)}\big)  \\
 %
 \qquad \sep \big(\bigwedge_{\jvar \in \domain(\sstore)} \, \jvar = \sstore(\jvar)\big) \sep \pc
\end{array}}
\end{equation*}

\noindent where $\varoast$ denotes the iterated separating conjunction~\cite{}. 
Analogously, an assertion can be normalised into a symbolic state: 
 cell assertions form the heap; 
object domain assertions form the domain table;
 equalities involving program variables form the store; and 
 pure assertions form the path condition. 
Finally,  all occurrences of program variables in the heap, domain table, and path condition 
are replaced with their corresponding symbolic expressions from the store. 
We refer to the normalised symbolic state corresponding 
to $\pass$ by $\normaliser(\pass)$. 
%
We also use $\interpret{}{}(\sstate)$ for denoting the set 
$\{ (\jstate, \heap_f) \mid \exists \senv \, . \, (\jstate, \heap_f) \in \interpret{\symbconc}{\senv}(\sstate) \}$ 
and $\interpret{}{}(\pass)$ for denoting $\interpret{}{}(\normaliser(\pass))$. 

\myparagraph{Inductive Predicates}
\cosette does not support symbolic execution over inductive predicates, which are commonplace 
in SL-style specifications~\cite{smallf, berdine:aplas:2005}. 
As in~\cite{korat}, we deal with user-defined inductive predicates by \emph{unfolding} 
those predicates up to a fixed, user-defined bound. We omit this unfolding mechanism 
as it is routine. 

\myparagraph{Asserting SL-Assertions}
We extend \jsil with a special construct, $\sepassert(P)$, for stating that 
the assertion $P$ must hold whenever that command is evaluated. 
The symbolic semantics is given below. 

\vspace*{-0.2cm}
{\footnotesize
\begin{mathpar}
\inferrule[\textsc{SL-Assert - True}]
  { 
     \ccmd{i}  = \sepassert(\pass)  \\\\
     %
     \unificationfun(\sstate, \pass) = \success{\subst, \sstate_f}
  }{
    \abssemrule{\sstate, \scs, i}{\sstate, \scs, i{+}1}{\top}{\top}{\symbolic}
}
\qquad
\inferrule[\textsc{SL-Assert - False}]
  { 
     \ccmd{i}  = \sepassert(\pass)  \\\\
     %
    \unificationfun(\sstate, \pass) = \fail{\pc_f}  \quad
    %
     (\sstate.\pcsel \wedge \pc_f) \text{ SAT}
  }{
    \abssemrule{\sstate, \scs, i}{\sstate, \scs, i}{\top}{\bot}{\symbolic}
}
\end{mathpar}}

\vspace*{-0.2cm}
\noindent The rules use a partial decision procedure $\unificationfun(\sstate, \pass)$ for 
determining if a given symbolic state $\sstate$ satisfies an assertion $P$, 
undecidable in general \cite{citemeplease}. More concretely, 
the decision procedure outputs: 
 $\success{\subst, \sstate_f}$ when it finds a substitution $\subst$ and 
a symbolic state frame $\sstate_f$ such that $\interpret{}{}(\sstate) \subseteq \interpret{}{}(\sstate_f \statecompose \normaliser(\subst(\pass)))$ holds;\footnote{ 
We use $\statecompose$ for the composition of two symbolic states.}
and $\fail{\pc_f}$ when it finds a first-order formula $\pc_f$, such that 
$\interpret{}{}(\sstate \, \wedge \, \pc_f) \cap \interpret{}{}(\pass) = \emptyset$. 
Note that every concrete state and heap frame in $\interpret{}{}(\sstate \, \wedge \, \pc_f)$ are counter models 
for $P$. By requiring that $(\sstate.\pcsel \, \wedge \, \pc_f)$ is satisfiable, 
the semantics only triggers an assertion failure when it finds a concrete witness for the failure---any instantiation of $(\sstate \, \wedge \, \pc_f)$. 

\subsection{The Frame Inference Problem}\label{subsec:fip}

We describe a partial decision procedure, which we  
implement as part of the \jsil symbolic interpreter, for proving entailments 
between symbolic states \underline{and} finding counter 
models in case of failure.  
As it is customary~\cite{javert,jacobs2011verifast,sepwithsmt}, the decision procedure works by first using \emph{pattern-matching} 
on the spatial part of the symbolic state, and then discharging the pure part of the 
entailment to an external constraint solver (in our case, \rosette). 

\myparagraph{Unification Plan}
When solving $\unificationfun(\sstate, \pass)$, the symbolic variables of $\pass$ that are not 
in $\sstate$ are assumed to be existentially quantified. 
To find the appropriate bindings for these variables, we 
introduce \emph{unification plans} (Def.~\ref{def:up}).
Informally, a unification plan is an ordering of the simple assertions in $\pass$ that 
guarantees that the unification algorithm does not have to backtrack at unification~time. 

\vspace{-0.2cm}
\begin{table}[!h]
{\small \begin{tabular}{@{}c@{}ccc@{}c@{}}\toprule
\emph{Argument} & & \textbf{IN}  & & \textbf{OUT}  \\
\cmidrule{1-1} \cmidrule{3-3} \cmidrule{5-5}

$\svar$                                                       & & $\{ \svar \}$                                                          & & $\{ \svar \}$    \\
$\jsillist{\lexpr_1, ..., \lexpr_n}$                     & & $\upin(\lexpr_1) \cup ... \cup \upin(\lexpr_n)$      & & $\upout(\lexpr_1) \cup ... \cup \upout(\lexpr_n)$ \\
$\lexpr_1 + \lexpr_2$                                    & & $\upin(\lexpr_1) \cup \upin(\lexpr_2)$                  & & $\emptyset$ \\
$\cdots$ & & $\cdots$ & & $\cdots$ \\[1pt]
%%
$(\lexpr_1, \lexpr_2)\pointsto \lexpr_3$   & & $\upin(\lexpr_1) \cup \upin(\lexpr_2)$ & & $\upout(\lexpr_3)$  \\
%
$\emptyfields{\lexpr_1}{\lexpr_2}$           &  & $\upin(\lexpr_1) \cup \upin(\lexpr_2)$ & & $\emptyset$ \\
%
$\lexpr_1 = \lexpr_2$                               & & $\upin(\lexpr_1)$/$\upin(\lexpr_2)$      & & $\upout(\lexpr_2)$/$\upout(\lexpr_1)$ \\
%
$\sass$                                                    & & $\fv(\sass)$                                           & & $\emptyset$ \\
\bottomrule
\end{tabular}}
%\caption{\emph{in} and \emph{out} sets for assertions and logical expressions}
%\label{tab:insouts}
\vspace{-0.3cm}
\end{table}

To construct unification plans, we define an \emph{in} set and an \emph{out} set for each assertion and logical expression, illustrated above. These 
sets are reminiscent of the predicate parameter modes in~\cite{nguyen:vmcai:2008}).
Intuitively, the variables in the \emph{out} set of an assertion are those that can be computed 
using the variables in the \emph{in} set, together with the current state (e.g.~given the assertion $(\svar_1, \svar_2) \pointsto \svar_3$, if we know the bindings
for $\svar_1$ and $\svar_2$, we can compute the bindings for $\svar_3$, given 
the current symbolic state). 
%
For logical expressions, the variables in the \emph{out} set are those that can be computed
given the value of the whole expression, whereas the variables in the \emph{in} set 
are those that we need to know to compute the value of the whole expression.  
Finally, the definition of a unification plan is given below. 

\begin{definition}[Unification Plan]\label{def:up}
A \emph{unification plan} $\up$ is a sequence of simple assertions $\sqass_i \mid_{i=0}^n$ such that
for all $0 \leq i \leq n$, it holds that:
$
 \upin(\sqass_i) \subseteq \big(\cup_{j = 0}^{i-1} \upout(\sqass_j)\big) \cup \upin_0
$,
where $\upin_0$ is the set of \underline{non}-existentially quantified logical variables. 
\end{definition}

\vspace{-3pt}
\noindent It is not always possible to generate a unification plan for an SL-assertion. We only 
consider assertions that admit a unification plan. 

\myparagraph{Unification Algorithm}
Given a symbolic state $\sstate$ and an assertion $\pass$, $\unificationfun(\sstate, \pass)$: 
\dtag{1} replaces all occurrences of program variables in $\pass$ with their bindings 
given by $\sstate.\stosel$;
\dtag{2} computes an initial substitution $\subst_0$, mapping all the non-existentially quantified symbolic 
variables in $\pass$ to themselves (formally: $\subst_0 = \identity_{\fv(\sstate) \cap \fv(\pass)}$); 
\dtag{3} creates a unification plan $\up$ for $\pass$; and, 
\dtag{4} calls Algorithm~\ref{fip:symb:states}. 
%
Algorithm~\ref{fip:symb:states} makes use of the following auxiliary functions: 

\begin{description}
\setlength{\itemsep}{0.2em}
  \item[FIP GetCell.] In case of success, $\GetCellV{\sstate, \sloc, \sexprp}$ returns 
          the symbolic expression $\sexprv$ associated with 
          $(\sloc, \sexprp)$ in the heap component of $\sstate$ \underline{and} 
          the state obtained by removing that cell from $\sstate.\hpsel$.
  
  \item[FIP GetDomain.] In case of success, $\GetDomainV{\sstate, \sloc}$ returns 
          the symbolic expression $\sexprv_d$, denoting the domain 
          of the object at location $\sloc$ in $\sstate$, \underline{and} 
          the state obtained by removing all the negative resource associated with 
          $\sloc$ from $\sstate$.  
  
  \item[Expression Unification.]  In case of success, $\unifylexpr(\sexprv, \sexprv', \subst, \pc)$ 
          returns a substitution $\subst'$ that extends $\subst$ such that $\pc \vdash \sexprv = \subst'(\sexprv')$. 
\end{description}

{\footnotesize \begin{algorithm}[t!]
\algblock[Name]{match}{end}
\caption{Frame Inference for Symbolic States}\label{fip:symb:states}
\begin{algorithmic}[1]
\Function{Unification}{$\sstate$, $\up$, $\subst$}
    \State $\textbf{match}$ $\up$ $\textbf{with}$
    \State $\mid~\lstemp:$ \Return $\success{\subst, \sstate}$
   % Cell ASS
    \State $\mid~(\sloc, \sexprp) \pointsto \sexprv \lstcons \up' :$ 
    \State $\qquad \textbf{match} \ \GetCellV{\sstate, \subst(\sloc), \subst(\sexprp)}$ $\textbf{with}$
    \State $\qquad \mid~\success{\sexprv', \sstate'}:$
    \State $\qquad \qquad \textbf{match} \ \unifylexpr(\sexprv, \sexprv', \subst, \sstate.\pcsel)$ $\textbf{with}$
     \State $\qquad \qquad \mid~ \success{\subst'}:$ \Return \Call{Unification}{$\sstate'$, $\up'$, $\subst'$}
      \State $\qquad \qquad \mid~ \fail{\pc_f} \ \, :$ \Return $\fail{\pc_f}$
      \State $\qquad \mid~\fail{\pc_f}:$ \Return $\fail{\pc_f}$
      % EF ASS
     \State $\mid~\emptyfields{\sloc}{\sexprv} \lstcons \up' :$  
       \State $\qquad \textbf{match} \ \GetDomainV{\sstate, \subst(\sloc)}$ $\textbf{with}$
       \State $\qquad \mid~\success{\sexprv', \sstate'}:$
         \State $\qquad \qquad \textbf{match} \ \unifylexpr(\sexprv, \sexprv', \subst, \sstate.\pcsel)$ $\textbf{with}$
       \State $\qquad \qquad \mid~ \success{\subst'}:$ \Return \Call{Unification}{$\sstate'$, $\up'$, $\subst'$}
       \State $\qquad \qquad \mid~ \fail{\pc_f} \ \, :$ \Return $\fail{\pc_f}$
       \State $\qquad \mid~\fail{\pc_f}:$ \Return $\fail{\pc_f}$
     % Logical Equality  
     \State $\mid~(\sexprv = \sexprv') \lstcons \up' :$  
        \State $\qquad \textbf{match} \ \unifylexpr(\sexprv, \sexprv', \subst, \sstate.\pcsel)$ $\textbf{with}$
         \State $\qquad \qquad \mid~ \success{\subst'}:$ \Return \Call{Unification}{$\sstate$, $\up'$, $\subst'$}
       \State $\qquad \qquad \mid~ \fail{\pc_f} \ \, :$ \Return $\fail{\pc_f}$
     % OTHER PURE ASS
     \State $\mid~\sass \lstcons \up' :$   
      \State $\qquad \textbf{if} \,(\sstate.\pcsel \vdash \subst(\sass))$
       \State $\qquad \qquad \textbf{then}$ \Return  \Call{Unification}{$\sstate$, $\up'$, $\subst$}
      \State $\qquad \qquad \textbf{else}$  \Return $\fail{\subst(\sass)}$
\EndFunction
\end{algorithmic}
\end{algorithm}}

\vspace*{-0.8cm}
We give selected rules for $\GetCellV{\sstate, \sloc, \sexprp}$ and $\GetDomainV{\sstate, \sloc}$, analogous to those in \S\ref{subsec:symb:semantics}, except that they return a new symbolic state 
from which the matched resource is removed and their corresponding constraints are lifted to the premise (highlighted in blue). Also, in case of failure, all auxiliary functions return a constraint $\pc_f$ under which the unification is not possible (highlighted in red). 

\vspace{2pt}
\begin{display}{Selected FIP Rules}
\text{
{\scriptsize
\begin{mathpar} 
  \inferrule[\textsc{GetDomain}]
   { 
       \sheap = \sheap' \, \uplus \, \big((\sloc, \sexprp_i) \mapsto \sexprv_i \big)\mid_{i = 0}^m  
         \quad 
          (\sloc,-) \notin \domain (\sheap')  
         \quad
        \forall_{0 \leq i \leq n} \,  \sexprv_i \neq \none 
         \quad
           \forall_{n < i \leq m} \, \sexprv_i = \none
           \\\\ 
           \sexprv =  \{ \sexprp_i \mid_{i = n{+}1}^m\}
           \and
           \sheap'' = (\sloc, \sexprp_i) \mapsto \sexprv_i  \mid_{i=0}^n
           \and
           \sdom = \sdom' \dunion (\sloc \mapsto \sexprv')
   }{  \GetDomainV{(\sheap, \sdom, \sstore, \pc), \sloc} \semeq \success{(\sheap' \, \uplus \,  \sheap'', \sdom', \sstore, \pc), \sexprv' \backslash \sexprv}}
  \\
      \inferrule[\textsc{GetCell - Found}]
   { 
      (\sheap, \sdom, \sstore, \pc) = \sstate    
       \quad
       \sheap = \sheap' \, \uplus \, (\sloc, \sexprp') \mapsto \sexprv 
       \\\\
       {\color{blue} \pc \vdash (\sexprp = \sexprp')}
       \quad
       \sstate' = (\sheap', \sdom, \sstore, \pc)
   }{  \GetCellV{\sstate, \sloc, \sexprp} \semeq \success{\sstate', \sexprv}}
\quad
     \inferrule[\textsc{GetCell - Not Found}]
   { 
     (\sheap, \sdom, \sstore, \pc) = \sstate  
     \quad 
        { \color{blue} \pc \vdash \sexprp \not\in \sdom(\sloc)}
        \\\\
        \sstate' = (\sheap, \sdom[\sloc \mapsto \sdom(\sloc) \cup \jsilset{\sexprp}], \sstore,  \pc)
   }{  \GetCellV{\sstate, \sloc, \sexprp} \semeq \success{\sstate', \none}}
\\
     \inferrule[\textsc{GetCell - Fail with Domain Info}]
   { 
       \sheap = \sheap'' \, \uplus \, \big((\sloc, \sexprp_i) \mapsto \sexprv_i \big)\mid_{i = 0}^m
      \qquad
       (\sloc,-) \notin \domain (\sheap'')
       \qquad
        { \color{blue} \pc \not\vdash \sexprp \not\in \sdom(\sloc)}
        \qquad
          { \color{blue} \pc \not\vdash \sexprp = \sexprp_i \mid_{i=0}^m}
   }{  \GetCellV{(\sheap, \sdom, \sstore, \pc), \sloc, \sexprp} \semeq \fail{{\color{red} (\sexprp \in \sdom(\sloc)) \, \wedge \, (\wedge_{i=0}^m (\sexprp_i \neq \sexprp))}}}
 \\
 \\
     \inferrule[\textsc{GetCell - Fail without Domain Info}]
   { 
       \sheap = \sheap'' \, \uplus \, \big((\sloc, \sexprp_i) \mapsto \sexprv_i \big)\mid_{i = 0}^m
      \qquad
       (\sloc,-) \notin \domain (\sheap'')
       \qquad
       \sloc \not\in \domain(\sdom)
        \qquad
          { \color{blue} \pc \not\vdash \sexprp = \sexprp_i \mid_{i=0}^m}
   }{  \GetCellV{(\sheap, \sdom, \sstore, \pc), \sloc, \sexprp} \semeq \fail{{\color{red} \wedge_{i=0}^m (\sexprp_i \neq \sexprp)}}}
 \end{mathpar}}}
 \end{display}

\myparagraph{Formal Guarantees}
The unification algorithm is sound: 
given an SL-assertion $\pass$ and a symbolic state $\sstate$, if
$\unificationfun(\sstate, \pass) = \success{\subst, \sstate_f}$, then there is a symbolic state
$\sstate'$ such that $\sstate = \sstate' \statecompose \sstate_f$ and $\sstate'$ satisfies $\pass$ (Theorem~\ref{teo:fip:soundness}). 
The bug-finding theorem, Theorem~\ref{teo:fip:bugfinding}, is more subtle. It states that, 
in case of failure, to find a counter-model for $\pass$, one has to pick a concretisation of the 
symbolic state consistent with the failing constraint generated by the unification.% algorithm.


\begin{theorem}[Soundness of FIP]\label{teo:fip:soundness}
$$
\begin{array}{l}
	\unificationfun(\sstate, \pass) = \success{\subst, \sstate_f}
        \implies 
        \interpret{}{}(\sstate) \subseteq \interpret{}{}(\sstate_f \statecompose \normaliser(\subst(\pass)))
\end{array}
$$ 
\end{theorem}

\begin{theorem}[Bug-finding for SL]\label{teo:fip:bugfinding}
$$
\begin{array}{l}
\unificationfun(\sstate, \pass) = \fail{\pc_f} 
   \implies
   \interpret{}{}(\sstate \, \wedge \, \pc_f) \cap \interpret{}{}(\pass) = \emptyset
\end{array}
$$ 
\end{theorem}



\subsection{From Specifications to Symbolic Tests}\label{specs:to:symbolic:tests}

\jsil Logic specifications have the form $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$, where $\pass$ and $\qass$ are the 
pre- and postconditions of the procedure with identifier $\pid$ and formal parameters $\jvec{x}$. 
Each specification is associated with a return mode $\flag \in \{ \fnormal, \ferror \}$, indicating if the function
 returns normally or with an error. 
 %If it returns normally, then its return value can be accessed  via a dedicated variable 
% $\retvar$, and $\errvar$ otherwise. 
 Intuitively, a specification $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$ is 
valid for a given \jsil program $\prog$, if $\prog$ contains a procedure with identifier 
$\pid$ and ``whenever $\pid$ is executed in a state satisfying $P$, then, 
if it terminates, it does so in a state satisfying $Q$, with return mode $\flag$''.
The formal definition is given below. 


\begin{definition}[Validity of \jsil Logic Specifications]
A \jsil logic specification $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$ is valid with respect to a program 
$\prog$, written $\prog \satisfies \specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$, if and only if, for all logical 
contexts $(\iheap, \store, \senv)$, heaps $\heap_f$, stores $\store_f$, and flags $\flag'$, it holds that: 
$$
\begin{array}{l}
   (\jstate, \heap_f, \cs) \in \interpret{}{}(P) 
   \ \wedge \ 
    \abssemrule{\jstate \dunion \heap_f, \cs, 0}{\jstate', \cs', i_{\flag'}}{\top}{\top}{\concrete} \\ \quad \
   \implies
      \flag' = \flag \ \wedge \ \exists \jstate'' \, . \, \jstate' = \jstate'' \dunion \heap_f
          \ \wedge \   (\jstate'', \heap_f, \cs') \in \interpret{}{}(Q) 
\end{array}
$$
\end{definition}

\begin{figure}
{\footnotesize
$$
\begin{array}{lll}
\testify{}(\specsig{P}{\pid(\jvar_1, ..., \jvar_n)}{Q}{\flag}) \ \semeq                           &  \testify{\fnormal}(\pid, \svar_i\mid_{i=0}^n, Q) \ \semeq \\
%
\ \  \mathbf{let} \ \sstore =  [ \jvar_i \mapsto \svar_i \mid_{i=0}^n] \ \mathbf{in}        &  \ \  \darkmath{\sf proc} \jsilmain () \{    \\
%
 \ \  \mathbf{let} \ \sstate = \normaliser(\sstore(P)) \ \mathbf{in}                               &   \ \ \ \ 0_{\phantom{\sf nm}}: \jsilcall{\jvar}{\pid}{\svar_0, ..., \svar_n}{\errlab} \\
 %
\ \  \mathbf{let} \ Q' = \sstore(Q) \ \mathbf{in}                                                           &    \ \ \ \ \retlab \, : \sepassert(Q[\jvar/\retvar])  \\
 %
 \ \  \mathbf{let} \ \proc = \testify{\flag}(\pid, \svar_i\mid_{i=0}^n, Q')  \ \mathbf{in}  &    \ \ \ \ \errlab \, \, \, : \jassert(\jfalse)   \\
 %
 \ \ \ \ (\proc, \sstate)                                                                                                 &    \ \ \}  
\end{array}
$$}
\vspace*{-0.4cm}
\caption{Symbolic Test Generation Algorithm~\label{fig:test:generation}}
\vspace*{-0.2cm}
\end{figure}

Given a \jsil program $\prog$ containing a procedure $\pid$ with spec {\small $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$}, 
our goal is to construct a symbolic test for checking whether or not $\pid$ behaves as its specification mandates.
A symbolic test is a pair $(\proc, \sheap)$ consisting of a \jsil procedure with the code of the test and the initial 
symbolic heap on which to execute the test. 
%
Figure~\ref{fig:test:generation} presents the test generation procedure. Intuitively, $\testify{}(\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag})$ 
returns the symbolic test for $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$. The test generation function $\testifyfun{} \ $ is defined in terms 
of two auxiliary functions, $\testifyfun{\fnormal}$ and $\testifyfun{\ferror}$, for generating tests for $\fnormal$-mode and 
$\ferror$-mode specifications, respectively. 
For space reasons, we only present $\testifyfun{\fnormal}$ ($\testifyfun{\ferror}$ is equivalent). 
The test program $\prog'$, denoted by $\prog[\jsilmain \mapsto \proc]$, is obtained from the original program $\prog$ and the test procedure $\proc$ by replacing the 
$\jsilmain$ of $\prog$ with the new test procedure, $\proc$. 

Finally, Theorem~\ref{teo:bug:finding:sl} states that if the symbolic execution of the 
test generated for $\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}$ finds a bug, then the specification 
is not~valid.

\begin{theorem}[Bug-finding for SL Specifications]\label{teo:bug:finding:sl}
$$
\begin{array}{l}
\testify{}(\specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag})  = (\proc, \sstate) \, \wedge \, 
  \prog' :  \transabssemrule{\sstate, \csmain, 0}{-}{\top}{\bot}{\symbolic} \\ \quad \quad 
    \implies  
         \prog \not\satisfies \specsig{\pass}{\pid(\jvec{x})}{\qass}{\flag}
\end{array}
$$
\noindent where:  $\csmain = [ (\jsilmain, -, -, -) ]$ 
and $\prog' = \prog[\jsilmain \mapsto \proc]$.
\end{theorem}



