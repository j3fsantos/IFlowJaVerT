%!TEX root = ../main.tex

\newtheorem{lemmax}{}
\newtheorem{temax}{}
\newtheorem{cormax}{}


\section{Full Definitions --- Section~\ref{sec:jsil:symb:exec}}

%\pmax{Needs updating with symbolic variables.}

\subsection{Abstract Semantics}

\begin{figure}[h!]
\begin{tabular}{l}
$\jnumber \in \numbers$ \jspc  $\jbool \in \bools$ \jspc $\jstring \in \strings$  \jspc 
$\loc \in \locs$ \jspc $\jvar \in \jvars$ \jspc $\jtype \in \jtypes$ \\[0.1cm]
%
$\val \in \vals$ \defeq\ $\jnumber \! \mid \! \jbool \! \mid \! \jstring \! \mid \! {\small \jundefined} \! \mid \! {\small \jnull} \! \mid \! {\small \jempty} \! \mid \! \loc \! \mid \! \jtype \! \mid \!  \pid$
   \\[0.1cm]
 %
  $\jsilexpr \in \exprs$ \defeq\ $\val \mid \jvar \mid \ominus\ \jsilexpr \mid \jsilexpr \binop{} \jsilexpr$
 \\[0.1cm]
%
$\bcmd \in \bcmds$ \defeq\ $\jsilskip \mid \jvar := \jsilexpr  \mid \jvar := \jsilnew() \mid \jvar := [\jsilexpr, \jsilexpr]$ \\
%
\hspace{0.02cm} $\mid [\jsilexpr, \jsilexpr] := \jsilexpr \mid \jsildelete(\jsilexpr, \jsilexpr) \mid \jvar := \hasfield(\jsilexpr, \jsilexpr)$ \\
\hspace{0.02cm} $\mid \jvar := \getfields(\jsilexpr) \mid \jvar := \makesymbolic(\jtype)$  \\[0.1cm]
% Commands
$\jcmd \in \cmds$ \defeq \ $ \bcmd \mid \goto \ i \mid  \ifgoto{\jsilexpr}{i}{j} \mid \jsilcall{\jvar}{\jsilexpr}{\jvec{\jsilexpr}}{j}$ \\
\hspace{0.02cm} $ \mid \assume(\jsilexpr) \mid \jassert(\jsilexpr)$ \\[0.1cm]
%
$\proc \in \procs$ \defeq \ $\procedure{\pid}{\jvec{\jvar}}{\jvec{\jcmd}}$
 \end{tabular}
 \caption{Syntax of the \jsil Language}
 \end{figure}
 
 \begin{figure}[h!]
 \begin{tabular}{ll}
 \textsc{Expression Eval.:} & $\evalexpr{} :  (\jvars \partialmap \absvals)  \partialmap \exprs \partialmap \absvals$ \\ 
                                                    & $\absval = \evalexpr{}(\absstore, \jsilexpr)$ \\[2pt]
 %
 \textsc{Heap Allocation:}            & $\absalloc{}: \absstates \rightarrow \absvals \times \absstates$ \\ 
                                                    & $\absstate' = \absalloc{}(\absstate)$ \\[2pt]
 %
\textsc{Store Selector:}                & $\stosel : \absstates \rightarrow (\jvars \partialmap \absvals)$ \\ 
                                                     & $\absstore' = \absstate.\stosel$ \\[2pt]
% 
\textsc{Store Update:}                 & $\stupdt{}: \absstates \rightarrow \jvars \rightarrow \absvals \rightarrow \absstates$ \\
                                                    & $\absstate' = \stupdt{}(\absstate, \jvar, \absval)$ \\[2pt]
%             
\textsc{Heap Update:}                 & $\hpupdt{} : \absstates \rightarrow \absvals \rightarrow \absvals \rightarrow \setext{\absvals}{\none} \rightarrow \absstates$\\
                                                    & $\absstate' = \hpupdt{}(\absstate, \absloc, \absprop, \absval)$ \\[2pt]
 %
 \textsc{GetCell:}                         & $\getcell \subseteq \absstates \times \exprs \times \exprs \times \absstates \times \absvals \times \absvals \times \setext{\absvals}{\none}$ \\ 
                                                    & $\absgetcellrule{}{\absstate, \jsilexpr_1, \jsilexpr_2}{\absstate', (\absloc, \absprop, \absval)}$ \\[2pt]
%
 \textsc{GetDomain:}                   & $\getdomain : \absstates \rightarrow \exprs \partialmap \absvals$ \\ 
                                                    & $\absval = \absgetdomainfun{}(\absstate, \jsilexpr)$ \\[2pt]
% 
\textsc{Assumption:}                   & $\absassume{} : \absstates \rightarrow (\exprs \partialmap \absvals) \partialmap \absstates$ \\ 
                                                    & $\absstate' = \absassume{}(\absstate, \jsilexpr)$ \\[2pt]
%
\textsc{Satisfiability:}                   & $\abssat{} : \absstates \rightarrow \exprs \partialmap \bools$ \\ 
                                                    & $\jbool = \abssat{}(\absstate, \jsilexpr)$ 
 \end{tabular}
 \caption{Abstract State Signature}
 \end{figure}
 
 
 \begin{figure}[h!]
\begin{mathpar}
  \inferrule[\textsc{Skip}]{}
	{ \absbsemrule{\absstate, \jsilskip}{\absstate}{}}  	
\and 
\inferrule[\textsc{Property Collection}]
  {
           \absval = \absgetdomainfun{}(\absstate, \jsilexpr)  
           \quad
           \absstate' =  \stupdt{}(\absstate, \jvar, \absval)
  }{\absbsemrule{\absstate, \jvar := \getfields(\jsilexpr)}{\absstate'}{}} 
%
\\ 
\inferrule[\textsc{Assignment}]
  {
        \absstore = \absstate.\stosel
        \quad 
        \absval = \evalexpr{}(\absstore, \jsilexpr)
  }{\absbsemrule{\absstate, \jvar := \jsilexpr}{\stupdt{}(\absstate, \jvar, \absval)}{}} 
\and
\inferrule[\textsc{Property Access}]
  { 
  	\absgetcellrule{}{\absstate, \jsilexpr_1, \jsilexpr_2}{\absstate', (-, -, \absval)}
  }{ \absbsemrule{\absstate, \jvar := [\jsilexpr_1, \jsilexpr_2]}{\stupdt{}(\absstate', \jvar, \absval)}{}}
%
\end{mathpar}
%
\caption{Abstract semantics of basic commands: {\small $\absbsemrule{\absstate, \bcmd}{\absstate'}{}$}}
%
\end{figure}



 \begin{figure}[h!]
\begin{mathpar}
\inferrule[\textsc{Object Creation}]
  { 
       (\absstate_1, \loc) = \absalloc{}(\absstate) 
       \\\\
        \absgetcellrule{}{\absstate_1, \loc, \protop}{\absstate_2, -} 
        \\\\ 
        \absstate_3 = \hpupdt{}(\absstate_2, \loc, \protop, \jnull) 
       }{\absbsemrule{\absstate, \jvar := \jsilnew()}{\stupdt{}(\absstate_3, \jvar, \loc)}{}}
\and
\inferrule[\textsc{Property Assignment}]
  {    
       \absval = \evalexpr{}(\absstate.\stosel, \jsilexpr_3)
       \\\\
      \absgetcellrule{}{\absstate, \jsilexpr_1, \jsilexpr_2}{\absstate_1, (\absloc, \absprop, -)} 
      \\\\ 
     \absstate_2 = \hpupdt{}(\absstate', \absloc, \absprop, \absval)
  }{\absbsemrule{\absstate, [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3}{\absstate_2}{}} 
  \\
 \inferrule[\textsc{Property Deletion}]
  { 
        \absgetcellrule{}{\absstate, \jsilexpr_1, \jsilexpr_2}{\absstate_1, (\absloc, \absprop, \absval)}
        \\\\
     	\absval \neq \none 
	\quad 
	\absstate_2 = \hpupdt{}(\absstate_1, \absloc, \absprop, \none)
  }{\absbsemrule{\absstate, \jsildelete(\jsilexpr_1, \jsilexpr_2)}{\absstate_2}{}}
\quad
\inferrule[\textsc{Member Check - True}]
  { 
     \absgetcellrule{}{\absstate, \jsilexpr_1, \jsilexpr_2}{\absstate_1, (-, -, \absval)} 
     \\\\
    \absstate_2 = \stupdt{}(\absstate_1, \jvar, \absval \neq \none)
  }{\absbsemrule{\absstate, \jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)}{\absstate_2}{}}
 %
 %
\end{mathpar}
%
\caption{Abstract semantics of basic commands (cont.): {\small $\absbsemrule{\absstate, \bcmd}{\absstate'}{}$}}
%
\end{figure}




\begin{figure}[h!]
\begin{mathpar} 
\inferrule[\textsc{Basic Command}]
   { 
     \ccmd{i} = \bcmd 
     \quad
     \absbsemrule{\absstate, \bcmd}{\absstate'}{} 
   }{\abssemrule{\absstate, \abscs, i}{\absstate', \abscs, i{+}1}{\top}{\top}{}}
   \and 
     \inferrule[\textsc{Goto}]
   { 
   \ccmd[\prog][\abscs]{i} = \goto \, j \quad}
   {\abssemrule{\absstate, \abscs, i}{\absstate, \abscs, j}{\top}{\top}{}}
   \\
   %
  \inferrule[\textsc{Cond. Goto - True}]
   { \ccmd{i} =  \ifgoto{\jsilexpr}{j}{k} 
     \\\\
     \absstate' = \absassume{}(\absstate, \jsilexpr) 
   }
   {\abssemrule{\absstate, \abscs, i}{\absstate', \abscs, j}{\top}{\top}{}}
  %
  \qquad
  % 
  \inferrule[\textsc{Cond. Goto - False}]
   { \ccmd{i} =  \ifgoto{\jsilexpr}{j}{k} 
       \\\\ 
      \absstate' = \absassume{}(\absstate, \neg\jsilexpr) 
   }
   {\abssemrule{\absstate, \abscs, i}{\absstate', \abscs, k}{\top}{\top}{}}
  %
  \\
   %
   \inferrule[\textsc{Normal Return}]
   {
       \abscs = (-, \absstore', \jvar, i, -) :: \abscs'  
       \\\\ 
       \absstore = \absstate.\stosel
       \quad 
       \absstate' = \absstate[\stosel \mapsto \absstore']
       \\\\
       \absstate'' = \stupdt{}(\absstate', \jvar, \absstore(\retvar))
   }  
   {\abssemrule{\absstate, \abscs, \retlab}{\absstate'', \abscs', i}{\top}{\top}{}}
     %
   \qquad 
   %
      \inferrule[\textsc{Error Return}]
   { 
       \abscs = (-, \absstore', \jvar, -, j) :: \abscs'
       \\\\ 
       \absstore = \absstate.\stosel
       \quad 
       \absstate' = \absstate[\stosel \mapsto \absstore'] 
       \\\\
        \absstate'' = \stupdt{}(\absstate', \jvar, \absstore(\errvar))
   }  
   {\abssemrule{\absstate, \abscs, \errlab}{\absstate'', \abscs', j}{\top}{\top}{}}
      \\
    \inferrule[\textsc{Procedure Call}]
   { 
    \ccmd{i} =   \jsilcall{\jvar}{\jsilexpr}{\jsilexpr_i \mid_{i = 0}^{n}}{j}
     \qquad
     \absstore = \absstate.\stosel 
     \\\\
    \evalexpr{}(\absstore, \jsilexpr) =  \pid' 
      \qquad
     \args(\pid') = \jsillist{\jvar_1, ..., \jvar_{m}} 
      \qquad
      \absval_i = \evalexpr{}(\absstore, \jsilexpr_i) \mid_{i = 0}^{n} 
     \\\\
      \absval_i = \jundefined \mid_{i = n+1}^{m}  
      \and
      \absstore' = [ \jvar_i \mapsto \absval_i \mid_{i = 0}^{m}]
   }
   {\abssemrule{\absstate, \abscs, i}{\absstate[\stosel \mapsto \absstore'],  (\pid', \absstore, \jvar, i{+}1, j) :: \abscs, 0}{\top}{\top}{}}
    \\
%
\inferrule[\textsc{Assume}]
  { 
      \ccmd{i}  = \assume(\jsilexpr) 
      \and 
     \absstate' = \absassume{}(\absstate, \jsilexpr) 
  }{\abssemrule{\absstate, \abscs, i}{\absstate', \abscs, i{+}1}{\top}{\top}{}} 
\\
\inferrule[\textsc{Assert - True}]
  { 
      \ccmd{i}  = \jassert(\jsilexpr)
      \\\\ 
       \abssat{}(\absstate, \neg \jsilexpr) = \jfalse
  }{\abssemrule{\absstate, \abscs, i}{\absstate, \abscs, i{+}1}{\top}{\top}{}} 
\qquad 
\inferrule[\textsc{Assert - False}]
  { 
      \ccmd{i}  = \jassert(\jsilexpr)
      \\\\ 
      \abssat{}(\absstate, \neg \jsilexpr) = \jtrue
  }{\abssemrule{\absstate, \abscs, i}{\absstate, \abscs, i}{\top}{\bot}{}} 
 \end{mathpar}
\caption{Abstract semantics of commands: \\{\small $\abssemrule{\absstate, \abscs, i}{\absstate', \abscs', j}{\mode}{\mode'}{}$}}
\end{figure}

\newpage
$\phantom{xxx}$
\newpage 

\subsection{Concrete Semantics}

\begin{figure}[h!]
\begin{mathpar} 
  \inferrule[\textsc{Expression Evaluation}]
  {}{
  {\begin{array}{l}
     \evalexpr{\concrete}(\store, \val) \semeq \val \quad 
  	\evalexpr{\concrete}(\store, \jvar) \semeq \store(\jvar) \quad
	\evalexpr{\concrete}(\store, \ominus \jsilexpr) \semeq \semop{\ominus} \ \evalexpr{c}(\store, \jsilexpr) \\
	%
	 \evalexpr{\concrete}(\store, \jsilexpr_1 \oplus \jsilexpr_2) \semeq \evalexpr{c}(\store, \jsilexpr_1) \ \semop{\oplus} \ \evalexpr{c}(\store, \jsilexpr_2)
  \end{array}}}
  \\
 %
     \inferrule[\textsc{Allocation}]
   { 
         (\loc, -) \not\in \domain(\jstate.\hpsel)
   }{  \absalloc{\concrete}(\jstate) \semeq (\jstate, \loc) }
 \quad
       \inferrule[\textsc{Store Selector}]
   {}{  \stosel((-, \store)) \semeq  \store}
    \quad 
 %
     \inferrule[\textsc{Store Update}]
   { 
         \store' = \store[\jvar \mapsto \val]
   }{  \stupdt{\concrete}((\heap, \store), \jvar, \val) \semeq (\heap, \store')}
 \\
 %
       \inferrule[\textsc{Positive Heap Update}]
   { 
         \heap' = \heap[(\loc, p) \mapsto \val]
         \quad 
         \val \neq \none
   }{  \hpupdt{\concrete}((\heap, \store), \loc, p, \val) \semeq  (\heap', \store)}
 \qquad
       \inferrule[\textsc{Negative Heap Update}]
   { 
         \heap = \heap' \dunion (\loc, p) \mapsto -
   }{  \hpupdt{\concrete}((\heap, \store), \loc, p, \none) \semeq  (\heap', \store)}
   \\
    %
        \inferrule[\textsc{GetCell - Found}]
   { 
         \loc = \evalexpr{c}(\store, \jsilexpr_1)
        \quad 
         p = \evalexpr{}(\store, \jsilexpr_2) 
        \\\\
       \heap = - \, \uplus \, (\loc, p) \mapsto \val
       \quad 
       r = (\loc, p, \val)
        }{  \absgetcellrule{\concrete}{(\heap, \store), \jsilexpr_1, \jsilexpr_2}{(\heap, \store), r}}
        \qquad
    \inferrule[\textsc{GetCell - Not Found}]
   { 
         \loc = \evalexpr{c}(\store, \jsilexpr_1)
        \quad 
         p = \evalexpr{}(\store, \jsilexpr_2)
        \\\\
       (\loc, p) \not\in \domain(\heap)
       \quad 
       r = (\loc, p, \none)
        }{  \absgetcellrule{\concrete}{(\heap, \store), \jsilexpr_1, \jsilexpr_2}{(\heap, \store), r}}
  %
  \\
  \inferrule[\textsc{GetDomain}]
   { 
        \loc = \evalexpr{c}(\store, \jsilexpr) 
      \and
       (\loc,-) \notin \domain (\heap') 
      \and
       \heap = \heap' \, \uplus \, \big((\loc, p_i) \mapsto \val_i \big)\mid_{i = 0}^m  
       }{  \absgetdomainfun{\concrete}((\heap, \store), \jsilexpr) \semeq \jsilset{p_1, ..., p_m}}
  %
   \\
      \inferrule[\textsc{Symbolic Value}]
   {\val \in \vals \text{ is of type } \jtype}{\absmakesymbolicrule{\concrete}{\jstate, \jtype} \semeq \val}
     \and 
  \inferrule[\textsc{Assume}]
   {
       \evalexpr{\concrete}(\jstate.\stosel, \jsilexpr) = \jtrue
   }{  \absassume{\concrete}(\jstate, \jsilexpr) \semeq  \jstate }
  	\and
    \inferrule[\textsc{Check Sat}]
   {
        \jbool = \evalexpr{\concrete}(\jstate.\stosel, \jsilexpr) 
   }{  \abssat{\concrete}(\jstate, \jsilexpr) \semeq \jbool}
  \end{mathpar}
  \caption{Concrete Semantics Rules}
\end{figure}


\subsection{Instrumented Semantics}

\begin{figure}[h!]
\begin{mathpar} 
   \inferrule[\textsc{Allocation}]
   { 
         \istate = (\iheap, \idom, \store) 
           \quad 
         (\loc, -) \not\in \domain(\istate.\hpsel) 
         \\\\
         \idom' = \idom[\loc \mapsto \{ \}]
   }{  \absalloc{\instrumented}(\istate) \semeq  ((\iheap, \idom', \store), \loc) }
   \qquad
   \inferrule[\textsc{Heap Update}]
   { 
         \istate = (\iheap, \idom, \store) \quad 
         (\loc, p) \in \domain(\iheap) 
         \\\\
         \iheap' = \iheap[(\loc, p) \mapsto \ival]
   }{  \hpupdt{\instrumented}(\istate, (\loc, p), \ival) \semeq  (\iheap', \idom, \store) }
   \\
      \inferrule[\textsc{GetCell - Found}]
   { 
         \loc = \evalexpr{\concrete}(\store, \jsilexpr_1) 
      \quad
         p = \evalexpr{\concrete}(\store, \jsilexpr_2) 
         \\\\ 
       \iheap = - \, \uplus \, (\loc, p) \mapsto \ival
       \quad 
       r = (\loc, p, \ival)
        }{  \absgetcellrule{\instrumented}{(\iheap, -, \store), \jsilexpr_1, \jsilexpr_2}{\istate, r}}
        \quad
 % 
     \inferrule[\textsc{GetCell - Not Found}]
   { 
         \loc = \evalexpr{\concrete}(\store, \jsilexpr_1) 
        \quad 
        p = \evalexpr{\concrete}(\store, \jsilexpr_2) 
       \\\\
       p \not\in \idom(\loc) 
       \quad
        \iheap' = \iheap \dunion ((\loc, p) \mapsto \none)
       \\\\ 
       \idom' = \idom[\loc \mapsto \idom(\loc) \cup \jsilset{p}]
       \ 
       r = (\loc, p, \none)
     }{  \absgetcellrule{\instrumented}{(\iheap, \idom, \store), \jsilexpr_1, \jsilexpr_2}{(\iheap', \idom', \store), r}}
  %
  \\
  \inferrule[\textsc{GetDomain}]
   { 
        \loc = \evalexpr{\concrete}(\store, \jsilexpr) 
      \and
       \iheap = \iheap' \, \uplus \, \big((\loc, p_i) \mapsto - \big)\mid_{i = 0}^m  
        \and
        %
          (\loc,-) \notin \domain (\iheap')  
        \\\\
          \jsilset{p_1, ..., p_m} = \idom(\loc)
          \and
        \forall_{0 \leq i \leq n} \, \val_i \neq \none 
         \and 
           \forall_{n < i \leq m} \, \val_i = \none 
   }{  \absgetdomainfun{\instrumented}((\iheap, \idom, \store), \jsilexpr) \semeq \jsilset{p_1, ..., p_n}}
  \end{mathpar}
  \caption{Instrumented Semantics Rules: For all the omitted functions the rules coincide with the concrete 
  semantics.}
\end{figure}

\begin{figure}[h!]
\begin{mathpar}
\inferrule[Empty Heap]{}{\interpret{\instconc}{}(\hemp) \semeq \hemp}
\qquad
\inferrule[Heap Non-$\none$-Cell]{}{
\interpret{\instconc}{}(\hcell{\loc}{p}{\val}) \semeq   \hcell{\loc}{p}{\val}
}
\\
\inferrule[Heap $\none$-Cell]
{}{
 \interpret{\instconc}{}(\hcell{\loc}{p}{\none}) \semeq \hemp 
}
\qquad
\inferrule[Heap Composition]
{
 \interpret{\instconc}{}(\iheap_i) = \heap_i \mid_{i =1,2}
}{
\interpret{\instconc}{}(\iheap_1 \dunion \iheap_2) \semeq  \heap_1 \dunion \heap_2
}
\\
\inferrule[Symbolic States]{
    \interpret{\instconc}{}(\iheap) = \heap
}{
\interpret{\instconc}{}(\iheap, \idom, \store) \semeq (\heap, \store)
}
\end{mathpar}
\caption{Instrumented State Interpretation - Erasure}
\end{figure}

\newpage
\subsection{Symbolic Semantics}


\begin{figure}[h!]
\begin{mathpar} 
 \inferrule[\textsc{Expression Evaluation}]
  {}{  
      {\begin{array}{c}
        \evalexpr{\symbolic}(\sstore, \val) \semeq \val 
        %
        \qquad
       %
        \evalexpr{\symbolic}(\sstore, \jvar) \semeq \sstore(\jvar)  
	%
	 \qquad
	 %
	\frac{
		\val =  \evalexpr{\symbolic}(\sstore, \jsilexpr) 
           }{
	    \evalexpr{\symbolic}(\sstore, \ominus \jsilexpr) \semeq \semop{\ominus} (\val)
	  } \\[10pt]
	%
	\frac{
		\sexprv =  \evalexpr{\symbolic}(\sstore, \jsilexpr) 
		\quad 
		\sexprv \not\in \vals
           }{
	    \evalexpr{\symbolic}(\sstore, \ominus \jsilexpr) \semeq \ominus \sexprv
	  }  
	  %
	  \quad 
	  % 
	  \frac{
	      \val_1 = \evalexpr{\symbolic}(\sstore, \jsilexpr_1)
	      \quad 
	      \val_2 = \evalexpr{\symbolic}(\sstore, \jsilexpr_2)  
	  }{\evalexpr{\symbolic}(\sstore, \jsilexpr_1 \oplus \jsilexpr_2) \semeq \semop{\oplus}(\val_1, \val_2)} \\[10pt]
	  %
	      \frac{
	      \sexprv_1 = \evalexpr{\symbolic}(\sstore, \jsilexpr_1)
	      \quad 
	      \sexprv_2 = \evalexpr{\symbolic}(\sstore, \jsilexpr_2)  
	      \quad 
	      \{ \sexprv_1, \sexprv_2 \} \not\subseteq \vals
	  }{\evalexpr{\symbolic}(\sstore, \jsilexpr_1 \oplus \jsilexpr_2) \semeq \sexprv_1 \oplus \sexprv_2}
	\end{array}}
	}
	\\
   %
   \inferrule[\textsc{Allocation}]
   { 
         \istate = (\sheap, \sdom, \sstore) 
           \and 
         (\loc, -) \not\in \domain(\sstate.\hpsel) 
         \and
         \sdom' = \sdom[\loc \mapsto \{ \}]
   }{  \absalloc{\instrumented}(\sstate) \semeq  ((\sheap, \sdom', \sstore), \loc) }
   %
   \\
   %
   \inferrule[\textsc{Store Selector}]
   	{}{  \stosel((-, -, \sstore, -)) \semeq \sstore}
  \and 
  \inferrule[\textsc{Store Update}]
   { 
         \sstore' = \sstore[\jvar \mapsto \val]
   }{  \stupdt{\symbolic}((\sheap, \sdom, \sstore, \pc), \jvar, \val) \semeq (\sheap, \sdom, \sstore', \pc)  }
   \\
   %
       \inferrule[\textsc{Heap Update}]
   { 
         \sheap' = \sheap[(\sloc, \sexprp) \mapsto \sexprv]
   }{  \hpupdt{\symbolic}((\sheap, \sdom, \sstore, \pc), (\sloc, \sexprp), \sexprv) \semeq (\sheap', \sdom, \sstore, \pc)' }
   %
  \\
      \inferrule[\textsc{GetCell - Found}]
   { 
        \sloc = \evalexpr{}(\sstore, \jsilexpr_1) 
        \and 
        \sexprp = \evalexpr{}(\sstore, \jsilexpr_2) 
      \and
       \sheap = - \, \uplus \, (\sloc, \sexprp') \mapsto \sexprv
   }{  \absgetcellrule{\symbolic}{(\sheap, \sdom, \sstore, \pc), \jsilexpr_1, \jsilexpr_2}{(\sheap, \sdom, \sstore, \pc \wedge (\sexprp = \sexprp')), (\sloc, \sexprp, \sexprv)}}
   \\ 
   %
     \inferrule[\textsc{GetCell - Not Found}]
   { 
         \sloc = \evalexpr{\symbolic}(\sstore, \jsilexpr_1) 
        \quad 
        \sexprp = \evalexpr{\symbolic}(\sstore, \jsilexpr_2) 
        \quad 
        \sheap' = \sheap \dunion ((\sloc, \sexprp) \mapsto \none)
       \\\\
       \sdom' = \sdom[\sloc \mapsto \sdom(\sloc) \cup \jsilset{\sexprp}]
   }{  \absgetcellrule{\symbolic}{(\sheap, \sdom, \sstore, \pc), \jsilexpr_1, \jsilexpr_2}{(\sheap', \sdom', \sstore, \pc \, \wedge \, \sexprp \not\in \sdom(\sloc)), (\sloc, \sexprp, \none)}}
 \end{mathpar}
 \caption{Symbolic Semantics Rules}
 \end{figure}


\begin{figure}[h!]
\begin{mathpar} 
\inferrule[\textsc{GetDomain}]
   { 
        \sloc = \evalexpr{\symbolic}(\sstore, \jsilexpr) 
      \qquad
       \sheap = \sheap' \, \uplus \, \big((\sloc, \sexprp_i) \mapsto \sexprv_i \big)\mid_{i = 0}^m  
        \qquad
        %
          (\sloc,-) \notin \domain (\sheap')  
        \\\\
         \pc \vdash \jsilset{\sexprp_1, ..., \sexprp_m} = \sdom(\sloc)
         \qquad
        \forall_{0 \leq i \leq n} \, \sexprv_i \neq \none 
         \qquad 
           \forall_{n < i \leq m} \, \sexprv_i = \none 
   }{  \absgetdomainfun{\symbolic}((\sheap, \sdom, \sstore, \pc), \jsilexpr) \semeq \jsilset{\sexprp_1, ..., \sexprp_n}}
  \\
   \inferrule[\textsc{Symbolic Value Creation}]
   {\svar \in \svars \text{ is of type } \jtype
     \quad 
     \svar \not\in \fv(\sstate)
    }{\absmakesymbolicrule{\symbolic}{\sstate, \jtype} = \svar}
   \and 
   \inferrule[\textsc{Assume}]
   {  
         \sexprb = \evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr)
   }{  \absassume{\symbolic}(\sstate, \jsilexpr) =  \sstate \, \wedge \, \sexprb }
   \\
    
   \qquad
    \inferrule[\textsc{Check Sat - True}]
   { 
   	\sexprb = \evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr)
         \\\\
         (\sstate.\pcsel \wedge \sexprb) \text{ SAT}
   }{  \abssat{\symbolic}(\sstate, \jsilexpr) = \jtrue}
 \qquad 
    \inferrule[\textsc{Check Sat - False}]
   { 
         \sexprb = \evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr)
         \\\\
         (\sstate.\pcsel \wedge \sexprb) \text{ UNSAT}
   }{  \abssat{\symbolic}(\sstate, \jsilexpr) = \jfalse} 
 \end{mathpar}
 \caption{Symbolic Semantics Rules - cont.}
 \end{figure}



\begin{figure}[h!]
\begin{mathpar}
\inferrule[Symbolic Expressions]
{}{
{\begin{array}{l}
\interpret{\symbconc}{\senv}(\val) \semeq \val 
%
\quad
%
\interpret{\symbconc}{\senv}(\svar) \semeq \senv(\svar)
%
\quad
%
\interpret{\symbconc}{\senv}(\unoper\ \sexpr) \semeq \semop{\unoper} (\interpret{\symbconc}{\senv}(\sexpr)) \\[5pt]
% 
\interpret{\symbconc}{\senv}(\sexpr_1 \binoper \sexpr_2) \semeq \semop{\binoper}(\interpret{\symbconc}{\senv}(\sexpr_1), \interpret{\symbconc}{\senv}(\sexpr_2)) 
\end{array}}
}
\\
%
\inferrule[Symbolic Stores]{}{
 \interpret{\symbconc}{\senv}(\storeemp) \semeq \storeemp   
\qquad
\frac{
   \val = \interpret{\symbconc}{\senv}(\sexpr) 
   \quad 
   \store = \interpret{\symbconc}{\senv}(\sstore)
}{
  \interpret{\symbconc}{\senv}((\jvar: \sexpr) \dunion \sstore) \semeq (\jvar: \val) \dunion \store 
}}
\and
\inferrule[Symbolic Contexts]{}{
\interpret{\symbconc}{\senv}(\lstemp) \semeq \lstemp
\qquad
\frac{
    \store = \interpret{\symbconc}{\senv}(\sstore)
    \quad 
    \cs = \interpret{\symbconc}{\senv}(\scs)
}{
\interpret{\symbconc}{\senv}((\pid, \sstore, \jvar, i, j) \lstcons \scs) \semeq (\pid, \store, \jvar, i, j) \lstcons \cs
}}
\\
\inferrule[Empty Heap]{}{\interpret{\symbinst}{\senv}(\hemp) \semeq \hemp}
\qquad
\inferrule[Heap Non-$\none$-Cell]{
  l = \interpret{\symbconc}{\senv}(\sexprl) \quad 
    p =  \interpret{\symbconc}{\senv}(\sexprp) \\
   v =  \interpret{\symbconc}{\senv}(\sexprv) \quad 
}{
\interpret{\symbinst}{\senv}(\hcell{\sexprl}{\sexprp}{\sexprv}) \semeq  \hcell{l}{p}{v}
}
\\
\inferrule[Heap $\none$-Cell]
{
  l = \interpret{\symbconc}{\senv}(\sexprl) \quad 
    p =  \interpret{\symbconc}{\senv}(\sexprp) 
}{
 \interpret{\symbinst}{\senv}(\hcell{\sexprl}{\sexprp}{\none}) \semeq \hcell{l}{p}{\none} 
}
\qquad
\inferrule[Heap Composition]
{
 \interpret{\symbinst}{\senv}(\sheap_i) = \iheap_i \mid_{i =1,2}
}{
\interpret{\symbinst}{}(\sheap_1 \dunion \sheap_2) \semeq  \iheap_1 \dunion \iheap_2
}
%
\\
\inferrule[Symbolic Domains]
{
   \idom(\loc) = \val  \iff  \exists \sexprl \in \domain(\sdom) \, . \,  \loc = \interpret{\symbconc}{\senv}(\sexprl) \, \wedge \, \val = \interpret{\symbconc}{\senv}(\sdom(\sexprl))
}{
\interpret{\symbinst}{\senv}(\sdom) \semeq \idom
}
\and
\inferrule[Symbolic States]{
    \interpret{\symbinst}{\senv}(\sheap) = \iheap
   \quad
    \interpret{\symbinst}{\senv}(\sdom) = \idom
    \quad
    \interpret{\symbconc}{\senv}(\sstore) = \store 
    \quad
    \interpret{\symbconc}{\senv}(\pc) = \jtrue 
}{
\interpret{\symbinst}{\senv}(\sheap, \sdom, \sstore, \pc) \semeq (\iheap, \idom, \store)
}
\end{mathpar}
\caption{Symbolic State Instrumented Interpretation}
\end{figure}


\newpage 

$\phantom{xxxx}$

\newpage

\begin{figure}[h!]
\begin{mathpar}
\inferrule[Symbolic Expressions]
{}{
{\begin{array}{l}
\proginterpret{\senv}(\val) \semeq \val 
%
\qquad
%
\proginterpret{\senv}(\svar) \semeq \senv(\svar)
%
\qquad
%
\proginterpret{\senv}(\jvar) \semeq \jvar  \\[5pt]
%
\proginterpret{\senv}(\unoper\ \jsilexpr) \semeq \unoper\ \proginterpret{\senv}(\jsilexpr) 
%
\qquad 
%
\proginterpret{\senv}(\jsilexpr_1 \binoper \jsilexpr_2) \semeq \proginterpret{\senv}(\jsilexpr_1) \binoper \proginterpret{\senv}(\jsilexpr_2) 
\end{array}}
}
\\
\inferrule[Skip]
{}{\proginterpret{\senv}(\jsilskip) \semeq \jsilskip}
\quad 
\inferrule[Property Collection]
{}{\proginterpret{\senv}(\jvar := \getfields(\jsilexpr)) \semeq \jvar := \getfields(\proginterpret{\senv}(\jsilexpr)) }
\and
\inferrule[Assignment]
{}{\proginterpret{\senv}(\jvar := \jsilexpr) \semeq \jvar := \proginterpret{\senv}(\jsilexpr) }
\quad 
\inferrule[Object Creation]
{}{\proginterpret{\senv}(\jvar := \jsilnew()) \semeq \jvar := \jsilnew()}
\and 
%
\inferrule[Property Access]
{}{\proginterpret{\senv}(\jvar := [\jsilexpr_1, \jsilexpr_2]) \semeq \jvar := [\proginterpret{\senv}(\jsilexpr_1), \proginterpret{\senv}(\jsilexpr_2)] }
\and 
\inferrule[Property Assignment]
{}{\proginterpret{\senv}([\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3) \semeq [\proginterpret{\senv}(\jsilexpr_1), \proginterpret{\senv}(\jsilexpr_2)] := \proginterpret{\senv}(\jsilexpr_3) }
\and
\inferrule[Member Check]
{}{\proginterpret{\senv}(\jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)) \semeq \jvar := \hasfield(\proginterpret{\senv}(\jsilexpr_1), \proginterpret{\senv}(\jsilexpr_2)) }
\and 
\inferrule[Goto]
{}{\proginterpret{\senv}(\goto \ i) \semeq \goto \ i }
\qquad 
\inferrule[Cond. Goto]
{}{\proginterpret{\senv}(\ifgoto{\jsilexpr}{i}{j}) \semeq \ifgoto{\proginterpret{\senv}(\jsilexpr)}{i}{j} }
\and 
\inferrule[Procedure Call]
{
    \jsilexpr = \proginterpret{\senv}(\jsilexpr)
    \qquad
   \jsilexpr_i' = \proginterpret{\senv}(\jsilexpr_i) \mid_{i=0}^n 
}{\proginterpret{\senv}(\jsilcall{\jvar}{\jsilexpr}{\jsilexpr_i\!\mid_{i=0}^n}{j}) \semeq \jsilcall{\jvar}{\jsilexpr'}{\jsilexpr_i'\!\mid_{i=0}^n}{j} }
\and 
\inferrule[Assume]
{
 \jsilexpr' = \proginterpret{\senv}(\jsilexpr)
}{\proginterpret{\senv}(\assume(\jsilexpr)) \semeq  \assume(\jsilexpr') }
\and 
\inferrule[Assert]
{
  \jsilexpr' = \proginterpret{\senv}(\jsilexpr)
}{\proginterpret{\senv}(\jassert(\jsilexpr)) \semeq  \jassert(\jsilexpr') }
\end{mathpar}
\caption{Symbolic Program Interpretation}
\end{figure}


\subsection{Linking the Semantics}

\begin{figure}[h!]
\begin{mathpar}
\inferrule[Empty Heap]{}{\interpret{\symbinst}{\senv}(\hemp) \semeq \hemp, \emptyset}
\qquad
\inferrule[Heap Non-$\none$-Cell]{
  l = \interpret{\symbconc}{\senv}(\sexprl) \quad 
    p =  \interpret{\symbconc}{\senv}(\sexprp) \\
   v =  \interpret{\symbconc}{\senv}(\sexprv) \quad 
}{
\interpret{\symbconc}{\senv}(\hcell{\sexprl}{\sexprp}{\sexprv}) \semeq  \hcell{l}{p}{v}, \emptyset
}
\\
\inferrule[Heap $\none$-Cell]
{
  l = \interpret{\symbconc}{\senv}(\sexprl) \quad 
    p =  \interpret{\symbconc}{\senv}(\sexprp) 
}{
 \interpret{\symbconc}{\senv}(\hcell{\sexprl}{\sexprp}{\none}) \semeq \hemp, \jsilset{ (l, p) }
}
\\
\inferrule[Heap Composition]
{
 \interpret{\symbconc}{\senv}(\sheap_i) = \heap_i, \hdom_i \mid_{i =1,2}
}{
\interpret{\symbconc}{}(\sheap_1 \dunion \sheap_2) \semeq  \heap_1 \dunion \heap_2, \hdom_1 \dunion \hdom_2
}
%
\\
\inferrule[Symbolic Domains]
{
  \hdom =  \{ (l, p) \mid \sexprl \in \domain(\sdom) \, \wedge \, l = \interpret{\symbconc}{\senv}(\sexprl) 
                 \, \wedge \, p \not\in \interpret{\symbconc}{\senv}(\sdom(\sexprl)) \}
}{
\interpret{\symbconc}{\senv}(\sdom) 
    \semeq \hdom 
}
\and
\inferrule[Symbolic States]{
   \interpret{\symbconc}{\senv}(\sheap) = \heap, \hdom_1
   \quad
   \interpret{\symbconc}{\senv}(\sdom) = \hdom_2
   \\\\
   \interpret{\symbconc}{\senv}(\sstore) = \store
    \quad 
    \interpret{\symbconc}{\senv}(\pc) = \jtrue 
    \quad 
    \hdom = \domain(h) \cup \hdom_1 \cup \hdom_2 
}{
\interpret{\symbconc}{\senv}(\sheap, \sdom, \sstore, \pc) \semeq \{ (\heap, \store, \heap_f) \mid \domain(\heap_f) \cap \hdom = \emptyset \} 
}

\end{mathpar}
\end{figure}


\section{Proof --- Section~\ref{sec:jsil:symb:exec}}

\subsection{Instrumented Semantics}

% Frame Proofs
\subsubsection{Frame Property}

\begin{lemma}[Heap Update - Frame]\label{lemma:frame:heap:update}
$$
\begin{array}{l}
\hpupdt{\instrumented}(\istate, \loc, p, \ival)  = \istate' \implies 
    \hpupdt{\instrumented}(\istate \dunion \heap_f, \loc, p, \ival) = \istate' \dunion \heap_f
\end{array}
$$
\end{lemma}
\begin{proof}
Immediate from the definition of $\hpupdt{\instrumented}$, 
noting that $\hpupdt{\instrumented}$ is only defined when $(\loc, p)$ exists in the 
domain of $\istate.\hpsel$. 
\end{proof}


\begin{lemma}[Store Update - Frame]\label{lemma:frame:store:update}
$$
\begin{array}{l}
 \stupdt{\instrumented}(\istate, \jvar, \val) = \istate'  \implies 
      \stupdt{\instrumented}(\istate \dunion \iheap_f, \jvar, \val) = \istate' \dunion \iheap_f
\end{array}
$$
\end{lemma}
\begin{proof}
Immediate from the definitions of $\stupdt{\instrumented}$.
\end{proof}


\begin{lemma}[Assume - Frame]\label{lemma:frame:assume}
$$
\begin{array}{l}
\absassume{\instrumented}(\istate, \jsilexpr) =  \istate' 
    \implies \absassume{\instrumented}(\istate \dunion \iheap_f, \jsilexpr) =  \istate' \dunion \iheap_f
\end{array}
$$
\end{lemma}
\begin{proof}
Immediate from the definition of $\absassume{\instrumented}$.
\end{proof}

\begin{lemma}[Check Sat -Frame]\label{lemma:frame:sat}
$$
\begin{array}{l}
      \abssat{\instrumented}(\istate, \jsilexpr) =  \jbool 
          \implies 
               \abssat{\instrumented}(\istate \dunion \iheap_f, \jsilexpr) =  \jbool 
\end{array}
$$
\end{lemma}
\begin{proof}
Immediate from the definition of $\abssat{\instrumented}$.
\end{proof}


\begin{lemma}[GetCell - Frame]\label{frame:getcell}
$$
\begin{array}{l}
% 
\absgetcellrule{\instrumented}{\istate, \jsilexpr_1, \jsilexpr_2}{\istate', (\loc, p, \ival)} \\ \quad \quad
  \implies \absgetcellrule{\instrumented}{\istate \dunion \iheap_f, \jsilexpr_1, \jsilexpr_2}{\istate' \dunion \iheap_f, (\loc, p, \ival)} \end{array}
$$
\end{lemma}
\begin{proof}
Suppose $\absgetcellrule{\instrumented}{\istate, \jsilexpr_1, \jsilexpr_2}{\istate', (\loc, p, \ival)}$ (\hyp{1}). 
We proceed by case analysis on the rule used to derive \hyp{1}. 
\vspace{3pt} 

\noindent \prooflab{GetCell - Found} 
We conclude that: 
$\loc = \evalexpr{\concrete}(\store, \jsilexpr_1)$ (\ieq{1}), 
$p = \evalexpr{\concrete}(\store, \jsilexpr_2)$ (\ieq{2}), and 
$\istate.\hpsel = - \, \uplus \, (\loc, p) \mapsto \ival$ (\ieq{3}). 
From \ieq{3}, we conclude that $\istate.\hpsel \dunion \iheap_f =   - \, \uplus \, (\loc, p) \mapsto \ival \dunion \iheap_f$ (\ieq{4}). 
From \ieq{1}, \ieq{2}, and \ieq{4}, the result follows. 
\vspace{5pt}

\noindent \prooflab{GetCell - Not Found} 
We conclude that: 
$\loc = \evalexpr{\concrete}(\store, \jsilexpr_1)$ (\ieq{1}), 
$p = \evalexpr{\concrete}(\store, \jsilexpr_2)$ (\ieq{2}), and 
$p \not\in \istate.\domsel(\loc)$ (\ieq{3}). 
From \ieq{3}, we conclude that $p \not\in (\istate \dunion \iheap_f).\domsel(\loc)$ (\ieq{4}). 
From \ieq{1}, \ieq{2}, and \ieq{4}, the result follows. 
\end{proof}



\begin{lemma}[GetDomain - Frame]\label{lemma:getdomain:frame}
$$
  \absgetdomainfun{\instrumented}(\istate, \jsilexpr) = \val  
  \implies 
      \absgetdomainfun{\instrumented}(\istate \dunion \iheap_f, \jsilexpr) = \val  
$$
\end{lemma}
\begin{proof}
Suppose that $\absgetdomainfun{\instrumented}(\istate, \jsilexpr) = \val$ (\hyp{1}). 
From \hyp{1}, we conclude that there is a location $\loc$, an instrumented heap $\iheap'$, 
properties $p_i \mid_{i=0}^m$ such that: 
$\loc = \evalexpr{\concrete}(\store, \jsilexpr)$ (\ieq{1}), 
$\iheap = \iheap' \, \uplus \, \big((\loc, p_i) \mapsto - \big)\mid_{i = 0}^m$ (\ieq{2}), 
$(\loc,-) \notin \domain (\iheap')$ (\ieq{3}), 
$\jsilset{p_1, ..., p_m} = \idom(\loc)$ (\ieq{4}), 
$\forall_{0 \leq i \leq n} \, \val_i \neq \none$ (\ieq{5}), and
$\forall_{n < i \leq m} \, \val_i = \none$ (\ieq{6}), 
and $\val = \jsilset{p_1, ..., p_n}$ (\ieq{7}), 
where $\istate =  (\iheap, \idom, \store)$ (\ieq{8}). 
Since $\istate \dunion \iheap_f$ is defined, we conclude that, from \ieq{4}, that 
$(\loc, -) \not\in \iheap_f$ (\ieq{9}). 
Hence, we can rewrite \ieq{2} and \ieq{3} as follows: 
$\iheap \dunion \iheap_f = (\iheap' \dunion \iheap_f) \, \uplus \, \big((\loc, p_i) \mapsto - \big)\mid_{i = 0}^m$ (\ieq{10}) and 
$(\loc,-) \notin \domain (\iheap' \dunion \iheap_f)$ (\ieq{11}). 
From  \ieq{1}, \ieq{4}-\ieq{7}, and \ieq{10}-\ieq{11}, the result follows. 
\end{proof}

\begin{lemma}[Basic Commands - Frame]\label{lemma:frame:basic:commands}
$$
\begin{array}{l}
\absbsemrule{\istate, \bcmd}{\istate'}{\instrumented} 
     \implies 
           \absbsemrule{\istate \dunion \iheap_f, \bcmd}{\istate' \dunion \iheap_f}{\instrumented} 
\end{array}
$$
\end{lemma}
\begin{proof}
By case analysis on the rule used to derive $\absbsemrule{\istate, \bcmd}{\istate'}{\instrumented}$. 
\end{proof}

\begin{lemma}[Control Flow Commands - Frame]\label{frame:control:flow:cmds}
$$
\begin{array}{l} 
\abssemrule{\istate, \cs, i}{\istate', \cs', j}{\mode}{\mode'}{\instrumented} \\ \quad \quad
     \implies
        \abssemrule{\istate \dunion \iheap_f, \cs, i}{\istate' \dunion \iheap_f, \cs', j}{\mode}{\mode'}{\instrumented} 
 \end{array}
$$
\end{lemma}
\begin{proof}
By case analysis on the rule used to derive $\abssemrule{\istate, \cs, i}{\istate', \cs', j}{\mode}{\mode'}{\instrumented}$. 
\end{proof}

\begin{temax}[Frame Proper of Instrumented Semantics- Theorem~\ref{teo:frame:property}]
$$
\begin{array}{l} 
\transabssemrule{\istate, \cs, i}{\istate', \cs', j}{\mode}{\mode'}{\instrumented} \\ \quad \quad 
   \Rightarrow \transabssemrule{\istate \dunion \iheap_f, \cs, i}{\istate' \dunion \iheap_f, \cs', j}{\mode}{\mode'}{\instrumented} 
 \end{array}
$$
\end{temax}
\begin{proof}
By induction on the derivation of $\transabssemrule{\istate, \cs, i}{\istate', \cs', j}{\mode}{\mode'}{\instrumented}$. 
\end{proof}


%%
%%
%% Erasure Proofs
%%
%%

\subsubsection{Erasure}

\begin{lemma}[Heap Update - Erasure]\label{lemma:erasure:heap:update}
$$
\begin{array}{l}
\jstate = \interpret{\instconc}{}(\istate)  
   \implies \hpupdt{\concrete}(\jstate, \loc, p, \val) = \interpret{\instconc}{}(\hpupdt{\instrumented}(\istate, \loc, p, \val)) \\[3pt]
%       
\jstate = \interpret{\instconc}{}(\istate)
  \implies \hpupdt{\concrete}(\jstate, \loc, p, \none) = \interpret{\instconc}{}(\hpupdt{\instrumented}(\istate, \loc, p, \none)) 
\end{array}
$$
\end{lemma}
\begin{proof}
Immediate from the definitions of $\hpupdt{\concrete}$ and $\hpupdt{\instrumented}$.
\end{proof}


\begin{lemma}[Store Update - Erasure]\label{lemma:erasure:store:update}
$$
\begin{array}{l}
 \stupdt{\concrete}(\interpret{\instconc}{}(\istate), \jvar, \val) = \interpret{\instconc}{}(\stupdt{\instrumented}(\istate, \jvar, \val)) 
\end{array}
$$
\end{lemma}
\begin{proof}
Immediate from the definitions of $\stupdt{\concrete}$ and $\stupdt{\instrumented}$.
\end{proof}

\begin{lemma}[Assume - Erasure]\label{lemma:erasure:assume}
$$
\begin{array}{l}
\interpret{\instconc}{}(\absassume{\instrumented}(\istate, \jsilexpr)) = \absassume{\concrete}( \interpret{\instconc}{}(\istate), \jsilexpr) 
\end{array}
$$
\end{lemma}
\begin{proof}
Immediate from the definitions of $\absassume{\concrete}$ and $\absassume{\instrumented}$.
\end{proof}

\begin{lemma}[Check Sat -Erasure]\label{lemma:erasure:sat}
$$
\begin{array}{l}
      \abssat{\instrumented}(\istate, \jsilexpr) =  \abssat{\concrete}(\interpret{\instconc}{}(\istate), \jsilexpr) 
\end{array}
$$
\end{lemma}
\begin{proof}
Immediate from the definitions of $\abssat{\concrete}$ and $\abssat{\instrumented}$.
\end{proof}

\begin{lemma}[GetCell - Erasure]\label{erasure:getcell}
$$
\begin{array}{l}
\jstate = \interpret{\instconc}{}(\istate)  \ \wedge \ 
\absgetcellrule{\instrumented}{\istate, \jsilexpr_1, \jsilexpr_2}{\istate', (\loc, p, \ival)} \\ \quad \quad
  \implies \absgetcellrule{\concrete}{\jstate, \jsilexpr_1, \jsilexpr_2}{\jstate', (\loc, p, \ival)} 
     \ \wedge \ \jstate' = \interpret{\instconc}{}(\istate')
\end{array}
$$
\end{lemma}
\begin{proof}
For clarity, we name the hypotheses: $\jstate = \interpret{\instconc}{}(\istate)$ (\hyp{1})
and $\absgetcellrule{\instrumented}{\istate, \jsilexpr_1, \jsilexpr_2}{\istate', (\loc, p, \ival)}$ (\hyp{2}).
From \hyp{2}, we conclude that there is a location $\loc$ and a property $p$, such 
that $\loc = \evalexpr{\concrete}(\store, \jsilexpr_1)$ (\ieq{1}) and 
$p = \evalexpr{\concrete}(\store, \jsilexpr_2)$ (\ieq{2}). 
We  proceed by case analysis on the rule used to derive \hyp{2}. 
 \vspace{3pt} 
 
  \noindent \prooflab{GetCell - Found} 
   It follows that $\istate.\hpsel = - \, \uplus \, (\loc, p) \mapsto \ival$ (\ieq{2}). 
   We have two cases to consider: $\ival = \none$ and $\ival \neq \none$. 
   \begin{itemize}
        \item Suppose $\ival = \none$ (\ieq{3}). It follows from \hyp{1} and \ieq{3} 
                 that $(\loc, p) \not\in \domain(\jstate)$ (\ieq{4}). 
                 We conclude from \ieq{1}, \ieq{2}, and \ieq{4} that 
                 $$
                   \absgetcellrule{\concrete}{\jstate, \jsilexpr_1, \jsilexpr_2}{\jstate, (\loc, p, \none)}
                 $$ establishing the first claim. 
        %
        \item Suppose $\ival \neq \none$ (\ieq{5}). It follows from \hyp{1} and \ieq{3}, 
                 $\jstate.\hpsel(\loc, p) = \ival$ (\ieq{6}). 
                  We conclude from \ieq{1}, \ieq{2}, and \ieq{6} that 
                   $$
                   \absgetcellrule{\concrete}{\jstate, \jsilexpr_1, \jsilexpr_2}{\jstate, (\loc, p, \none)}
                 $$ establishing the first claim.                  
   \end{itemize}
   Noticing that in both cases $\istate' = \istate$ and $\jstate' = \jstate$, we conclude the
   second claim. 
   \vspace{3pt}
   
    \noindent \prooflab{GetCell - Not Found} It follows that $p \not\in \istate.\domsel(\loc)$ (\ieq{7}) and 
       $\istate' = (\iheap', \idom', \store)$ (\ieq{8}), where: 
       $\iheap' = \istate.\hpsel \dunion ((\loc, p) \mapsto \none)$ (\ieq{9}) and $\idom' = \istate.\domsel[\loc \mapsto \istate.\domsel(\loc) \cup \jsilset{p}]$ (\ieq{10}). 
       From \ieq{7}, we conclude that $(\loc, p) \not\in \domain(\istate.\hpsel)$ (\ieq{11}).
       %
       From \hyp{1} and \ieq{11}, it follows that $(\loc, p) \not\in \domain(\jstate.\hpsel)$ (\ieq{12}). 
       From \ieq{1}, \ieq{2}, and \ieq{12}, we conclude that: 
       $$
          \absgetcellrule{\concrete}{\jstate, \jsilexpr_1, \jsilexpr_2}{\jstate, (\loc, p, \none)}
       $$
       establishing the first claim of the result. Noticing that $\jstate' = \jstate$ and 
       $\interpret{\symbconc}{}(\istate') = \interpret{\symbconc}{}(\istate)$, we 
       establish the second claim of the lemma.
\end{proof}


\begin{lemma}[GetDomain - Erasure]\label{lemma:getdomain:erasure}
$$
\jstate = \interpret{\instconc}{}(\istate) \ \wedge \ 
  \absgetdomainfun{\instrumented}(\istate, \jsilexpr) = \val  
  \implies \absgetdomainfun{\concrete}(\jstate, \jsilexpr) = \val
$$
\end{lemma}
\begin{proof}
Suppose that $\jstate = \interpret{\instconc}{}(\istate)$ (\hyp{1}) and 
$\absgetdomainfun{\instrumented}(\istate, \jsilexpr) = \val$ (\hyp{2}). 
From \hyp{2}, we conclude that $\loc = \evalexpr{\concrete}(\store, \jsilexpr)$ (\ieq{1}), 
$\iheap = \iheap' \, \uplus \, \big((\loc, p_i) \mapsto - \big)\mid_{i = 0}^m$ (\ieq{2}), 
$(\loc,-) \notin \domain (\iheap')$ (\ieq{3}), 
$\jsilset{p_1, ..., p_m} = \idom(\loc)$ (\ieq{4}), 
$\forall_{0 \leq i \leq n} \, \val_i \neq \none$ (\ieq{5}), and
$\forall_{n < i \leq m} \, \val_i = \none$ (\ieq{6}), 
and $\val = \jsilset{p_1, ..., p_n}$ (\ieq{7}), 
where $\istate =  (\iheap, \idom, \store)$ (\ieq{8}). 
From \ieq{3}, we conclude that $(\loc,-) \notin \domain (\interpret{\instconc}{}(\iheap'))$ (\ieq{9}).
From \ieq{2}, \ieq{5}, and \ieq{6}, it follows that 
$$
\interpret{\instconc}{}(\big((\loc, p_i) \mapsto - \big)\mid_{i = 0}^m)
   = \big((\loc, p_i) \mapsto - \big)\mid_{i = 0}^n \text{ (\ieq{10})}
$$
From \ieq{7}, \ieq{9}, and \ieq{10}, we conclude that: 
$
\absgetdomainfun{\concrete}(\jstate, \jsilexpr) = \val
$
establishing the result. 
\end{proof}

\begin{lemma}[Basic Commands - Erasure]\label{lemma:erasure:basic:commands}
$$
\begin{array}{l}
\absbsemrule{\istate, \bcmd}{\istate'}{\instrumented} 
    \, \wedge \, \jstate = \interpret{\instconc}{}(\istate) \\ \quad \quad
     \implies 
        \exists \, \jstate' \, . \, \absbsemrule{\jstate, \bcmd}{\jstate'}{\concrete} \, \wedge \, 
            \jstate' = \interpret{\instconc}{}(\istate')
\end{array}
$$
\end{lemma}
\begin{proof}
Suppose $\absbsemrule{\istate, \bcmd}{\istate'}{\instrumented}$ (\hyp{1}) and 
$\jstate = \interpret{\instconc}{}(\istate)$ (\hyp{2}).
We proceed by case analysis on the rule used to derive \hyp{1}. 
\vspace{3pt}

\noindent \prooflab{Skip} It follows that $\absbsemrule{\istate, \jsilskip}{\istate}{\instrumented}$ (\ieq{1}) and 
$\absbsemrule{\jstate, \jsilskip}{\jstate}{\concrete}$ (\ieq{2}). 
From \hyp{1} and \ieq{1}, we conclude that $\istate' = \istate$ (\ieq{3}). 
From \hyp{2} and \ieq{3}, it follows that $\jstate = \interpret{\instconc}{}(\istate')$ (\ieq{4}). 
Letting $\jstate' = \jstate$, the result follows from \ieq{2} and \ieq{4}. 
\vspace{5pt}


\noindent \prooflab{Property Collection} From \hyp{1}, it follows that 
$$
\absbsemrule{\istate, \jvar := \getfields(\jsilexpr)}{\istate'}{\instrumented} \text{ (\ieq{1})}
$$ 
From \ieq{1}, we conclude that there is a value $\val$ such that 
$\absgetdomainfun{\instrumented}(\istate, \jsilexpr) = \val$ (\ieq{2}) 
and $\istate' = \stupdt{\symbolic}(\istate, \jvar, \val)$ (\ieq{3}).  
Applying Lemma~\ref{lemma:getdomain:erasure} to \hyp{2} and \ieq{2}, we conclude that 
$\absgetdomainfun{\concrete}(\jstate, \jsilexpr) = \val$ (\ieq{4}). 
Applying Lemma~\ref{lemma:erasure:store:update} to \ieq{4}, it follows that 
$\interpret{\instconc}{}(\istate') = \stupdt{\concrete}(\jstate, \jvar, \val)$ (\ieq{5}). 
From \ieq{4} and \ieq{5}, we conclude that $\absbsemrule{\jstate, \jvar := \getfields(\jsilexpr)}{\interpret{\instconc}{}(\istate')}{\concrete}$, 
establishing the result. 
\vspace{5pt}

 \noindent \prooflab{Assignment} From \hyp{1}, it follows that $\absbsemrule{\istate, \jvar := \jsilexpr}{\istate'}{\instrumented}$ (\ieq{1}). 
From \ieq{1}, we conclude that there is a value $\val$ such that 
$\val = \evalexpr{\concrete}(\istate.\stosel, \jsilexpr)$ (\ieq{2}) and $\istate' = \stupdt{\concrete}(\istate, \jvar, \val)$ (\ieq{3}). 
%
Applying Lemma~\ref{lemma:erasure:store:update} to \ieq{3}, it follows
that $ \interpret{\instconc}{}(\istate') = \stupdt{\concrete}(\jstate, \jvar, \val)$ (\ieq{4}).
% 
Combining \ieq{2} and \ieq{4}, we conclude that 
$\absbsemrule{\jstate,\jvar := \jsilexpr}{\interpret{\instconc}{}(\istate')}{\concrete}$, establishing the result. 
\vspace{5pt}
%

 \noindent \prooflab{Object Creation} From \hyp{1}, it follows that $\absbsemrule{\istate, \jvar := \jsilnew()}{\istate'}{\instrumented}$ (\ieq{1}). 
From \ieq{1}, we conclude that there is a location $\loc$ such that $(\loc, -) \not\in \domain(\istate.\hpsel)$ (\ieq{2}) and 
$\istate' = \hpupdt{\instrumented}(\istate'', \loc, \protop, \jnull)$ (\ieq{3}), 
$\istate'' = \istate[\domsel \mapsto \{ \}]$ (\ieq{4}). 
From \hyp{2} and \ieq{2}, we conclude that $\loc \not\in \domain(\jstate.\hpsel)$ (\ieq{5}). 
Noting that $\interpret{\instconc}{}(\istate') = \interpret{\instconc}{}(\istate'')$, 
we can apply Lemma~\ref{lemma:soundiness:heap:update} to \ieq{3} to conclude that 
$$\interpret{\instconc}{}(\istate') = \hpupdt{\concrete}(\jstate, \loc, \protop, \jnull) \text{ (\ieq{6})}$$ 
Combining \ieq{5} and \ieq{6}, the result follows. 
\vspace{5pt}

\noindent \prooflab{Property Access} From \hyp{1}, it follows that 
$$\absbsemrule{\istate, \jvar := \jvar := [\jsilexpr_1, \jsilexpr_2]}{\istate'}{\instrumented} \text{ (\ieq{1})}$$
From \ieq{1}, we conclude that there is a symbolic expression $\val$ and a symbolic state $\istate''$ such that 
$\absgetcellrule{\instrumented}{\istate, \jsilexpr_1, \jsilexpr_2}{\istate'', (-, -, \val)}$ (\ieq{2}) 
and $\istate' = \stupdt{\instrumented}(\istate'', \jvar, \val)$ (\ieq{3}). 
Applying Lemma~\ref{erasure:getcell} to \ieq{2}, we conclude that 
there is a concrete state $\jstate''$ such that  
$\absgetcellrule{\concrete}{\jstate, \jsilexpr_1, \jsilexpr_2}{\jstate'', (-, -, \val)}$ (\ieq{4})
and $\jstate'' = \interpret{\instconc}{}(\istate'')$ (\ieq{5}). 
Applying Lemma~\ref{lemma:erasure:store:update} to \ieq{3} and \ieq{5}, 
it follows that 
$$
\interpret{\instconc}{}(\istate') = \stupdt{\concrete}(\jstate'', \jvar, \val) \text{ \ieq{6}}
$$
Combining \ieq{2} and \ieq{6}, the result follows. 
\vspace{5pt}

 %
\noindent \prooflab{Property Assignment}
From \hyp{1}, it follows that 
$$\absbsemrule{\istate, [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3}{\istate'}{\instrumented} \text{ (\ieq{1})}$$
From \ieq{1}, we conclude that there is a location $\loc$, a property $p$, and an instrumented $\istate''$ such that 
$$\absgetcellrule{\instrumented}{\istate, \jsilexpr_1, \jsilexpr_2}{\istate'', (\loc, p, -)} \text{ (\ieq{2})}$$
$\evalexpr{\concrete}(\istate''.\stosel, \jsilexpr_3) = \val$ (\ieq{3}),  
$\istate' = \hpupdt{\instrumented}(\istate'', \loc, p, \val)$ (\ieq{4}). 
%
Applying Lemma~\ref{erasure:getcell} to \ieq{2}, we conclude that
there is an instrumented state $\istate''$, such that 
$\absgetcellrule{\concrete}{\jstate, \jsilexpr_1, \jsilexpr_2}{\jstate'', (\loc, p, -)}$ (\ieq{5}) 
and $\jstate'' = \interpret{\instconc}{}(\istate'')$ (\ieq{6}). 
%
Applying Lemma~\ref{lemma:erasure:heap:update} to \ieq{4} and \ieq{6}, we conclude that 
$\interpret{\instconc}{}(\istate') = \hpupdt{\concrete}(\jstate'', \loc, p, \val)$ (\ieq{7}).
%
Combining \ieq{5} and \ieq{7}, the result follows. 
\vspace{5pt}


\noindent \prooflab{Property Deletion}
From \hyp{1}, it follows that 
$$\absbsemrule{\istate, \jsildelete(\jsilexpr_1, \jsilexpr_2)}{\istate'}{\instrumented} \text{ (\ieq{1})}$$
From \ieq{1}, we conclude that there is a location $\loc$, property $\sexprp$, value $\val$, and instrumented state $\istate''$ such that 
$$\absgetcellrule{\instrumented}{\istate, \jsilexpr_1, \jsilexpr_2}{\istate'', (\loc, p, \val)} \text{ (\ieq{2})}$$ 
and 
$\istate' = \hpupdt{\instrumented}(\istate'', \loc, p, \none)$ (\ieq{3}). 
%
Applying Lemma~\ref{erasure:getcell} to \ieq{2}, we conclude that
there exists a concrete state $\jstate''$ such that
$$\absgetcellrule{\concrete}{\jstate, \jsilexpr_1, \jsilexpr_2}{\jstate'', (\loc, p, \val)} \text{ (\ieq{4})}$$ 
and 
$\jstate'' = \interpret{\instconc}{}(\istate'')$ (\ieq{5}). 
%
Applying Lemma~\ref{lemma:erasure:heap:update} to \ieq{3} and \ieq{5}, 
we conclude that $\interpret{\instconc}{}(\istate') = \hpupdt{\concrete}(\jstate'', \loc, p, \none)$ (\ieq{6}). 
Combining \ieq{4} and \ieq{6}, the result follows. 
\vspace{5pt} 

The remaining cases are proven analogously. 
\end{proof}


\begin{lemma}[Control Flow Commands - Erasure]\label{erasure:control:flow:cmds}
$$
\begin{array}{l} 
\abssemrule{\istate, \cs, i}{\istate', \cs', j}{\mode}{\mode'}{\instrumented} 
     \, \wedge \, \jstate = \interpret{\symbconc}{}(\istate) \\ \quad \quad
     \implies 
        \exists \, \jstate' \, . \, \abssemrule{\jstate, \cs, i}{\jstate', \cs', j}{\mode}{\mode'}{\concrete} 
         \, \wedge \, 
            \jstate' = \interpret{\instconc}{}(\istate') 
 \end{array}
$$
\end{lemma}
\begin{proof}
Suppose $\abssemrule{\istate, \cs, i}{\istate', \cs', j}{\mode}{\mode'}{\instrumented}$ (\hyp{1}) and 
$\jstate = \interpret{\symbconc}{}(\istate)$ (\hyp{2}).
We proceed by case analysis on the rule used to derive \hyp{1}. 
\vspace{3pt}

\noindent \prooflab{Basic Command} 
From \hyp{1}, it follows that $\abssemrule{\istate, \cs, i}{\istate', \cs, i{+}1}{\top}{\top}{\instrumented}$ (\ieq{1}), 
$\ccmd[\prog][\cs]{i} = \bcmd$ (\ieq{2}), and $\absbsemrule{\istate, \bcmd}{\istate'}{\instrumented}$ (\ieq{3}). 
Applying Lemma~\ref{lemma:erasure:basic:commands} to \ieq{3} and \hyp{2}, we conclude that 
there is a concrete state $\jstate'$ such that: 
$\absbsemrule{\jstate, \bcmd}{\jstate'}{\concrete}$ (\ieq{4}) and $\jstate' = \interpret{\instconc}{}(\istate')$ (\ieq{5}). 
From \ieq{2} and \ieq{4}, we conclude that $\abssemrule{\jstate, \cs, i}{\jstate', \cs, i{+}1}{\top}{\top}{\concrete}$ (\ieq{6}). 
 Combining \ieq{5} and \ieq{6}, we obtain the result.  
 \vspace{5pt}


\noindent \prooflab{Cond. Goto - True} 
From \hyp{1}, it follows that $\abssemrule{\istate, \cs, i}{\istate', \cs, j}{\top}{\top}{\instrumented}$ (\ieq{1}), 
$\ccmd[\prog][\cs]{i} =  \ifgoto{\jsilexpr}{j}{k}$ (\ieq{2}), and 
$ \istate' = \absassume{\instrumented}(\istate, \jsilexpr)$ (\ieq{3}). 
Applying Lemma~\ref{lemma:erasure:assume} to \hyp{2} and \ieq{3}, we conclude that 
$\interpret{\instconc}{}(\istate') = \absassume{\concrete}(\jstate, \jsilexpr)$ (\ieq{4}).  
From \ieq{2} and \ieq{4}, we conclude that 
$$\abssemrule{\jstate, \cs, i}{\interpret{\symbconc}{}(\istate'), \cs, i{+}1}{\top}{\top}{\concrete} \text{ (\ieq{5})}$$
from which the result follows.      
 \vspace{5pt}
 
 
\noindent \prooflab{Cond. Goto - False} Similar to \prooflab{Cond. Goto - True}. 
\vspace{5pt}

 
\noindent \prooflab{Goto} From \hyp{1}, it follows that $\abssemrule{\istate, \cs, i}{\istate, \cs, j}{\top}{\top}{\instrumented}$ (\ieq{1}),   
where $\ccmd[\prog][\cs]{i} = \goto \, j$ (\ieq{2}). 
From \ieq{2}, we conclude that 
$$\abssemrule{\jstate, \cs, i}{\jstate, \cs, j}{\top}{\top}{\concrete} \text{ (\ieq{3})}$$
Combining \hyp{2} and \ieq{3}, we obtain the result. 
 \vspace{5pt}
 
 
\noindent \prooflab{Normal Return}
From \hyp{1}, it follows that $\abssemrule{\istate, \cs, \retlab}{\istate', \cs', i}{\top}{\top}{\symbolic}$ (\ieq{1}), 
$\cs = (-, \store', \jvar, i, -) :: \cs'$ (\ieq{2}), $\store = \istate.\stosel$ (\ieq{3}), 
and 
$$\istate' = \stupdt{\instrumented}(\istate[\stosel \mapsto \store'], \jvar, \store(\retvar)) \text{ (\ieq{4})}$$
From \ieq{3}, we conclude that $\jstate.\stosel = \store$ (\ieq{5}). 
Applying Lemma~\ref{lemma:erasure:store:update} to \ieq{4} and \ieq{5}, we conclude that 
$$
\interpret{\instconc}{}(\istate') = \stupdt{\concrete}(\jstate[\stosel \mapsto \store'], \jvar, \jstate.\stosel(\retvar)) 
 \text{ (\ieq{6})}
$$ 
From \ieq{2} and \ieq{6}, we conclude that 
$$\abssemrule{\jstate, \cs, \retlab}{\interpret{\instconc}{}(\istate'), \cs', i}{\top}{\top}{\concrete}$$ 
establishing the result. 
 \vspace{5pt}

\noindent \prooflab{Error Return}
Similar to \prooflab{Normal Return}. 
 \vspace{5pt}
 
 
\noindent \prooflab{Procedure Call}
From \hyp{1}, it follows that $\abssemrule{\istate, \cs, i}{\istate', \cs', 0}{\top}{\top}{\instrumented}$ (\ieq{1}), 
$\ccmd[\prog][\cs]{i} =\jsilcall{\jvar}{\jsilexpr}{\jsilexpr_i \mid_{i = 0}^{n}}{j}$ (\ieq{2}), 
$\pid' = \evalexpr{\concrete}(\istate.\stosel, \jsilexpr)$ (\ieq{3}), 
$\args(\prog, \pid') = \jsillist{\jvar_1, ..., \jvar_{m}}$ (\ieq{4}), 
$\val_i = \evalexpr{\concrete}(\sstate.\stosel, \jsilexpr_i) \mid_{i = 0}^{n}$ (\ieq{5}), 
$\val_i = \jundefined \mid_{i = n+1}^{m}$ (\ieq{6}), 
$\store' = [\jvar_i \mapsto \val_i \mid_{i = 0}^{m}]$ (\ieq{7}),  
$\cs' = (\pid', \istate.\stosel, \jvar, i{+}1, j) :: \cs$ (\ieq{8}), and 
$\istate' = \istate[\stosel \mapsto \store']$ (\ieq{9}). 
From \hyp{2}, we conclude that $\istate.\stosel = \jstate.\stosel$ (\ieq{10}), from 
which it follows that 
$\pid' = \evalexpr{\concrete}(\jstate.\stosel, \jsilexpr)$ (\ieq{11})
and 
$\val_i = \evalexpr{\concrete}(\jstate.\stosel, \jsilexpr_i) \mid_{i = 0}^{n}$ (\ieq{12}). 
From \ieq{2}, \ieq{11}, \ieq{4}, \ieq{12}, \ieq{6}, \ieq{7}, \ieq{8}, \ieq{10}, we conclude that 
$$
 \abssemrule{\jstate, \cs, i}{\jstate[\stosel \mapsto \store'], \cs', 0}{\top}{\top}{\instrumented} \text{ (\ieq{13})}
$$
Combining \hyp{2} and \ieq{13}, the result follows. 
\vspace{5pt}


\noindent \prooflab{Assume}
From \hyp{1}, it follows that $\abssemrule{\istate, \cs, i}{\istate', \cs, i{+}1}{\top}{\top}{\symbolic}$ (\ieq{1}), 
$\ccmd[\prog][\cs]{i}  = \assume(\jsilexpr)$ (\ieq{2}), and $\istate' = \absassume{\instrumented}(\istate, \jsilexpr)$ (\ieq{3}). 
Applying Lemma~\ref{lemma:erasure:assume} to 
\hyp{2} and \ieq{3}, we conclude that 
$\interpret{\symbconc}{}(\istate') = \absassume{\concrete}(\jstate, \jsilexpr)$ (\ieq{4}). 
From \ieq{2} and \ieq{4}, we conclude that: 
 $$\abssemrule{\jstate, \cs, i}{\interpret{\symbconc}{}(\istate'), \cs, i{+}1}{\top}{\top}{\concrete} \text{ (\ieq{5})}$$
  Combining  \ieq{2} and \ieq{5}, the result follows.
 \vspace{5pt}


\noindent \prooflab{Assert - True}
From \hyp{1}, it follows that $\abssemrule{\istate, \cs, i}{\istate, \cs, i{+}1}{\top}{\top}{\instrumented}$ (\ieq{1}), 
$ \ccmd[\prog][\cs]{i}  = \jassert(\jsilexpr)$ (\ieq{2}), and $\abssat{\instrumented}(\istate, \neg \jsilexpr) = \jfalse$ (\ieq{3}). 
Applying Lemma~\ref{lemma:erasure:sat} to \ieq{3}, we conclude that 
$\abssat{\concrete}(\jstate, \neg \jsilexpr) = \jfalse$ (\ieq{4}). 
Combining \ieq{2} and \ieq{4}, the result follows. 
 \vspace{5pt}

\noindent \prooflab{Assert - False}
Similar to \prooflab{Assert - True}. 
\end{proof}


\begin{temax}[Transparency for Instrumentation - Theorem~\ref{lemma:instrumented:semantics}]
$$
\begin{array}{l} 
\transabssemrule{\istate, \cs, i}{\istate', \cs', j}{\mode}{\mode'}{\instrumented} \\ \quad \quad
\implies \transabssemrule{\interpret{\instconc}{}(\istate), \cs, i}{\interpret{\instconc}{}(\istate'), \cs', j}{\mode}{\mode'}{\concrete} 
 \end{array}
$$
\end{temax}
\begin{proof}
Suppose:
$$
\transabssemrule{\istate, \cs, i}{\istate', \cs', j}{\mode}{\mode'}{\instrumented} \text{ (\hyp{1})}
\quad 
 \jstate = \interpret{\symbconc}{}(\istate) \text{ (\hyp{2})}
 $$
and
We have to prove that there is a concrete state $\jstate'$,
such that $\transabssemrule{\jstate, \cs, i}{\jstate', \cs', j}{\mode}{\mode'}{\concrete}$ and
$\istate' = \interpret{\instconc}{}(\istate', \cs')$.
We proceed by induction on the length of the symbolic trace 
$\transabssemrule{\istate, \cs, i}{\istate', \cs', j}{\mode}{\mode'}{\instrumented}$. 
Suppose the symbolic trace has length $n$. 
\vspace{6pt}

\noindent \prooflab{Base Case} $n = 0$. It follows that $\istate' = \istate$, 
$\cs = \cs'$, and $j = i$. Noting that 
$\transabssemrule{\jstate, \cs, i}{\jstate, \cs, i}{\mode}{\mode'}{\concrete}$
and 
$\jstate = \interpret{\symbconc}{}(\sstate)$ (from \hyp{2}), 
the result follows. 
\vspace{6pt}


\noindent \prooflab{Inductive Case} $n = m + 1$. It follows that there is an instrumented state 
$\istate''$, a context $\cs''$, an index $k$, and a mode $\mode''$, such that: 
$$
\begin{array}{c}
\transabssemrule{\istate, \cs, i}{\istate'', \cs'', k}{\mode}{\mode''}{\instrumented} \text{ (\ieq{1})} \\ 
\abssemrule{\istate'', \cs'', k}{\istate', \cs', j}{\mode}{\mode'}{\instrumented} \text{ (\ieq{2})}
\end{array}
$$
From \ieq{1} and \ieq{2}, it follows that $\mode = \mode'' = \top$. 
Applying the induction hypothesis to \hyp{2} and \ieq{1}, we conclude that 
there is a concrete state $\jstate''$, such that
$\transabssemrule{\jstate, \cs, i}{\jstate'', \cs'', k}{\mode}{\mode''}{\concrete}$ (\ieq{3}) and 
$\jstate'' = \interpret{\symbconc}{}(\jstate'')$ (\ieq{4}).
Applying Lemma~\ref{erasure:control:flow:cmds} to \ieq{2} and \ieq{4},
it follows that  
$\abssemrule{\jstate'', \cs'', k}{\jstate', \cs', j}{\mode}{\mode'}{\concrete}$ (\ieq{5})
and 
$\jstate' = \interpret{\instconc}{}(\istate')$ (\ieq{6}).
Combining \ieq{3} and \ieq{5}, we conclude that 
$\abssemrule{\jstate, \cs, i}{\jstate', \cs', j}{\mode}{\mode'}{\instrumented}$ (\ieq{7}). 
Combining \ieq{6} and \ieq{7}, we obtain the result. 
\end{proof}


%%%
%%%
%%% Symbolic to Instrument
%%%
%%%
%%%
\subsection{Symbolic Semantics}

\begin{lemma}[Expression Evaluation - Soundness for Symbolic Semantics]\label{symb:eval:expr}
$$
\interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstore, \jsilexpr)) = \evalexpr{\concrete}(\interpret{\symbconc}{\senv}(\sstore), \jsilexpr)
$$
\end{lemma}
\begin{proof}
By induction on the structure of  $\jsilexpr$. 
\vspace{5pt}

\noindent \prooflab{Value} $\jsilexpr = \val$. It follows that: 
$$
\begin{array}{ll}
  \interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstore, \jsilexpr))  & \\ 
      \qquad  =  \interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstore, \val)) & \text{by hyp.} \\  
      \qquad =  \interpret{\symbconc}{\senv}(\val)  & \text{by def. of } \evalexpr{\symbolic}(-, -) \\ 
      \qquad = \val  & \text{by def. of } \interpret{\symbconc}{\senv}(-) \\ 
      \qquad = \evalexpr{\concrete}(\interpret{\symbconc}{\senv}(\sstore), \val)  & \text{by def. of }  \text{by def. of } \evalexpr{\concrete}(-, -)
\end{array}
$$
\vspace{3pt}

\noindent \prooflab{Variable} $\jsilexpr = \jvar$. It follows that: 
$$
\begin{array}{ll}
  \interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstore, \jsilexpr))  & \\
       \qquad =  \interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstore, \jvar)) & \text{by hyp.} \\  
        \qquad =  \interpret{\symbconc}{\senv}(\sstore(\jvar))  & \text{by def. of } \evalexpr{\symbolic}(-, -) \\ 
       \qquad =  (\interpret{\symbconc}{\senv}(\sstore))(\jvar)   & \text{by def. of } \interpret{\symbconc}{\senv}(-) \\ 
      \qquad = \evalexpr{\concrete}(\interpret{\symbconc}{\senv}(\sstore), \jvar)  &  \text{by def. of } \evalexpr{\concrete}(-, -)
\end{array}
$$
\vspace{3pt}

\noindent \prooflab{Unary Operator} $\jsilexpr = \ominus \jsilexpr$. We consider two distinct cases: 
$\evalexpr{\symbolic}(\sstore, \jsilexpr) \in \vals$ and $\evalexpr{\symbolic}(\sstore, \jsilexpr) \not\in \vals$. 
If $\evalexpr{\symbolic}(\sstore, \jsilexpr) \in \vals$, it means that there is a value $\val$ such 
that  $\evalexpr{\symbolic}(\sstore, \jsilexpr) = \val$ (\ieq{1}). From \ieq{1}, we conclude that 
$\interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstore, \jsilexpr)) = \val$ (\ieq{2}). 
Applying the induction hypothesis to \ieq{2}, we conclude that: 
$\evalexpr{\concrete}(\interpret{\symbconc}{\senv}(\sstore), \jsilexpr) = \val$ (\ieq{3}). 
It follows that: 
$$
\begin{array}{lll}
  \interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstore, \jsilexpr))  & \\
       \qquad =  \interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstore, \ominus \jsilexpr)) & \text{by hyp.} \\   
      \qquad =  \interpret{\symbconc}{\senv}(\semop{\ominus}(\val))  & \text{by def. of } \evalexpr{\symbolic}(-, -) + \text{ hyp.} \\ 
      \qquad =  \semop{\ominus}(\val)   & \text{by def. of } \interpret{\symbconc}{\senv}(-) \\ 
      \qquad =  \semop{\ominus}(\evalexpr{\concrete}(\interpret{\symbconc}{\senv}(\sstore), \jsilexpr))   & \text{by \ieq{3}}\\ 
      \qquad = \evalexpr{\concrete}(\interpret{\symbconc}{\senv}(\sstore), \ominus \jsilexpr)  & \text{by def. of } \evalexpr{\concrete}(-, -) 
\end{array}
$$
If $\evalexpr{\symbolic}(\sstore, \jsilexpr) \not\in \vals$, it follows that: 
$$
\begin{array}{lll}
  \interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstore, \jsilexpr))  & \\ 
    \qquad   =  \interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstore, \ominus \jsilexpr)) & \text{by hyp.} \\  
      \qquad =  \interpret{\symbconc}{\senv}(\ominus \, \evalexpr{\symbolic}(\sstore, \jsilexpr))  & \text{by def. of } \evalexpr{\symbolic}(-, -) + \text{ hyp.} \\ 
      \qquad =  \semop{\ominus}(\interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstore, \jsilexpr)))   & \text{by def. of } \interpret{\symbconc}{\senv}(-) \\
      \qquad =  \semop{\ominus}(\evalexpr{\concrete}(\interpret{\symbconc}{\senv}(\sstore), \jsilexpr))   & \text{by \indhyp}\\
    \qquad   = \evalexpr{\concrete}(\interpret{\symbconc}{\senv}(\sstore), \ominus \jsilexpr)  & \text{by def. of } \evalexpr{\concrete}(-, -) 
\end{array}
$$

\noindent \prooflab{Binary Operator} Similar to the previous case. 
\end{proof}

\begin{lemma}[Heap Update - Soundness for Symbolic Semantics]\label{lemma:soundiness:heap:update}
$$
\begin{array}{l}
\istate = \interpret{\symbinst}{\senv}(\sstate) \, \wedge \, 
   \loc = \interpret{\symbconc}{\senv}(\sloc)  \, \wedge \, 
   p = \interpret{\symbconc}{\senv}(\sexprp)  \, \wedge \, 
   \val = \interpret{\symbconc}{\senv}(\sexprv)   \\  \qquad \qquad
       \implies \hpupdt{\instrumented}(\istate, \loc, p, \val) \in \interpret{\symbconc}{\senv}(\hpupdt{\symbolic}(\sstate, \sloc, \sexprp, \sexprv)) \\[3pt]
%       
\istate = \interpret{\symbinst}{\senv}(\sstate) \, \wedge \, 
   \loc = \interpret{\symbconc}{\senv}(\sloc)  \, \wedge \, 
   p = \interpret{\symbconc}{\senv}(\sexprp) \\  \qquad \qquad
  \implies \hpupdt{\instrumented}(\istate, \loc, p, \none) = \interpret{\symbconc}{\senv}(\hpupdt{\symbolic}(\sstate, \sloc, \sexprp, \none)) 
\end{array}
$$
\end{lemma}
\begin{proof}
Immediate from the definitions of $\hpupdt{\instrumented}$ and $\hpupdt{\symbolic}$.
\end{proof}


\begin{lemma}[Store Update - Soundness for Symbolic Semantics]\label{lemma:soundiness:store:update}
$$
\begin{array}{l}
\istate = \interpret{\symbinst}{\senv}(\sstate) \, \wedge \, 
   \val = \interpret{\symbconc}{\senv}(\sexprv) \\ \qquad   
       \implies \stupdt{\instrumented}(\istate, \jvar, \val) = \interpret{\symbinst}{\senv}(\stupdt{\symbolic}(\sstate, \jvar, \sexprv)) 
\end{array}
$$
\end{lemma}
\begin{proof}
Immediate from the definitions of $\stupdt{\instrumented}$ and $\stupdt{\symbolic}$.
\end{proof}


\begin{lemma}[Assume - Soundness for Symbolic Semantics]\label{lemma:soundiness:assume}
$$
\begin{array}{l}
\istate = \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \sstate'.\pcsel)  
       \implies  \interpret{\symbinst}{\senv}(\absassume{\instrumented}(\istate, \jsilexpr)) = \absassume{\symbolic}(\sstate, \jsilexpr) 
\end{array}
$$
\end{lemma}
\begin{proof}
Suppose that $\istate = \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \sstate'.\pcsel)$ (\hyp{1}).
Observe that $\absassume{\symbolic}(\sstate, \jsilexpr) = \sstate \, \wedge \, \sexprb$ (\ieq{1}), where 
$\sexprb = \evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr)$ (\ieq{2}). 
From \hyp{1} and \ieq{1}, it follows that $\interpret{\symbinst}{\senv}(\sexprb) = \jtrue$ (\ieq{3}). 
Combining \ieq{2} and \ieq{3}, we obtain $\interpret{\symbinst}{\senv}( \evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr)) = \jtrue$ (\ieq{4}). 
Applying Lemma~\ref{symb:eval:expr} to \ieq{4}, we conclude that
$\evalexpr{\concrete}(\interpret{\symbinst}{\senv}(\sstate.\stosel), \jsilexpr) = \jtrue$ (\ieq{5}). 
From \ieq{5}, it follows that $\evalexpr{\concrete}(\istate.\stosel, \jsilexpr) = \jtrue$ (\ieq{6}), 
from which we conclude that $\absassume{\instrumented}(\istate, \jsilexpr) = \istate$ (\ieq{7}). 
From \hyp{1} and \ieq{7}, the result follows. 
\end{proof}


\begin{lemma}[Check Sat - Soundness for Symbolic Semantics]\label{lemma:soundiness:sat}
$$
\begin{array}{l}
      \abssat{\symbolic}(\sstate, \jsilexpr) = \jtrue   
      \iff  \exists \, \senv \, . \, 
          \abssat{\instrumented}(\interpret{\symbinst}{\senv}(\sstate), \jsilexpr) = \jtrue
\end{array}
$$
\end{lemma}
\begin{proof}
We prove each direction of the equivalence separately. 
\vspace{5pt}

\noindent \prooflab{Left-to-Right} 
Suppose that $\abssat{\symbolic}(\sstate, \jsilexpr) = \jtrue$ (\hyp{1}).
We conclude that $(\sstate.\pcsel \wedge \sexprb)$ is satisfiable for 
$\sexprb = \evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr)$ (\ieq{1}). 
Because  $(\sstate.\pcsel \wedge \sexprb)$  is satisfiable, we conclude that 
there is a symbolic environment $\senv$ such that $\interpret{\symbconc}{\senv}(\sstate.\pcsel) = \jtrue$ (\ieq{2})
and  $\interpret{\symbconc}{\senv}(\sexprb) = \jtrue$ (\ieq{3}). 
Combining \ieq{1} and \ieq{3}, we obtain $\interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr)) = \jtrue$  (\ieq{4}). 
Applying Lemma~\ref{symb:eval:expr} to \ieq{4}, we conclude that
$\evalexpr{\concrete}(\interpret{\symbinst}{\senv}(\sstate.\stosel), \jsilexpr) = \jtrue$ (\ieq{5}), 
from which the result follows. 
\vspace{3pt}

\noindent \prooflab{Right-to-Left} 
Suppose that there is a symbolic environment $\senv$ such that 
$\abssat{\instrumented}(\interpret{\symbinst}{\senv}(\sstate), \jsilexpr) = \jtrue$ (\hyp{1}). 
We conclude from \hyp{1} (using the definition of $\abssat{\instrumented}$) that 
$\evalexpr{\concrete}(\store, \jsilexpr) = \jtrue$ (\ieq{1}) for 
$\store = (\interpret{\symbinst}{\senv}(\sstate)).\stosel$ (\ieq{2}). 
From \ieq{2}, we conclude that $\store = \interpret{\symbinst}{\senv}(\sstate.\stosel)$, 
from which it follows that 
$\evalexpr{\concrete}(\interpret{\symbinst}{\senv}(\sstate.\stosel), \jsilexpr) = \jtrue$ (\ieq{3}). 
Applying Lemma~\ref{symb:eval:expr} to \ieq{4}, we conclude that
$\interpret{\symbinst}{\senv}(\evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr)) = \jtrue$ (\ieq{4}).
 From \hyp{1}, we conclude that $\interpret{\symbinst}{\senv}(\sstate.\pcsel) = \jtrue$ (\ieq{5}). 
 Combining \ieq{4} and \ieq{5}, we conclude that $\interpret{\symbinst}{\senv}(\sstate.\pcsel \, \wedge \, \evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr)) = \jtrue$ (\ieq{6}), 
 from which we conclude that $\sstate.\pcsel \, \wedge \, \evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr)$ is satisfiable. 
\end{proof}


%\begin{lemma}[Symbolic Value Creation - Soundness for Symbolic Semantics]\label{lemma:symbvalue:soundiness}
%$$
%\begin{array}{l}
%\istate = \interpret{\symbinst}{\senv}(\sstate) \\ \qquad
%   \implies \exists \, \senv' \, . \,  \senv' \fextends \senv \ \wedge \ \absmakesymbolicrule{\concrete}{\istate, \jtype} 
%              = \interpret{\symbinst}{\senv[\svar \mapsto \val]}(\absmakesymbolicrule{\symbolic}{\istate, \jtype})
%\end{array}
%$$
% \end{lemma}
% \begin{proof}
% Immediate from the definitions of $\absmakesymbolic_{\concrete}$ and $\absmakesymbolic_{\symbolic}$.  
% \end{proof}


\begin{lemma}[GetCell - Soundness for Symbolic Semantics]\label{soundiness:getcell}
$$
\begin{array}{l}
\istate = \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \sstate'.\pcsel)  \ \wedge \ 
\absgetcellrule{\symbolic}{\sstate, \jsilexpr_1, \jsilexpr_2}{\sstate', (\sloc, \sexprp, \sexprv)} \\ \quad \quad
  \implies \absgetcellrule{\instrumented}{\istate, \jsilexpr_1, \jsilexpr_2}{\istate', (\loc, p, \ival)} 
     \ \wedge \ \istate' = \interpret{\symbinst}{\senv}(\sstate') \\ \qquad \qquad
     \ \wedge \ \interpret{\symbconc}{\senv}((\sloc, \sexprp, \sexprv)) = (\loc, p, \ival)
\end{array}
$$
 \end{lemma}
 \begin{proof}
 Suppose $\istate = \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \sstate'.\pcsel)$ (\hyp{1}) 
 and:
 $$\absgetcellrule{\symbolic}{\sstate, \jsilexpr_1, \jsilexpr_2}{\sstate', (\sloc, \sexprp, \sexprv)} \text{ (\hyp{2})}
 $$ 
 We consider two distinct cases, one in which the inspected field exists 
 in the object and one in which it does not. 
 \vspace{3pt} 
 
 \noindent \prooflab{Found} It follows that:  $\evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr_1) = \sloc$ (\ieq{1}), 
 $\evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr_2) = \sexprp$ (\ieq{2}), 
 $\sstate.\hpsel = - \, \uplus \, (\sloc, \sexprp') \mapsto \sexprv$ (\ieq{3}), and
 $\sstate' = \sstate \, \wedge \, (\sexprp = \sexprp')$  (\ieq{4}). 
 From \hyp{1}, we conclude that $\interpret{\symbconc}{\senv}(\sstate.\stosel) = \istate.\stosel$ (\ieq{5}). 
 From \ieq{1} and \ieq{2}, we obtain 
 $\interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr_1))= \interpret{\symbconc}{\senv}(\sloc)$ (\ieq{6}) 
 and 
 $\interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr_2))= \interpret{\symbconc}{\senv}(\sexprp)$ (\ieq{7}). 
 Applying Lemma~\ref{symb:eval:expr} to \ieq{6} and \ieq{7}, we conclude that 
$\evalexpr{\concrete}(\interpret{\symbconc}{\senv}(\sstate.\stosel), \jsilexpr_1) = \interpret{\symbconc}{\senv}(\sloc)$ (\ieq{8})
and 
$\evalexpr{\concrete}(\interpret{\symbconc}{\senv}(\sstate.\stosel), \jsilexpr_2) = \interpret{\symbconc}{\senv}(\sexprp)$ (\ieq{9}). 
Combining \ieq{5} with \ieq{8} and \ieq{9}, respectively, we obtain
 $\evalexpr{\concrete}(\istate.\stosel, \jsilexpr_1)) = \interpret{\symbconc}{\senv}(\sloc)$ (\ieq{10})
and 
$\evalexpr{\concrete}(\istate.\stosel, \jsilexpr_2)) = \interpret{\symbconc}{\senv}(\sexprp)$ (\ieq{11}). 
From \hyp{1} and \ieq{3}, we conclude that: 
 $\istate.\hpsel = - \, \uplus \, (\interpret{\symbconc}{\senv}(\sloc), \interpret{\symbconc}{\senv}(\sexprp')) \mapsto \interpret{\symbconc}{\senv}(\sexprv)$ (\ieq{12}). 
 From \hyp{1} and \ieq{4}, we conclude that $\interpret{\symbconc}{\senv}(\sexprp') = \interpret{\symbconc}{\senv}(\sexprp)$ (\ieq{13}). 
 Combining \ieq{12} and \ieq{13}, it follows that 
 $\istate.\hpsel = - \, \uplus \, (\interpret{\symbconc}{\senv}(\sloc), \interpret{\symbconc}{\senv}(\sexprp)) \mapsto \interpret{\symbconc}{\senv}(\sexprv)$ (\ieq{14}). 
 From \ieq{10}, \ieq{11}, and \ieq{14}, we conclude that 
 $$\absgetcellrule{\instrumented}{\istate, \jsilexpr_1, \jsilexpr_2}{\istate, (\loc, p, \ival)} \text{ (\ieq{15})}$$ 
 for $(\loc, p, \ival) =  \interpret{\symbconc}{\senv}(\sloc, \sexprp, \sexprv)$ (\ieq{16}). 
 From \ieq{4}, it follows that $\istate \in \interpret{\symbinst}{\senv}(\sstate')$ (\ieq{17}). 
 From \ieq{15}-\ieq{17}, the result follows. 
 \vspace{3pt}
 
  \noindent \prooflab{NOT Found} It follows that: $\evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr_1) = \sloc$ (\ieq{1}), 
$\evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr_2) = \sexprp$ (\ieq{2}), 
$\sheap = \sheap'' \, \uplus \, \big((\sloc, \sexprp_i) \mapsto \sexprv_i \big)\mid_{i = 0}^m$ (\ieq{3}), 
$(\sloc,-) \notin \domain (\sheap'')$  (\ieq{4}), 
$\sheap' = \sheap \dunion (\sloc, \sexprp) \mapsto \none$ (\ieq{5}),
$\sdom' = \sdom[\sloc \mapsto \sdom(\sloc) \cup \jsilset{\sexprp}]$ (\ieq{6}), 
$\pc' = \pc \wedge \sexprp \not\in (\sdom(\sloc) \cup \jsilset{\sexprp_i \mid_{i=0}^m})$ (\ieq{7}), 
$\sstate' = (\sheap', \sdom', \sstore, \pc')$ (\ieq{8}), and 
$\sexprv = \none$ (\ieq{9}), for $\sstate = (\sheap, \sdom, \sstore, \pc)$ (\ieq{10}). 
From \ieq{1}, \ieq{2}, and \ieq{10}, we obtain 
 $\interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstore, \jsilexpr_1))= \interpret{\symbconc}{\senv}(\sloc)$ (\ieq{11}) 
 and 
 $\interpret{\symbconc}{\senv}(\evalexpr{\symbolic}(\sstore, \jsilexpr_2))= \interpret{\symbconc}{\senv}(\sexprp)$ (\ieq{12}). 
 Applying Lemma~\ref{symb:eval:expr} to \ieq{11} and \ieq{12}, we conclude that 
$\evalexpr{\concrete}(\interpret{\symbconc}{\senv}(\sstore), \jsilexpr_1) = \interpret{\symbconc}{\senv}(\sloc)$ (\ieq{13})
and 
$\evalexpr{\concrete}(\interpret{\symbconc}{\senv}(\sstore), \jsilexpr_2) = \interpret{\symbconc}{\senv}(\sexprp)$ (\ieq{14}).
 From \hyp{1} and \ieq{10}, we conclude that $\interpret{\symbconc}{\senv}(\sstore) = \istate.\stosel$ (\ieq{15}). 
Combining \ieq{5} with \ieq{13} and \ieq{14}, respectively, we obtain
 $\evalexpr{\concrete}(\istate.\stosel, \jsilexpr_1) = \interpret{\symbconc}{\senv}(\sloc)$ (\ieq{16})
and 
$\evalexpr{\concrete}(\istate.\stosel, \jsilexpr_2) = \interpret{\symbconc}{\senv}(\sexprp)$ (\ieq{17}).
For clarity, we use the following renaming: $\loc = \interpret{\symbconc}{\senv}(\sloc)$ (\ieq{18}) and 
$p = \interpret{\symbconc}{\senv}(\sexprp)$ (\ieq{19}). From \ieq{16}-\ieq{19}, we conclude 
that  $\evalexpr{\concrete}(\istate.\stosel, \jsilexpr_1) = \loc$ (\ieq{20}) and 
$\evalexpr{\concrete}(\istate.\stosel, \jsilexpr_2) = p$ (\ieq{21}).

 \noindent From \hyp{1}, \ieq{3}, and \ieq{21}, we conclude that 
 $\istate.\hpsel = \interpret{\symbinst}{\senv}(\sheap'') \, \uplus  \, \big((\loc, \interpret{\symbconc}{\senv}(\sexprp_i)) \mapsto 
 \interpret{\symbconc}{\senv}(\sexprv_i) \big)\mid_{i = 0}^m$ (\ieq{22}).
 From \ieq{7}, we conclude that $p \not\in \interpret{\symbconc}{\senv}(\sdom(\sloc)) \cup \jsilset{\interpret{\symbconc}{\senv}(\sexprp_i) \mid_{i=0}^m})$ (\ieq{23}).
 From \ieq{23} and \ieq{18}, it follows that  
 $p \not\in \interpret{\symbinst}{\senv}(\sdom)(\loc) \cup \jsilset{\interpret{\symbconc}{\senv}(\sexprp_i) \mid_{i=0}^m})$ (\ieq{24}).
  From \hyp{1}, \ieq{4}, and \ieq{18}, we conclude that $(\loc,-) \notin \domain (\interpret{\symbinst}{\senv}(\sheap''))$ (\ieq{25}). 
  
 \noindent From \ieq{20}, \ieq{21}, \ieq{22}, \ieq{24}, and \ieq{25}, it follows 
 $\istate'.\hpsel = \istate.\hpsel \dunion (\loc, p) \mapsto \none$ (\ieq{27}), 
 $\istate'.\domsel = \istate.\domsel[\loc \mapsto \istate.\domsel(\loc) \cup \jsilset{p}]$ (\ieq{28}), 
 and $\istate'.\stosel = \istate.\stosel$ (\ieq{29}). 
 From \hyp{1}, \ieq{5},  \ieq{18}, \ieq{19}, and \ieq{27}, we conclude that $\istate'.\hpsel = \interpret{\symbinst}{\senv}(\sstate'.\hpsel)$ (\ieq{30}). 
 From \hyp{1}, \ieq{6}, \ieq{18}, and \ieq{28}, we conclude that $\istate'.\domsel =  \interpret{\symbinst}{\senv}(\sstate'.\domsel)$ (\ieq{31}). 
 From \hyp{1}, \ieq{8}, \ieq{29}, \ieq{30}, and \ieq{31}, it follows that $\istate' = \interpret{\symbinst}{\senv}(\sstate')$ (\ieq{32}). 
 \end{proof}


\begin{lemma}[GetDomain - Soundness for Symbolic Semantics]\label{lemma:getdomain:soundiness}
$$
\istate = \interpret{\symbinst}{\senv}(\sstate) \ \wedge \ 
  \absgetdomainfun{\symbolic}(\sstate, \jsilexpr) = \sexpr  
  \implies \absgetdomainfun{\instrumented}(\istate, \jsilexpr) = \val
$$
\end{lemma}
\begin{proof}
Suppose that the following hold: 
$\istate = \interpret{\symbinst}{\senv}(\sstate)$ (\hyp{1}) and $\absgetdomainfun{\symbolic}(\sstate, \jsilexpr) = \sexpr$ (\hyp{2}). 
From \hyp{2}, we conclude that 
$\evalexpr{\symbolic}(\sstore, \jsilexpr) = \sloc$ (\ieq{1}), 
$\sheap = \sheap' \, \uplus \, \big((\sloc, \sexprp_i) \mapsto \sexprv_i \big)\mid_{i = 0}^m$ (\ieq{2}), 
$(\sloc,-) \notin \domain (\sheap')$ (\ieq{3}), 
$\pc \vdash \jsilset{\sexprp_1, ..., \sexprp_m} = \sdom(\sloc)$ (\ieq{4}), 
$\forall_{0 \leq i \leq n} \, \sexprv_i \neq \none$ (\ieq{5}), 
and $\forall_{n < i \leq m} \, \sexprv_i = \none$ (\ieq{6}), for $\sstate = (\sheap, \sdom, \sstore, \pc)$ (\ieq{7}). 
From \hyp{1} and \ieq{7}, we conclude that $\istate.\stosel = \interpret{\symbconc}{\senv}(\sstore)$ (\ieq{8}). 
 Applying Lemma~\ref{symb:eval:expr} to \ieq{1}, we conclude 
 $\evalexpr{\symbolic}(\interpret{\symbconc}{\senv}(\sstore), \jsilexpr) = \interpret{\symbconc}{\senv}(\sloc)$ (\ieq{2}). 
 For clarity, we use the naming $\loc = \interpret{\symbconc}{\senv}(\sloc)$ (\ieq{3}). 
 From \hyp{1}, \ieq{2}, \ieq{3}, and \ieq{7}, we conclude 
 $\istate.\hpsel =  \interpret{\symbinst}{\senv}(\sheap') \, \uplus \, \big((\loc, \interpret{\symbconc}{\senv}(\sexprp_i)) \mapsto \interpret{\symbconc}{\senv}(\sexprv_i) \big)\mid_{i = 0}^m$ (\ieq{4}), 
$(\loc,-) \notin \domain (\interpret{\symbinst}{\senv}(\sheap'))$ (\ieq{5}).
From \hyp{1} and \ieq{4}, it follows that: 
$$\jsilset{\interpret{\symbconc}{\senv}(\sexprp_1), ..., \interpret{\symbconc}{\senv}(\sexprp_m)} = \interpret{\symbconc}{\senv}(\sdom(\sloc)) \text{ (\ieq{6})}$$
From \ieq{6} and \ieq{3}, we conclude that 
 $$\jsilset{\interpret{\symbconc}{\senv}(\sexprp_1), ..., \interpret{\symbconc}{\senv}(\sexprp_m)} = (\interpret{\symbinst}{\senv}(\sdom))(\loc) \text{ (\ieq{7})}$$ 
 From \ieq{5} and \ieq{6}, we conclude that 
 {\small $\forall_{0 \leq i \leq n} \, \interpret{\symbconc}{\senv}(\sexprv_i) \neq \none$} (\ieq{8}) and  
{\small $\forall_{n < i \leq m} \, \interpret{\symbconc}{\senv}(\sexprv_i) = \none$} (\ieq{9}).
From \ieq{2}, \ieq{3}, \ieq{5}, \ieq{6}, \ieq{7}-\ieq{9}, we conclude that 
$\absgetdomainfun{\instrumented}(\istate, \jsilexpr) = \interpret{\symbconc}{\senv}(\sexprp_1), ..., \interpret{\symbconc}{\senv}(\sexprp_n)$, 
establishing the result. 
\end{proof}

\begin{lemma}[Basic Commands - Bounded Soundness for Symbolic Semantics]\label{lemma:soundiness:basic:commands}
$$
\begin{array}{l}
\absbsemrule{\sstate, \bcmd}{\sstate'}{\symbolic} 
    \, \wedge \, \istate = \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \pc)
    \, \wedge \, \pc \vdash \sstate''.\pcsel \\ \quad \quad
     \implies 
        \exists \, \istate' \, . \, \absbsemrule{\istate, \bcmd}{\istate'}{\instrumented} \, \wedge \, 
            \istate' = \interpret{\symbinst}{\senv'}(\sstate' \, \wedge \, \pc)  \, \wedge \, 
            \senv' \fextends  \senv
\end{array}
$$
\end{lemma}
\begin{proof}
Suppose $\absbsemrule{\sstate, \bcmd}{\sstate'}{\symbolic}$ (\hyp{1}) and 
$\istate = \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \sstate'.\pcsel)$ (\hyp{2}).
We proceed by case analysis on the rule used to derive \hyp{1}. 
\vspace{3pt}

\noindent \prooflab{Skip} It follows that $\absbsemrule{\sstate, \jsilskip}{\sstate}{\symbolic}$ (\ieq{1}) and 
$\absbsemrule{\istate, \jsilskip}{\istate}{\instrumented}$ (\ieq{2}). 
From \hyp{1} and \ieq{1}, we conclude that $\sstate' = \sstate$ (\ieq{3}). 
From \hyp{2} and \ieq{3}, it follows that $\istate \in \interpret{\symbinst}{\senv}(\sstate')$ (\ieq{4}). 
Letting $\istate' = \istate$, the result follows from \ieq{2} and \ieq{4}. 
\vspace{5pt}

\noindent \prooflab{Property Collection} From \hyp{1}, it follows that 
$$
\absbsemrule{\sstate, \jvar := \getfields(\jsilexpr)}{\sstate'}{\symbolic} \text{ (\ieq{1})}
$$ 
From \ieq{1}, we conclude that there is a symbolic value $\sexprv$ such that 
$\absgetdomainfun{\symbolic}(\sstate, \jsilexpr) = \sexprv$ (\ieq{2}) 
and $\sstate' = \stupdt{\symbolic}(\sstate, \jvar, \sexprv)$ (\ieq{3}).  
From \hyp{2}, we conclude that $\istate = \interpret{\symbinst}{\senv}(\sstate)$ (\ieq{4}). 
Applying Lemma~\ref{lemma:getdomain:soundiness} to \ieq{2} and \ieq{4}, we conclude that 
$\absgetdomainfun{\instrumented}(\istate, \jsilexpr) = \interpret{\symbconc}{\senv}(\sexprv)$ (\ieq{5}). 
Applying Lemma~\ref{lemma:soundiness:store:update} to \ieq{3} and \ieq{4}, it follows that 
$ \interpret{\symbinst}{\senv}(\sstate') = \stupdt{\instrumented}(\istate, \jvar, \interpret{\symbconc}{\senv}(\sexprv))$ (\ieq{6}). 
From \ieq{5} and \ieq{6}, we conclude that $\absbsemrule{\istate, \jvar := \getfields(\jsilexpr)}{\interpret{\symbinst}{\senv}(\sstate')}{\instrumented}$, establishing the result. 
\vspace{5pt}

 \noindent \prooflab{Assignment} From \hyp{1}, it follows that $\absbsemrule{\sstate, \jvar := \jsilexpr}{\sstate'}{\symbolic}$ (\ieq{1}). 
From \ieq{1}, we conclude that there is a symbolic value $\sexprv$ such that 
$\sexprv = \evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr)$ (\ieq{2}) and $\sstate' = \stupdt{\symbolic}(\sstate, \jvar, \sexprv)$ (\ieq{3}). 
From \hyp{2}, we conclude that $\istate = \interpret{\symbinst}{\senv}(\sstate)$ (\ieq{4}). 
Applying Lemma~\ref{symb:eval:expr} to \ieq{2} and \ieq{4}, it follows that 
$\evalexpr{\symbolic}(\istate.\stosel, \jsilexpr) = \interpret{\symbconc}{\senv}(\sexprv)$ (\ieq{5}). 
Applying Lemma~\ref{lemma:soundiness:store:update} to \ieq{3} and \ieq{4}, it follows
that $ \interpret{\symbinst}{\senv}(\sstate') = \stupdt{\instrumented}(\istate, \jvar, \interpret{\symbconc}{\senv}(\sexprv))$ (\ieq{6}). 
Combining \ieq{5} and \ieq{6}, we conclude that $\absbsemrule{\istate,\jvar := \jsilexpr}{\interpret{\symbinst}{\senv}(\sstate')}{\instrumented}$, establishing the result. 
\vspace{5pt}

 \noindent \prooflab{Object Creation} From \hyp{1}, it follows that $\absbsemrule{\sstate, \jvar := \jsilnew()}{\sstate'}{\symbolic}$ (\ieq{1}). 
From \ieq{1}, we conclude that there is a symbolic location $\sloc$ such that $(\sloc, -) \not\in \domain(\sstate.\hpsel)$ (\ieq{2}) and 
$\sstate' = \hpupdt{\symbolic}(\sstate, \sloc, \protop, \jnull)$ (\ieq{3}). From \hyp{2}, 
we conclude that $\istate = \interpret{\symbinst}{\senv}(\sstate)$ (\ieq{4}). 
Let us now pick a location $\loc$ such that $(\loc, -) \not\in \domain(\istate.\hpsel)$ (\ieq{5}). 
From \ieq{5}, it follows that $\absbsemrule{\istate, \jvar := \jsilnew()}{\istate'}{\instrumented}$ (\ieq{6}) for 
$\istate' = \hpupdt{\instrumented}(\sstate, \sloc, \protop, \jnull)$ (\ieq{7}). 
Letting $\senv' = \senv[\sloc \mapsto \loc]$ (\ieq{8}), we conclude that 
$(\loc, \protop, \jnull) = \interpret{\symbinst}{\senv'}(\sloc, \protop, \jnull)$ (\ieq{9})
and $\istate = \interpret{\symbinst}{\senv'}(\sstate)$ (\ieq{10}). 
Applying Lemma \ref{lemma:soundiness:heap:update} to \ieq{3}, \ieq{7}, \ieq{9}, and \ieq{10}, 
the result follows. 
\vspace{5pt}

 \noindent \prooflab{Property Access} From \hyp{1}, it follows that 
 $$\absbsemrule{\sstate, \jvar := \jvar := [\jsilexpr_1, \jsilexpr_2]}{\sstate'}{\symbolic} \text{ (\ieq{1})}$$
From \ieq{1}, we conclude that there is a symbolic expression $\sexprv$ and a symbolic state $\sstate''$ such that 
$\absgetcellrule{\symbolic}{\sstate, \jsilexpr_1, \jsilexpr_2}{\sstate'', (-, -, \sexprv)}$ (\ieq{2}) 
and $\sstate' = \stupdt{\symbolic}(\sstate'', \jvar, \sexprv)$ (\ieq{3}). 
Since, $\stupdt{\symbolic}$ does not affect the path condition, we conclude, from \hyp{2} and \ieq{3}, that
$\istate = \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \sstate''.\pcsel)$ (\ieq{4}). 
Applying Lemma~\ref{soundiness:getcell} to \ieq{2} and \ieq{4}, we conclude that
there is an instrumented state $\istate''$ and an instrumented value $\ival$, such that 
$\absgetcellrule{\instrumented}{\istate, \jsilexpr_1, \jsilexpr_2}{\istate'', (-, -, \ival)}$ (\ieq{5}), 
where $\istate'' = \interpret{\symbinst}{\senv}(\sstate'')$ (\ieq{6}) and $\ival = \interpret{\symbconc}{\senv}(\sexprv)$ (\ieq{7}). 
Applying Lemma~\ref{lemma:soundiness:store:update} to \ieq{3}, \ieq{6}, and \ieq{7}, it follows
that  $\interpret{\symbinst}{\senv}(\sstate') = \stupdt{\instrumented}(\istate'', \jvar, \ival)$ (\ieq{8}). 
From \ieq{5} and \ieq{8}, we conclude the result. 
\vspace{5pt}

 \noindent \prooflab{Property Assignment}
From \hyp{1}, it follows that 
$$\absbsemrule{\sstate, [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3}{\sstate'}{\symbolic} \text{ (\ieq{1})}$$
From \ieq{1}, we conclude that there is a symbolic location $\sloc$, a symbolic expression $\sexprp$, and a symbolic state $\sstate''$ such that 
$$\absgetcellrule{\symbolic}{\sstate, \jsilexpr_1, \jsilexpr_2}{\sstate'', (\sloc, \sexprp, -)} \text{ (\ieq{2})}$$ and 
$\sstate' = \hpupdt{\symbolic}(\sstate'', \sloc, \sexprp, \evalexpr{\symbolic}(\sstate''.\stosel, \jsilexpr_3))$ (\ieq{3}). 
Since, $\hpupdt{\symbolic}$ does not affect the path condition, we conclude, from \hyp{2} and \ieq{3}, that
$\istate = \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \sstate''.\pcsel)$ (\ieq{4}). 
Applying Lemma~\ref{soundiness:getcell} to \ieq{2} and \ieq{4}, we conclude that
there is an instrumented state $\istate''$, a location $\loc$, and a property $p$, such that 
$\absgetcellrule{\instrumented}{\istate, \jsilexpr_1, \jsilexpr_2}{\istate'', (\loc, p, -)}$ (\ieq{5}), 
where: $\istate'' = \interpret{\symbinst}{\senv}(\sstate'')$ (\ieq{6}), 
 $\loc = \interpret{\symbconc}{\senv}(\sloc)$ (\ieq{7}), and  $p = \interpret{\symbconc}{\senv}(\sexprp)$ (\ieq{8}).
Applying Lemma~\ref{symb:eval:expr} to \ieq{6}, we conclude that 
$\interpret{\symbinst}{\senv}(\evalexpr{\symbolic}(\sstate''.\stosel, \jsilexpr_3)) = \evalexpr{\symbolic}(\istate''.\stosel, \jsilexpr_3)$ (\ieq{9}). 
Applying Lemma~\ref{lemma:soundiness:heap:update} to \ieq{3} and \ieq{6}-\ieq{9}, the result follows.
\vspace{5pt} 

\noindent \prooflab{Property Deletion}
From \hyp{1}, it follows that 
$$\absbsemrule{\sstate, \jsildelete(\jsilexpr_1, \jsilexpr_2)}{\sstate'}{\symbolic} \text{ (\ieq{1})}$$
From \ieq{1}, we conclude that there is a symbolic location $\sloc$, symbolic expressions $\sexprp$ and $\sexprv$, and a symbolic state $\sstate''$ such that 
$$\absgetcellrule{\symbolic}{\sstate, \jsilexpr_1, \jsilexpr_2}{\sstate'', (\sloc, \sexprp, \sexprv)} \text{ (\ieq{2})}$$ 
$\sexprp \neq \none$ (\ieq{3}), and  
$\sstate' = \hpupdt{\symbolic}(\sstate'', \sloc, \sexprp, \none)$ (\ieq{4}). 
Since, $\hpupdt{\symbolic}$ does not affect the path condition, we conclude, from \hyp{2} and \ieq{4}, that
$\istate = \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \sstate''.\pcsel)$ (\ieq{5}). 
Applying Lemma~\ref{soundiness:getcell} to \ieq{2} and \ieq{5}, we conclude that
there is an instrumented state $\istate''$, a location $\loc$, a property $p$, and a value $\val$, such that 
$\absgetcellrule{\instrumented}{\istate, \jsilexpr_1, \jsilexpr_2}{\istate'', (\loc, p, \val)}$ (\ieq{6}), 
where: $\istate'' = \interpret{\symbinst}{\senv}(\sstate'')$ (\ieq{7}) and 
 $(\loc, p, \val) = \interpret{\symbconc}{\senv}(\sloc, \sexprp, \sexprv)$ (\ieq{8}). 
From \ieq{3}, we conclude that $\val \neq \none$ (\ieq{9}) directly. 
Applying Lemma~\ref{lemma:soundiness:heap:update} to \ieq{4} and \ieq{8}, we conclude that 
$ \hpupdt{\instrumented}(\istate'', \loc, p, \none) = \interpret{\symbinst}{\senv}(\sstate')$ (\ieq{10}). 
Combining \ieq{6}, \ieq{9}, and \ieq{10}, we obtain the result. 
\vspace{5pt} 

\noindent \prooflab{Member Check - True}
From \hyp{1}, it follows that:
$$\absbsemrule{\sstate, \jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)}{\sstate'}{\symbolic} \text{ (\ieq{1})}$$ 
From \ieq{1}, we conclude that there is a symbolic expression $\sexprv$, and a symbolic state $\sstate''$ such that 
$\absgetcellrule{\symbolic}{\sstate, \jsilexpr_1, \jsilexpr_2}{\sstate'', (-, -, \sexprp)}$ (\ieq{2}), $\sexprp \neq \none$ (\ieq{3}), 
and $\sstate' = \stupdt{\symbolic}(\sstate'', \jvar, \jtrue)$ (\ieq{4}). 
Since, $\stupdt{\symbolic}$ does not affect the path condition, we conclude, from \hyp{2} and \ieq{2}, that
$\istate = \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \sstate''.\pcsel)$ (\ieq{5}).
Applying Lemma~\ref{soundiness:getcell} to \ieq{2} and \ieq{5}, we conclude that
there is an instrumented state $\istate''$ and an instrumented value $\ival$, such that 
$\absgetcellrule{\instrumented}{\istate, \jsilexpr_1, \jsilexpr_2}{\istate'', (-, -, \ival)}$ (\ieq{6}), 
where $\istate'' = \interpret{\symbinst}{\senv}(\sstate'')$ (\ieq{7}) and $\ival = \interpret{\symbconc}{\senv}(\sexprv)$ (\ieq{8}). 
From \ieq{3} and \ieq{8}, we conclude that $\ival \neq \none$ (\ieq{9}). 
Applying Lemma~\ref{lemma:soundiness:store:update} to \ieq{4} and \ieq{7}, it follows
that  $\interpret{\symbinst}{\senv}(\sstate') = \stupdt{\instrumented}(\istate'', \jvar, \jtrue)$ (\ieq{10}).
Combining \ieq{6}, \ieq{9}, and \ieq{10}, we obtain the result. 
\vspace{5pt} 

\noindent \prooflab{Member Check - False}
From \hyp{1}, it follows that 
$$\absbsemrule{\sstate, \jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)}{\sstate'}{\symbolic} \text{ (\ieq{1})}$$
From \ieq{1}, we conclude that there is a symbolic expression $\sexprv$, and a symbolic state $\sstate''$ such that 
$\absgetcellrule{\symbolic}{\sstate, \jsilexpr_1, \jsilexpr_2}{\sstate'', (-, -, \sexprp)}$ (\ieq{2}), $\sexprp = \none$ (\ieq{3}), 
and $\sstate' = \stupdt{\symbolic}(\sstate'', \jvar, \jfalse)$ (\ieq{4}). 
Since, $\stupdt{\symbolic}$ does not affect the path condition, we conclude, from \hyp{2} and \ieq{2}, that
$\istate = \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \sstate''.\pcsel)$ (\ieq{5}).
Applying Lemma~\ref{soundiness:getcell} to \ieq{2} and \ieq{5}, we conclude that
there is an instrumented state $\istate''$ and an instrumented value $\ival$, such that 
$\absgetcellrule{\instrumented}{\istate, \jsilexpr_1, \jsilexpr_2}{\istate'', (-, -, \ival)}$ (\ieq{6}), 
where $\istate'' = \interpret{\symbinst}{\senv}(\sstate'')$ (\ieq{7}) and $\ival = \interpret{\symbconc}{\senv}(\sexprv)$ (\ieq{8}). 
 From \ieq{3} and \ieq{8}, we conclude that $\ival = \none$ (\ieq{9}). 
Applying Lemma~\ref{lemma:soundiness:store:update} to \ieq{4} and \ieq{7}, it follows
that  $\interpret{\symbinst}{\senv}(\sstate') = \stupdt{\instrumented}(\istate'', \jvar, \jtrue)$ (\ieq{10}).
Combining \ieq{6}, \ieq{9}, and \ieq{10}, we obtain the result. 
%\vspace{5pt} 
%
%\noindent \prooflab{Make Symbolic}
%From \hyp{1}, it follows that 
%$$\absbsemrule{\sstate, \jvar := \jvar := \makesymbolic(\jtype)}{\sstate'}{\symbolic} \text{ (\ieq{1})}$$ 
%From \ieq{1}, we conclude that there is a symbolic variable $\svar$ such that 
%$\absval = \absmakesymbolicrule{\symbolic}{\absstate, \jtype}$ (\ieq{2}) and $\sstate' = \stupdt{}(\absstate, \jvar, \svar)$ (\ieq{3}). 
%From \hyp{2} and \ieq{2}, we conclude that there is a symbolic environment $\senv'$ such that
%$\ival = \absmakesymbolicrule{\instrumented}{\istate, \jtype}$ (\ieq{4}) and $\ival = \interpret{\symbconc}{\senv'}(\svar)$ (\ieq{5}). 
%Applying Lemma~\ref{lemma:soundiness:store:update} to \hyp{2}, \ieq{3}, and \ieq{5}, it follows that 
% $\interpret{\symbinst}{\senv}(\sstate') = \stupdt{\instrumented}(\istate, \jvar, \ival)$ (\ieq{6}).
% Combining \ieq{4} and \ieq{6}, we obtain the result.  
\end{proof}

\begin{lemma}[Control Flow Commands - Bounded Soundness for Symbolic Semantics]\label{soundiness:control:flow:cmds}
$$
\begin{array}{l} 
\abssemrule{\sstate, \scs, i}{\sstate', \scs', j}{\mode}{\mode'}{\symbolic} 
     \, \wedge \, (\istate, \cs) = \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \pc, \scs) \\ \quad
     \, \wedge \, \pc \vdash \sstate'.\pcsel  \\ \quad \quad
     \implies 
        \exists \, \istate' \, . \, \abssemrule{\istate, \cs, i}{\istate', \cs', j}{\mode}{\mode'}{\instrumented} \\  \quad \quad \quad \quad \quad
         \, \wedge \, 
            (\istate', \cs') = \interpret{\symbinst}{\senv'}(\sstate' \, \wedge \, \pc, \cs')  \, \wedge \, 
            \senv' \fextends  \senv
 \end{array}
$$
\end{lemma}

\begin{proof}
Suppose $\abssemrule{\sstate, \scs, i}{\sstate', \scs', j}{\mode}{\mode'}{\symbolic}$ (\hyp{1}) and 
$(\istate, \cs) = \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \sstate'.\pcsel, \scs)$ (\hyp{2}).
We proceed by case analysis on the rule used to derive \hyp{1}. 
\vspace{3pt}

\noindent \prooflab{Basic Command} 
From \hyp{1}, it follows that $\abssemrule{\sstate, \scs, i}{\sstate', \scs, i{+}1}{\top}{\top}{\symbolic}$ (\ieq{1}), 
$\ccmd[\prog][\scs]{i} = \bcmd$ (\ieq{2}), and $\absbsemrule{\sstate, \bcmd}{\sstate'}{\symbolic}$ (\ieq{3}). 
Applying Lemma~\ref{lemma:soundiness:basic:commands} to \ieq{3} and \hyp{2}, we conclude that 
there is a symbolic environment $\senv'$ and an instrumented state $\istate'$ such that: 
$\absbsemrule{\istate, \bcmd}{\istate'}{\instrumented}$ (\ieq{4}), $\istate' = \interpret{\symbinst}{\senv}(\sstate')$ (\ieq{5}), 
and $\senv' \fextends \senv$ (\ieq{6}). 
From \ieq{2} and \ieq{4}, we conclude that $\abssemrule{\istate, \cs, i}{\istate', \cs, i{+}1}{\top}{\top}{\instrumented}$ (\ieq{7}). 
 Combining \hyp{2} and \ieq{5}-\ieq{7}, we obtain the result.  
 \vspace{5pt}

\noindent \prooflab{Cond. Goto - True} 
From \hyp{1}, it follows that $\abssemrule{\sstate, \scs, i}{\sstate', \scs, j}{\top}{\top}{\symbolic}$ (\ieq{1}), 
$\ccmd[\prog][\scs]{i} =  \ifgoto{\jsilexpr}{j}{k}$ (\ieq{2}), and 
$ \sstate' = \absassume{\symbolic}(\sstate, \jsilexpr)$ (\ieq{3}). 
Applying Lemma~\ref{lemma:soundiness:assume} to 
\hyp{2}, we conclude that 
$ \absassume{\instrumented}(\istate, \jsilexpr) = \interpret{\symbinst}{\senv}(\sstate')$ (\ieq{4}). 
From \ieq{2} and \ieq{4}, we conclude that 
$$\abssemrule{\istate, \cs, i}{\interpret{\symbinst}{\senv}(\sstate'), \cs, i{+}1}{\top}{\top}{\instrumented} \text{ (\ieq{5})}$$
Combining \hyp{2} and \ieq{5}, we obtain the result.     
 \vspace{5pt}

\noindent \prooflab{Cond. Goto - False} Similar to \prooflab{Cond. Goto - True}. 
 \vspace{5pt}
 
\noindent \prooflab{Goto} From \hyp{1}, it follows that $\abssemrule{\sstate, \scs, i}{\sstate, \scs, j}{\top}{\top}{\symbolic}$ (\ieq{1}),   
where $\ccmd[\prog][\scs]{i} = \goto \, j$ (\ieq{2}). 
From \ieq{2}, we conclude that 
$$\abssemrule{\istate, \cs, i}{\istate, \cs, j}{\top}{\top}{\instrumented} \text{ (\ieq{3})}$$
Combining \hyp{2} and \ieq{3}, we obtain the result. 
 \vspace{3pt}
 
\noindent \prooflab{Normal Return}
From \hyp{1}, it follows that $\abssemrule{\sstate, \scs, \retlab}{\sstate', \scs', i}{\top}{\top}{\symbolic}$ (\ieq{1}), 
$\scs = (-, \sstore', \jvar, i, -) :: \scs'$ (\ieq{2}), $\sstore = \sstate.\stosel$ (\ieq{3}), 
and 
$$\sstate' = \stupdt{\symbolic}(\sstate[\stosel \mapsto \sstore'], \jvar, \sstore(\retvar)) \text{ (\ieq{4})}$$
From \ieq{2}, we conclude that $\cs = (-, \interpret{\symbconc}{\senv}(\sstore'), \jvar, i, -) :: \interpret{\symbconc}{\senv}(\scs')$ (\ieq{5}). 
From \ieq{3}, we conclude that $\istate.\stosel = \interpret{\symbconc}{\senv}(\sstore)$ (\ieq{6}). 
Applying Lemma~\ref{lemma:soundiness:store:update} to \hyp{2}, \ieq{4} and \ieq{6}, we conclude that 
$$
\stupdt{\instrumented}(\istate[\stosel \mapsto \interpret{\symbconc}{\senv}(\sstore')], \jvar, \istate.\stosel(\retvar)) = \interpret{\symbinst}{\senv}(\sstate')
 \text{ (\ieq{7})}
$$ 
From \ieq{5} and \ieq{7}, we conclude that 
$$\abssemrule{\istate, \scs, \retlab}{\interpret{\symbinst}{\senv}(\sstate'), \interpret{\symbconc}{\senv}(\scs'), i}{\top}{\top}{\instrumented}$$ 
establishing the result. 
 \vspace{5pt}

\noindent \prooflab{Error Return}
Similar to \prooflab{Normal Return}. 
 \vspace{5pt}


\noindent \prooflab{Procedure Call}
From \hyp{1}, it follows that $\abssemrule{\sstate, \scs, i}{\sstate', \scs', 0}{\top}{\top}{\symbolic}$ (\ieq{1}), 
$\ccmd[\prog][\scs]{i} =   \jsilcall{\jvar}{\jsilexpr}{\jsilexpr_i \mid_{i = 0}^{n}}{j}$ (\ieq{2}), 
$\evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr) =  \pid'$ (\ieq{3}), 
$\args(\prog, \pid') = \jsillist{\jvar_1, ..., \jvar_{m}}$ (\ieq{4}), 
$\sexprv_i = \evalexpr{\symbolic}(\sstate.\stosel, \jsilexpr_i) \mid_{i = 0}^{n}$ (\ieq{5}), 
$\sexprv_i = \jundefined \mid_{i = n+1}^{m}$ (\ieq{6}), 
$\sstore' = [\jvar_i \mapsto \sexprv_i \mid_{i = 0}^{m}]$ (\ieq{7}),  
$\scs' = (\pid', \sstate.\stosel, \jvar, i{+}1, j) :: \scs$ (\ieq{8}), and 
$\sstate' = \sstate[\stosel \mapsto \sstore']$ (\ieq{9}). 
Applying Lemma~\ref{symb:eval:expr} to \hyp{2}, \ieq{3} and \ieq{5}, we conclude that 
$\evalexpr{\concrete}(\istate.\stosel, \jsilexpr) =  \pid'$ (\ieq{9}) 
and 
$\evalexpr{\concrete}(\istate.\stosel, \jsilexpr_i) = \interpret{\symbolic}{\senv}(\sexprv_i) \mid_{i = 0}^{n}$ (\ieq{10}). 
From \ieq{7}, it follows that $\interpret{\symbconc}{\senv}(\sstore') = [\jvar_i \mapsto \interpret{\symbconc}{\senv}(\sexprv_i) \mid_{i = 0}^{m}]$ (\ieq{11}). 
From \hyp{2} and \ieq{8}, it follows that $\interpret{\symbconc}{\senv}(\scs') = (\pid', \istate.\stosel, \jvar, i{+}1, j) :: \cs$ (\ieq{12}).
From \hyp{2}, \ieq{9}, and \ieq{11}, it follows that 
$\interpret{\symbconc}{\senv}(\sstate') = \istate[\stosel \mapsto  [\jvar_i \mapsto \interpret{\symbconc}{\senv}(\sexprv_i) \mid_{i = 0}^{m}]]$ (\ieq{13}). 
Combining \ieq{4} and \ieq{9}-\ieq{12}, the result follows. 
\vspace{5pt}

\noindent \prooflab{Assume}
From \hyp{1}, it follows that $\abssemrule{\sstate, \scs, i}{\sstate', \scs, i{+}1}{\top}{\top}{\symbolic}$ (\ieq{1}), 
$\ccmd[\prog][\scs]{i}  = \assume(\jsilexpr)$ (\ieq{2}), and $\sstate' = \absassume{}(\sstate, \jsilexpr)$ (\ieq{3}). 
Applying Lemma~\ref{lemma:soundiness:assume} to 
\hyp{2} and \ieq{3}, we conclude that 
$\absassume{\instrumented}(\istate, \jsilexpr) = \interpret{\symbinst}{\senv}(\sstate')$ (\ieq{4}). 
From \ieq{2} and \ieq{4}, we conclude that 
 $$\abssemrule{\istate, \cs, i}{\interpret{\symbinst}{\senv}(\sstate'), \cs, i{+}1}{\top}{\top}{\instrumented} \text{ (\ieq{5})}$$
 Combining  \ieq{2} and \ieq{5}, the result follows.
 \vspace{5pt}

\noindent \prooflab{Assert - True}
From \hyp{1}, it follows that $\abssemrule{\sstate, \scs, i}{\sstate, \scs, i{+}1}{\top}{\top}{\symbolic}$ (\ieq{1}), 
$ \ccmd[\prog][\scs]{i}  = \jassert(\jsilexpr)$ (\ieq{2}), and $\abssat{\symbolic}(\sstate, \neg \jsilexpr) = \jfalse$ (\ieq{3}). 
Applying Lemma~\ref{lemma:soundiness:sat} to \ieq{3}, we conclude that 
$\abssat{\instrumented}(\istate, \neg \jsilexpr) = \jfalse$ (\ieq{4}). 
Combining \ieq{2} and \ieq{4}, the result follows. 
 \vspace{5pt}
 
\noindent \prooflab{Assert - False}
Similar to \prooflab{Assert - True}. 
 \vspace{5pt} 
\end{proof}


\begin{lemma}[Monotonicity of Path Condition]\label{lemma:pc:monotonocity}
$$
\begin{array}{l}
\transabssemrule{\sstate, \scs, i}{\sstate', \scs', j}{\mode}{\mode'}{\symbolic} 
    \implies \sstate'.\pcsel \vdash \sstate.\pcsel
\end{array}
$$
\end{lemma}
\begin{proof}
By induction on the length of the symbolic trace 
$$\transabssemrule{\sstate, \scs, i}{\sstate', \scs', j}{\mode}{\mode'}{\symbolic}$$
The proof becomes trivial once we've observed that one step of the symbolic execution either does not change the path condition or further constrains it through conjunction), i.e.,~the path condition is never relaxed by the symbolic execution. Therefore, all models of $\sstate'.\pcsel$ must also be the models of $\sstate.\pcsel$.
\end{proof}


\begin{lemma}[Bounded Soundness of the \jsil symbolic execution: Symbolic-to-Instrumented (1)]\label{lemma:full:soundiness}
$$
\begin{array}{l} 
\transabssemrule{\sstate, \scs, i}{\sstate', \scs', j}{\mode}{\mode'}{\symbolic} \, \wedge \, 
     (\istate, \cs) = \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \pc, \scs)  \\ \quad \, \wedge \, 
     \pc \vdash \sstate'.\pcsel \\ \quad \quad
     \implies 
        \exists \, \istate', \cs' \, . \, \transabssemrule{\istate, \cs, i}{\istate', \cs', j}{\mode}{\mode'}{\instrumented} \\ \quad \quad \quad
         \, \wedge \, 
            (\istate', \cs') = \interpret{\symbinst}{\senv'}(\sstate', \scs')  \, \wedge \, 
            \senv' \fextends  \senv
 \end{array}
$$
\end{lemma}
\begin{proof}

Suppose:
$$
\transabssemrule{\sstate, \scs, i}{\sstate', \scs', j}{\mode}{\mode'}{\symbolic} \text{ (\hyp{1})}
\quad 
 (\istate, \cs) = \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \pc, \scs) \text{ (\hyp{2})}
 $$
and
$\pc \vdash \sstate'.\pcsel$ (\hyp{3}). 
We have to prove that there is an instrumented state $\istate'$,
such that $\transabssemrule{\istate, \cs, i}{\istate', \cs', j}{\mode}{\mode'}{\instrumented}$, 
$(\istate', \cs') = \interpret{\symbinst}{\senv'}(\sstate', \scs')$, and $\senv' \fextends  \senv$.
We proceed by induction on the length of the symbolic trace 
 $\transabssemrule{\sstate, \scs, i}{\sstate', \scs', j}{\mode}{\mode'}{\symbolic}$. 
Suppose the symbolic trace has length $n$. 
\vspace{6pt}

\noindent \prooflab{Base Case} $n = 0$. It follows that $\sstate' = \sstate$, 
$\scs = \scs'$, and $j = i$. Noting that 
$\transabssemrule{\istate, \cs, i}{\istate, \cs, i}{\mode}{\mode'}{\instrumented}$
and 
$(\istate, \cs) = \interpret{\symbinst}{\senv}(\sstate, \scs)$ (from \hyp{2}), 
the result follows. 
\vspace{6pt}


\noindent \prooflab{Inductive Case} $n = m + 1$. It follows that there is a symbolic state 
$\sstate''$, a context $\scs''$, an index $k$, and a mode $\mode''$, such that: 
$$
\begin{array}{c}
\transabssemrule{\sstate, \scs, i}{\sstate'', \scs'', k}{\mode}{\mode''}{\symbolic} \text{ (\ieq{1})} \\ 
\abssemrule{\sstate'', \scs'', k}{\sstate', \scs', j}{\mode}{\mode'}{\symbolic} \text{ (\ieq{2})}
\end{array}
$$
From \ieq{1} and \ieq{2}, it follows that $\mode = \mode'' = \top$. 
Applying Lemma~\ref{lemma:pc:monotonocity} to \ieq{2}, we conclude that $\sstate'.\pcsel \vdash \sstate''.\pcsel$ (\ieq{3}). 
From \hyp{3} and \ieq{3}, it follows that $\pc \vdash \sstate''.\pcsel$ (\ieq{4}). 
Applying the induction hypothesis to \hyp{2}, \ieq{1} and \ieq{4}, and, we conclude that 
there is an instrumented state $\istate''$ and $\cs''$, such that
$\transabssemrule{\istate, \cs, i}{\istate'', \cs'', k}{\mode}{\mode''}{\instrumented}$ (\ieq{5}), 
$(\istate'', \cs'') = \interpret{\symbinst}{\senv'}(\sstate'' \, \wedge \, \pc, \scs'')$ (\ieq{6}), and 
$\senv' \fextends  \senv$ (\ieq{7}). 
Applying Lemma~\ref{soundiness:control:flow:cmds} to \hyp{2}, \ieq{2}, and \ieq{6},
it follows that  
$\abssemrule{\istate'', \cs'', k}{\istate', \cs', j}{\mode}{\mode'}{\instrumented}$ (\ieq{8}), 
$(\istate', \cs') = \interpret{\symbinst}{\senv''}(\sstate' \, \wedge \, \pc, \cs')$ (\ieq{9}), and 
$\senv'' \fextends  \senv$ (\ieq{10}). 
Combining \ieq{5} and \ieq{8}, we conclude that 
$\abssemrule{\istate, \cs, i}{\istate', \cs', j}{\mode}{\mode'}{\instrumented}$ (\ieq{11}). 
Combining \ieq{9}, \ieq{10}, and \ieq{11}, we obtain the result. 
\end{proof}

\begin{lemma}[Bounded-Soundness of the \jsil symbolic execution: Symbolic-to-Instrumented (2)]
$$
\begin{array}{l}
\transabssemrule{\sstate, \scs, i}{\sstate', \scs', j}{\mode}{\mode'}{\symbolic}  
    \ \wedge \ (\istate, \cs) \in \interpret{\symbinst}{\senv}(\sstate \, \wedge \, \pc, \scs) \\ \quad \quad 
    \ \implies \ \exists \, \senv', \istate', \cs' \, . \, 
        \transabssemrule{\istate, \cs, i}{\istate', \cs', j}{\mode}{\mode'}{\instrumented} \\ \quad \quad  \quad \quad \quad \quad 
               \ \wedge \ (\istate', \cs') \in \interpret{\symbinst}{\senv'}(\sstate', \scs')
\end{array}
$$
\end{lemma}
\begin{proof}
Immediate, from Lemma~\ref{lemma:full:soundiness}, by picking $\pc = \sstate'.\pcsel$.
\end{proof}

\begin{lemma}[Two-Level Symbolic Interpretation]\label{lemma:symb:interpretation}
$$
\begin{array}{l}
((\jstate, \heap_f), \cs) \in \interpret{\symbconc}{\senv}(\sstate, \scs) \\ \quad \quad
   \iff 
   \exists \, \istate, h_F \, . \, 
         (\istate, \cs) = \interpret{\symbinst}{\senv}(\sstate, \scs)  
          \ \wedge \   
      \jstate = \interpret{\instconc}{}(\istate) \\ \quad \quad \quad \quad \quad
      \ \wedge \
      h_F \disjoint \istate.\hpsel
\end{array}
$$
\end{lemma}
\begin{proof}
Immediate from the definitions of $\interpret{\symbconc}{\senv}$, $\interpret{\symbinst}{\senv}$, 
and $\interpret{\instconc}{}$. 
\end{proof}


\begin{temax}[Bounded Soundness + Frame Resilience - Theorem~\ref{teo:soundness:jsil:symb:exe}]
$$
\begin{array}{l}
 \transabssemrule{\sstate, \scs, i}{\sstate', \scs', j}{\mode}{\mode'}{\symbolic} 
    \\ \quad \wedge \ (\jstate, \heap_f) \in \interpret{\symbconc}{\senv}(\sstate \, \wedge \, \sstate'.\pcsel) \ \wedge \ \cs = \shorthand(\scs) \\ \qquad \implies \exists \, \jstate', \cs' \, . \,
       \transabssemrule{\jstate \dunion \heap_f, \cs, i}{\jstate' \dunion \heap_f, \cs', j}{\mode}{\mode'}{\concrete} \\ \qquad \qquad \quad
               \wedge \ (\jstate', \heap_f) \in \interpret{\symbconc}{\senv}(\sstate')
               \ \wedge \ \cs' = \shorthand(\scs')
\end{array}
$$
\end{temax}
\begin{proof}
We show how the intermediate results can be used together to 
obtain the soundiness theorem (Theorem~\ref{teo:soundness:jsil:symb:exe}). 
Assume we have that 
$\transabssemrule{\sstate, \scs, i}{\sstate', \scs', j}{\mode}{\mode'}{\symbolic}$ (\hyp{1}) and 
 $(\jstate, \cs, \heap_f) \in \interpret{\symbconc}{\senv}(\sstate \, \wedge \, \sstate'.\pcsel, \scs)$ (\hyp{2}).  
 From \hyp{2}, we conclude, using Lemma~\ref{lemma:symb:interpretation}, that there is an 
 instrumented state $\istate$ and a heap $\heap_f$ such that $(\istate, \cs) = \interpret{\symbinst}{\senv}(\sstate  \, \wedge \, \sstate'.\pcsel, \scs)$ (\ieq{1}), 
 $\jstate = \interpret{\instconc}{}(\istate)$ (\ieq{2}), and $h_F \disjoint \istate.\hpsel$ (\ieq{3}). 
 Applying Theorem~\ref{lemma:soundness:jsil:symb:exe:instrumented:instrumented} to \hyp{1} 
 and \ieq{1}, it follows that there is a symbolic environment $\senv'$, an instrumented state $\istate'$, 
 an a call stack $\cs'$ such that: 
$\transabssemrule{\istate, \cs, i}{\istate', \cs', j}{\mode}{\mode'}{\instrumented}$~(\ieq{4})
and $(\istate', \cs') = \interpret{\symbinst}{\senv'}(\sstate', \scs')$ (\ieq{5}).
From \ieq{3} and \ieq{4}, we conclude, using Theorem~\ref{teo:frame:property}, that the following 
holds $\transabssemrule{\istate \dunion \heap_f, \cs, i}{\istate' \dunion \heap_f, \cs', j}{\mode}{\mode'}{\instrumented}$ (\ieq{6}). 
Applying Lemma~\ref{lemma:instrumented:semantics} to \ieq{2} and \ieq{6}, we conclude that 
 $\transabssemrule{\jstate \dunion \heap_f, \cs, i}{\jstate' \dunion \heap_f, \cs', j}{\mode}{\mode'}{\instrumented}$ (\goal{1}), 
 where $\jstate' = \interpret{\instconc}{}(\istate')$ (\ieq{8}).
 From \ieq{5}, \ieq{6}, and \ieq{8}, we conclude, applying Lemma~\ref{lemma:symb:interpretation}, 
 that:
 $$(\jstate', \cs', \heap_f) \in \interpret{\symbconc}{\senv}(\sstate', \scs') \text{ (\goal{2})}$$  
 which concludes the proof. 
\end{proof}

%
\begin{cormax}[Corollary~\ref{bug:finding} - Bug-finding]
$$
\transabssemrule{\sstate, \scs, i}{\sstate', \scs', j}{\mode}{\bot}{\symbolic}  
      \ \implies \  \exists \jstate, \cs \, . \, \transabssemrule{\jstate, \cs, i}{-, -, j}{\mode}{\bot}{\concrete}  
$$
\end{cormax}

