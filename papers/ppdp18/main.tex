\documentclass[sigconf, review]{acmart}


\usepackage{enumitem}
\setlist[description]{leftmargin=\parindent,labelindent=\parindent}

\usepackage{xcolor}
%\usepackage{amsmath}
\usepackage{listingsutf8}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{xspace}
\usepackage{textcomp}
\usepackage{wasysym,stmaryrd}
\usepackage{mathpartir}
\usepackage{url}
%\usepackage{upgreek}
\usepackage{xparse}
\usepackage{booktabs}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage{stix}
\usepackage{placeins} % for \FloatBarrier

\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage[export]{adjustbox}

%\usepackage{algorithm}
%\usepackage{algpseudocode}

\usepackage{enumitem}

\usepackage{wrapfig}
\usepackage{fancyvrb}

\usepackage{caption}

\usepackage{makecell}

\usepackage{varwidth}
\DeclareCaptionFormat{nastyCaption}{%
  % #1: label (e.g. "Table 1")
  % #2: separator (e.g. ": ")
  % #3: caption text
  \begin{varwidth}{\linewidth}%
    \centering
    #1#2#3%
  \end{varwidth}%
}

\setlist[description]{leftmargin=\parindent,labelindent=\parindent}

\usepackage{subcaption}

\makeatletter
\newif\ifFV@bgcolor
\newbox\FV@bgbox
\define@key{FV}{bgcolor}{\FV@bgcolortrue\def\FV@bgcolor{#1}}

\def\FV@BeginVBox{%
  \leavevmode\ifFV@bgcolor\setbox\FV@bgbox=\fi
  \hbox\ifx\FV@boxwidth\relax\else to\FV@boxwidth\fi\bgroup
  \ifcase\FV@baseline\vbox\or\vtop\or$\vcenter\fi\bgroup}
\def\FV@EndVBox{\egroup\ifmmode$\fi\hfil\egroup
  \ifFV@bgcolor\colorbox{\FV@bgcolor}{\box\FV@bgbox}\fi}
\makeatother

\newcommand{\shat}{\^{s}}

%JavaScript 
\definecolor{SkyBlue}{rgb}{0.20,0.39,0.64}
\definecolor{Plum}{rgb}{0.46,0.31,0.48}
\definecolor{Chocolate}{rgb}{0.75,0.49,0.07}
\definecolor{Aluminium5}{rgb}{0.33,0.34,0.32}
\definecolor{DarkGreen}{rgb}{0.2,0.5,0.2}
\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkblue}{rgb}{0,0.2,0.7}
\definecolor{dkgreen}{rgb}{0,0.4,0}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}
\definecolor{dkred}{rgb}{0.6,0,0}
\definecolor{talkred}{rgb}{0.69,.20,0.22}
\definecolor{talkblue}{rgb}{0.04,0.40,0.80}
\definecolor{talkgreen}{rgb}{0.34,.81,0.10}
\definecolor{oldtalkblue}{rgb}{0.22,.20,0.69}
\definecolor{greenish}{rgb}{.0,.65,.0}
\definecolor{mygray}{gray}{0.9}

\lstset{
	showstringspaces=false
}

\lstdefinelanguage{JavaScript}{
  morekeywords=[1]{typeof, new, true, false, catch,
    function, return, null, catch, switch, var,
    if, in, while, do, else, case, break, continue},
  morekeywords=[2]{class, export, boolean, throw, implements, import, this},
  numbers=left,
  numbersep=4pt,
  numberstyle=\tiny\color{dkblue},
  columns=fullflexible,
  sensitive=false,
  comment=[l]{//},
  captionpos=b,   
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  basicstyle=\scriptsize\texttt,
  identifierstyle=\ttfamily\color{Aluminium5},
  keywordstyle=[1]\ttfamily\color{Plum},
  keywordstyle=[2]\ttfamily\color{SkyBlue},
  stringstyle=\ttfamily\color{DarkGreen},
  commentstyle=\ttfamily, 
%  commandchars=\$\{\}
}[keywords,comments,strings]

\lstdefinelanguage{Scheme}{
  morekeywords=[1]{define, define-syntax, define-macro, lambda, define-stream, stream-lambda},
  morekeywords=[2]{begin, call-with-current-continuation, call/cc,
    call-with-input-file, call-with-output-file, case, cond,
    do, else, for-each, if,
    let*, let, let-syntax, letrec, letrec-syntax,
    let-values, let*-values,
    and, or, not, delay, force,
    quasiquote, quote, unquote, unquote-splicing,
    map, fold, syntax, syntax-rules, eval, environment, query },
  morekeywords=[3]{import, export},
  alsodigit=!\$\%&*+-./:<=>?@^_~,
  sensitive=true,
  morecomment=[l]{;},
  morecomment=[s]{\#|}{|\#},
  morestring=[b]",
  basicstyle=\scriptsize\ttfamily,
  keywordstyle=\bf\ttfamily\color[rgb]{0,.3,.7},
  commentstyle=\color[rgb]{0.133,0.545,0.133},
  stringstyle={\color[rgb]{0.75,0.49,0.07}},
  upquote=true,
  breaklines=true,
  breakatwhitespace=true,
  literate=*{`}{{`}}{1}
}

\def\schemeinline{\lstinline[language=Scheme, basicstyle=\small\ttfamily]}

\lstnewenvironment{lstjs}{\lstset{language=JavaScript,basicstyle=\fontsize{8}{8}\ttfamily,escapeinside={~}{~}}}{}
\def\jsinline{\lstinline[language=JavaScript, basicstyle=\small]}


% The Acronyms of the project and some other stuff
\newcommand{\jsil}{JSIL\xspace}
\newcommand{\jsverify}{JSVerify\xspace}
\newcommand{\JSComp}{JS-2-JSIL\xspace}
\newcommand{\jsilverify}{JSILVerify\xspace}


% Tikz 
\usepackage{tikz}
\usetikzlibrary{calc,positioning,arrows,shapes,decorations.pathmorphing}
\usetikzlibrary{arrows,positioning} 
\tikzset{
    %Define standard arrow tip
    >=stealth',
    % Define arrow style
    pil/.style={
           ->,
           shorten <=2pt,
           shorten >=2pt,}
}

\newcommand{\runpic}{\includegraphics[width=0.06\picwidth]{running.pdf}}
\newcommand{\tickpic}{\resizebox{0.06\picwidth}{!}{\(\color{greenish} \checkmark \)}}
\tikzset{
  box/.style = {rectangle, draw=black,align=center,font=\scriptsize},
  sbox/.style = {rectangle,draw=black,align=left,font=\scriptsize,text width=1.7cm},
  p/.style = {-latex},
  dp/.style = {latex-latex},
  sz/.style n args={2}{minimum width=#2, minimum height=#1},
  m/.style = {midway,inner sep=0pt,fill=white},
  ll/.style = {font=\scriptsize,anchor=south west}
}



% Polishing...
\newcommand{\polish}[1]{{\color{red}#1}}


\usepackage{cosette_macros}


% macros_js as for Jose Santos
%\usepackage{macros_js}
%\usepackage{gdshojs}

\newcommand{\cosette}{Cosette\xspace}
\newcommand{\rosette}{Rosette\xspace}

\newcommand{\myparagraph}[1]{\smallskip\noindent {\bf #1.}\hspace{1pt}}
\newcommand{\myparagraphq}[1]{\smallskip\noindent {\bf #1?}\hspace{1pt}}

% COMMENTS

\newcommand{\pginline}[1]{ {\color{purple} *** PG : #1 ***} }
\newcommand{\pgmaxinline}[1]{ {\color{purple} *** PG : #1 ***} }
\newcommand{\pmaxinline}[1]{ {\color{blue} *** PM : #1 ***} }
\newcommand{\pinline}[1]{ {\color{blue} *** PM : #1 ***} }
\newcommand{\jfsinline}[1]{ {\color{green} *** JFS : #1 ***} }
\newcommand{\jdinline}[1]{ {\color{green} *** JD : #1 ***} }

\newif\ifComments
\Commentstrue

\newcommand{\pg}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.4\textwidth} \color{red}
{\rm PG: \small #1}
\end{minipage}}
\end{center}
\fi}

\newcommand{\pmax}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.4\textwidth} \color{blue}
{\rm PM: \small #1}
\end{minipage}}
\end{center}
\fi}

\newcommand{\jfs}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.4\textwidth} \color{SkyBlue}
{\rm JFS: \small #1}
\end{minipage}}
\end{center}
\fi}

\newcommand{\jd}[1]{%
\ifComments
\begin{center}
\fbox{\begin{minipage}{0.4\textwidth} \color{purple}
{\rm JD: \small #1}
\end{minipage}}
\end{center}
\fi}

\begin{abstract}
%\pginline{Not touched.}
We present \cosette, a framework for trustworthy, compositional symbolic execution of JavaScript programs.
%\cosette is the first symbolic analysis tool for JavaScript that
%precisely models the semantics of the language.
Its aim  is to
  provide \emph{general-purpose} symbolic analysis and {\em assist} 
  developers in the testing of their code: the developer writes symbolic tests for which \cosette provides concrete counter-models.
We create \cosette following a new, general methodology for designing compositional program analyses for dynamic languages.
We prove that the symbolic execution underpinning \cosette is sound
and does not generate false positives. We establish additional trust
by  using the theory to precisely guide the implementation and
by thorough testing.  
We apply Cosette to whole-program symbolic testing of real-world JavaScript libraries and compositional debugging of separation logic specifications of JavaScript programs. 

%Moreover, its compositionality allows us to use \cosette to find bugs in specifications of JS programs that are not detectable by standard symbolic execution techniques.
%\pmaxinline{Now compositionality.}
%
%We evaluate \cosette on challenging examples that showcase JS-specific features, as well as on real-world Node.js libraries, in which we detect several bugs. %These examples involve JavaScript-specific features, such as prototype inheritance, function closures, the for-in statement, and dynamic dispatch. 
%We highlight the range of \cosette by using it to debug %non-trivial 
%separation logic specifications of JS programs. 
%
%It works by compiling JavaScript programs to \jsil using \JSComp, a well-tested, standard-compliant compiler from JavaScript to \jsil, and then symbolically executing the obtained \jsil code using a novel symbolic interpreter for \jsil. We prove that the \jsil symbolic interpreter is \emph{sound} and that it does not generate false positives.
%
%\bigskip
%We present \cosette, a symbolic execution tool for JavaScript (ECMAScript 5, ES5), which precisely follows the language standard. At the core of \cosette is a sound symbolic interpreter for \jsil, an intermediate language well-suited for verification and analysis. This interpreter is written in \underline{Rosette}, %~\cite{Rosette2,Rosette1}, 
%a symbolic virtual machine that enables the design of new solver-aided languages. 
%\cosette works by first compiling JavaScript programs to \jsil using \underline{\JSComp}, %~\cite{javert}, 
%a well-tested, standard-compliant compiler from JavaScript to \jsil, and then symbolically executing the compiled \jsil code in the \jsil symbolic interpreter. 
%We study two complementary uses of \cosette. 
%First, we show how \cosette can be used for symbolic testing of JavaScript programs by finding concrete executions that trigger assertion and test failures. 
%We highlight the range of \cosette by giving examples using strings, regular expressions, and the notorious \jsinline|eval| statement.
%Second, building on \cosette, we develop a tool for debugging separation logic specifications by compiling them to symbolic tests in order to find 
%witnesses for bugs in both specification and code.
%
%\bigskip
%We present \cosette, a framework for bounded symbolic execution of JavaScript (JS) code (ECMAScript 5, ES5). 
%\cosette is the first symbolic execution tool for JS that models the language semantics precisely.  
%It works by first compiling JS programs to \jsil using \JSComp, a well-tested, standard-compliant compiler from 
%JS to \jsil, and then symbolically executing the obtained \jsil code using a novel symbolic interpreter for \jsil. 
%We prove that the \jsil symbolic interpreter is \emph{sound} and that it does not to generate false positives. 
%%every time the tool reports a bug, it provides a concrete model that triggers that bug. 
%
%We demonstrate how \cosette can be used for the symbolic testing of JS programs by 
%finding concrete executions that trigger assertion and test failures. We highlight the range of \cosette 
%by giving examples involving JS-specific features, such as: prototype-based inheritance, 
%the for-in statement, and JS arrays. Finally, we thoroughly evaluate \cosette against a 
%representative fragment of test262 adapted to include symbolic~values.
%
\end{abstract}

\title[\cosette:~Symbolic Execution for JavaScript]{\cosette:~Symbolic Execution for JavaScript}       

\author[J. Fragoso Santos, P. Maksimovi\'c, T. Grohens, J. Dolby, P. Gardner]{Jos\'e Fragoso Santos$^1$, Petar Maksimovi\'c$^1$, Th\'eotime
  Grohens$^2$, Julian Dolby$^3$, Philippa Gardner$^1$}
\affiliation{$^1\ $Imperial College London, $^2\ $ENS Paris, $^3\ $IBM Research}


\begin{document}
%

\maketitle 

%\pgmaxinline{Addresses in title are a bit weird.}

\section{Introduction}
\label{sec:intro}

%\pg{This is what we should answer by the introduction: 
%What's the problem with the current state of the art?
%What is our solution?
%Why is the problem we're solving hard?
%How do we solve the challenges?
%Why do we do better than existing work?
%What are the lessons learnt from the paper?}

%\pmax{Many messages, let's not forget any:
%\begin{itemize}
%\item Methodology for analysis of languages with no frame property
%\item Trustworthiness
%\item Compositionality
%\item Proper description of what we do and not do (soundiness, with or without the term itself) (no eval, for-in with a chosen enumeration)
%\item more...?
%\end{itemize}
%}
%
%%%symbolic execution is...
%

%%JS and symbolic execution, a gap 

%\pgmaxinline{Maybe can summarise the bug patterns, I jsut lifted from related work.}

JavaScript (JS)  is the most widespread dynamic language, used by 95.1\% of websites~\cite{JS948percent}.
Due to its dynamic, complex nature, it is known to be a difficult target for symbolic analysis. 
Recent symbolic execution tools for JavaScript~\cite{saxena:sp:2010,wittern:icse:2018,li:fse:2014} have made significant progress. 
%They focus on specific bug patterns for finding, for example, security vulnerabilities related to the misuse of strings~\cite{saxena:sp:2010}, malformed Web API requests~\cite{wittern:icse:2018}, and bugs arising from the DOM API~\cite{li:fse:2014}. 
They are fully automatic, aim at code in the large, and primarily
focus on scalability and coverage issues.  However, these tools do have some
limitations. They only target specific bug
patterns rather than general-purpose symbolic execution, and depend on
whole-program analysis.

Whole-program analysis is not sufficient for JavaScript applications, 
which are commonly run in highly dynamic execution
environments: for example, client-side programs dynamically load and
execute third-party code as a matter of course. One also needs to be
able to analyse incomplete code in a compositional manner.
Designing compositional analyses for dynamic languages such as JavaScript, 
however, is non-trivial. This is because, unlike static languages
such as C, C++ and Java, dynamic languages do not observe the
\emph{frame property}~\cite{reynolds:lics:2002}, essential for
compositionality. Intuitively, the frame property means that the
output of a program cannot change if the state in which it is run is
extended. In JavaScript, it is possible to introduce bugs by 
extending the state in which a program is run. To our knowledge, 
there has been no previous work on compositional symbolic execution
for JavaScript.

%Unlike static languages such as C, C++ and Java, JavaScript does 
%not observe the \emph{frame property}~\cite{reynolds:lics:2002}. 
%Intuitively, the frame property means that the output of a program 
%cannot change if the state in which is run is extended. 
%In JavaScript, it is possible to introduce bugs by extending the 
%state in which a program is run.

%Also, they do not come with formal correctness guarantees.

%% another gap

%test specs - stepping stone for fully compositional symbolic execution for JavaScript

%\polish{In order to provide such a tool, one has to be able to analyse incomplete code in a compositional manner.} 
%Such compositional analysis is especially important for JavaScript
%applications, which are commonly run in highly dynamic execution
%environments: for example, client-side programs dynamically load and
%execute third-party code as a matter of course. 


%%what we do and what are our contributions

%\pgmaxinline{This next paragraph is very clunky, but says the main
%  points, it needs to be kerpow, in one paragraph this is summary of
% what we've done.}




  We introduce \cosette, a framework for trusted, compositional 
  symbolic execution of JavaScript
  (ECMAScript 5 Strict~\cite{ecma}). 
  %\footnote{It is straightforward to extend this work to the 
  %non-strict mode of the language. Later extensions and 
  %revisions contain ECMAScript 5 as a common core.}).  
  Its target  is to
  provide \emph{general-purpose} symbolic analysis and {\em assist} 
  developers in the testing of their code.
  We present a new, general methodology for developing {\em compositional} 
  analyses for languages that do not satisfy the frame property, 
  and apply it to the design of the symbolic execution of Cosette. 
  %
  In contrast to existing tools, the symbolic analysis of \cosette 
  is fully formalised in a way that guides the implementation and is
  also {\em trusted}, in that it  follows the JavaScript
  semantics and does not produce false positive bug reports.
%  We design Cosette so that it can be {\em trusted}, with proper integration
%  between the semantics and tool development. This integration is not
%  present in other symbolic execution tools for JavaScript, since the
%  goal is usually to focus on specific bug-finding patterns rather
%  than general-purpose symbolic execution. 
  We apply Cosette to whole-program symbolic testing of 
  real-world JavaScript libraries and compositional debugging of separation 
  logic specifications of JavaScript programs. We illustrate these use cases 
  with a running example in \S\ref{sec:overview}.

\begin{wrapfigure}{R}{0.23\textwidth}
\vspace*{-0.3cm}
\hspace*{-0.63cm}
\centering
\includegraphics[width=0.26\textwidth]{figures/jilette_blue.png}
\vspace*{-0.55cm}
\label{fig:jilette:diagram}
\end{wrapfigure}

The architecture of \cosette is shown on the right. We extend JavaScript with constructs for creating and reasoning about symbolic values. Using \JSComp~\cite{javert}, a trusted compiler from JS to the \jsil intermediate language, we compile the extended JS program to an extended \jsil program. The core of \cosette is a new symbolic interpreter for
\jsil,  written in 
Rosette~\cite{Rosette2,Rosette1}, a framework for the creation of
symbolic interpreters. The 
JSIL symbolic interpreter either outputs a concrete counter-model for the given assertions, or guarantees correctness up to a given bound for unfolding loops and recursive~predicates. %\pmaxinline{This is the first time we mention `bound'.}


%comprises a
%simple extension of \JSComp~\cite{javert}, a trusted compiler from 
%JavaScript to the \jsil intermediate language, to account for symbolic values and
%assertions, and a new symbolic interpreter for JSIL, implemented using
%Rosette~\cite{Rosette2,Rosette1}.  
%The JSIL symbolic interpreter 
%either outputs a concrete counter-model for the given assertions, or
%guarantees correctness up to a given bound for unfolding loops and
%predicates.  %\pmaxinline{This is the first time
%                                %we mention `bound'.}
                  
%\pmax{Now, get rid of JS-2-JSIL. Lifting}  
            
Our new, general methodology underpinning the compositional JSIL symbolic
interpreter consists of three stages: \dtag{1}~we design an JSIL
instrumented semantics that exhibits the frame property by explicitly
keeping track of object properties that we know are {\em not present}; 
\dtag{2}~we define
the JSIL symbolic semantics by lifting the JSIL instrumented
semantics; and \dtag{3}~we link the JSIL symbolic semantics to the
JSIL concrete  semantics by describing the frames that can be safely
added to the initial state.
%
%Much like JavaScript, \jsil does not exhibit the frame property~\cite{reynolds:lics:2002}, raising the issue of how to guarantee that the results of the analysis still hold when extending the initial state of the analysed program with a given arbitrary frame.
The key innovation is to have the instrumented semantics as a proper
interim stage in the design of the symbolic execution, obtaining more modular
reasoning and substantially simpler proofs. We present this methodology  in~\S\ref{sec:jsil:symb:exec}. 








%We extend the syntax of JavaScript with constructs
%for creating and reasoning about symbolic values, which allow the
%developer to easily write assertions about the behaviour of their
%program. Using \JSComp, we compile the extended JS program to an
%extended \jsil program. The core of \cosette is a symbolic interpreter
%for \jsil, 



%%how do we do it


%Cosette depends on a new methodology, presented here, for designing compositional
%program analyses for languages that do not exhibit the frame property.
%
%For Cosette, the methodology is applied to JSIL, which like JavaScript
%does not satisfy the frame property. 




%\pgmaxinline{In section 3, just mention methodology, then immediately get on to
%  the abstract semantics, which is the key additional technical point
%  that I'm not mentioning in the introduction. Basically, most of para
%1 is out because given here.} 








%in that it comes with formal correctness guarantees and a \polish{result stating the precise conditions under which symbolic execution gives soundness}. 


An essential goal for us was to establish trust in Cosette. In
\S\ref{sex:formal:guarantees}, we give a {\em bounded soundness
  result} for the \jsil symbolic semantics and prove that \cosette
never produces false positive bug reports. These theoretical results,
combined with the correctness of the \JSComp compiler
and the fact that the memory models of JavaScript and \jsil are the
same by design, enable us to lift the results of analyses done on
compiled \jsil code back to the original JavaScript code
(cf.~\S\ref{subsec:liftmejs1}, \S\ref{subsec:liftmejs2}). We must also
establish trust in the Cosette implementation. 
We  implement the \jsil  instrumented interpreter following the \jsil 
instrumented semantics of \S\ref{subsec:instrumented} to the letter.
We test the combination of the 
JS-2-JSIL compiler and the \jsil instrumented  interpreter using Test262, 
the official ECMAScript test suite~\cite{test262}. Out of the
10469 tests for ES5 Strict, we identify 8330 tests appropriate
for our coverage, of which we pass 100\%.
Finally, we ensure that the \jsil symbolic interpreter obtained by the 
Rosette lifting of the \jsil instrumented interpreter is consistent 
with the symbolic semantics of \S\ref{subsec:symb:semantics}
by systematically constructing symbolic unit tests for each \jsil command,
assuming the premises and asserting the conclusion of the 
appropriate rule of the symbolic~semantics. 


%We also created a number of symbolic tests specifically to demonstrate that Cosette can reason about essential JavaScript features, such as prototype inheritance, function closures, arrays, strings, as well as the substantially more challenging for-in statement and dynamic dispatch.


%\pgmaxinline{Not finished trust, next bits might be useful.} 

%The main issue with most bug-finding tools is not that they are not sound, but that they are not \emph{trustworthy}: the extent of their soundness and precision is not formally characterised. They are usually not justified with respect to the semantics of the targeted language, often relying on unstated simplifying assumptions, if not explicitly departing from the semantics. Consequently, the fact that a bug-finding tool cannot find a bug carries no guarantees whatsoever with respect to the correctness of the input program. We trust these tools because they appear to work empirically. 

%The current approaches~\cite{.} normally do not give a formal account of the analysis and/or simplify the language semantics. Our approach to designing \cosette is grounded on adherence to the standard and establishing trust. 




%We move the analysis to \jsil, an intermediate representation for logic-based analysis of JavaScript, which comes with a trusted compiler, \JSComp~\cite{javert}.
%, which has been extensively tested against the official test suite, Test262.\footnote{\url{https://github.com/tc39/test262}} 
%and produces \jsil code that corresponds line-by-line to the
%standard. 





%In \S\ref{sec:jsil:symb:exec}, we give a novel abstract semantics for \jsil, which we instantiate to obtain the concrete and symbolic semantics, connected via a {\em bounded soundness result}. Moreover, we prove that \cosette is precise, meaning that it never produces false positive bug reports. 
%These theoretical results, combined with the correctness of \JSComp and the fact that the memory models of JavaScript and \jsil are the same by design, 
%allow us to  provably lift the results of analyses done on compiled
%\jsil code back up to JavaScript (\S\ref{sec:lifting}). %To our
                                %knowledge, this is the first
                                %formalisation of a symbolic execution
                                %used for JavaScript analysis, and is
                                %the first symbolic execution for
                                %JavaScript that precisely follows the
                                %semantics of the language.


%\pgmaxinline{The bit on trustworthyness in section 5 can be shortened. Readers need to be reminded what was said in intro,  that's all. I do think there should be a proper evaluation of  Cosette coverage in evaluation. We can do whole-program analysis up  to the coverage point.}


%\pgmaxinline{This next bit can be shortened, to dovetail with section 2 which is also on application. For each applciation, update the evaluation to match what you do in 5} 





We apply Cosette to whole-program symbolic testing. 
A general developer can use \cosette for symbolic testing of
their code by having symbolic inputs instead of concrete
inputs and stating the constraints that the output needs to satisfy as
simple, intuitive first-order assertions over these inputs. If
a test fails, \cosette provides the concrete input that causes it to
fail, exposing bugs in the tested code. In \S\ref{sec:evaluation}, 
we evaluate \cosette on two real-world JavaScript data structure libraries,
where, using fewer tests, we achieve better coverage (100\%) than
the concrete unit test suites shipped with the libraries, and
discover unexpected bugs in both libraries.


%: Buckets.js [? ] with 65k downloads on
%npm~\cite{.}, and queue-pri [? ]. We found a significant bug in both
%libraries, and obtained 100\% coverage with fewer symbolic tests.
%
%and provide a detailed evaluation in~\S\ref{sec:evaluation}



%In \S\ref{sec:evaluation}, we evaluate \cosette on challenging
%real-world examples that showcase JS-specific features, as well as on real-world Node.js libraries, in which we discover several~bugs. 


We also apply Cosette to specification-driven bug-finding. 
%\pmaxinline{Feeling stuck here.} 
%Due to the complexity of JavaScript semantics, 
Full functional correctness 
specifications of JavaScript programs are highly intricate, with only
a few tools (mainly, \javert~\cite{javert} and KJS~\cite{Park:2015,stefanescu:oopsla:2016}) supporting such expressivity. 
%They target the specialist developer wanting rich, mechanically verified specifications of critical JavaScript code.
When these tools cannot prove that a given function satisfies
a specification, the specialist developer needs to
understand in detail a complicated proof trace to discover the error. 
% (\javert), or act with essentially no feedback~(KJS). 
In \S\ref{subsec:sdbf}, we show how
\cosette can be used as an auxiliary mechanism for debugging
separation logic specifications of JavaScript programs in \javert.
This application of Cosette is possible due 
to its compositionality.
Our approach, described in detail in \S\ref{sec:specs}, consists of
translating the separation logic specifications into symbolic tests
and running these tests using \cosette.  Then, if a symbolic test
generated from a given specification fails, we can be sure that the
code to be verified does not satisfy its specification.  More
importantly, \cosette then generates a concrete witness that
invalidates the specification. This information greatly simplifies the
debugging of both specifications and code.

%%how we do it


%\pgmaxinline{Next para probably in conclusions, it's all about next
%  steps.} 
%
%
%Because it is trustworthy, \cosette can be used both as a basis for building other more specific analysis 
%\polish{(I can talk about the analysis that Peter Thieman wants to write)} and 
%as a testing oracle for other symbolic execution tools for JavaScript that purposely 
%ignore some corner cases of the language semantics. 
%\polish{No previous symbolic execution tool for JavaScript came with the frame resilience result. 
%None of them can be used to test JS specs.}



%
%Symbolic testing provides an analysis of whole program behaviour. It
%works well for static languages such as C and Java which satisfy the
%{\em frame property}. Intuitively, the frame property states that, if
%a program produces an output when run in a given state, then it will
%produce the same output when run in an extended state. With the frame
%property, testing a C or Java program with respect to a symbolic state
%guarantees that the program will behave in the same way when the state
%is extended arbitrarily.  Symbolic testing works less well for dynamic
%languages such as JavaScript which do not satisfy the frame property.
%Without the frame property, testing a JavaScript program with respect
%to an initial symbolic state does not guarantee that the program will
%behave in the same way when the state is extended.  Such whole-program
%analysis is therefore not the best fit for JavaScript applications,
%which are commonly run in highly dynamic execution environments
% where the state can be extended  arbitrarily. 
%
%
%
%%%what is our solution: compositionality
%
%
% We introduce {\em compositional} symbolic testing for JavaScript
% programs by working with partial instrumented symbolic heaps.
% Compositionality is acheived by providing instrumentation that
% explicitly keeping track of properties that must {\em not be present}
% in a given partial heap in order for the program to behave correctly.
% The operational semantics of JavaScript over such instrumented heaps does satisfy the frame
% property.  
%
%,,,,,
%
%
%
%
%
%
%
%instrumentation needed for frame. 
%
%spec-driven bug finding and compositional symbolic testing. 
%
%
%%%trustworthiness
%
%
%
%
%%%%%%evaluation of the tool
%
%We are doing compositional symbolic execution  for JavaScript 
%applications to whole-program symbolic testing, specification-driven
%bug finding and whatever else you've talking about 
%
%
%Moreover, the compositionality of \cosette allows us to catch bugs that are not reachable by standard symbolic execution tools.
%We illustrate the capabilities of \cosette on an array of examples, which include tests from the Test262 test suite and real-world Node.js libraries, and which make use of JavaScript-specific features, such as prototype inheritance, function closures, the for-in statement, and dynamic dispatch. \pmaxinline{Revisit after evaluation.}
%
%
%



%---------------THE OLD INTRO-----------------------

%\pmax{What is the reader supposed to learn?}






%In current program analysis research, there exists a gap between bug-finding techniques and verification techniques. Bug-finding discovers concrete executions that cause a given program to behave incorrectly, emphasising precision, that is, the absence of false positives. Verification produces proofs that a given program \emph{always} behaves correctly, emphasising soundness, which mandates adherence to the language standard and  exploration of all possible paths.
%
%Achieving soundness, however, is difficult and often costly, resulting in prohibitive scalability issues. In fact, most modern analysis applications, including bug-finding tools, have various intended and/or unintended sources of unsoundness~\cite{soundyPaper}.
%
%\polish{There is a growing consensus among experts that soundness is,
%in fact, not a necessity for most modern analysis
%applications~\cite{.}. Instead, the property they advocate and
%observe in the  majority of tools is \emph{soundiness}---maintaining
%soundness as much as possible, but without detrimental effects to
%precision and/or scalability.}


%Additionally, its compositionality allows us to catch a broader class of bugs than the current symbolic execution tools and also allows us to state the conditions under which the soundiness of \cosette becomes soundness, that is, when the absence of found bugs implies verification.

%However, compositionality is not trivial to achieve when the targeted programming language does not exhibit the frame property, as is the case for most dynamic languages including JavaScript.




%JavaScript is the most widespread dynamic language: it is the de facto language for client-side Web applications, used by 94.8\% of websites\footnote{\url{https://w3techs.com/technologies/details/cp-javascript/all/all}}; it is used for server-side scripting via Node.js; and it is even run on small embedded devices with limited memory. 
%It is the most active language in both GitHub and StackOverflow.\footnote{\url{http://githut.info}; \url{https://exploratory.io/viz/Hidetaka-Ko/94368d12800a?cb=1469037012628}}
%Due to its dynamic nature and complex semantics, JavaScript remains a difficult target for symbolic analysis and logic-based verification. 

%\pmax{Now, sth about the state-of-the-art}

% TO RELATED WORK
%Currently, several symbolic analysis tools for JavaScript are available, such as \pmaxinline{list them, cite them - are we doing static or dynamic also?}. \pmaxinline{Say something positive, don't know what, mention bug-finding}. However, there exists a gap that needs to be addressed. The symbolic analysis engines of these tools are not formalised and do not come with correctness guarantees \pmaxinline{check, especially Jalangi}. Their analyses are also not compositional \pmaxinline{We don't know what this means yet, also check, but possibly omit}. Moreover, each of these tools is tailored for catching a specific category of bugs, rather than targeting bug-finding in general \pmaxinline{give evidence - also, why do we care?}.



%We evaluate \cosette on an array of examples, including tests from the official JavaScript Test262 test suite and real-world Node.js libraries. These examples involve JavaScript-specific features, such as prototype inheritance, function closures, the for-in statement, and dynamic dispatch. We highlight the range of \cosette by using it to find bugs in a number of non-trivial separation logic specifications of JavaScript programs.



%In \S\ref{???}, we give an abstract semantics of \jsil, which we instantiate to obtain the concrete %, instrumented (discussed shortly), 
%and symbolic semantics, connected via a {\em soundness result}. Moreover, we prove that, when used for symbolic testing (discussed shortly), \cosette never produces false counter-models. 
%These theoretical results, combined with the correctness of \JSComp, allows us to lift the results of analyses done on compiled \jsil code back up to JavaScript. 

%To our knowledge, this is the first formalisation of a symbolic execution used for JavaScript analysis, and is the first symbolic execution that precisely follows the semantics of the language.
 



%
%Current symbolic execution tools for JavaScript~\cite{???} are not compositional. They assume access to the entire program, meaning that the results they obtain when analysing functions in isolation cannot be reused, as they would not account for the interaction between the function and all of its possible frames.
%
%In contrast, the symbolic execution of \cosette is compositional. This has several important benefits.
%
%First, it allows us to use function specifications instead of symbolically executing function bodies at each call site, speeding up execution time. This benefit is independent of the analysed language.
%
%Next, it allows us to catch frame bugs, which are not reachable by non-compositional symbolic execution tools. This benefit is specific to dynamic languages.
%
%Finally, it allows us to state a verification result for \cosette, precisely capturing the conditions under which our symbolic execution is sound.
%
%, meaning that once a program is analysed successfully, once can choose to re-use the results of the analysis when analysing code that calls it, also yielding a more scalable analysis.
 

%The second component that \cosette uses is \JSComp~\cite{javert}, 
%a well-tested, standard-compliant compiler from JavaScript to \jsil. We extend
%\JSComp with support for the non-strict mode of ES5, as well as
%regular expressions and the entire \jsinline|String| built-in library.
%\JSComp allows us to lift the \jsil symbolic execution to JavaScript by first compiling JavaScript code to \jsil code, and
%then symbolically executing the compiled code in the 
%\jsil symbolic interpreter. This process, described in \S\ref{symb:exec:comp},
%involves extending JavaScript syntax and the \JSComp compiler to support symbolic values and 
%constructs for reasoning about them. These constructs are intuitive
%and allow the general developer to easily write assertions about the behaviour
%of their program. 
%Moreover, we adjust the \jsil symbolic interpreter so that the abstraction level 
%of the generated \jsil code precisely matches the abstraction level of Rosette, 
% maximising the use of Rosette's native reasoning capabilities.

%dynamic languages: they feature extensible objects, dynamic property access, and dynamic function calls. In terms of separation logic, they do not have the frame property~\cite{???}. What this effectively means is that is possible to introduce bugs into a JS/\jsil program by only extending the state for which it behaved correctly. We refer to such bugs as {\em frame bugs}.  This benefit is independent of the analysed language. Second, it allows us to catch frame bugs, which are not reachable by non-compositional symbolic execution tools. This benefit is specific to dynamic languages. We achieve compositionality by keeping track of properties that we know are {\em not present} in a given object. This we describe in detail in \S\ref{???}. To our knowledge, \cosette is the first compositional symbolic execution tool for dynamic languages.



%\myparagraph{Overview} 
%In \S\ref{sec:overview}, we illustrate how \cosette can be used for symbolic testing and specification-directed debugging of JS code. In~\S\ref{sec:jsil:symb:exec}, we present our methodology for the design of program analyses for dynamic languages and give a detailed account of our symbolic execution for \jsil. Our experimental evaluation of \cosette is given in . Finally, in \S\ref{sec:rwc}, we discuss related work and give conclusions.


%\pmax{Say more clearly what the novelty is. Say in a very pretty way the connection between seplogic and non-seplogic, verification and symbolic execution, etc.}

%We highlight two relevant use cases for \cosette. First, we show how \cosette can be used as \dtag{i}~a tool for running symbolic tests for JavaScript programs; and \dtag{ii} a debugging tool for separation logic specifications of JavaScript programs.

%\myparagraph{Architecture}
%The core of \cosette consists of a symbolic interpreter for
%\jsil~\cite{javert}, a simple intermediate goto language. 
%We obtain this symbolic interpreter \emph{for free}, 
%by implementing a concrete \jsil interpreter in Rosette~\cite{Rosette2,Rosette1},~a 
%symbolic virtual machine that facilitates generation of solver-aided languages.
%We design the concrete interpreter so that all of Rosette's natively supported solver-aided features, such as advanced string and regular-expression reasoning, 
%are lifted to the \jsil symbolic interpreter. 
%In~\S\ref{sec:jsil:symb:exec}, we give a formalisation of the \jsil concrete and symbolic executions, linking them together with a {\em soundness result}. We also provide insights on how to correctly design the concrete \jsil interpreter in Rosette.

%The second component that \cosette uses is \JSComp~\cite{javert}, 
%a well-tested, standard-compliant compiler from JavaScript to \jsil. We extend
%\JSComp with support for the non-strict mode of ES5, as well as
%regular expressions and the entire \jsinline|String| built-in library.
%\JSComp allows us to lift the \jsil symbolic execution to JavaScript by first compiling JavaScript code to \jsil code, and
%then symbolically executing the compiled code in the 
%\jsil symbolic interpreter. This process, described in \S\ref{symb:exec:comp},
%involves extending JavaScript syntax and the \JSComp compiler to support symbolic values and 
%constructs for reasoning about them. These constructs are intuitive
%and allow the general developer to easily write assertions about the behaviour
%of their program. 
%Moreover, we adjust the \jsil symbolic interpreter so that the abstraction level 
%of the generated \jsil code precisely matches the abstraction level of Rosette, 
% maximising the use of Rosette's native reasoning capabilities.

%\myparagraph{Application: Symbolic Testing} A commonly used 
%approach to obtaining trust in JavaScript code is running it against 
%adhoc test batteries---verifying that given concrete inputs, the code produces the expected
%output. The main drawback of this approach is that tests, in general,
%cannot guarantee exhaustiveness. % we also cant guarantee exhaustiveness 
%In \S\ref{symbolic:testing}, we show how to use \cosette
%for symbolic testing of JavaScript code: instead of 
%tests with concrete 
%inputs, the developer uses symbolic inputs and states the 
%constraints that the output needs to satisfy as simple, intuitive 
%first-order assertions over these inputs. 
%Furthermore, if a test fails, \cosette provides the concrete inputs that cause it 
%to fail, exposing bugs in the tested code. 
%We highlight the capabilities of \cosette through examples that showcase
%challenging reasoning on strings, regular expressions, and the \jsinline|eval|
%statement.

%\myparagraph{Application: Debugging Separation Logic Specifications}
%Due to the complexity of JavaScript semantics, functional correctness 
%specifications of JS programs are highly intricate. 
%There are only a few tools (for example, \javert \cite{javert} and KJS \cite{Park:2015,stefanescu-park-yuwen-li-rosu-2016-oopsla}) that support such expressivity. They target the specialist developer wanting rich, 
%mechanically verified specifications of critical JavaScript code.
%However, when these 
%tools cannot prove that a given function satisfies a specification, to discover the error, 
%the developer needs to understand in detail a complicated proof trace (\javert), or even act with almost no feedback~(KJS). 
%
%In \S\ref{sec:specs}, we show how \cosette can be used as an auxiliary mechanism for debugging 
%separation logic specifications of JavaScript programs in \javert. 
%Our approach consists of: translating the separation logic specifications 
%into symbolic tests 
%and running these tests using \cosette. 
%Then, if a symbolic test generated from a given specification fails, we can 
%be sure that the code to be verified does not satisfy its specification. 
%More importantly, \cosette then generates a concrete witness that 
%invalidates the specification. This information greatly simplifies the debugging of 
%both specifications and code. 

%Jilette has the following benefits: 
%
%\dtag{1} it is \emph{useful}, in that it has tangible applications:
%	it can report bugs in JavaScript programs, producing concrete witnesses that trigger these  bugs; 
%	%
%	it can be used as a helper tool for developers of logic-based functional correctness specifications of JavaScript code; 
%	%
%	and it has support for advanced string reasoning, critical for reasoning about commonly used JavaScript code;
%
%\dtag{2} it is \emph{accessible}, in that it can easily be used by a general JavaScript developer: 
%	the annotation burden of \cosette is minimal; 
%	%
%	and the assertion language is simple and intuitive;
%\dtag{3} it is \emph{trustworthy}, in that its components come with correctness guarantees: 
%	the correctness of the \JSComp compiler ensures full adherence to the real semantics of JavaScript;
%	%
%	the soundness result for the symbolic execution used in \cosette guarantees absence of false positives;
%	and \polish{sentence about unification;}
%and \dtag{4} it is \emph{extensible}, in that its coverage can easily be extended in a modular way, allowing support for: 
%	built-in libraries not covered by \JSComp; 
%	%
%	and widely used runtime libraries that are not part of the standard, such as the DOM.

%\pmax{What's the story?
%\begin{enumerate}
%\setlength{\itemsep}{0.5em}
%\item 
%	{\bfseries Slogan}: Symbolic execution for JavaScript that precisely follows the language standard. \\ 
%	{\bfseries Goal}: Symbolic testing, bug-finding, concrete counter-models. \\
%	{\bfseries Novelty}: The precision wrt semantics, formal correctness guarantees. \\ 
%	{\bfseries Benefits}: Trustworthy, sound analysis. \\
%	{\bfseries Limitations}: No loop invariants, bounded. No eval.
%
%\item 
%	{\bfseries Slogan}: Compositional execution for dynamic languages in general, and JavaScript in particular. \\ 
%	{\bfseries Novelty}: Compositionality. \\ 
%	{\bfseries Benefits}: summaries, frame-related bugs.   
%	
%\item 
%	{\bfseries Application}: Symbolic testing of JavaScript programs. \\
%	{\bfseries Novelty}: None? \\ 
%	{\bfseries Evaluation}: Tests for the symbolic execution rules; JS programs using prototype inheritance, arrays, function closures, for-in, dynamic dispatch, etc.; test262 tests; node.js libraries for data structures
%	
%\item 
%	{\bfseries Application}: Debugging of separation logic specifications. \\ 
%	{\bfseries Novelty}: Counter-models for separation logic assertions. \\
%	{\bfseries Evaluation}: JaVerT specifications of this and that.
%\end{enumerate}}




%
%\myparagraphq{Why \cosette} 
%\cosette is \emph{useful}: it has tangible applications. 
%It can report bugs in JavaScript programs, producing concrete witnesses triggering the bugs. It can also be used as a helper tool for developers of logic-based functional correctness specifications of JavaScript code.
%\cosette is \emph{approachable}: it can easily be used by a general JavaScript developer. The annotation burden of \cosette is minimal and the assertion language is simple and intuitive. \polish{Sweet spot?}
%\cosette is \emph{trustworthy}: its components come with correctness guarantees. 
%The correctness of the \JSComp compiler ensures full adherence to the real semantics of JavaScript. The \cosette symbolic execution engine is based on a sound symbolic
%analysis for \jsil, guaranteeing the absence of false positives. \polish{Sentence about unification.}
%Finally, \cosette is \emph{extensible}: its coverage can easily be extended in a modular way. This gives us the mechanism for supporting built-in libraries not covered by \JSComp, or adding support for standard-external runtime libraries, such as the DOM.




%\newpage
%
%\myparagraph{What's in the paper}
%
%\bigskip
%\polish{TO GO IN SOMEWHERE \\
%
%Clarify ES5 Strict
%
%JaVerT targets the specialist
%developer wanting rich, mechanically verified specifications of critical JavaScript code.
%Functional correctness, yes, and it works, but paid for by a heavy annotation burden.
%}



%We show how  to use Jilette for writing symbolic tests for client side 
%JavaScript code calling Web APIs. In particular, we demonstrate how to 
%checking the conformance of Web API requests with their specified signatures. 
%The existing solutions for this problem are still imprecise due to the 
%dynamicity of JavaScript combined with the difficulty of reasoning about
%operations on symbolic strings \cite{Idontknow}. Jilette is an excellent fit for
%this task as it leverages on Rosette's back-end
%constraint solver, Z3, which supports reasoning on symbolic strings
%and regular expressions, whereas JS-2-JSIL successfully
%contains the complexity of JavaScript itself.

\section{Using \cosette}\label{sec:overview}
\input{sections/overview}

\section{Symbolic Execution for \jsil}\label{sec:jsil:symb:exec}
\input{sections/jsil_symb_exec}

\section{Specification-Driven Bug-Finding}\label{sec:specs}
\input{sections/specs}

%\newpage
%\section{From \jsil to JavaScript}\label{sec:lifting}
%\input{sections/lifting}

\section{Evaluation}\label{sec:evaluation}
\input{sections/evaluation}

\section{Related Work}
\label{sec:rwc} 

The existing literature covers a wide range of JavaScript analysis techniques, including: 
type systems~\cite{thiemann:esop:2005,anderson:ecoop:2005,jensen:sas:2009,typescript:toot:2014,feldthaus:oopsla:2014,bierman:ecoop:2014,rastogi:popl:2015},
control flow analysis~\cite{feldthaus2013efficient}, pointer analysis~\cite{jang2009points,sridharan:ecoop:12} and abstract
interpretation~\cite{kashyap:fse:14,jensen:sas:2009,andreasen:oopsla:2014,park:ecoop:15}, among others. We focus on the existing work on symbolic execution and  
logic-based analysis for JavaScript, and discuss techniques for specification-driven 
test generation in general.  

\myparagraph{Symbolic Execution for JS}
The majority of the existing bug-finding symbolic execution tools for JavaScript target specific bug patterns, 
such as security vulnerabilities related to the misuse of strings~\cite{saxena:sp:2010} 
(for example, absence of sanitisation before security critical operations), malformed Web API requests~\cite{wittern:icse:2018}, and
DOM API specific bugs~\cite{li:fse:2014}. These tools are fully automatic and aim at code in 
the large, primarily focusing on scalability and coverage issues. \cosette has a different 
purpose: it is not designed to be fully automatic, but to \emph{assist} developers in 
testing their code. 
%
The work closest to ours is \emph{Jalangi}~\cite{koushik:fse:2015}, a general-purpose 
symbolic execution tool for JavaScript that implements a sophisticated state merging 
algorithm to deal with the problem of symbolic state explosion. 
%
However, Jalangi, as all existing symbolic execution tools for JavaScript, does not follow 
the semantics of the language precisely. 
%
In contrast, \cosette is \emph{trustworthy}: it does follow the semantics of 
JavaScript and its theoretical underpinnings are formalised and proven sound. 
Therefore, it can be used both as a basis for building other more specific analyses 
(e.g., combining symbolic execution with a type-based analysis to increase the precision of the latter) and 
as a testing oracle for other symbolic execution tools for JavaScript that purposely 
ignore some corner cases of the JavaScript semantics. 
Furthermore, \cosette is the first symbolic execution tool for JavaScript that provides 
frame resilience guarantees, which are essential for any specification-related reasoning.
%None of them can be used to test JS specs. 
%None offer insights into implementation either.

%
%\begin{itemize}
%   %\item \cite{saxena:sp:2010} - Kudzu
%  % \item \cite{li:fse:2014} - Toshiba guys
%   \item \polish{\cite{koushik:fse:2015} - jalangi} Jalangi~\cite{koushik:fse:2015} is the closest 
%            to ours in spirit. It is a general analysis. It does not model the JavaScript semantics 
%            precisely. 
%   %\item \cite{wittern:icse:2018} -  Julian 
%\end{itemize}

% \cite{saxena:sp:2010,li:fse:2014,koushik:fse:2015,wittern:icse:2018}


%\begin{itemize}
%   \item \cite{dolby:fse:2007} - Julian 
%   \item \cite{milicevic:icse:2007} \cite{boyapati:issta:2002} - Korat
%   \item \cite{seidel:esop:2015} - Target
%   \item \cite{claessen:icfp:2000} - QuickCheck. but also: FLOPS 2014 - Generating constrained random data with uniform distribution
%\end{itemize}

\myparagraph{Specification-driven Testing}
There is a long line of work on specification-driven test synthesis, dating back to 
\emph{Quickcheck}~\cite{claessen:icfp:2000}. \emph{Quickcheck} and its followers~\cite{runciman:haskell:2008,claessen:jfunc:2015}
translate Haskell type declarations into comprehensive test-suites. 
Recently, Seidel et al.~\cite{seidel:esop:2015} proposed \emph{Target}, a test generation tool 
that advances the agenda of \emph{Quickcheck} by supporting precise refinement types. 
The key insight of \emph{Target} is to use %combine the approach of \emph{Quickcheck} with the use of
an SMT solver for finding models for the supported type refinements. 
Specification-driven test generation has also been successfully applied to Java.
\emph{Korat}~\cite{boyapati:issta:2002,milicevic:icse:2007} generates test cases for Java classes annotated with
JML specifications~\cite{jml}, but it requires the class code to include 
a special Java method for checking if the class invariants hold. 
More recently, Dolby et al. \cite{dolby:fse:2007} proposed a SAT-based approach
for testing Java code annotated with relational logic specifications.
 %
To the best of our knowledge, there are no tools for specification-driven
testing of JavaScript, as well as no tools for test generation 
based on separation logic specifications.
 % 
 %With \cosette, one could easily concretise the resulting symbolic tests, effectively  obtaining a concrete test generation tool for JaVerT specifications.
 %
% However, the resulting tests would necessarily have a smaller coverage than the original symbolic tests; hence, we opted not to do this. 

\myparagraph{Logic-based Verification for JavaScript}
\javert~\cite{javert} is a verification toolchain for JavaScript based on separation logic. 
It comes with a trusted compiler, \JSComp, which we extend with constructs for creating and reasoning about symbolic values and reuse as part of \cosette. Like \cosette, \javert also performs its analysis on compiled \jsil code. However, the rules for the \jsil symbolic execution of \javert are not syntax-directed and offer little implementation insight; our novel symbolic semantics for \jsil is syntax-directed and is specifically designed to guide  implementations. JaVerT has been used to verify functional correctness properties of simple data structure libraries. We reuse the specifications of these libraries to evaluate our symbolic test generation mechanism. These specifications are readable and easy to write, as JaVerT provides abstractions for most JavaScript-specific constructs. 
 
%There is little work on logic-based analyses for JavaScript.
%\citet{gardner:popl:2012} have developed JS Logic, a separation logic for a tiny fragment of ES3, to reason about the variable store emulated in the JavaScript heap. 
%This logic has proven difficult to automate and is not extensible to the entire language. 

Alternatively, we could have considered using the matching logic specifications of KJS~\cite{stefanescu:oopsla:2016}, a symbolic verification tool for core ES5 obtained by instantiating the general $\mathbb{K}$ framework with the semantics of JavaScript~\cite{Park:2015}. Similarly to \javert, KJS has been used to verify functional correctness properties of small data structure libraries.
However, KJS specifications are difficult to write and error-prone, as the developer has to  explicitly address all language internals. They are also not fully compositional, as they do not allow partial descriptions of JavaScript objects. 

There is also the work of \citet{swamy:pldi:2013}, who prove absence of runtime errors for higher-order JavaScript (ES3) programs by: compiling JS programs annotated with assertions and loop invariants to the logic of F*; generating verification conditions for the absence of runtime errors; and automatically discharging these conditions using Z3. However, as this analysis does not consider specifications, it was not possible for us to reuse its results for \cosette. 

All of the above-mentioned verification tools provide strong correctness guarantees, but have severe scalability limitations, as they require loop invariants and abstractions for the recursive structures that the programs use. For instance, the Buckets.js library would be out of their reach, as none of the existing tools comes with abstractions to accurately describe: JavaScript arrays, for-in loop invariants, and higher-order functions.  As a bug-finding tool, Cosette does not require any such abstractions, and can therefore be used for analysing substantially larger, more complex codebases.
% but the price paid is it can provide only bounded correctness guarantees when a bug has not been~found.


\section{Conclusions}

We have presented \cosette, a trustworthy, compositional symbolic execution
framework for JavaScript, combining the JS-2-JSIL compiler
and our JSIL symbolic interpreter written in Rosette. We
have applied Cosette to whole-program symbolic testing of real-world
JavaScript libraries and compositional debugging of separation logic
specifications of JavaScript programs.

We have developed a methodology for designing compositional program
analyses for dynamic languages in general, and symbolic execution for
JSIL in particular. We achieved this by introducing a new, abstract
semantics for JSIL, which we instantiated to obtain the concrete,
instrumented, and symbolic semantics. 
This abstract semantics is the bedrock for both the theoretical results 
and the implementation of the analysis. We prove that the \jsil symbolic 
execution of Cosette is
sound, frame-resilient and does not generate false positives. We
establish additional trust by using the theory to precisely guide the
implementation and by thorough~testing.

\cosette brings ideas from current separation logic research to the well-established 
setting of classical symbolic execution~\cite{andreasen:acmsurv:2017}. We believe that 
it is a stepping stone towards a {\em fully automatic} compositional symbolic execution 
tool for JavaScript in the style of Infer~\cite{calcagno:nasa:2011}. In future, 
our goal is to implement such a tool, using the \jsil abstract semantics presented here.


%\myparagraph{Entailment in Separation Logic and Countermodels}
%\begin{itemize}
%   \item 
%\end{itemize}



%
%\cite{gardner:popl:2012} have developed a separation logic for a small fragment of ECMAScript 3, to reason about the variable store emulated in the JavaScript heap.
%%
%\cite{rosu-serbanuta-2010-jlap} have developed $\mathbb{K}$, a term-rewriting framework  for  formalising the operational
%semantics of programming languages.
% In particular, they have developed KJS~\cite{Park:2015} which provides a $\mathbb{K}$-interpretation of the core language and part of the built-in libraries of the ES5 standard. KJS has been tested against the official ECMAScript Test262 test suite and passed all 2782 tests for the core language; the testing results for the built-in libraries are not reported. 
%\cite{stefanescu-park-yuwen-li-rosu-2016-oopsla} introduce a language-independent verification infrastructure 
%that can be instantiated with a $\mathbb{K}$-interpretation of a  language to automatically generate a symbolic verification tool for that language based on the $\mathbb{K}$ reachability logic. They apply this infrastructure to KJS to generate a verification tool for JavaScript, which they use to verify functional correctness properties of operations for manipulating data structures such as binary search trees, AVL trees, and lists.


%\section{Conclusions}\label{conclusions}

%\pmaxinline{Can we be more general, and say something like 'logic-based specifications'? It's all about translating to FOL, or even some version of PL. Also, we need to say at some point why we care about specifications written in separation logic.}

\newpage
\bibliographystyle{ACM-Reference-Format}
\bibliography{ppdp18}


\newpage
\appendix

\input{sections/appendix}
\input{sections/appendix-unification}
\newpage
\input{sections/appendix_eval}

\end{document}



We apply 
Cosette to whole-program symbolic testing and compositional,
specification-driven bug finding. With whole-program symbolic testing,
general JavaScript developers can test their programs with symbolic
tests instead of concrete unit tests. Symbolic tests have symbolic
inputs instead of concrete inputs and constraints that the output
needs to satisfy given by simple, intuitive first-order assertions. 
If a test fails, \cosette provides the concrete inputs that cause it 
to fail, exposing bugs in the tested code. With specification-driven
bug finding, specialist JavaScript developers can specify their code 


test their 
programs with symbolic tests arising from specification.




\myparagraph{Application: Specification-directed Bug-finding} 
%\pmaxinline{Feeling stuck here.} 
Due to the complexity of JavaScript semantics, functional correctness 
specifications of JavaScript programs are highly intricate. 
There are only a few tools (e.g.,~\javert~\cite{javert} and KJS~\cite{Park:2015,stefanescu:oopsla:2016}) that support such expressivity. 
%They target the specialist developer wanting rich, mechanically verified specifications of critical JavaScript code.
However, when these 
tools cannot prove that a given function satisfies a specification, to discover the error, 
the developer needs to understand in detail a complicated proof trace (\javert), or  act with essentially no feedback~(KJS). In \S\ref{subsec:sdbf}, we show how \cosette can be used as an auxiliary mechanism for debugging 
separation logic specifications of JavaScript programs in \javert. 
Our approach, described in detail in \S\ref{sec:specs}, consists of translating the separation logic specifications 
into symbolic tests 
and running these tests using \cosette. 
Then, if a symbolic test generated from a given specification fails, we can 
be sure that the code to be verified does not satisfy its specification. 
More importantly, \cosette then generates a concrete witness that 
invalidates the specification. This information greatly simplifies the debugging of 
both specifications and code.


%
%We prove that the symbolic execution underpinning Cosette is sound and
%that it does not generate false positives. Moreover, this symbolic
%execution is compositional, which allows us to use Cosette to  nd bugs
%in separation logic speci cations of JavaScript programs that are not
%detectable by standard symbolic execution techniques. 
%
%%%really good thereotical results
%


%Because JavaScript does not observe the frame property, such conditions need to refer to positive resources, object properties that need to be present with certain properties, as well as negative resources, object properties that must not be present. 
%Compositionality also allows us to state a verification result for
%\cosette, precisely capturing the conditions under which our symbolic
%execution is sound.






%It aims at the sweet spot between bug-finding and verification, 
%It is not done directly on JavaScript, but instead on \jsil, an intermediate representation previously introduced for JavaScript verification~\cite{javert}. \jsil comes with a trusted infrastructure that allows us to provably lift the results of symbolic analyses on compiled \jsil code back up to JavaScript. 


%%This is what we do


%%This is how we do it: compositionality and trust
