
*** Prelude: Stage 1: Parsing program. ***

The procedures that we will be verifying are: test7


*** Prelude: Stage 1: Parsing successfully completed. ***

*** Prelude: Stage 2: Transforming the program.

Entering resolve_imports.

Predicates Program:

Procedures Program:

	test7

Exiting resolve_imports.

Going to desugar procedure test7 baby!!!

spec test7 (a, x, y)
 	[[ emp ]]
	[[ emp ]]
	normal

proc test7 (a, x, y) {
		[a, "foo"] := (l-nth(x, 3.) + 2.)
		skip
} with {
	ret: a, 1;
};

after succ and pred tables!!!

after which pred computation!!!


*** Prelude: Stage 2: Done transforming the program.


*** Prelude: Stage 3: Normalising predicates.


*** Prelude: Stage 3: Normalisation of predicates completed successfully.



*** Prelude: Stage 4: Building the spec table.


*************************
* Normalising the spec: *
*************************

test7 ( a x y )

[[ emp ]]
[[ emp ]]
Normal


Going to process the SPECS of test7. The time now is: 0.011553

  normalise_single_spec: Time: 0.011568
Precondition  : emp
Postcondition : emp
NSS: Entry
NSS: Pre-normalise

Pres: 
emp
Posts: 
emp
Normalising assertion:
	emp
NPA: Pure formulae: 	
Substitution: 
	

simplify_symb_state: Time: 0.011624
I am going to check whether the following precondition makes sense:
Heap: 
	
Store: 	
Pure Formulae: 	
Gamma: 	
Preds: 


heap constraints:

simplify_symb_state: Time: 0.011676
About to check sat of:
Pure formulae:
	
Gamma:
	


Not found in cache. Cache length 2.
SAT: About to check the following:
(forall ((x Real)) (>= (s-len x) 0.0)),
(forall ((x JSIL_Literal_List)) (>= (l-len x) 0.0))
The solver returned: SAT
Adding emp to cache. Cache length 3.
The precondition makes sense.
POST: Checking a postcondition.

emp
POST: Gamma from the pre: 	
Post Existentially Quantified Vars: 
Post spec vars: 
Normalising assertion:
	emp
NPA: Pure formulae: 	
Substitution: 
	

simplify_symb_state: Time: 0.024964
Subst: Substitution: 
	

New subst: Substitution: 
	

POST: Gamma from the post: 	
For the postcondition to make sense the following must be satisfiable:
	

simplify_symb_state: Time: 0.024992
About to check sat of:
Pure formulae:
	
Gamma:
	


Found in cache. Cache length 3.
simplify_symb_state: Time: 0.025008
simplify_symb_state: Time: 0.025019
-----------------------------
-----------------------------
Spec Table:
Specs for test7 (a, x, y): 
Single Spec - normal

Precondition
Heap: 
	
Store: 	
Pure Formulae: 	
Gamma: 	
Preds: 

Postconditions
Post 0: 
Heap: 
	
Store: 	
Pure Formulae: 	
Gamma: 	
Preds: 
;

*** Prelude: Stage 4: Finished building the spec table

*** Prelude: Stage 5: Add phantom procedures for only-specs.

*** Prelude: Stage 5: Finished adding phantom procedures for only-specs


*********** Starting bi-abduction symbolic execution. ***********

Normalising predicate definitions.

----------------------------------
----------------------------------
Symbolic execution of test7
Initial symbolic state:
Heap: 
	
Store: 	
Pure Formulae: 	
Gamma: 	
Preds: 

AF in symb_evaluate_proc :
Heap: 
	
Store: 	
Pure Formulae: 	
Gamma: 	
Preds: 


simplify_symb_state: Time: 0.025085
AF in symb_evaluate_next_cmd_cont:
Heap: 
	
Store: 	
Pure Formulae: 	
Gamma: 	
Preds: 


simplify_symb_state: Time: 0.025103
----------------------------------
--0--
TIME: 0.025117
 ---- STATE: ---- 
Heap: 
	
Store: 	
Pure Formulae: 	
Gamma: 	
Preds: 
 -------- 
 ---- ANTI_FRAME: ----
Heap: 
	
Store: 	
Pure Formulae: 	
Gamma: 	
Preds: 
 -------- 
 CMD: [a, "foo"] := (l-nth(x, 3.) + 2.)
----------------------------------
LVAR LHS: l-nth(_lvar_1, 3.) 
LVAR LHS: _lvar_2 
Updtate-abs-heap. loc: _$l_0. field:"foo". v:(_lvar_2 + 2.)simplify_symb_state: Time: 0.025156
simplify_symb_state: Time: 0.025191
AF in symb_evaluate_next_cmd_cont:
Heap: 
	_$l_0 |-> [(\"foo\": _lvar_4), (default: $$unknown)]
Store: 	
	(a: _lvar_0)
	(x: _lvar_1)
Pure Formulae: 	
	(_lvar_2 == l-nth(_lvar_1, 3.))
	(_$l_0 == _lvar_0)
Gamma: 	
	(_lvar_2: $$number_type)
	(_lvar_1: $$list_type)
Preds: 


simplify_symb_state: Time: 0.025220
----------------------------------
--1--
TIME: 0.025241
 ---- STATE: ---- 
Heap: 
	_$l_0 |-> [(\"foo\": (l-nth(_lvar_1, 3.) + 2.)), (default: $$unknown)]
Store: 	
	(a: _$l_0)
	(x: _lvar_1)
Pure Formulae: 	
Gamma: 	
	(a: $$object_type)
	(x: $$list_type)
	(_lvar_1: $$list_type)
Preds: 
 -------- 
 ---- ANTI_FRAME: ----
Heap: 
	_$l_0 |-> [(\"foo\": _lvar_4), (default: $$unknown)]
Store: 	
	(a: _lvar_0)
	(x: _lvar_1)
Pure Formulae: 	
	(_lvar_2 == l-nth(_lvar_1, 3.))
	(_$l_0 == _lvar_0)
Gamma: 	
	(_lvar_2: $$number_type)
	(_lvar_1: $$list_type)
Preds: 
 -------- 
 CMD: skip
----------------------------------
simplify_symb_state: Time: 0.025262
About to bi-unify the current symb state against the posts. Here it is: Heap: 
	_$l_0 |-> [(\"foo\": (l-nth(_lvar_1, 3.) + 2.)), (default: $$unknown)]
Store: 	
	(a: _$l_0)
	(x: _lvar_1)
Pure Formulae: 	
Gamma: 	
	(a: $$object_type)
	(x: $$list_type)
	(_lvar_1: $$list_type)
Preds: 

LVARS: 
Unifying stores:
Store: 	
	(a: _$l_0)
	(x: _lvar_1) 
Pat_store: 	
Discharges: 0

Pfs to add to the antiframe after unify stores: 
Unify heaps 
	 
and 
	_$l_0 |-> [("foo": (l-nth(_lvar_1, 3.) + 2.)), (default: $$unknown)] 
with substitution: Substitution: 
	

with pure formulae: 	
with gamma: 	
	(a: $$object_type)
	(x: $$list_type)
	(_lvar_1: $$list_type)
PatHeapDomain: 
Heap again 
	_$l_0 |-> [("foo": (l-nth(_lvar_1, 3.) + 2.)), (default: $$unknown)]
End of unify_symb_heaps: do enjoy the quotient_heap: 
	_$l_0 |-> [("foo": (l-nth(_lvar_1, 3.) + 2.)), (default: $$unknown)]
Heaps unified successfully.

Entering unify_pred_arrays.
Check if 
 (	) 
 entails 
 (	) 
 with gamma 
 (	
	(a: $$object_type)
	(x: $$list_type)
	(_lvar_1: $$list_type))
check_entailment: Time: 0.025350
Preparing entailment check:
Existentials:

Left:
	
Right:
	
Gamma:
	
	(a: $$object_type)
	(x: $$list_type)
	(_lvar_1: $$list_type)

simplify_symb_state: Time: 0.025359
simplify_symb_state: Time: 0.025369
Finished existential simplification:

Existentials:

Left:
	
Right:
	

Gamma:
	


simplify_symb_state: Time: 0.025383
About to check sat of:
Pure formulae:
	
Gamma:
	


Found in cache. Cache length 3.
Return value: true

Pfs to add to the antiframe after step 0: 
I am about to bi-unify two gammas

pat_gamma: 	.
gamma: 	
	(a: $$object_type)
	(x: $$list_type)
	(_lvar_1: $$list_type).
subst: Substitution: 
	



EXITING unify_gamma: res: true


Checking if 	
 entails 	
 with existentials

and gamma 	
	(a: $$object_type)
	(x: $$list_type)
	(_lvar_1: $$list_type)
check_entailment: Time: 0.025422
Preparing entailment check:
Existentials:

Left:
	
Right:
	
Gamma:
	
	(a: $$object_type)
	(x: $$list_type)
	(_lvar_1: $$list_type)

simplify_symb_state: Time: 0.025430
simplify_symb_state: Time: 0.025437
Finished existential simplification:

Existentials:

Left:
	
Right:
	

Gamma:
	


simplify_symb_state: Time: 0.025447
About to check sat of:
Pure formulae:
	
Gamma:
	


Found in cache. Cache length 3.
entailment_check: true
I AM in the case - fully unified with possible antiframe, MARICA!!!!
The substitution: Substitution: 
	

Symb_state: Heap: 
	_$l_0 |-> [(\"foo\": (l-nth(_lvar_1, 3.) + 2.)), (default: $$unknown)]
Store: 	
	(a: _$l_0)
	(x: _lvar_1)
Pure Formulae: 	
Gamma: 	
	(a: $$object_type)
	(x: $$list_type)
	(_lvar_1: $$list_type)
Preds: 

anti_frame: Heap: 
	_$l_0 |-> [(\"foo\": _lvar_4), (default: $$unknown)]
Store: 	
	(a: _lvar_0)
	(x: _lvar_1)
Pure Formulae: 	
	(_lvar_2 == l-nth(_lvar_1, 3.))
	(_$l_0 == _lvar_0)
Gamma: 	
	(_lvar_2: $$number_type)
	(_lvar_1: $$list_type)
Preds: 

-------------------------------------------------------------------

-------------INSIDE MERGE HEAPS------------------------------------

-------------------------------------------------------------------

heap: 
	_$l_0 |-> [("foo": (l-nth(_lvar_1, 3.) + 2.)), (default: $$unknown)]

pat_heap: 
	

p_formulae: 	

gamma: 	
	(a: $$object_type)
	(x: $$list_type)
	(_lvar_1: $$list_type)

Finished merging heaps.
-------------------------------------------------------------------

-------------INSIDE MERGE HEAPS------------------------------------

-------------------------------------------------------------------

heap: 
	_$l_0 |-> [("foo": _lvar_4), (default: $$unknown)]

pat_heap: 
	

p_formulae: 	
	(_lvar_2 == l-nth(_lvar_1, 3.))
	(_$l_0 == _lvar_0)

gamma: 	
	(_lvar_2: $$number_type)
	(_lvar_1: $$list_type)

Finished merging heaps.
Symb_state: Heap: 
	_$l_0 |-> [(\"foo\": (l-nth(_lvar_1, 3.) + 2.)), (default: $$unknown)]
Store: 	
	(a: _$l_0)
	(x: _lvar_1)
Pure Formulae: 	
Gamma: 	
	(a: $$object_type)
	(x: $$list_type)
	(_lvar_1: $$list_type)
Preds: 

anti_frame: Heap: 
	_$l_0 |-> [(\"foo\": _lvar_4), (default: $$unknown)]
Store: 	
	(a: _lvar_0)
	(x: _lvar_1)
Pure Formulae: 	
	(_lvar_2 == l-nth(_lvar_1, 3.))
	(_$l_0 == _lvar_0)
Gamma: 	
	(_lvar_2: $$number_type)
	(_lvar_1: $$list_type)
Preds: 

simplify_symb_state: Time: 0.025561
simplify_symb_state: Time: 0.025571
----------------------------------
----------------------------------
----------------------------------

-------------------------------------------------------------------

-------------INSIDE MERGE HEAPS------------------------------------

-------------------------------------------------------------------

heap: 
	_$l_0 |-> [("foo": _lvar_4), (default: $$unknown)]

pat_heap: 
	

p_formulae: 	
	(_lvar_0 == _$l_0)
	(_lvar_2 == l-nth(_lvar_1, 3.))

gamma: 	
	(_lvar_2: $$number_type)
	(_lvar_1: $$list_type)
	(_lvar_0: $$object_type)

Finished merging heaps.
simplify_symb_state: Time: 0.025633
The obtained simplification_subst was: Substitution: 
	_lvar_0: _$l_0;
	 _lvar_2: l-nth(_lvar_1, 3.)

Spec Var: #s_0
Spec Var: #s_1
Spec Var: #s_2
Spec Var: #s_3
Spec Var: #s_1

********** Finished bi-abduction symbolic execution. **********


**********    Starting normal symbolic execution.    **********

Normalising predicate definitions.

----------------------------------
----------------------------------
Symbolic execution of test7
Initial symbolic state:
Heap: 
	_$l_0 |-> [(\"foo\": #s_3), (default: $$unknown)]
Store: 	
	(a: _$l_0)
	(x: #s_1)
Pure Formulae: 	
	(#s_2 == l-nth(#s_1, 3.))
	(#s_0 == _$l_0)
Gamma: 	
	(a: $$object_type)
	(#s_1: $$list_type)
	(#s_0: $$object_type)
	(x: $$list_type)
Preds: 

Spec vars (symb_evaluate_next_cmd_cont): #s_0, #s_1, #s_2, #s_3
simplify_symb_state: Time: 0.025807
Spec vars (symb_evaluate_next_cmd_cont, loop): #s_0, #s_1, #s_2, #s_3
simplify_symb_state: Time: 0.025858
----------------------------------
--0--
TIME: 0.025901
STATE:
Heap: 
	_$l_0 |-> [(\"foo\": #s_3), (default: $$unknown)]
Store: 	
	(a: _$l_0)
	(x: #s_1)
Pure Formulae: 	
	(#s_2 == l-nth(#s_1, 3.))
	(#s_0 == _$l_0)
Gamma: 	
	(a: $$object_type)
	(#s_1: $$list_type)
	(#s_0: $$object_type)
	(x: $$list_type)
Preds: 
CMD: [a, "foo"] := (l-nth(x, 3.) + 2.)
----------------------------------
LVAR LHS: #s_2 
The EVALUATION OF THIS PROC GAVE AN ERROR: 0 The logical expression (#s_2 + 2.) is not typable in the typing enviroment: 	
	(a: $$object_type)
	(#s_1: $$list_type)
	(#s_0: $$object_type)
	(x: $$list_type) 
 with the pure formulae 	
	(#s_2 == l-nth(#s_1, 3.))
	(#s_0 == _$l_0)!!!!
----------------------------------
----------------------------------
----------------------------------


Verified: 0.		Prunings: 1.

RESULTS
Proc test7  - Single Spec - normal

Precondition
Heap: 
	_$l_0 |-> [(\"foo\": #s_3), (default: $$unknown)]
Store: 	
	(a: _$l_0)
	(x: #s_1)
Pure Formulae: 	
	(#s_2 == l-nth(#s_1, 3.))
	(#s_0 == _$l_0)
Gamma: 	
	(a: $$object_type)
	(#s_1: $$list_type)
	(#s_0: $$object_type)
	(x: $$list_type)
Preds: 

Postconditions
Post 0: 
Heap: 
	_$l_0 |-> [(\"foo\": (l-nth(#s_1, 3.) + 2.)), (default: $$unknown)]
Store: 	
	(a: _$l_0)
	(x: #s_1)
Pure Formulae: 	
Gamma: 	
	(a: $$object_type)
	(#s_1: $$list_type)
	(x: $$list_type)
Preds: 
;
 -- FAILED with msg: The logical expression (#s_2 + 2.) is not typable in the typing enviroment: 	
	(a: $$object_type)
	(#s_1: $$list_type)
	(#s_0: $$object_type)
	(x: $$list_type) 
 with the pure formulae 	
	(#s_2 == l-nth(#s_1, 3.))
	(#s_0 == _$l_0)

There were Failures in 0.025983

**********     Ending normal symbolic execution.     **********

BI-ABDUCTIVE RESULTS: 


--------------
FAILED TO VERIFY SPEC:  
--------------

test7
----------
The logical expression (#s_2 + 2.) is not typable in the typing enviroment: 	
	(a: $$object_type)
	(#s_1: $$list_type)
	(#s_0: $$object_type)
	(x: $$list_type) 
 with the pure formulae 	
	(#s_2 == l-nth(#s_1, 3.))
	(#s_0 == _$l_0)


