pred dll_node(node, val, next, prev):
  types(node : Obj) *
  ((node, "value")  -> val) *
  ((node, "next")   -> next) *
  ((node, "prev")   -> prev) *
  ((node, "@proto") -> null);

pred dll_seg(head, head_prev, last, last_next, list):
  types(list: List) *
  (list == {{ }}) *
  (head_prev == last) *
  (head == last_next),

  (! (head == last_next)) *
  types(list: List) *
  (list == (#item :: #items)) *
  (dll_node(head, #item, #next, head_prev)) *
  (dll_seg(#next, head, last, last_next, #items));

pred ll_node(node, val, next):
  types(node : Obj) *
  ((node, "value")  -> val) *
  ((node, "next")   -> next) *
  ((node, "@proto") -> null);

pred ll_seg(head, last_next, list):
  types(list: List) *
  (list == {{ }}) *
  (head == last_next),

  (! (head == last_next)) *
  (list == (#item :: #items )) *
  types(list: List, #items: List, head: Obj) *
  (ll_node(head, #item, #head_next)) *
  (ll_seg(#head_next, last_next, #items));

pred ll_obj(obj, head, last_next, list):
  types(obj: Obj, list: List) *
  ((obj, "head")      -> head) *
  ((obj, "last_next") -> last_next) *
  ((obj, "@proto")    -> null) *
  ll_seg(head, last_next, list);

pred dll_obj(obj, head, head_prev, last, last_next, list):
  types(obj: Obj, list: List) *
  ((obj, "head")      -> head) *
  ((obj, "head_prev") -> head_prev) *
  ((obj, "last")      -> last) *
  ((obj, "last_next") -> last_next) *
  ((obj, "@proto")    -> null) *
  dll_seg(head, head_prev, last, last_next, list);

spec ll_seg_to_dll_seg (head, head_prev, last_next)
  [[ (head == #head) * (last_next == #last_next) * (head_prev == #head_prev) *
     ll_seg(#head, #last_next, #list) ]]
  [[ (ret == #ret) *
     types(#ret: Obj) *
     ((#ret, "head")   -> #head) *
     ((#ret, "last")   -> #last) *
     ((#ret, "@proto") -> null) *
     dll_seg(#head, #head_prev, #last, #last_next, #list) ]]
  normal

(* Returns an object containing pointers to
   the head of a dll-seg representing the same list as the ll-seg passed to it,
   and the last item in the dll *)
proc ll_seg_to_dll_seg (head, head_prev, last_next) {

  [* unfold ll_seg(#head, #last_next, #list) *]

  return_obj := new ();
  [return_obj, "head"] := head;

  (* Base case: empty list *)
  goto [head = last_next] emptyList nonemptyList;

  emptyList:

    (* dummy variable to avoid parser error *)
    z := 5;

    [return_obj, "last"] := head_prev;

    [* fold dll_seg(#head, #head_prev, #head_prev, #head, #list) *]

    goto rlab;

  nonemptyList:

    (* Set the prev pointer of the current element *)
    [head, "prev"] := head_prev;

    (* Recurse *)
    head_next        := [head, "next"];
    new_dll_seg_obj  := "ll_seg_to_dll_seg" (head_next, head, last_next);

    new_dll_seg_head := [new_dll_seg_obj, "head"];
    new_dll_seg_last := [new_dll_seg_obj, "last"];

    [head, "next"]   := new_dll_seg_head;

    [return_obj, "last"] := new_dll_seg_last;

    [* fold dll_seg(#head, #head_prev, #last, #last_next, #list) *]

    deleteObject(new_dll_seg_obj);

    goto rlab;

  rlab:
    skip
} with { ret: return_obj, rlab; };

spec ll_obj_to_dll_obj (obj)
  [[ (obj == #obj) * ll_obj(obj, #head, #last_next, #list) ]]
  [[ dll_obj(#obj, #head, #head_prev, #last, #last_next, #list) * (ret == #obj) ]]
  normal

proc ll_obj_to_dll_obj (obj) {

  head      := [obj, "head"];
  head_prev := null; (* ??? *)
  last_next := [obj, "last_next"];

  dll_seg_obj   := "ll_seg_to_dll_seg" (head, head_prev, last_next);
  dll_seg_head  := [dll_seg_obj, "head"];
  dll_seg_last  := [dll_seg_obj, "last"];

  [obj, "head"]      := dll_seg_head;
  [obj, "head_prev"] := head_prev;
  [obj, "last"]      := dll_seg_last;

  deleteObject(dll_seg_obj);

  goto rlab;

  rlab:
    skip

} with { ret: obj, rlab; };
