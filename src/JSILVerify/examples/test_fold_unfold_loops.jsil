(** Totals: 0 fails and 2 passes **)


pred my_list (x) :
	(x == null),
	((x, "value") -> #y) * ((x, "next") -> #z) * ((x, "@proto") -> null) * my_list(#z) * types(#y: Num);


(** Expected result: YES             **)
spec list_cons (x, y)
   [[ my_list(x) * types(y: Num) ]]
   [[ my_list(x) ]]
   normal
proc list_cons (x, y) {
		   z := new ();
		   [z, "value"] := y;
		   [z, "next"] := x;
		   x := z;
		   [* fold(my_list(x)) *]
   rlab:   skip
} with { ret: x, rlab; };



(** Expected result: YES                             **)
spec list_count (x)
   [[ (x == #x) * my_list(#x) ]]
   [[ my_list(#x) * types(ret: Num) ]]
   normal
proc list_count (x) {
		   [* unfold(my_list(x)) *]
		   goto [ x = null ] then1 else1;
   then1:   count := 0;
           goto rlab;
   else1:   z := [x, "next"];
           count := "list_count"(z);
           count := count + 1;
           [* fold(my_list(x)) *]
   rlab:   skip
} with { ret: count, rlab; };


(** Expected result: YES                                                     **)
spec list_append (x, y)
   [[ (x == #x) * (! (#x == null)) * (y == #y) * my_list(#x) * my_list(#y) ]]
   [[ my_list(#x) * (x == #x)                                                ]]
   normal;
   [[ (x == #x) * (#x == null) * (y == #y) * my_list(#y)                   ]]
   [[ my_list(#y) * (x == #y)                                                ]]
   normal
proc list_append (x, y) {
		   goto [ x = null ] then1 else1;
   then1:  x := y;
           goto rlab;
           [* unfold(my_list(x)) *]
   else1:  z := [x, "next"];
    	   goto [z = null] then2 else2;
   then2: foo := "bar"; (* Dummy variable -
						               putting a logical assertion as the first statement in a block throws a syntax error *)
					[* unfold(my_list(z)) *]
	        [x, "next"] := y;
   		   [* fold(my_list(x)) *]
   		   skip;
           goto rlab;
   else2:  z := "list_append" (z, y);
           [* fold(my_list(x)) *]
           skip;
   rlab:   skip
} with { ret: x, rlab; };
