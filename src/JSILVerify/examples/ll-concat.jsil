pred ll_node(node, val, next):
  types(node : Obj) *
  ((node, "value")  -> val) *
  ((node, "next")   -> next) *
  ((node, "@proto") -> null);

pred ll_seg(head, last_next, list):
  types(list: List) *
  (list == {{ }}) *
  (head == last_next),

  (! (head == last_next)) *
  (list == (#item :: #items )) *
  types(list: List, #items: List) *
  (ll_node(head, #item, #head_next)) *
  (ll_seg(#head_next, last_next, #items));

pred disjoint_ll_seg(head, last_next, list, disjoint_element):
  types(list: List) *
  (list == {{ }}) * (! (head == disjoint_element)) *
  (head == last_next),

  (! (head == last_next)) * (! (head == disjoint_element)) *
  (list == (#item :: #items )) *
  types(list: List, #items: List) *
  (ll_node(head, #item, #head_next)) *
  (disjoint_ll_seg(#head_next, last_next, #items, disjoint_element));

(* Returns an object holding pointers to the head and last_next
   of the list segment resulting from the appending of the two arguments *)
spec append_ll_seg (head_1, last_next_1, head_2, last_next_2)
   [[ (head_1 == #head_1) * (last_next_1 == #last_next_1) * (head_2 == #head_2) * (last_next_2 == #last_next_2) *
      types(#list_2: List) *
      disjoint_ll_seg(#head_1, #last_next_1, #list_1, #last_next_2) *
      ll_seg(#head_2, #last_next_2, #list_2) ]]
   [[ (#appended_list == (#list_1 @ #list_2)) *
      types(ret: Obj) *
      ((ret, "head")      -> #appended_head) *
      ((ret, "last_next") -> #last_next_2) *
      ((ret, "@proto")    -> null) *
      ll_seg(#appended_head, #last_next_2, #appended_list) ]]
    normal

proc append_ll_seg(head_1, last_next_1, head_2, last_next_2) {

  [* unfold disjoint_ll_seg(#head_1, #last_next_1, #list_1, #last_next_2) *]

  return_obj := new ();

  goto [head_1 = last_next_1] emptyList nonemptyList;

  emptyList:

    (* Simply return the second list *)
    [return_obj, "head"]      := head_2;
    [return_obj, "last_next"] := last_next_2;

    goto rlab;

  nonemptyList:

      (* Recurse *)
      head_next_1 := [head_1, "next"];
      new_seg_obj := "append_ll_seg" (head_next_1, last_next_1, head_2, last_next_2);

      (* Update pointers to point to the appended segment *)
      new_seg_obj_head := [new_seg_obj, "head"];
      [head_1, "next"] := new_seg_obj_head;

      (* The result will be the updated head and the returned last_next *)
      new_seg_obj_last_next     := [new_seg_obj, "last_next"];
      [return_obj, "head"]      := head_1;
      [return_obj, "last_next"] := new_seg_obj_last_next;

      (* Remove unwanted heap object *)
      deleteObject(new_seg_obj);

      [* fold ll_seg(#head_1, #last_2, (#list_1 @ #list_2)) *]

      goto rlab;

  rlab:
    skip

} with { ret: return_obj, rlab; };
