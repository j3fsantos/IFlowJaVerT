import javert_internal_functions, javert_logic_macros, javert_js_predicates;

(* *******************************************
   *** *** ***   JAVASCRIPT TEST   *** *** ***
   ******************************************* *)

spec main ()

	[[ initialHeapPre() ]]
	[[ initialHeapPost() *
	   (($lg, "x") -> {{ "d", 2, true, true, true }}) * (($lg, "arguments") -> {{ "d", undefined, true, true, true }}) *
	   isTypeError(x__te) * isSyntaxError(x__se) *
	   ((x__scope, "main") -> $lg) * ((x__scope, "@proto") -> null) *
	   (ret == 2) ]]
	normal

proc main () {
			x_0 := "setupInitialHeap"();
			x__scope := new();
			[x__scope, "main"] := $lg;
			x__this := $lg;
			[$lg, "x"] := {{ "d", undefined, true, true, true }};
			[$lg, "arguments"] := {{ "d", undefined, true, true, true }};
			x__te := "TypeError"();
			x__se := "SyntaxError"();
			x__true := true;
			x__false := false;
			x_1 := empty;
			x_2 := [x__scope, "main"];
			x_3 := {{ "v", x_2, "x" }};
			x_4_v := "i__getValue"(2.) with elab;
			x_5 := "i__checkAssignmentErrors"(x_3) with elab;
			[* fold Pi ($lg, "x", #aux_01, #aux_02, #aux_03, #aux_04, #aux_05) *]
			x_6 := "i__putValue"(x_3, x_4_v) with elab;
			x_4_v_v := "i__getValue"(x_4_v) with elab;
			skip;
			[* unfold Pi ($lg, "x", #aux_06, #aux_07, #aux_08, #aux_09, #aux_10) *]
			xret := x_4_v_v;
	rlab:	skip;
	elab:	xerr := PHI(x_4_v, x_5, x_6, x_4_v_v)
} with {
	ret: xret, rlab;
	err: xerr, elab;
};
