

pred my_lseg(x, y, alpha_sum) : 
      (alpha_sum == 0) * (x == y) * types(alpha_sum: $$number_type),
      
      (! (x == y)) * ((x, "value") -> #v) * ((x, "next") -> #z) * (alpha_sum == (#v + #beta_sum)) * 
          my_lseg(#z, y, #beta_sum) * types(alpha_sum: $$number_type, #beta_sum: $$number_type);

    
pred my_list(x, alpha_sum) : 
  (x == $$null) * (alpha_sum == 0),
  ((x, "value") -> #v) * ((x, "next") -> #z)  * my_list(#z, #beta_sum) * (alpha_sum == #v + #beta_sum)
    * types(#v: $$number_type, alpha_sum: $$number_type, #beta_sum: $$number_type); 



lemma lseg2list(x, alpha_sum)
  [[ my_lseg(x, $$null, alpha_sum) ]]
  [[ my_list(x, alpha_sum) ]]


lemma lseg_append(x, alpha_sum, y, v, z)
  [[ my_lseg(x, y, alpha_sum) * ((y, "value") -> v) * ((y, "next") -> z) * types (v : $$number_type) ]]
  [[ my_lseg(x, z, alpha_sum + v) ]]

spec list_sum_iterative (x)
   [[ (x == #x) * my_list(#x, #alpha_sum) * types(#alpha_sum: $$number_type) ]]
   [[ my_list(#x, #alpha_sum) * (ret == #alpha_sum) ]]
   normal
proc list_sum_iterative(x){
           
   [* fold my_lseg (#x, #x, 0) *]
   count := 0;  

   [[ my_lseg(#x, x, count) * my_list(x, #rest_sum) * (#alpha_sum == (count + #rest_sum)) *
        types(count: $$number_type, #rest_sum: $$number_type) ]]

   head:  skip;
          [* unfold my_list (x, #rest_sum)  *]
	        goto [ x = $$null ] rlab else1;
   
   else1: 
           x_next := [x, "next"];
           x_val  := [x, "value"];
           count := count + x_val;

           [*  apply lseg_append (#x, #cur_sum, x, x_val, x_next) *]
           x := x_next;
           
           goto head;

           [* apply lseg2list(#x, #alpha_sum) *]
   rlab:   skip
} with { ret: count, rlab; };
