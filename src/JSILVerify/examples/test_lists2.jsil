(** Totals: 0 fails and 1 passes **)

pred pure_list_sum (alpha, sum) : 
  (alpha == {{ }}) * (sum == 0), 

  (alpha == #a :: #beta) * (sum == (#a + #rest_sum)) * 
    pure_list_sum (#beta, #rest_sum) * 
    types (#a: $$number_type, #beta: $$list_type, #rest_sum: $$number_type);


pred my_list (x, alpha) :
  (x == $$null) * (alpha == {{ }}),

  ((x, "value") -> #y) * ((x, "next") -> #z) * ((x, "@proto") -> $$null) *
    (alpha == (#y :: #beta)) * my_list(#z, #beta) * 
    types(#y: $$number_type, #alpha: $$list_type, #beta: $$list_type); 



(** Expected result: YES                             **)
spec list_sum (x)
   [[ (x == #x) * my_list(#x, #alpha) * pure_list_sum (#alpha, #sum) * 
      types(#sum: $$number_type, #alpha: $$list_type) ]]
   [[ my_list(#x, #alpha) * pure_list_sum (#alpha, #sum) * (ret == #sum) ]]
   normal
proc list_sum (x) {
       [* unfold(my_list(x, #alpha)); 
          unfold(pure_list_sum (#alpha, #sum))  *]
          goto [ x = $$null ] then1 else1;
   then1: sum := 0;
          goto rlab;
   else1: z := [x, "next"];
          count := "list_count"(z);
          count := count + 1;
          [* fold my_list(x, #alpha, #size); 
             fold pure_list_sum (#alpha, #sum) *]
   rlab:  skip
} with { ret: count, rlab; };

proc make_list (list) {
          goto [ list = $$nil] then1 else1;
  then1:  x := $$null;
          goto rlab;
  else1:  x := new ();
          [x, "value"] := l-nth(list, 0);
          y := "make_list"(cdr list);
          [x, "next"] := y;
          goto rlab;
  rlab:   skip
} with { ret: x, rlab; };

proc main () {
        x := "make_list" ({{ 1, 2, 3}});
        y := "list_sum" (x);
  rlab: skip
} with { ret: y, rlab; };
