pred dll_node(node, val, next, prev):
  types(node : $$object_type) *
  ((node, "value")  -> val) *
  ((node, "next")   -> next) *
  ((node, "prev")   -> prev) *
  ((node, "@proto") -> $$null);

(* Unfolds from the left *)
pred dll_seg(head, head_prev, last, last_next, list):
  types(list: $$list_type) *
  (list == {{ }}) *
  (head_prev == last) *
  (head == last_next),

  (! (head == last_next)) *
  types(list: $$list_type) *
  (list == (#item :: #items)) *
  (dll_node(head, #item, #next, head_prev)) *
  (dll_seg(#next, head, last, last_next, #items));

(* Unfolds from the right *)
pred dll_seg_2(head, head_prev, last, last_next, list):
  types(list: $$list_type) *
  (list == {{ }}) *
  (head_prev == last) *
  (head == last_next),

  (! (head == last_next)) *
  (list == (#items @ {{ #item }})) *
  types(list: $$list_type, #items: $$list_type, head: $$object_type, last: $$object_type) *
  (dll_node(last, #item, last_next, #last_prev)) *
  (dll_seg_2(head, head_prev, #last_prev, last, #items));

pred dll_obj(obj, head, head_prev, last, last_next, list):
  types(obj: $$object_type, list: $$list_type) *
  ((obj, "head")      -> head) *
  ((obj, "head_prev") -> head_prev) *
  ((obj, "last")      -> last) *
  ((obj, "last_next") -> last_next) *
  ((obj, "@proto")    -> $$null) *
  dll_seg(head, head_prev, last, last_next, list);

only spec switch_end_to_right(head, head_prev, last, last_next, list)
  [[ dll_seg(head, head_prev, last, last_next, list) ]]
  [[ dll_seg_2(head, head_prev, last, last_next, list) ]]
  normal

only spec switch_end_to_left(head, head_prev, last, last_next, list)
  [[ dll_seg_2(head, head_prev, last, last_next, list) ]]
  [[ dll_seg(head, head_prev, last, last_next, list) ]]
  normal

spec append_dll_obj(dll_obj_1, dll_obj_2)
  [[ (dll_obj_1 == #dll_obj_1) * (dll_obj_2 == #dll_obj_2) *
     (! (#head_1 == #head_2)) *
     dll_obj(#dll_obj_1, #head_1, #head_prev_1, #last_1, #last_next_1, #list_1) *
     dll_obj(#dll_obj_2, #head_2, #head_prev_2, #last_2, #last_next_2, #list_2)  ]]
  [[ (#appended_list == (#list_1 @ #list_2)) *
     dll_obj(ret, #appended_head, #appended_head_prev, #appended_last, #appended_last_next, #appended_list) ]]
  normal

proc append_dll_obj(dll_obj_1, dll_obj_2) {

  (* Unfold first seg from right *)
  [* callspec switch_end_to_right(#ignore, #head_1, #head_prev_1, #last_1, #last_next_1, #list_1);
     unfold dll_seg_2(#head_1, #head_prev_1, #last_1, #last_next_1, #list_1) *]

  head_1      := [dll_obj_1, "head"];
  last_next_1 := [dll_obj_1, "last_next"];

  goto [head_1 = last_next_1] emptyList1 nonemptyList1;

  emptyList1:

    (* Simply return the second dll object *)
    return_obj := dll_obj_2;
    deleteObject(dll_obj_1);

    goto rlab;

  nonemptyList1:

    foo := bar;

    (* Unfold second seg from left *)
    [* unfold dll_seg(#head_2, #head_prev_2, #last_2, #last_next_2, #list_2) *]

    head_2           := [dll_obj_2, "head"];
    last_next_2      := [dll_obj_2, "last_next"];

    goto [head_2 = last_next_2] emptyList2 nonemptyList2;

    emptyList2:

      (* Simply return the first dll object *)
      return_obj := dll_obj_1;
      deleteObject(dll_obj_2);

      goto rlab;

    nonemptyList2: (* Both lists non-empty *)

      (* Set forward pointer *)
      last_1           := [dll_obj_1, "last"];
      head_2           := [dll_obj_2, "head"];
      [last_1, "next"] := head_2;

      (* Set backwards pointer *)
      [head_2, "prev"] := last_1;

      (* Collapse both the list preds and flip the first back to the left *)
      (* Second fold is causing an error *)
      [* fold dll_seg(#head_2, last_1, #last_2, #last_next_2, #list_2);
         fold dll_seg_2(#head_1, #head_prev_1, #last_1, head_2, #list_1);
         callspec switch_end_to_left(#ignore, #head_1, #head_prev_1, #last_1, head_2, #list_1) *]

      (* TODO: Unify with post- *)

      goto rlab;

  rlab:
    skip
} with { ret: return_obj, rlab; };
