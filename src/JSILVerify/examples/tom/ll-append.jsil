pred ll_node(node, val, next):
  types(node : $$object_type) *
  ((node, "value")  -> val) *
  ((node, "next")   -> next) *
  ((node, "@proto") -> $$null);

pred ll_seg(head, last_next, list):
  types(list: $$list_type) *
  (list == {{ }}) *
  (head == last_next),

  (! (head == last_next)) *
  (list == (#item :: #items )) *
  types(list: $$list_type, #items: $$list_type) *
  (ll_node(head, #item, #head_next)) *
  (ll_seg(#head_next, last_next, #items));

pred disjoint_ll_seg(head, last_next, list, disjoint_element):
  types(list: $$list_type) *
  (list == {{ }}) * (! (head == disjoint_element)) *
  (head == last_next),

  (! (head == last_next)) * (! (head == disjoint_element)) *
  (list == (#item :: #items )) *
  types(list: $$list_type, #items: $$list_type) *
  (ll_node(head, #item, #head_next)) *
  (disjoint_ll_seg(#head_next, last_next, #items, disjoint_element));

(* Returns an object holding pointers to the head and last_next
   of the list segment resulting from the appending of the two arguments *)
spec append_ll_seg (head_1, last_next_1, head_2, last_next_2)
   [[ (head_1 == #head_1) * (last_next_1 == #last_next_1) * (head_2 == #head_2) * (last_next_2 == #last_next_2) *
      types(#list_2: $$list_type) *
      disjoint_ll_seg(#head_1, #last_next_1, #list_1, #last_next_2) *
      ll_seg(#head_2, #last_next_2, #list_2) ]]
   [[ (#appended_list == (#list_1 @ #list_2)) *
      types(ret: $$object_type) *
      ((ret, "head")      -> #appended_head) *
      ((ret, "last_next") -> #last_next_2) *
      ((ret, "@proto")    -> $$null) *
      ll_seg(#appended_head, #last_next_2, #appended_list) ]]
    normal

proc append_ll_seg(head_1, last_next_1, head_2, last_next_2) {

  [* unfold disjoint_ll_seg(#head_1, #last_next_1, #list_1, #last_next_2) *]

  return_obj := new ();

  goto [head_1 = last_next_1] emptyList nonemptyList;

  emptyList:

    (* Simply return the second list *)
    [return_obj, "head"]      := head_2;
    [return_obj, "last_next"] := last_next_2;

    goto rlab;

  nonemptyList:

      (* Recurse *)
      head_next_1 := [head_1, "next"];
      new_seg_obj := "append_ll_seg" (head_next_1, last_next_1, head_2, last_next_2);

      (* Update pointers to point to the appended segment *)
      new_seg_obj_head := [new_seg_obj, "head"];
      [head_1, "next"] := new_seg_obj_head;

      (* The result will be the updated head and the returned last_next *)
      new_seg_obj_last_next     := [new_seg_obj, "last_next"];
      [return_obj, "head"]      := head_1;
      [return_obj, "last_next"] := new_seg_obj_last_next;

      (* Remove unwanted heap object *)
      deleteObject(new_seg_obj);

      (* Need to say that head_1 != new_seg_obj_last_next *)
      [* fold ll_seg(head_1, new_seg_obj_last_next, (#list_1 @ #list_2)) *]

      (* If this line isn't here it will try the fold in the line above
         when it goes to the rlab label  *)
      foo := bar;

  rlab:
    skip

} with { ret: return_obj, rlab; };
