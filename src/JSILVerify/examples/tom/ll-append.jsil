pred ll_node(node, val, next):
  types(node : $$object_type) *
  ((node, "value")  -> val) *
  ((node, "next")   -> next) *
  ((node, "@proto") -> $$null);

pred ll_seg(head, last_next, list):
  types(list: $$list_type) *
  (list == {{ }}) *
  (head == last_next),

  (! (head == last_next)) *
  (list == (#item :: #items )) *
  types(list: $$list_type, #items: $$list_type) *
  (ll_node(head, #item, #head_next)) *
  (ll_seg(#head_next, last_next, #items));

pred ll_obj(obj, head, last_next, list):
  types(obj: $$object_type, list: $$list_type) *
  ((obj, "head")      -> head) *
  ((obj, "last_next") -> last_next) *
  ((obj, "@proto")    -> $$null) *
  ll_seg(head, last_next, list);

(* Returns an object holding pointers to the head and last_next
   of the list segment resulting from the appending of the two arguments *)
(* The appended seg will have the same last_next as the second seg *)
(* Specified type for #list_2 "twice" to save having to fold/unfold,
   but the types() assertion is pure so this shouldn't matter? *)
(* Is it always the case that the result last_next = last_next_2?
   What about when we append onto an empty list?
   Can't think of a solution except for having multiple specs.. *)
spec append_ll_seg (head_1, last_next_1, head_2, last_next_2)
   [[ (head_1 == #head_1) * (last_next_1 == #last_next_1) * (head_2 == #head_2) * (last_next_2 == #last_next_2) *
      (! (#last_next_1 == #last_next_2)) *
      types(#list_2: $$list_type) *
      ll_seg(#head_1, #last_next_1, #list_1) *
      ll_seg(#head_2, #last_next_2, #list_2) ]]
   [[ (#appended_list == (#list_1 @ #list_2)) *
      types(ret: $$object_type) *
      ((ret, "head")      -> #appended_head) *
      ((ret, "last_next") -> #last_next_2) *
      ((ret, "@proto")    -> $$null) *
      ll_seg(#appended_head, #last_next_2, #appended_list) ]]
    normal

proc append_ll_seg(head_1, last_next_1, head_2, last_next_2) {

  [* unfold ll_seg(#head_1, #last_next_1, #list_1) *]

  return_obj := new ();

  goto [head_1 = last_next_1] emptyList nonemptyList;

  emptyList:

    (* Simply return the second list *)
    [return_obj, "head"]      := head_2;
    [return_obj, "last_next"] := last_next_2;

    [* fold ll_seg(#head_2, #last_next_2, (#list_1 @ #list_2)) *]

    goto rlab;

  nonemptyList:

      (* Recurse *)
      head_next_1 := [head_1, "next"];
      new_seg_obj := "append_ll_seg" (head_next_1, last_next_1, head_2, last_next_2);

      (* Update pointers to point to the appended segment *)
      new_seg_obj_head := [new_seg_obj, "head"];
      [head_1, "next"] := new_seg_obj_head;

      (* The result will be the updated head and the returned last_next *)
      new_seg_obj_last_next     := [new_seg_obj, "last_next"];
      [return_obj, "head"]      := head_1;
      [return_obj, "last_next"] := new_seg_obj_last_next;

      (* Remove unwanted heap object *)
      deleteObject(new_seg_obj);

      [* fold ll_seg(head_1, new_seg_obj_last_next, (#list_1 @ #list_2)) *]

      (* Fold requires:
               head,   last_next,             list
        ll_seg(head_1, new_seg_obj_last_next, (#list_1 @ #list_2))
        :=
          (! (head_1 == new_seg_obj_last_next)) done (by transivitity)
          ((#list_1 @ #list_2) == (#item :: #items )) done
          (ll_node(head_1, #item, #head_next)) item done
          (ll_seg(#head_next, new_seg_obj_last_next, #items)) done
          Should work, we have everything needed
      *)

    goto rlab;

  rlab:
    skip

} with { ret: return_obj, rlab; };
