pred optional_object(obj):
  (obj == $$null) * types(obj: $$null_type),

  types(obj: $$object_type);

pred dll_node(node, val, next, prev):
  (node == #node) * (val == #val) * (next == #next) * (prev == #prev) *
  ((#node, "value") -> #val) *
  ((#node, "next") -> #next) *
  ((#node, "prev") -> #prev) *
  ((#node, "@proto") -> $$null);

(* prev: the predecessor of the first item of the list segment *)
(*       in general, this may or may not be null *)
(* first: the first item of the list segment *)
(* last: the last item of the list segment *)
(* list: the literal list described by the list segment *)
pred dll_seg(prev, first, last, list):
  (* Empty List *)
  (first == #first) * (last == #last) * (list == #list) *
  types(#first: $$null_type, #last: $$null_type, #list: $$list_type) *
  (list == {{ }}) *
  (#first == $$null) * (#last == $$null),

  (* Singleton List *)
  (prev == #prev) * (first == #first) * (last == #last) * (list == #list) * (#list == (#item :: #items)) *
  types(#first: $$object_type, #last: $$object_type, #list: $$list_type, #items: $$list_type) *
  optional_object(#prev) *
  (#items == {{ }}) *
  (#first == #last) *
  dll_node(#first, #item, $$null, #prev),

  (* Multiple Items in List *)
  (prev == #prev) * (first == #first) * (last == #last) * (list == #list) * (#list == (#item :: #items)) *
  types(#first: $$object_type, #last: $$null_type, #list: $$list_type, #items: $$list_type) *
  optional_object(#prev) *
  (!(#first == #last)) *
  dll_node(#first, #item, #next, #prev) *
  dll_seg(#first, #next, #last, #items);

pred dll_list(first, last, list):
  dll_seg($$null, first, last, list);

(* Creates an object, with fields for first and last elements of an empty doubly linked list *)
spec create_empty_dll ()
  [[ true ]]
  [[ ((ret, "first") -> #first) * ((ret, "last") -> #last) * ((ret, "@proto") -> $$null) * dll_seg($$null, #first, #last, $$nil) ]]
  normal

proc create_empty_dll () {
  dll := new ();
  [dll, "first"] := $$null;
  [dll, "last"] := $$null;
  [* fold(dll_seg($$null, #first, #last, $$nil)) *]
  goto rlab;
  rlab:
    skip
} with { ret: dll, rlab; };

(* Takes a dll representing a list
   and appends the item to the back of the list,
   returning a dll representing (list @ [item]) *)
spec append_to_dll (item, dll, list)
  [[ ((dll, "first") -> #first) * ((dll, "last") -> #last) * ((dll, "@proto") -> $$null) * (list == #list) * (item == #item) * dll_seg($$null, #first, #last, #list) ]]
  [[ ((ret, "first") -> #first) * ((ret, "last") -> #last) * ((ret, "@proto") -> $$null) * dll_seg($$null, #first, #last, (#list @ #item)) ]]
  normal

proc append_to_dll (item, dll, list) {
  goto [list = $$nil] emptyList nonemptyList;
  emptyList:
    (* create a new object, assigning the item to it.
       set first and last to it *)
    newNode := new ();
    [newNode, "value"] := item;
    [newNode, "next"] := $$null;
    [newNode, "prev"] := $$null;
    [dll, "first"] := newNode;
    [dll, "last"] := newNode;

    (* have to define these as variables to reference them in the fold? *)
    first := [dll, "first"];
    last := [dll, "last"];
    list := {{ item }};

    [* fold(dll_seg($$null, first, last, list)) *]
    goto rlab;
  nonemptyList:
    (* save pointer to first, we want to keep this *)
    first := [dll, "first"];
    (* change the pointer to first to the next element *)
    (* so we can iterate along the list *)
    next := [first, "next"];
    [dll, "first"] := next;
    (* move down the list *)
    appendedDll := append_to_dll (item, dll, cdr list);
    dll := appendedDll;
    (* this new dll will have the correct last pointer *)
    (* all we need to do is restore the value of the first pointer *)
    [dll, "first"] := first;
    goto rlab;
  rlab:
    skip
} with { ret: dll, rlab; };
