(* PM: null_type has only one inhabitant and for such types, 
       it's enough to give the type and the simplifications will
       automatically put in that the corresponding variable in 
       fact has value $$null *)
pred optional_object(obj):
  types(obj: $$null_type),
  types(obj: $$object_type);

(* PM: You don't have to do ...(node = #node)... for predicate 
       parameters in predicate definitions. You should do it
       in the specifications (pre-, postconditions) *)
pred dll_node(node, val, next, prev):
  types(node : $$object_type) *
  ((node, "value")  -> val) *
  ((node, "next")   -> next) *
  ((node, "prev")   -> prev) *
  ((node, "@proto") -> $$null);

(* prev: the predecessor of the first item of the list segment *)
(*       in general, this may or may not be null *)
(* first: the first item of the list segment *)
(* last: the last item of the list segment *)
(* list: the literal list described by the list segment *)
pred dll_seg(prev, first, last, list):
  (* Empty List *)
  (* PM: I didn't have any information on prev here - will I need it? *)
  types(prev: $$null_type, first: $$null_type, last: $$null_type, list: $$list_type) *
  (list == {{ }}),

  (* Singleton List *)
  (* PM: You can use the literal list notation to say that there's only one element,
         you don't need to do #item :: #items. *)
  (list == {{ #item }}) *
  types(first: $$object_type, last: $$object_type, list: $$list_type) *
  optional_object(prev) *
  (first == last) *
  dll_node(first, #item, $$null, prev),

  (* Multiple Items in List *)
  (list == (#item :: #items)) *
  types(first: $$object_type, last: $$object_type, list: $$list_type, #items: $$list_type) *
  optional_object(prev) *
  (! (first == last)) *
  dll_node(first, #item, #next, prev) *
  dll_seg(first, #next, last, #items);

pred dll_list(dll, first, last, list):
  ((dll, "first")  -> first) *
  ((dll, "last")   -> last) * 
  ((dll, "@proto") -> $$null) * 
  dll_seg($$null, first, last, list);

(* Creates an object, with fields for first and last elements of an empty doubly linked list *)
spec create_empty_dll ()
  (* PM: emp, not true - you don't need any resource *)
  [[ emp ]]
  [[ dll_list(ret, $$null, $$null, {{ }}) ]]
  normal

proc create_empty_dll () {
  dll := new ();
  [dll, "first"] := $$null;
  [dll, "last"]  := $$null;
  [* fold(dll_seg($$null, $$null, $$null, {{ }})) *]
  goto rlab;
  rlab:
    skip
} with { ret: dll, rlab; };

(* Takes a dll representing a list
   and appends the item to the back of the list,
   returning a dll representing (list @ [item]) *)
spec append_to_dll (dll, item)
  (* PM: You've unfolded dll manually - the input and output of 
         this procedure should be a dll, and then you unfold *)
  [[ (item == #item) * (dll == #dll) * dll_list(#dll, #first, #last, #list) ]]
  [[ dll_list(#dll, #new_first, #new_last, (#list @ {{ #item }})) ]]
  normal

proc append_to_dll (dll, item) {

  (* PM: This is independent of the unfold *)
    
  (* Create the new node partially *)
  newNode := new ();
  [newNode, "value"] := item;
  [newNode, "next"] := $$null;
  
  (* Get the current state of the dll *)
  first := [dll, "first"];
  last  := [dll, "last"];
  
  (* The last node in both cases is the new node *)
  [dll, "last"] := newNode;
  
  (* And only now unfold and branch *)
  [* unfold dll_seg($$null, #first, #last, #list) *]
  goto [first = $$null] emptyList nonemptyList;
  
  emptyList:   
    (* This is the only thing to do if we had an empty dll *)
    [newNode, "prev"] := last;
    [dll, "first"] := newNode;
    
    (* PM: You can use program variables, so you can use newNode
           and also you already have #item from the precondition *)
    [* fold(dll_seg($$null, newNode, newNode, {{ #item }})) *]
    goto rlab;
    
  nonemptyList:    
    [newNode, "prev"] := last;
  	[last, "next"] := newNode;
  	
    (* PM: This gets a bit difficult from here, since last is at the end 
           and unfolding works from the start *)
  	(* Recursive helper function required just for dll_seg 
  	   append_to_dll_seg(dll_seg, newNode) *)
  	
    goto rlab;
  rlab:
    skip
} with { ret: dll, rlab; };
