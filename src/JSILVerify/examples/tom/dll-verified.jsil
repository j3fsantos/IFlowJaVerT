pred dll_node(node, val, next, prev):
  types(node : $$object_type) *
  ((node, "value")  -> val) *
  ((node, "next")   -> next) *
  ((node, "prev")   -> prev) *
  ((node, "@proto") -> $$null);

(*
  head = first element of list
  head_prev = predecessor of head
  last = last element of list
  last_next = successor of last
  list = literal list represented
*)
(* Unfolds from the right *)
pred dll_seg_2(head, head_prev, last, last_next, list):
  (* Empty List *)
  types(list: $$list_type) *
  (list == {{ }}) * (last == $$null) *
  (head_prev == last) *
  (head == last_next),

  (* Need to force the unfold to use the correct predicate *)
  (* Trying to stay away from nulls and optionals because they're messy *)

  (* Normal List *)
  (list == (#items @ {{ #item }})) *
  types(list: $$list_type, #items: $$list_type, head: $$object_type, last: $$object_type) *
  (dll_node(last, #item, last_next, #last_prev)) *
  (dll_seg_2(head, head_prev, #last_prev, last, #items));

(* head is a POINTER to the first element *)
(* head prev is a pointer to the element before the first element *)
(* last is a pointer to the last element *)
(* last next is a pointer to the element after the last element *)

(* Wrap a dll in an object so we can pass it around *)
pred dll_obj(obj, head, head_prev, last, last_next, list):
  types(obj: $$object_type, list: $$list_type) *
  ((obj, "head")      -> head) *
  ((obj, "head_prev") -> head_prev) *
  ((obj, "last")      -> last) *
  ((obj, "last_next") -> last_next) *
  ((obj, "@proto")    -> $$null) *
  dll_seg_2(head, head_prev, last, last_next, list);

(* Returns an object containing an empty list *)
spec create_empty_dll ()
  [[ emp ]]
  [[ dll_obj(ret, $$null, $$null, $$null, $$null, {{ }}) ]]
  normal

proc create_empty_dll () {
  dll := new ();
  [dll, "head"]      := $$null;
  [dll, "head_prev"] := $$null;
  [dll, "last"]      := $$null;
  [dll, "last_next"] := $$null;
  [* fold dll_seg_2($$null, $$null, $$null, $$null, {{ }} ) *]
  goto rlab;
  rlab:
    skip
} with { ret: dll, rlab; };

spec append_to_dll (obj, list, new_node)
  (* Empty list (need a separate predicate as head changes) *)
  [[ (obj == #obj) * (new_node == #new_node) *
     (list == {{ }}) *
     (#head_prev == #last) * (#head == #last_next) *
     (#head_prev == $$null) * (#last_next == $$null) *
     dll_node(#new_node, #item, $$null, $$null) *
     dll_obj(#obj, #head, #head_prev, #last, #last_next, {{ }}) ]]
  [[ dll_obj(#obj, #new_node, $$null, #new_node, $$null, {{ #item }}) ]]
  normal;

  (* Normal list *)
  [[ (obj == #obj) * (new_node == #new_node) *
     (list == #list) *
     (! (#head_prev == #last)) * (! (#head == #last_next)) *
     (! (#head == #new_node)) *
     (types(#head: $$object_type, #last: $$object_type)) *
     dll_node(#new_node, #item, $$null, $$null) *
     dll_obj(#obj, #head, #head_prev, #last, #last_next, #list) ]]
  [[ (#new_list == (#list @ {{ #item }})) *
     dll_obj(#obj, #head, #head_prev, #new_last, #new_last_next, #new_list) ]]
  normal

proc append_to_dll (obj, list, new_node) {

  (* Extracting pointers *)
  head_prev := [obj, "head_prev"];
  last      := [obj, "last"];

  goto [head_prev = last] emptyList nonemptyList;

  emptyList: (* VERIFIED *)

    [obj, "head"]      := new_node;
    [obj, "last"]      := new_node;

    [* unfold dll_seg_2($$null, $$null, $$null, $$null, {{ }});
       fold dll_seg_2(new_node, $$null, new_node, $$null, {{ #item }}) *]

    goto rlab;

  nonemptyList:

    (* Extracting pointers *)
    last_next := [obj, "last_next"];

    [* unfold dll_seg_2(#head, #head_prev, #last, #last_next, #list) *]

    (* Both unfoldings succeeded, how to make it pick one? *)
    (* The only way I could force it to choose the correct predicate was by enforcing types,
       but this was messy - is there a way to make it respect logical values as much as types? *)

    [last, "next"]      := new_node;
    [new_node, "prev"]  := last;
    new_last_next       := [new_node, "next"];

    [obj, "last"]       := new_node;
    [obj, "last_next"]  := new_last_next;

    (* First fold is successful *)

    [* fold dll_seg_2(#head, #head_prev, last, new_node, #list);
       fold dll_seg_2(#head, #head_prev, new_node, new_last_next, (#list @ {{ #item }})) *]

    goto rlab;

  rlab:
    skip

} with { ret: dll, rlab; };
