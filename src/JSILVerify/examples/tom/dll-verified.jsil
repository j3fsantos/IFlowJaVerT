pred ll_node(node, val, next):
  types(node : $$object_type) *
  ((node, "value")  -> val) *
  ((node, "next")   -> next) *
  ((node, "@proto") -> $$null);


(*
  head = first element of list
  last_next = successor of last
*)
(* Unfolds from the right *)
pred ll_seg(head, last_next, list):
  (* Empty List *)
  types(list: $$list_type) *
  (list == {{ }}) *
  (head == last_next),

  (* Need to force the unfold to use the correct predicate *)
  (* Trying to stay away from nulls and optionals because they're messy *)

  (* Normal List *)
  (list == (#item :: #items)) *
  types(list: $$list_type, #items: $$list_type, head: $$object_type) *
  (ll_node(head, #item, #next)) *
  (ll_seg(#next, last_next, #items));




pred dll_node(node, val, next, prev):
  types(node : $$object_type) *
  ((node, "value")  -> val) *
  ((node, "next")   -> next) *
  ((node, "prev")   -> prev) *
  ((node, "@proto") -> $$null);


(* Unfolds from the right *)
(*
  head = first element of list
  head_prev = predecessor of head
  last = last element of list
  last_next = successor of last
  list = literal list represented
*)
pred dll_seg_2(head, head_prev, last, last_next, list):
  (* Empty List *)
  types(list: $$list_type) *
  (list == {{ }}) *
  (head_prev == last) *
  (head == last_next),

  (* Need to force the unfold to use the correct predicate *)
  (* Trying to stay away from nulls and optionals because they're messy *)

  (* Normal List *)
  (! (head_prev == last)) *
  (list == (#items @ {{ #item }})) *
  types(list: $$list_type, #items: $$list_type, head: $$object_type, last: $$object_type) *
  (dll_node(last, #item, last_next, #last_prev)) *
  (dll_seg_2(head, head_prev, #last_prev, last, #items));


(* head is a POINTER to the first element *)
(* head prev is a pointer to the element before the first element *)
(* last is a pointer to the last element *)
(* last next is a pointer to the element after the last element *)

(* Wrap a dll in an object so we can pass it around *)
pred dll_obj(obj, head, head_prev, last, last_next, list):
  types(obj: $$object_type, list: $$list_type) *
  ((obj, "head")      -> head) *
  ((obj, "head_prev") -> head_prev) *
  ((obj, "last")      -> last) *
  ((obj, "last_next") -> last_next) *
  ((obj, "@proto")    -> $$null) *
  dll_seg_2(head, head_prev, last, last_next, list);

(* Returns an object containing an empty list *)
spec create_empty_dll ()
  [[ emp ]]
  [[ dll_obj(ret, $$null, $$null, $$null, $$null, {{ }}) ]]
  normal

proc create_empty_dll () {
  dll := new ();
  [dll, "head"]      := $$null;
  [dll, "head_prev"] := $$null;
  [dll, "last"]      := $$null;
  [dll, "last_next"] := $$null;
  [* fold dll_seg_2($$null, $$null, $$null, $$null, {{ }} ) *]
  goto rlab;
  rlab:
    skip
} with { ret: dll, rlab; };



spec append_to_dll (obj, new_node)
  (* Normal list *)
  [[ (obj == #obj) * (new_node == #new_node) *
     (types(#head: $$object_type, #last: $$object_type)) *
     dll_node(#new_node, #item, #nn, #np) *
     dll_obj(#obj, #head, #head_prev, #last, #last_next, #list) *
     (! (new_node == #np)) *
     (! (#head_prev == new_node)) *
     types(#last_next: $$object_type)
  ]]
  [[ (#new_list == (#list @ {{ #item }})) * 
     dll_obj(#obj, #head_f, #head_prev_f, #new_last_f, #new_last_next_f, #new_list) ]]
  normal

proc append_to_dll (obj, new_node) {

  (* Extracting pointers *)
  head_prev := [obj, "head_prev"];
  last      := [obj, "last"];

  [* unfold dll_seg_2(#head, #head_prev, #last, #last_next, #list) *]
  goto [head_prev = last] emptyList nonemptyList;

  emptyList:

    [obj, "head"]      := new_node;
    [obj, "last"]      := new_node;
    node_prev          := [new_node, "prev"];
    node_next          := [new_node, "next"];
    [obj, "head_prev"] := node_prev;
    [obj, "last_next"] := node_next;

    [*
      fold dll_seg_2(new_node, #np, #np, new_node, {{ }});
      fold dll_seg_2(new_node, #np, new_node, #nn, {{ #item }}) *]
    goto rlab;

  nonemptyList:

    (* Both unfoldings succeeded, how to make it pick one? *)
    (* The only way I could force it to choose the correct predicate was by enforcing types,
       but this was messy - is there a way to make it respect logical values as much as types? *)

    [last, "next"]      := new_node;
    [new_node, "prev"]  := last;
    new_last_next       := [new_node, "next"];

    [obj, "last"]       := new_node;
    [obj, "last_next"]  := new_last_next;

    (* First fold is successful *)
    [* fold dll_seg_2(#head, #head_prev, new_node, new_last_next, (#list @ {{ #item }})) *]
    goto rlab;
  rlab:
    skip

} with { ret: dll, rlab; };






proc singly_to_doubly_linked_list_helper (x, prev) {
  (** check for null **)
  goto [ x = $$null] rlab notnull;
  notnull:
    (** create new element **)
    newnode := new ();
    sourcenodeval := [x, "value"];
    [newnode, "value"] := sourcenodeval;
    [newnode, "prev"] := prev;
    nextsourcenode := [x, "next"];
    nextnewnode := "singly_to_doubly_linked_list_helper" (nextsourcenode, newnode);
    [newnode, "next"] := nextnewnode;
  rlab:
    skip
} with { ret: x, rlab; };
