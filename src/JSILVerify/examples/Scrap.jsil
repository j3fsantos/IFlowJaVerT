(* *******************************************
   ****** SCRAP ******************************
   ******************************************* *)

(* *** PUT *** *)

(* 2. Property is not defined within the prototype chain at all, object not extensible, don't throw *)
[[ (l == #l) * (prop == #prop) * (value == #value) * (throw == false) *
   types (#l : Obj, #prop : Str, #cls : Str, #throw : Bool) *
   ((#l, "@extensible") -> false) *
   Pi (#l, #prop, #cls, undefined, #g_aux_4, #g_aux_5, #g_aux_6) ]]
[[ Pi (#l, #prop, #cls, undefined, #g_aux_4, #g_aux_5, #g_aux_6) *
   ((#l, "@extensible") -> false) *
   (ret == empty) ]]
normal;

(* 4. Property is defined in the object, data descriptor that is not writable, don't throw *)
[[ (l == #l) * (prop == #prop) * (value == #value) * (throw == false) *
   types (#l : Obj, #prop : Str, #cls : Str, #throw : Bool) *
   ((#l, "@extensible") -> false) *
   Pi (#l, #prop, #cls, #g_aux_1, {{ #l }}, #g_aux_3, #g_aux_4) *
   DataDescriptor(#g_aux_3) * desc_writ(#g_aux_1, false) ]]
[[ Pi (#l, #prop, #cls, #g_aux_1, {{ #l }}, #g_aux_3, #g_aux_4) *
   ((#l, "@extensible") -> false) *
   (ret == empty) ]]
normal;

(* 6. Property is defined in the prototype chain, not in the object, object not extensible, don't throw *)
[[ (l == #l) * (prop == #prop) * (value == #value) * (throw == false) *
   types (#l : Obj, #prop : Str, #cls : Str, #throw : Bool) *
   ((#l, "@extensible") -> false) *
   Pi (#l, #prop, #cls, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) *
   DataDescriptor(#g_aux_1) * (1 <# l-len (#g_aux_2)) * types (#g_aux_2 : List) ]]
[[ Pi (#l, #prop, #cls, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) *
   ((#l, "@extensible") -> false) *
   (ret == empty) ]]
normal;

(* 8. Property is defined in the prototype chain, not in the object, object extensible, property not writable, don't throw *)
[[ (l == #l) * (prop == #prop) * (value == #value) * (throw == false) *
   types (#l : Obj, #prop : Str, #cls : Str, #throw : Bool) *
   ((#l, "@extensible") -> true) *
   Pi (#l, #prop, #cls, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) *
   DataDescriptor(#g_aux_31) * desc_writ(#g_aux_1, false) * (1 <# l-len (#g_aux_2)) * types (#g_aux_2 : List) ]]
[[ Pi (#l, #prop, #cls, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) *
   ((#l, "@extensible") -> true) *
   (ret == empty) ]]
normal;

(* *** DELETE *** *)


[[ (throw == false) * (l == #l) * (prop == #prop) *
   types(#l : Obj, #prop: Str, #cls: Str, #v : List) *
   ((#l, "@class") -> #cls) *
   isClass(#cls, "Non-String") * Cell_o (#l, #prop, #v) *
   DataDescriptor(#v) * desc_conf (#v, false) ]]
[[ ((#l, "@class") -> #cls) *
   isClass(#cls, "Non-String") * Cell_o (#l, #prop, #v) *
   (ret == false) ]]
normal;

[[ (l == #l) * (prop == #prop) * (throw == false) *
   types(#l : Obj, #prop: Str, #cls: Str, #pv : Str, #desc : List) *
   ((#l, "@class") -> #cls) *
   isClass(#cls, "String") * Cell_s (#l, #prop, "SI", #desc, #pv) *
   DataDescriptor(#desc) ]]
[[ ((#l, "@class") -> #cls) *
   isClass(#cls, "String") * Cell_s (#l, #prop, "SI", #desc, #pv) *
   (ret == false) ]]
normal;

[[ (l == #l) * (prop == #prop) * (throw == false) *
   types(#l : Obj, #prop: Str, #cls: Str, #pv : Str, #desc : List) *
   ((#l, "@class") -> #cls) *
   isClass(#cls, "String") * Cell_s (#l, #prop, "NSI", #desc, #pv) *
   DataDescriptor(#desc) * desc_conf (#desc, false)]]
[[ ((#l, "@class") -> #cls) *
   isClass(#cls, "String") * Cell_s (#l, #prop, "NSI", #desc, #pv) *
   (ret == false) ]]
normal;
