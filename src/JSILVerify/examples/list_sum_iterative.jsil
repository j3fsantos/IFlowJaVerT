

pred my_lseg(x, y, alpha_sum) : 
      (alpha_sum == 0) * (x == y) * types(alpha_sum: $$number_type),
      
       ((x, "value") -> #v) * ((x, "next") -> #z) * (alpha_sum == (#v + #beta_sum)) * 
          my_lseg(#z, y, #beta_sum) * types(alpha_sum: $$number_type, #beta_sum: $$number_type, #v: $$number_type);

pred alpha_sum(alpha,sum) : 
  (alpha == $$nil) * (sum == 0),
  (alpha == (#v :: #beta))  * alpha_sum(#beta,#sum_beta) * (sum == (#sum_beta + #v)) 
    * types(#v: $$number_type, sum: $$number_type, #sum_beta: $$number_type, alpha: $$list_type, #beta: $$list_type);

pred my_list(x, alpha_sum) : 
  (x == $$null) * (alpha_sum == 0),

  ((x, "value") -> #v) * ((x, "next") -> #z)  * my_list(#z, #beta_sum) * (alpha_sum == #v + #beta_sum) * 
     types(#v: $$number_type, alpha_sum: $$number_type, #beta_sum: $$number_type); 


pred my_lseg_full(x, y, alpha_sum, alpha) : 
      (alpha_sum == 0) * (x == y) * types(alpha_sum: $$number_type) * (alpha == {{ }}),
       
      ((x, "value") -> #v) * ((x, "next") -> #z) * (alpha_sum == (#v + #beta_sum)) * (alpha == #v :: #beta) * 
          my_lseg_full(#z, y, #beta_sum, #beta) * types(alpha_sum: $$number_type, #beta_sum: $$number_type, #beta: $$list_type, #v: $$number_type);


pred my_list_full(x, alpha_sum, alpha) : 
  (x == $$null) * (alpha_sum == 0) * (alpha == {{ }}),
  
  ((x, "value") -> #v) * ((x, "next") -> #z)  * my_list_full(#z, #beta_sum, #beta) * (alpha_sum == #v + #beta_sum) * (alpha == #v :: #beta) *
    types(#v: $$number_type, alpha_sum: $$number_type, #beta_sum: $$number_type, #beta: $$list_type); 



lemma lseg2listfull(x, alpha_sum, alpha)
  [[ my_lseg_full(x, $$null, alpha_sum, alpha) * (alpha_sum == #alpha_sum) * (x == #x) * (alpha == #alpha) ]]
  [[ my_list_full(#x, #alpha_sum, #alpha) ]]
  [*
    unfold(my_lseg_full(#x, $$null, #alpha_sum, #alpha));
    if (not (#alpha = ({{ }}))) then {
      assert(my_lseg_full(#next, $$null, #beta_sum, #beta));
      apply lseg2listfull(#next, #beta_sum, #beta); 
      fold(my_list_full(#x, #alpha_sum, #alpha))
    } else {
      fold(my_list_full(#x, #alpha_sum, #alpha))
    }
  *]


lemma lsegfull2lseg(x, y, alpha_sum, alpha)
  [[ my_lseg_full(x, y, alpha_sum, alpha) * (alpha_sum == #alpha_sum) * (x == #x) * (y == #y) ]]
  [[ my_lseg(#x, #y, #alpha_sum) ]]
  [* 
    unfold(my_lseg_full(#x, #y, #alpha_sum, alpha));
    if (not (alpha = ({{ }}))) then {
      assert(my_lseg_full(#next, #y, #beta_sum, #beta));
      apply lsegfull2lseg(#next, #y, #beta_sum, #beta); 
      fold(my_lseg(#x, #y, #alpha_sum))
    } else {
      fold(my_lseg(#x, #y, #alpha_sum))
    }

  *]

   lemma lseg_append(x, y, alpha, yval, ynext)
  [[ my_lseg(x, y, alpha) * (x == #x) * (ynext == #ynext) * (yval == #yval) * 
  (alpha == #alpha) 
      * ((y, "value") -> yval) * ((y, "next") -> ynext) * types (yval : $$number_type) ]]
  [[ my_lseg(#x, #ynext, (#alpha @ {{ #yval }})) ]]
  [*
    unfold(my_lseg(#x, y, #alpha));
    if (#alpha = ({{ }})) then {
      fold(my_lseg(#x, #ynext, (#alpha @ {{ #yval }})))
    } else {
      assert(my_lseg(#next, y, #beta));
      apply lseg_append(#next, y, #beta, #yval, #ynext); 
      fold(my_lseg(#x, #ynext, (#alpha @ {{ #yval }})))
    }

   *]

   lemma lseg_append2(x, y, alpha, alpha_sum, yval, ynext)
  [[ my_lseg_full(x, y, alpha_sum, alpha) * (x == #x) * (ynext == #ynext) * (yval == #yval) 
      * ((y, "value") -> yval) * ((y, "next") -> ynext) * (#alpha == alpha) * (#alpha_sum == alpha_sum) * types (yval : $$number_type) ]]
  [[ my_lseg_full(#x, #ynext, #alpha_sum + #yval, #alpha @ {{ #yval }}) ]]
  [*
    unfold(my_lseg_full(#x, y, #alpha_sum, #alpha));
    if (not (#alpha = {{ }})) then {
      assert(my_lseg_full(#next, y, #beta_sum, #beta));
      apply lseg_append2(#next, y, #beta, #beta_sum, #yval, #ynext); 
      fold(my_lseg_full(#x, #ynext, #alpha_sum + #yval, #alpha @ {{ #yval }}))
    } else {
      fold(my_lseg_full(#x, #ynext, #alpha_sum + #yval, #alpha @ {{ #yval }}))
    }

   *]

lemma lseg2list(x, alpha_sum)
  [[ my_lseg(x, $$null, alpha_sum) * (alpha_sum == #alpha_sum) * (x == #x) ]]
  [[ my_list(#x, #alpha_sum) ]]
  [*
    unfold(my_lseg(#x, $$null, #alpha_sum));
    if (not (#x = ($$null))) then {
      assert(my_lseg(#next, $$null, #beta_sum));
      apply lseg2list(#next, #beta_sum); 
      fold(my_list(#x, #alpha_sum))
    } else {
      fold(my_list(#x, #alpha_sum))
    }

   *]




spec list_sum_iterative (x)
   [[ (x == #x) * my_list(#x, #alpha_sum) * types(#alpha_sum: $$number_type) ]]
   [[ my_list(#x, #alpha_sum) * (ret == #alpha_sum) ]]
   normal
proc list_sum_iterative(x){
           
   [* fold my_lseg (#x, #x, 0) *]
   count := 0;  

   [[ my_lseg(#x, x, count) * my_list(x, #rest_sum) * (#alpha_sum == (count + #rest_sum)) *
        types(count: $$number_type, #rest_sum: $$number_type) ]]

   head:  skip;
          [* unfold my_list (x, #rest_sum)  *]
	        goto [ x = $$null ] prerlab else1;
   
   else1: 
           x_next := [x, "next"];
           x_val  := [x, "value"];

           [*  apply lseg_append (#x, x, count, x_val, x_next) *]
           count := count + x_val;
           x := x_next;
           
           goto head;

              [* apply lseg2list(#x, #alpha_sum) *]
   prerlab:   skip; 

   rlab:      skip
} with { ret: count, rlab; };
