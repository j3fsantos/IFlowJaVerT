(** Totals: 0 fails and 2 passes **)

pred my_list (x, alpha, size) :
	(x == null) * (alpha == {{ }}) *
		(size == 0) * types(alpha: List, size: Num),

	((x, "value") -> #y) * ((x, "next") -> #z) * ((x, "@proto") -> null) *
		(alpha == (#y :: #beta)) * my_list(#z, #beta, #size_beta) * (size == (#size_beta + 1)) *
		types(#y: Num, #alpha: List, #beta: List, size: Num, #size_beta: Num);


(** Expected result: YES                             **)
spec list_count (x)
   [[ (x == #x) * my_list(#x, #alpha, #size) * types(#size: Num, #alpha: List) ]]
   [[ my_list(#x, #alpha, #size) * types(#size: Num) * (ret == #size) ]]
   normal
proc list_count (x) {
		   [* unfold my_list(x, #alpha, #size) *]
		   goto [ x = null ] then1 else1;
   then1:   count := 0;
           goto rlab;
   else1:   z := [x, "next"];
   		   (* [x, "value"] := 3; *)
           count := "list_count"(z);
           count := count + 1;
           [* fold my_list(x, #alpha, #size) *]
   rlab:   skip
} with { ret: count, rlab; };
