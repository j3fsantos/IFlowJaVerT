predicate list(+x, alpha) {
  (x == null) * (alpha == nil);
  ((x, head) -> #v) * ((x, tail) -> #z) * list(#z, #beta) * (alpha == #v::#beta)
}

predicate lseg(+x, +y, alpha) {
  (x == y) * (alpha == nil);
  ((x, head) -> #v) * ((x, tail) -> #z) * lseg(#z, y, #beta) * (alpha == #v::#beta)
}

predicate lrev(+alpha, beta) {
  (alpha == nil) * (beta == nil);
  (alpha == #a :: #arest) * (beta == #brest @ [ #a ]) *
  lrev(#arest, #brest)
}

lemma lseg_to_list(x, alpha) {
  hypothesis: (x == #x) * (alpha == #alpha) * lseg(#x, null, #alpha)
  conclusions: list(#x, #alpha)
  // proof: unfold(lseg(#x, null, #alpha));
  //        if (not (#x = null)) {
  //          assert lseg(#next, null, #beta);
  //          apply lseg_to_list(#next, #beta);
  //          fold list(#x, #alpha)
  //        } else {
  //          fold list(#x, #alpha)
  //        }
}

lemma lseg_append(x, y, alpha, yval, ynext) {
  variant: len alpha
  hypothesis: (x == #x) * (y == #y) * (alpha == #alpha) *
              (yval == #yval) * (ynext == #ynext) *
              lseg(#x, #y, #alpha) * ((#y, head) -> #yval)
              * ((#y, tail) -> #ynext)
  conclusions: lseg(#x, #ynext, #alpha@([#yval]))
  // proof: unfold(lseg(#x, #y, #alpha));
  //       if (not (#alpha = nil)) {
  //         assert lseg(#next, #y, #beta);
  //         apply lseg_append(#next, #y, #beta, #yval, #ynext); 
  //         fold(lseg(#x, #ynext, #alpha @ [#yval]))
  //       } else {
  //         fold(lseg(#x, #ynext, #alpha @ [#yval]))
  //       }
}


{ (x == #x) * list(x, #alpha) }
function llen(x) {
  { pre: fold lseg(#x, #x, nil)}
  y := x;
  n := 0;
  { invariant: (n == len #done) * lseg(#x, y, #done)
              * list(y, #rest) * (#alpha == #done @ #rest) }
  { pre: unfold list(y, #rest) }
  while (y != null) {
    { pre: assert y == #oldy}
    y := y.tail;
    { pre: assert ((#oldy, head) -> #yval) * ((#oldy, tail) -> #ytail);
           apply lseg_append(#x, #oldy, #done, #yval, #ytail) }
    n := n + 1
  }
  { post: apply lseg_to_list(#x, #alpha) };
  return n
}
{ list(x, #alpha) * (ret == len #alpha) }


{ (x == #x) * list(#x, #alpha) * lrev(#alpha, #beta) * lrev(#alpha, beta)}
function lrev(x) {
  y := null
  { post: fold list(y, nil) };
  { invariant: list(x, #rest) * list(y, #beta) * lrev(#alpha, #restinv @ #beta) * lrev(#rest, #restinv) }
  while (x != null) {
    {pre: unfold list(x, #rest)}
    z := x.tail;
    x.tail := y;
    y := x
    {post: fold list(y, #v::#beta)};
    x := z
  };
  return y
}
{ list(ret, #beta) * lrev(#beta, #alpha) }


function lcopy(x) {
  t := x;
  y := null;
  p := y;
  while (t != null) {
    c := new(head: null, tail: null);
    c.head := v;
    c.tail := null;
    if (p != null) {
      p.tail := c
    } else {
      y := c
    };
    p := c;
    t := t.tail
  };
  return y
}


function lconcat(x, y) {
  if (x = null) {
    x := y
  }
  else {
    t := x;
    n := x.tail;
    while (n != null) {
      t := n;
      n := t.tail
    };
    t.tail := y
  };
  return x
}

function lappend(x, v) {
  n := new();
  n.head := v;
  n.tail := null;
  if (x = null) {
    z := n
  } else {
    t := x;
    while (t != null) {
      y := t;
      t := t.tail
    };
    y.tail := n;
    z := x
  };
  return z
} 
