predicate list(+x, alpha) {
  (x == null) * (alpha == nil);
  ((x, head) -> #v) * ((x, tail) -> #z) *
  list(#z, #beta) * (alpha == #v::#beta)
}

predicate lseg(+x, +y, alpha) {
  (x == y) * (alpha == nil);
  ((x, head) -> #v) * ((x, tail) -> #z) *
  lseg(#z, y, #beta) * (alpha == #v::#beta)
}

lemma lseg_to_list(x, alpha) {
  hypothesis: (x == #x) * lseg(#x, null, #alpha)
  conclusions: list(#x, #alpha)
  proof: unfold(lseg(#x, null, #alpha));
          if (not (#x = null)) {
            assert lseg(#next, null, #beta);
            apply lseg_to_list(#next, #beta);
            fold list(#x, #alpha)
          } else {
            fold list(#x, #alpha)
          }
}

lemma lseg_append(x, y, alpha, yval, ynext) {
  variant: len alpha
  hypothesis: (x == #x) * (y == #y) * (alpha == #alpha) *
              (yval == #yval) * (ynext == #ynext) *
              lseg(#x, #y, #alpha) * ((#y, head) -> #yval)
              * ((#y, tail) -> #ynext)
  conclusions: lseg(#x, #ynext, #alpha@([#yval]))
  proof: unfold(lseg(#x, #y, #alpha));
         if (not (#alpha = nil)) {
           assert lseg(#next, #y, #beta);
           apply lseg_append(#next, #y, #beta, yval, ynext); 
           fold(lseg(#x, #ynext, #alpha @ [#yval]))
         } else {
           fold(lseg(#x, #ynext, #alpha @ [#yval]))
         }
}

function lrev(x) {
  y := null;
  while (x != null) {
    z := x.tail;
    x.tail := y;
    y := x;
    x := z
  };
  return y
}

{ (x == #x) * list(x, #alpha) }
function llen(x) {
  { pre: fold lseg(#x, #x, nil)}
  y := x;
  n := 0;
  { invariant: list(x, #alpha) * (n == len #done) * lseg(x, y, #done)
              * list(y, #rest) * (#alpha == #done @ #rest) }
  { pre: unfold list(x, #alpha) }
  while (y != null) {
    { pre: assert y == #z}
    y := y.tail;
    { pre: apply lseg_append(#x, x, #done, #z, y) }
    n := n + 1
  }
  {post: apply lseg_to_list(x, #alpha) };
  return n
}
{ list(x, #alpha) * (ret == len #alpha) }

function lcopy(x) {
  t := x;
  y := null;
  p := y;
  while (t != null) {
    c := new(head: null, tail: null);
    c.head := v;
    c.tail := null;
    if (p != null) {
      p.tail := c
    } else {
      y := c
    };
    p := c;
    t := t.tail
  };
  return y
}

function lconcat(x, y) {
  if (x = null) {
    x := y
  }
  else {
    t := x;
    n := x.tail;
    while (n != null) {
      t := n;
      n := t.tail
    };
    t.tail := y
  };
  return x
}

function lappend(x, v) {
  n := new();
  n.head := v;
  n.tail := null;
  if (x = null) {
    z := n
  } else {
    t := x;
    while (t != null) {
      y := t;
      t := t.tail
    };
    y.tail := n;
    z := x
  };
  return z
}

a := null;
a := lappend(a, 0);
a := lappend(a, 1);
b := null;
b := lappend(b, 2);
b := lappend(b, 3);
c := lconcat(a, b);
d := lcopy(c);
n := llen(d)
