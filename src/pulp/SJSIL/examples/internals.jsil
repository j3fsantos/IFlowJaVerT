(* ******************
   *** PREDICATES ***
   ****************** *)

(*
 * Predicate: isInternalProperty
 *
 * Resource: None
 *
 *)
pred isInternalProperty (prop) :
    (0 <# s-len prop) * (s-nth (prop, 0) == "@") * types (prop : $$string_type);

(*
 * Predicate: isNamedProperty
 *
 * Resource: None
 *
 *)
pred isNamedProperty (prop) :
    (0 <# s-len prop) * (! (s-nth (prop, 0) == "@")) * types (prop : $$string_type);

(*
 * Predicate: DataDescriptor
 *
 * Resource: None
 *
 *)
pred DataDescriptor (d) :
    types (d : $$list_type) * (d == {{ "d", #dval, #dwrit, #denum, #dconf }}) *
    types (#dwrit : $$boolean_type, #denum : $$boolean_type, #dconf : $$boolean_type);

(*
 * Predicate: AccessorDescriptor
 *
 * Resource: None
 *
 *)
pred AccessorDescriptor (d) :
    types (d : $$list_type) * (d == {{ "a", #aget, #aset, #aenum, #aconf }}) *
    types (#aenum : $$boolean_type, #aconf : $$boolean_type);

(*
 * Predicate: GenericDescriptor
 *
 * Resource: None
 *
 *)
pred GenericDescriptor (d) :
    types (d : $$list_type) * (d == {{ "g", #genum, #gconf, #gval, #gwrit, #gget, #gset }});

(*
 * Predicate: Projection functions for descriptors
 *
 * Resource: None
 *
 *)
pred desc_val (d, v) :
    types (d : $$list_type) * v == l-nth(d, 1);

pred desc_writ (d, v) :
    types (d : $$list_type) * v == l-nth(d, 2);

pred desc_get (d, v) :
    types (d : $$list_type) * v == l-nth(d, 1);

pred desc_set (d, v) :
    types (d : $$list_type) * v == l-nth(d, 2);

pred desc_enum (d, v) :
    types (d : $$list_type) * v == l-nth(d, 3);

pred desc_conf (d, v) :
    types (d : $$list_type) * v == l-nth(d, 4);

(*
 * Predicate: Cell_o(l, prop, X)
 *
 * Resource:
 *      (l, prop)
 *
 * Note: We are not allowing accessor descriptors in the heap yet
 *)
pred Cell_o (l, prop, None) :
    types(l : $$object_type) * isNamedProperty(prop) * ((l, prop) -> None);

pred Cell_o (l, prop, d) :
    types(l : $$object_type) * isNamedProperty(prop) * ((l, prop) -> d) * DataDescriptor(d);

(*
 * Predicate: IsStringIndex
 *
 * Resource: None
 *
 *)
pred IsStringIndex(S, prop, i) :
    types(S : $$string_type, prop : $$string_type, i : $$int_type) *
    (prop == num_to_string i) * (!(i <# 0)) * (i <# s-len S);

(*
 * Predicate: Cell_s((l, prop, _, X, primitiveValue))
 *
 * Resource:
 *      (l, prop)               via Cell_o
 *      (l, "@primitiveValue")
 *
 * Note: Must be used with String objects,
 *       otherwise (l, "@primitiveValue") is $$empty
 *
 *)
pred Cell_s (l, prop, "None", None, pv) :
     Cell_o (l, prop, None) * ((l, "@primitiveValue") -> pv) *
     (#i == num_to_int (string_to_num prop)) * (! IsStringIndex(pv, prop, #i)) *
     types (pv : $$string_type);

pred Cell_s (l, prop, "SI", desc, pv) :
	 Cell_o (l, prop, None) * ((l, "@primitiveValue") -> pv) *
     (#i == num_to_int (string_to_num prop)) * IsStringIndex(pv, prop, #i) *
     (#v == s-nth(pv, #i)) * (desc == {{ "d", #v, $$f, $$t, $$f }}) *
     types(#v : $$string_type, desc : $$list_type, #i : $$int_type, pv : $$string_type);

pred Cell_s (l, prop, "NSI", desc, pv) :
	 Cell_o (l, prop, desc) * ((l, "@primitiveValue") -> pv) *
     (! (desc == None)) * DataDescriptor(desc) * types (desc : $$list_type, pv : $$string_type);

 (*
  * Predicate: CommonMethods(l)
  *
  * Resource:
  *      (l, "@getProperty")    (l, "@get")         (l, "@canPut")
  *      (l, "@put")            (l, "@hasProperty") (l, "@deleteProperty")
  *      (l, "@defaultValue")   (l, "@match")       (l, "@parameterMap")
  *
  * Note: Standard methods that are common to all objects.
  *       Should be used only when specifying ENTIRE objects.
  *
  *)
pred CommonMethods (l) :
    types (l : $$object_type) *
	((l, "@getProperty")    -> "o__getProperty") *
    ((l, "@get")            -> "o__get") *
    ((l, "@canPut")         -> "o__canPut") *
    ((l, "@put")            -> "o__put") *
    ((l, "@hasProperty")    -> "o__hasProperty") *
    ((l, "@deleteProperty") -> "o__deleteProperty") *
    ((l, "@defaultValue")   -> "o__defaultValue") *
    ((l, "@match")          -> $$empty) *
    ((l, "@parameterMap")   -> $$empty);

(*
 * Predicate: NonFunctionMethods(l)
 *
 * Resource:
 *      (l, "@getProperty")     (l, "@get")                 (l, "@canPut")
 *      (l, "@put")             (l, "@hasProperty")         (l, "@deleteProperty")
 *      (l, "@defaultValue")    (l, "@match")               (l, "@parameterMap")
 *      (l, "@construct")       (l, "@call")                (l, "@hasInstance")
 *      (l, "@scope")           (l, "@formalParameters")    (l, "@targetFunction")
 *      (l, "@boundThis")       (l, "@boundArguments")
 *
 * Note: Special Methods that are common to non-function objects.
 *       Should be used only when specifying ENTIRE objects.
 *
 *)
pred NonFunctionMethods (l) :
    CommonMethods(l) *
        ((l, "@construct") -> $$empty) *
        ((l, "@call") -> $$empty) *
        ((l, "@hasInstance") -> $$empty) *
        ((l, "@scope") -> $$empty) *
        ((l, "@formalParameters") -> $$empty) *
        ((l, "@targetFunction") -> $$empty) *
        ((l, "@boundThis") -> $$empty) *
        ((l, "@boundArguments") -> $$empty);

(*
 * Note: the mutable and non-unique methods are
 *
 *      (l, "@proto")       (l, "@class")
 *      (l, "@extensible")  (l, "@primitiveValue")
 *
 *      (l, "@getOwnProperty")    - different for Strings
 *      (l, "@defineOwnProperty") - different for Arrays
 *
 *)

pred ErrorObject (l, pr) :
	NonFunctionMethods(l) *
	((l, "@proto") -> pr) * ((l, "@class") -> "Error") *
	((l, "@extensible") -> $$t) * ((l, "@primitiveValue") -> $$empty) *
	((l, "@getOwnProperty") -> "o__getOwnProperty") *
	((l, "@defineOwnProperty") -> "o__defineOwnProperty");

pred isTypeError(l) :
    ErrorObject (l, $lterr_proto);

pred isSyntaxError(l) :
    ErrorObject (l, $lserr_proto);

pred isReferenceError(l) :
    ErrorObject (l, $lrferr_proto);

(*
 * Predicate: PiClass(l, X)
 *
 * Resource:
 *      (l, "@class")	(l, "@getOwnProperty")
 *
 *)
pred PiClass (l, "String") :
	 types (l : $$object_type) *
     ((l, "@class") -> "String") * ((l, "@getOwnProperty") -> "s__getOwnProperty");
pred PiClass (l, "Object") :
	 types (l : $$object_type) *
     ((l, "@class") -> #c) * (!(#c == "String")) * ((l, "@getOwnProperty") -> "o__getOwnProperty");

(*
 * The PI predicate
 *)

(*
 * Resource:
 *		(l, "@class")   (l, "@getOwnProperty")  via PiClass
 *		(l, "proto")	(l, "prop")		(l, "@getProperty")
 *)
pred Pi (l, prop, "base", "General", $$undefined, ls, ltf, lpv) :
	PiClass (l, "Object") * Cell_o (l, prop, None) *
	((l, "@getProperty") -> "o__getProperty") * ((l, "@proto") -> $$null) *
    types(ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
    (ls == {{ l }}) * (ltf == {{ $$f }}) * (lpv == {{ "" }});

(*
 * Resource:
 *		(l, "@class")   (l, "@getOwnProperty")  via PiClass
 *		(l, "proto")	(l, "prop")		(l, "@getProperty")
 *)
pred Pi (l, prop, "base", "General", d, ls, ltf, lpv) :
	PiClass (l, "Object") * Cell_o (l, prop, d) * DataDescriptor(d) *
	((l, "@getProperty") -> "o__getProperty") *
    types(ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
    (ls == {{ l }}) * (ltf == {{ $$f }}) * (lpv == {{ "" }});

(*
 * Resource:
 *		(l, "@class")   (l, "@getOwnProperty")  via PiClass
 *		(l, "proto")	(l, "prop")		(l, "@getProperty")
 *		(l, "@primitiveValue")
 *)
pred Pi (l, prop, "base", "String", $$undefined, ls, ltf, lpv) :
    PiClass (l, "String") * Cell_s (l, prop, "None", None, #pv) *
	((l, "@getProperty") -> "o__getProperty") * ((l, "@proto") -> $$null) *
    types(ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
    (ls == {{ l }}) * (ltf == {{ $$t }}) * (lpv == {{ #pv }});

(*
 * Resource:
 *		(l, "@class")   (l, "@getOwnProperty")  via PiClass
 *		(l, "proto")	(l, "prop")		(l, "@getProperty")
 *		(l, "@primitiveValue")
 *)
pred Pi (l, prop, "base", "StringSI", d, ls, ltf, lpv) :
	PiClass (l, "String") * Cell_s (l, prop, "SI", d, #pv) *
	((l, "@getProperty") -> "o__getProperty") *
    types(ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
    (ls == {{ l }}) * (ltf == {{ $$t }}) * (lpv == {{ #pv }});

(*
 * Resource:
 *		(l, "@class")   (l, "@getOwnProperty")  via PiClass
 *		(l, "proto")	(l, "prop")		(l, "@getProperty")
 *		(l, "@primitiveValue")
 *)
pred Pi (l, prop, "base", "StringNSI", d, ls, ltf, lpv) :
	PiClass (l, "String") * Cell_s (l, prop, "NSI", d, #pv) *
	((l, "@getProperty") -> "o__getProperty") *
    types(ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
    (ls == {{ l }}) * (ltf == {{ $$t }}) * (lpv == {{ #pv }});

(*
 * Resource:
 *		(l, "@class")   (l, "@getOwnProperty")  via PiClass
 *		(l, "proto")	(l, "prop")		(l, "@getProperty")
 *		(l, "@primitiveValue")
 *
 *		Those five fields captured throughout the chain
 *)
pred Pi (l, prop, "inductive", "General", d, ls, ltf, lpv) :
	PiClass (l, "Object") * Cell_o (l, prop, None) *
	((l, "@getProperty") -> "o__getProperty") *
    ((l, "@proto") -> #lp) * (! (#lp == $$null)) *
    Pi (#lp, prop, #caseType, #class, d, #lsp, #ltfp, #lpvp) *
	((#lp, "@getProperty") -> "o__getProperty") *
    types(  ls : $$list_type,   ltf : $$list_type,   lpv : $$list_type,
          #lsp : $$list_type, #ltfp : $$list_type, #lpvp : $$list_type) *
    (ls == l :: #lsp) * (ltf == $$f :: #ltfp) * (lpv == "" :: #lpvp) *
    (0 <# l-len #lsp) * (0 <# l-len #ltfp) * (0 <# l-len #lpvp);

(*
 * Resource:
 *		(l, "@class")   (l, "@getOwnProperty")  via PiClass
 *		(l, "proto")	(l, "prop")		(l, "@getProperty")
 *		(l, "@primitiveValue")
 *
 *		Those five fields captured throughout the chain
 *)
pred Pi (l, prop, "inductive", "String", d, ls, ltf, lpv) :
	PiClass (l, "String") * Cell_s (l, prop, "None", None, #pv) *
    ((l, "@getProperty") -> "o__getProperty") *
	((l, "@proto") -> #lp) * (! (#lp == $$null)) *
    Pi (#lp, prop, #caseType, #class, d, #lsp, #ltfp, #lpvp) *
	((#lp, "@getProperty") -> "o__getProperty") *
    types(  ls : $$list_type,   ltf : $$list_type,   lpv : $$list_type,
          #lsp : $$list_type, #ltfp : $$list_type, #lpvp : $$list_type) *
    (ls == l :: #lsp) * (ltf == $$t :: #ltfp) * (lpv == #pv :: #lpvp) *
    (0 <# l-len #lsp) * (0 <# l-len #ltfp) * (0 <# l-len #lpvp);

(* *************************************
   *** *** ***   AUXILIARY   *** *** ***
   ************************************* *)

(* **********************
   *** i__isPrimitive ***
   ********************** *)

spec i__isPrimitive (v)
   [[ v == $$undefined ]]
   [[ ret == $$t ]]
   normal;
   [[ v == $$null ]]
   [[ ret == $$t ]]
   normal;
   [[ types (v : $$string_type) ]]
   [[ (ret == $$t) ]]
   normal;
   [[ types (v : $$int_type) ]]
   [[ (ret == $$t) ]]
   normal;
   [[ types (v : $$boolean_type) ]]
   [[ (ret == $$t) ]]
   normal;
   [[ types (v : $$string_type) ]]
   [[ (ret == $$t) ]]
   normal;
   [[ types (v : $$object_type) ]]
   [[ (ret == $$f) ]]
   normal

proc i__isPrimitive (v) {
			tv := typeOf(v);

	iu:		goto [(v = $$undefined) or (v = $$null) or
	              (typeOf(v) = $$boolean_type) or (typeOf(v) <: $$number_type) or
	              (typeOf(v) = $$string_type)] rt rf;

	rt:		xret := $$t;
			goto rlab;

	rf:		xret := $$f;
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* *******************
   *** i__toNumber ***
   ******************* *)

spec i__toNumber (v)
	[[ types(v : $$string_type, #v : $$string_type) * (v == #v) ]]
	[[ types(ret : $$number_type) * (ret == (string_to_num #v)) ]]
	normal

proc i__toNumber (v) {
    iu:		goto [v = $$undefined] undef in;
	undef:	xret := nan;
    		goto rlab;

    in:		goto [v = $$null] null ib;
	null:	xret := 0;
    		goto rlab;

    ib:		goto [typeOf(v) = $$boolean_type] bool inum;
	bool:	goto [v = $$t] is_t is_f;
    is_t:	xret := 1;
    		goto rlab;
    is_f:	xret := 0;
    		goto rlab;

    inum:	goto [typeOf(v) = $$number_type] num is;
    num:	xret := v;
    		goto rlab;

    is:		goto [typeOf(v) = $$string_type] str io;
    str:	xret := string_to_num v;
    		goto rlab;

    io:		goto [typeOf(v) = $$object_type] obj oops;
    obj:	xret := "i__toPrimitive" (v, "Number") with elab;
    		xret := "i__toNumber" (xret);
    		goto rlab;

    oops:	xret := "TypeError" ("ToNumber: This should not happen.");
            goto elab;

    rlab:	skip;
    elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* ********************
   *** i__toInteger ***
   ******************** *)

spec i__toInteger (v)
	[[ types(v : $$string_type, #v : $$string_type) * (v == #v) ]]
	[[ types(ret : $$int_type) * (ret == num_to_int (string_to_num #v)) ]]
	normal

proc i__toInteger (v) {
			xret := "i__toNumber" (v) with elab;
			xret := num_to_int (xret);

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *******************
   *** i__toString ***
   ******************* *)

spec i__toString (v)
	[[ types(v : $$int_type, #v : $$int_type) * (v == #v) ]]
	[[ types(ret : $$string_type) * (ret == (num_to_string #v)) ]]
	normal

proc i__toString (v) {
	iu:		goto [v = $$undefined] undef in;
	undef:	xret := "undefined";
			goto rlab;

	in:		goto [v = $$null] null ib;
	null:	xret := "null";
			goto rlab;

	ib:		goto [typeOf(v) = $$boolean_type] bool inum;
	bool:	goto [v = $$t] is_t is_f;
	is_t:	xret := "true";
			goto rlab;
	is_f:	xret := "false";
			goto rlab;

	inum:	goto [typeOf(v) <: $$number_type] num is;
	num:	xret := num_to_string v;
			goto rlab;

	is:		goto [typeOf(v) = $$string_type] str io;
	str:	xret := v;
			goto rlab;

	io:		goto [typeOf(v) = $$object_type] obj oops;
	obj:	xret := "i__toPrimitive" (v, "String") with elab;
			xret := "i__toString" (xret) with elab;
			goto rlab;

	oops:	xret := "TypeError" ("ToString: This should not happen.");
            goto elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* ******************* *)
(* I__ISDATADESCRIPTOR *)
(* ******************* *)

spec i__isDataDescriptor (desc)

    (* Property not defined at all *)
    [[ desc == $$undefined ]]
    [[ ret == $$f ]]
    normal;

    (* Data descriptor *)
    [[ DataDescriptor(desc) ]]
    [[ ret == $$t ]]
    normal;

    (* Accessor descriptor *)
    [[ AccessorDescriptor(desc) ]]
    [[ ret == $$f ]]
    normal;

    (* Generic descriptor, no data descriptor components *)
    [[ GenericDescriptor(desc) * (l-nth (desc, 3) == $$empty) * (l-nth (desc, 4) == $$empty) ]]
    [[ ret == $$f ]]
    normal;

    (* Generic descriptor, with value *)
    [[ GenericDescriptor(desc) * (! l-nth (desc, 3) == $$empty) ]]
    [[ ret == $$t ]]
    normal;

    (* Generic descriptor, with writable *)
    [[ GenericDescriptor(desc) * (! l-nth (desc, 4) == $$empty) ]]
    [[ ret == $$t ]]
    normal

proc i__isDataDescriptor (desc) {
			goto [desc = $$undefined] rf cont;
	cont:	d := l-nth (desc, 0);
			goto [d = "d"] rt gen;
	gen:	goto [d = "g"] test rf;
	test:	v := l-nth (desc, 3);
			w := l-nth (desc, 4);
			goto [(v = $$empty) and (w = $$empty)] rf rt;
	rt:		xret := $$t;
			goto rlab;
	rf:		xret := $$f;
	rlab:	skip
}
with
{
	ret : xret, rlab;
};

(* *********************** *)
(* I__ISACCESSORDESCRIPTOR *)
(* *********************** *)

spec i__isAccessorDescriptor (desc)

    (* Property not defined at all *)
    [[ desc == $$undefined ]]
    [[ ret == $$f ]]
    normal;

    (* Data descriptor *)
    [[ DataDescriptor(desc) ]]
    [[ ret == $$f ]]
    normal;

    (* Accessor descriptor *)
    [[ AccessorDescriptor(desc) ]]
    [[ ret == $$t ]]
    normal;

    (* Generic descriptor, no data descriptor components *)
    [[ GenericDescriptor(desc) * (l-nth (desc, 5) == $$empty) * (l-nth (desc, 6) == $$empty) ]]
    [[ ret == $$f ]]
    normal;

    (* Generic descriptor, with get *)
    [[ GenericDescriptor(desc) * (! l-nth (desc, 5) == $$empty) ]]
    [[ ret == $$t ]]
    normal;

    (* Generic descriptor, with set *)
    [[ GenericDescriptor(desc) * (! l-nth (desc, 6) == $$empty) ]]
    [[ ret == $$t ]]
    normal

proc i__isAccessorDescriptor (desc) {
			goto [desc = $$undefined] rf cont;
	cont:	d := l-nth (desc, 0);
			goto [d = "a"] rt gen;
	gen:	goto [d = "g"] test rf;
	test:	g := l-nth (desc, 5);
			s := l-nth (desc, 6);
			goto [(g = $$empty) and (s = $$empty)] rf rt;
	rt:		xret := $$t;
			goto rlab;
	rf:		xret := $$f;
	rlab:	skip
}
with
{
	ret : xret, rlab;
};

(* ********************** *)
(* I__ISGENERICDESCRIPTOR *)
(* ********************** *)

spec i__isGenericDescriptor (desc)

    (* Property not defined at all *)
    [[ desc == $$undefined ]]
    [[ ret == $$f ]]
    normal;

	(* Data descriptor *)
	[[ DataDescriptor(desc) ]]
	[[ ret == $$f ]]
	normal;

	(* Accessor descriptor *)
	[[ AccessorDescriptor(desc) ]]
	[[ ret == $$f ]]
	normal;

	(* Generic descriptor, no data descriptor components *)
	[[ GenericDescriptor(desc) *
	   (l-nth (desc, 3) == $$empty) * (l-nth (desc, 4) == $$empty) *
	   (l-nth (desc, 5) == $$empty) * (l-nth (desc, 6) == $$empty) ]]
	[[ ret == $$t ]]
	normal;

	(* Generic descriptor, with value *)
	[[ GenericDescriptor(desc) * (! (l-nth (desc, 3) == $$empty)) ]]
	[[ ret == $$f ]]
	normal;

	(* Generic descriptor, with writable *)
	[[ GenericDescriptor(desc) * (! (l-nth (desc, 4) == $$empty)) ]]
	[[ ret == $$f ]]
	normal;

	(* Generic descriptor, with get *)
	[[ GenericDescriptor(desc) * (! (l-nth (desc, 5) == $$empty)) ]]
	[[ ret == $$f ]]
	normal;

	(* Generic descriptor, with get *)
	[[ GenericDescriptor(desc) * (! (l-nth (desc, 6) == $$empty)) ]]
	[[ ret == $$f ]]
	normal

proc i__isGenericDescriptor (desc) {
			goto [desc = $$undefined] rf cont;

	cont:	dd := "i__isDataDescriptor" (desc);
			ad := "i__isAccessorDescriptor" (desc);
			xret := not (dd or ad);
			goto rlab;

	rf:		xret := $$f;
	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* ******************* *)
(* I__TODATADESCRIPTOR *)
(* ******************* *)

spec i__toDataDescriptor (desc)

    [[ DataDescriptor (#desc) * (desc == #desc) ]]
    [[ (ret == #desc) ]]
    normal

proc i__toDataDescriptor (desc) {
			d := l-nth (desc, 0);
			goto [d = "d"] rd cstr;

	cstr:	goto [d = "a"] ra gen;

	ra:		xret := {{ "d", $$undefined, $$f, l-nth (d, 3), l-nth (d, 4) }};
			goto rlab;

	gen:	e := l-nth (desc, 1);
			c := l-nth (desc, 2);
			v := l-nth (desc, 3);
			w := l-nth (desc, 4);

			goto [e = $$empty] fixe c;
	fixe:	e := $$f;
	c:		goto [c = $$empty] fixc v;
	fixc:	c := $$f;
	v:		goto [v = $$empty] fixv w;
	fixv:	v := $$undefined;
	w:		goto [w = $$empty] fixw fixed;
	fixw:	w := $$f;

	fixed:	xret := {{ "d", v, w, e, c }};
			goto rlab;

	rd:		xret := desc;
	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* *************** *)
(* OBJECT CREATION *)
(* *************** *)

(*
 * Note: the mutable and non-unique methods are
 *
 *      (l, "@proto")       (l, "@class")
 *      (l, "@extensible")  (l, "@primitiveValue")
 *
 *      (l, "@getOwnProperty")    - different for Strings
 *      (l, "@defineOwnProperty") - different for Arrays
 *
 *)

spec create_default_object (l, pr, cl, ext)

    [[ types(#l : $$object_type, pr : $$object_type) *
       (cl == $$undefined) * (ext == $$undefined) *
       ((#l, "@proto") -> $$null) * (l == #l)]]
    [[ NonFunctionMethods (#l) *
	   ((#l, "@proto") -> pr) * ((#l, "@class") -> "Object") *
	   ((#l, "@extensible") -> $$t) * ((#l, "@primitiveValue") -> $$empty) *
	   ((#l, "@getOwnProperty") -> "o__getOwnProperty") *
	   ((#l, "@defineOwnProperty") -> "o__defineOwnProperty") *
	   (ret == #l) ]]
    normal;

    [[ types(l : $$object_type, pr : $$object_type, cl : $$string_type) *
       (ext == $$undefined) * ((#l, "@proto") -> $$null) * (l == #l) ]]
    [[ NonFunctionMethods (#l) *
	   ((#l, "@proto") -> pr) * ((#l, "@class") -> cl) *
	   ((#l, "@extensible") -> $$t) * ((#l, "@primitiveValue") -> $$empty) *
	   ((#l, "@getOwnProperty") -> "o__getOwnProperty") *
	   ((#l, "@defineOwnProperty") -> "o__defineOwnProperty") *
	   (ret == #l) ]]
    normal;

    [[ types(l : $$object_type, pr : $$object_type, ext : $$boolean_type) *
       (cl == $$undefined) * ((#l, "@proto") -> $$null) * (l == #l) ]]
    [[ NonFunctionMethods (#l) *
	   ((#l, "@proto") -> pr) * ((#l, "@class") -> "Object") *
	   ((#l, "@extensible") -> ext) * ((#l, "@primitiveValue") -> $$empty) *
	   ((#l, "@getOwnProperty") -> "o__getOwnProperty") *
	   ((#l, "@defineOwnProperty") -> "o__defineOwnProperty") *
	   (ret == #l) ]]
    normal;

    [[ types(l : $$object_type, pr : $$object_type, cl : $$string_type, ext : $$boolean_type) *
       ((#l, "@proto") -> $$null) * (l == #l) ]]
    [[ NonFunctionMethods (#l) *
	   ((#l, "@proto") -> pr) * ((#l, "@class") -> cl) *
	   ((#l, "@extensible") -> ext) * ((#l, "@primitiveValue") -> $$empty) *
	   ((#l, "@getOwnProperty") -> "o__getOwnProperty") *
	   ((#l, "@defineOwnProperty") -> "o__defineOwnProperty") *
	   (ret == #l) ]]
    normal

proc create_default_object (l, pr, cl, ext) {

			goto [cl = $$undefined] scl text;
	scl:	cl := "Object";
	text:	goto [ext = $$undefined] sext setall;
	sext:	ext := $$t;

	setall:	[l, "@proto"] := pr;
			[l, "@class"] := cl;
			[l, "@extensible"] := ext;

			[l, "@getOwnProperty"]    := "o__getOwnProperty";
			[l, "@getProperty"]       := "o__getProperty";
			[l, "@get"]               := "o__get";
			[l, "@canPut"]            := "o__canPut";
			[l, "@put"]               := "o__put";
			[l, "@hasProperty"]       := "o__hasProperty";
			[l, "@deleteProperty"]    := "o__deleteProperty";
			[l, "@defaultValue"]      := "o__defaultValue";
			[l, "@defineOwnProperty"] := "o__defineOwnProperty";

			[l, "@primitiveValue"]   := $$empty;
			[l, "@construct"]        := $$empty;
			[l, "@call"]             := $$empty;
			[l, "@hasInstance"]      := $$empty;
			[l, "@scope"]            := $$empty;
			[l, "@formalParameters"] := $$empty;
			[l, "@targetFunction"]   := $$empty;
			[l, "@boundThis"]        := $$empty;
			[l, "@boundArguments"]   := $$empty;
			[l, "@match"]            := $$empty;
			[l, "@parameterMap"]     := $$empty;

	rlab:	xret := l
}
with
{
	ret:	xret, rlab;
};

(* ****** *)
(* ERRORS *)
(* ****** *)

spec Error_construct (xsc, vthis, v)

    (* Error constructor without message *)
    [[ (v == $$undefined) * (vthis == #vthis) * types (#vthis : $$object_type) *
       ((#vthis, "@class") -> #cls) * ((#vthis, "@extensible") -> #ext) ]]
    [[ (ret == #vthis) * ((#vthis, "@class") -> "Error") * ((#vthis, "@extensible") -> $$t) ]]
    normal

proc Error_construct (xsc, vthis, v) {
			xret := vthis;

			[vthis, "@class"] := "Error";
			[vthis, "@extensible"] := $$t;

			goto [v = $$undefined] rlab mess;

	mess:	xerr := "i__toString" (v) with elab;
			[xret, "message"] := {{ "d", xerr, $$t, $$f, $$t }};

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xerr, elab;
};

(* ********* *)
(* TYPEERROR *)
(* ********* *)

spec TypeError_call (xsc, vthis, v)

    [[ (v == $$undefined) ]]
    [[ isTypeError(ret) ]]
    normal

proc TypeError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lterr_proto, "Error", $$t);

			xret := "Error_construct" ($$undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec TypeError (v)

    [[ (v == $$undefined) ]]
    [[ isTypeError(ret) ]]
    normal

proc TypeError (v) {
			xret := "TypeError_call" ($$undefined, $$undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* ************** *)
(* REFERENCEERROR *)
(* ************** *)

spec ReferenceError_call (xsc, vthis, v)

    [[ (v == $$undefined) ]]
    [[ isReferenceError(ret) ]]
    normal

proc ReferenceError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lrferr_proto, "Error", $$t);

			xret := "Error_construct" ($$undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec ReferenceError (v)

    [[ (v == $$undefined) ]]
    [[ isReferenceError(ret) ]]
    normal

proc ReferenceError (v) {
			xret := "ReferenceError_call" ($$undefined, $$undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *********** *)
(* SYNTAXERROR *)
(* *********** *)

spec SyntaxError_call (xsc, vthis, v)

    [[ (v == $$undefined) ]]
    [[ isSyntaxError(ret) ]]
    normal

proc SyntaxError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lserr_proto, "Error", $$t);

			xret := "Error_construct" ($$undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec SyntaxError (v)

    [[ (v == $$undefined) ]]
    [[ isSyntaxError(ret) ]]
    normal

proc SyntaxError (v) {
			xret := "SyntaxError_call" ($$undefined, $$undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* **********************************************
   *** *** ***   INTERNAL FUNCTIONS   *** *** ***
   ********************************************** *)

(* *************************
   *** O__GETOWNPROPERTY ***
   ************************* *)

spec o__getOwnProperty (l, prop)
    [[ Cell_o (#l, #prop, None) * (l == #l) * (prop == #prop) ]]
    [[ Cell_o (#l, #prop, None) * (ret == $$undefined) ]]
    normal;
    [[ Cell_o (#l, #prop, #dx) * (l == #l) * (prop == #prop) *
	   DataDescriptor(#dx) * types (#dx : $$list_type) ]]
    [[ Cell_o (#l, #prop, #dx) * (ret == #dx) ]]
    normal

proc o__getOwnProperty (l, prop) {
	(*
		l must be an object
		prop must be a non-empty string
		prop must not be an internal property
	*)
	ch0:	goto [typeOf(l) = $$object_type] ch1 elab;
	ch1:	goto [typeOf(prop) = $$string_type] ch2 elab;
	ch2:	goto [0 < s-len prop] ch3 elab;
	ch3:	goto [not (s-nth(prop, 0) = "@")] start elab;

    start:	x := hasField(l, prop);
            goto [x] hp nhp;

    nhp:    xret := $$undefined;
            goto rlab;

    hp:     xret := [l, prop];

    rlab:   skip;

	elab:	xret := "TypeError" ()
}
with
{
    ret: 	xret, rlab;
	err:	xret, elab;
};

(* *************************
   *** S__GETOWNPROPERTY ***
   ************************* *)

spec s__getOwnProperty (l, prop)
    [[ Cell_s (#l, #prop, "None", None, #pv) * (l == #l) * (prop == #prop) ]]
    [[ Cell_s (#l, #prop, "None", None, #pv) * (ret == $$undefined) ]]
   	normal;
   	(* Same comment as in o__getOwnProperty applies *)
   	[[ Cell_s (#l, #prop, "SI", #u, #pv) * (l == #l) * (prop == #prop) ]]
   	[[ Cell_s (#l, #prop, "SI", #u, #pv) * (ret == #u) ]]
   	normal;
   	[[ Cell_s (#l, #prop, "NSI", #u, #pv) * (l == #l) * (prop == #prop) ]]
   	[[ Cell_s (#l, #prop, "NSI", #u, #pv) * (ret == #u) ]]
   	normal

proc s__getOwnProperty (l, prop) {

    ch0:	goto [typeOf(l) = $$object_type] ch1 elab;
    ch1:	goto [typeOf(prop) = $$string_type] ch2 elab;
    ch2:	goto [0 < s-len prop] ch3 elab;
    ch3:	goto [not (s-nth(prop, 0) = "@")] start elab;

   	start:	xret := "o__getOwnProperty" (l, prop);
   			goto [xret = $$undefined] str rlab;

   	str:	idx := "i__toInteger" (prop) with elab;
   			goto [idx < 0] rlab next;

   	next:	sidx := "i__toString" (idx);

   			goto [sidx = prop] index rlab;

   	index:	str := [l, "@primitiveValue"];
   			len := s-len (str);
   			goto [len <= idx] rlab return;

   	return: rstr := s-nth (str, idx);
   			xret := {{ "d", rstr, $$f, $$t, $$f }};

   	rlab: 	skip;
   	elab:	skip
}
with
{
    ret: 	xret, rlab;
   	err: 	xret, elab;
};

(* **********************
   *** O__GETPROPERTY ***
   ********************** *)

spec o__getProperty (l, prop)
	[[ Pi (#l, #prop, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4, #gp_aux_5, #gp_aux_6) * (l == #l) * (prop == #prop) ]]
	[[ Pi (#l, #prop, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4, #gp_aux_5, #gp_aux_6) * (ret == #gp_aux_3) ]]
	normal

proc o__getProperty (l, prop) {

			[* unfold Pi (#l, #prop, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4, #gp_aux_5, #gp_aux_6) *]
    ch0:	goto [typeOf(l) = $$object_type] ch1 elab;
    ch1:	goto [typeOf(prop) = $$string_type] ch2 elab;
    ch2:	goto [0 < s-len prop] ch3 elab;
    ch3:	goto [not (s-nth(prop, 0) = "@")] start elab;

	start:  gop := [l, "@getOwnProperty"];
			xret := gop (l, prop) with elab;
			goto [xret = $$undefined] next rlab;

	next:	proto := [l, "@proto"];
			goto [proto = $$null] rlab call;

	call:	gp := [proto, "@getProperty"];
			xret := gp (proto, prop) with elab;

			[* fold Pi (#l, #prop, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4, #gp_aux_5, #gp_aux_6) *]
    rlab:   skip;
    elab:	skip

}
with
{
    ret: 	xret, rlab;
    err:	xret, elab;
};

(* **************
   *** O__GET ***
   ************** *)

spec o__get (l, prop)
    [[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) * (#g_aux_3 == $$undefined) * (l == #l) * (prop == #prop)]]
    [[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) * (#g_aux_3 == $$undefined) * (ret == $$undefined) ]]
    normal;
    [[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) * DataDescriptor (#g_aux_3) * (l == #l) * (prop == #prop) ]]
    [[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) * desc_val (#g_aux_3, #desc_val) * (ret == #desc_val) ]]
    normal

proc o__get (l, prop) {

            [* unfold Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) *]
    ch0:	goto [typeOf(l) = $$object_type] ch1 elab;
    ch1:	goto [typeOf(prop) = $$string_type] ch2 elab;
    ch2:    goto [0 < s-len prop] ch3 elab;
    ch3:	goto [not (s-nth(prop, 0) = "@")] start elab;

	start:  gp := [l, "@getProperty"];
            [* fold Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) *]
		    xret := gp (l, prop) with elab;
            goto [xret = $$undefined] rlab def;

	def:	d := l-nth (xret, 0);
			xret := l-nth (xret, 1);
			goto [d = "d"] rlab acc;

	acc:	goto [xret = $$undefined] rlab get;
	get:	xsc := [xret, "@scope"];
			fun := [xret, "@call"];
			xret := fun (xsc, l) with elab;
			goto [xret = $$empty] undef rlab;
	undef:	xret := $$undefined;

	rlab:	skip;
	elab:	skip
}
with
{
   ret: xret, rlab;
   err: xret, elab;
};

(* ****** *)
(* CANPUT *)
(* ****** *)

spec o__canPut (l, prop)

    (* Property not defined at all, returning "@extensible" *)
    [[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) * (l == #l) * (prop == #prop) *
       (#g_aux_3 == $$undefined) * ((#l, "@extensible") -> #ext) * types (#ext: $$boolean_type) ]]
    [[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) *
       ((#l, "@extensible") -> #ext) * (ret == #ext) ]]
    normal;

	(* Property defined in the object itself, returning writable *)
	[[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) * (l == #l) * (prop == #prop) *
	   DataDescriptor(#g_aux_3) * desc_writ(#g_aux_3, #writable) * (#g_aux_4 == {{ l }}) ]]
	[[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) *
	   (ret == #writable) ]]
	normal;

	(* Property defined as a data descriptor outside, but object not extensible, return false *)
	[[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) * (l == #l) * (prop == #prop) *
	   DataDescriptor(#g_aux_3) * (1 <# l-len (#g_aux_4)) * ((#l, "@extensible") -> $$f) *
	   types (#g_aux_4 : $$list_type)]]
	[[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) *
	   ((#l, "@extensible") -> $$f) * (ret == $$f) ]]
	normal;

	(* Property defined as a data descriptor outside, object extensible, return writable *)
	[[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) * (l == #l) * (prop == #prop) *
	   DataDescriptor(#g_aux_3) * desc_writ(#g_aux_3, #writable) * (1 <# l-len (#g_aux_4)) *
	   ((#l, "@extensible") -> $$t) * types (#g_aux_4 : $$list_type) ]]
	[[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) *
	   ((#l, "@extensible") -> $$t) * (ret == #writable) ]]
	normal;

	(* Property defined as an accessor descriptor, set doesn't exist, return false *)
	[[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) * (l == #l) * (prop == #prop) *
	   AccessorDescriptor(#g_aux_3) * desc_set(#g_aux_3, $$undefined) *
	   ((#l, "@extensible") -> #ext) * types (#ext : $$boolean_type) ]]
	[[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) *
	   ((#l, "@extensible") -> #ext) * (ret == $$f) ]]
	normal;

	(* Property defined as an accessor descriptor, set exists, return true *)
	[[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) * (l == #l) * (prop == #prop) *
	   AccessorDescriptor(#g_aux_3) * desc_set(#g_aux_3, #set) *
	   ((#l, "@extensible") -> #ext) * types (#ext : $$boolean_type, #set: $$object_type) ]]
	[[ Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) *
	   ((#l, "@extensible") -> #ext) * (ret == $$t) ]]
	normal

proc o__canPut (l, prop) {
            [* unfold Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) *]
    ch0:	goto [typeOf(l) = $$object_type] ch1 elab;
    ch1:	goto [typeOf(prop) = $$string_type] ch2 elab;
    ch2:    goto [0 < s-len prop] ch3 elab;
    ch3:	goto [not (s-nth(prop, 0) = "@")] start elab;

	start:  gop := [l, "@getOwnProperty"];
            xret := gop (l, prop) with elab;
	op:		goto [xret = $$undefined] nop odesc; 	(* Does the own property exist? *)

	odesc:	d := l-nth (xret, 0);					(* It does; get the descriptor type *)
			goto [d = "d"] odd nop;					(* Is the descriptor a data descriptor? *)

	odd:	xret := l-nth (xret, 2);				(* It is; return the Writable attribute *)
            [* fold Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) *]
			goto rlab;

	nop:	gp := [l, "@getProperty"];
            [* fold Pi (#l, #prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) *]
            xret := gp (l, prop) with elab;			(* Does the property exist? *)
            e := [l, "@extensible"];
            goto [xret = $$undefined] ext desc;		(* It doesn't; return extensible *)

	desc:	d := l-nth (xret, 0);					(* Get the descriptor type *)
			v := l-nth (xret, 2);					(* Get the writable/setter *)
			goto [d = "d"] dd ad;					(* Is it a data descriptor? *)

	dd:     goto [e] wr ext;						(* Yes; is the object extensible? *)
	wr:		xret := v;								(* Yes; return writable *)
			goto rlab;

	ad:		xret := not (v = $$undefined);		     (* Accessor descriptor *)
            goto rlab;

	ext:	xret := e;                				(* Return extensible *)

    rlab:   skip;
    elab:	skip
}
with
{
    ret: 	xret, rlab;
    err:	xret, elab;
};

(* ************** *)
(* DELETEPROPERTY *)
(* ************** *)

spec o__deleteProperty (l, prop, throw)

    [[ Cell_o (#l, #prop, #v) * ((#l, "@getOwnProperty") -> "o__getOwnProperty") *
	   DataDescriptor(#v) * desc_conf (#v, $$f) * (throw == $$t) * (l == #l) * (prop == #prop) ]]
    [[ Cell_o (#l, #prop, #v) * ((#l, "@getOwnProperty") -> "o__getOwnProperty") *
	   isTypeError(err) ]]
    error;

    [[ Cell_o (#l, #prop, #v) * ((#l, "@getOwnProperty") -> "o__getOwnProperty") *
	   DataDescriptor(#v) * desc_conf (#v, $$f) * (throw == $$f) * (l == #l) * (prop == #prop) ]]
    [[ Cell_o (#l, #prop, #v) * ((#l, "@getOwnProperty") -> "o__getOwnProperty") *
	   (ret == $$f) ]]
    normal;

    [[ Cell_o (#l, #prop, #v) * ((#l, "@getOwnProperty") -> "o__getOwnProperty") *
	   DataDescriptor(#v) * desc_conf (#v, $$t) * (l == #l) * (prop == #prop) ]]
    [[ Cell_o (#l, #prop, None) * ((#l, "@getOwnProperty") -> "o__getOwnProperty") *
	   (ret == $$t) ]]
    normal;

    [[ Cell_o (#l, #prop, None) * ((#l, "@getOwnProperty") -> "o__getOwnProperty") * (l == #l) * (prop == #prop) ]]
    [[ Cell_o (#l, #prop, None) * ((#l, "@getOwnProperty") -> "o__getOwnProperty") *
	   (ret == $$t) ]]
    normal;

	[[ Cell_s (#l, #prop, "None", None, #pv) * ((#l, "@getOwnProperty") -> "o__getOwnProperty") * (l == #l) * (prop == #prop) ]]
	[[ Cell_s (#l, #prop, "None", None, #pv) * ((#l, "@getOwnProperty") -> "o__getOwnProperty") *
	   (ret == $$t)]]
	normal;

	[[ Cell_s (#l, #prop, "SI", #desc, #pv) * ((#l, "@getOwnProperty") -> "s__getOwnProperty") *
	   (throw == $$t) * (l == #l) * (prop == #prop)]]
	[[ Cell_s (#l, #prop, "SI", #desc, #pv) * ((#l, "@getOwnProperty") -> "s__getOwnProperty") *
	   isTypeError(err) ]]
	error;

	[[ Cell_s (#l, #prop, "SI", #desc, #pv) * ((#l, "@getOwnProperty") -> "s__getOwnProperty") *
	   DataDescriptor(#desc) * (throw == $$f) * (l == #l) * (prop == #prop)]]
	[[ Cell_s (#l, #prop, "SI", #desc, #pv) * ((#l, "@getOwnProperty") -> "s__getOwnProperty") *
	   (ret == $$f) ]]
	normal

proc o__deleteProperty (l, prop, throw) {
    ch0:	goto [typeOf(l) = $$object_type] ch1 elab;
    ch1:	goto [typeOf(prop) = $$string_type] ch2 elab;
    ch2:    goto [0 < s-len prop] ch3 elab;
    ch3:	goto [not (s-nth(prop, 0) = "@")] start elab;

	start:	gop := [l, "@getOwnProperty"];
			xret := gop (l, prop) with elab;
			goto [xret = $$undefined] dt cont;

  	cont:	c := l-nth (xret, 4);
  			goto [c] del reject;
  	del:	delete (l, prop);

  	dt:		xret := $$t;
      		goto rlab;

	df:   	xret := $$f;
	rlab: 	skip;

	reject:	goto [throw] tt df;

    tt:     xret := "TypeError" ();
    elab:   skip
}
with
{
  ret: xret, rlab;
  err: xret, elab;
};
