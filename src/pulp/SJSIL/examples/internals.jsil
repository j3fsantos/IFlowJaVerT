(* ******************
   *** PREDICATES ***
   ****************** *)

(* Internal properties *)
pred isInternalProperty (prop) :
    (0 <# s-len prop) * (s-nth (prop, 0) == "@") * types (prop : $$string_type);

(* Named properties *)
pred isNamedProperty (prop) :
    (0 <# s-len prop) * (! (s-nth (prop, 0) == "@")) * types (prop : $$string_type);

(* Location *)
pred isObjectLocation (v) :
    types (v : $$object_type);

pred isList (v) :
    types (v : $$list_type);

(* Data descriptors *)
pred DataDescriptor (d) :
    isList(d) * (d == {{ #dtype, #dval, #writ, #enum, #conf }}) * (#dtype == "d") *
    types (#dtype : $$string_type, #writ : $$boolean_type, #enum : $$boolean_type, #conf : $$boolean_type);

pred desc_val (d, v) :
    isList(d) * v == l-nth(d, 1);

pred desc_writ (d, v) :
    isList(d) * v == l-nth(d, 2);

pred desc_enum (d, v) :
    isList(d) * v == l-nth(d, 3);

pred desc_conf (d, v) :
    isList(d) * v == l-nth(d, 4);

pred VariableReference (r) :
    isList(r) * (r == {{ #rtype, #rbase, #rfield }}) * (#rtype == "v") *
    types (#rtype : $$string_type, #rfield : $$string_type);

pred ObjectReference (r) :
    isList(r) * (r == {{ #rtype, #rbase, #rfield }}) * (#rtype == "o") *
    types (#rtype : $$string_type, #rfield : $$string_type);

(* Standard object cell stuff *)
pred Cell_o (l, prop, None) :
    isObjectLocation(l) * isNamedProperty(prop) * ((l, prop) -> None);
pred Cell_o (l, prop, d) :
    isObjectLocation(l) * isNamedProperty(prop) * ((l, prop) -> d) * DataDescriptor(d);

pred IsStringIndex(S, prop, i) :
    types(S : $$string_type, prop : $$string_type, i : $$int_type) *
    (prop == num_to_string i) * (!(i <# 0)) * (i <# s-len S);

(* String cell stuff *)
pred Cell_s (l, prop, "None", None, pv) :
     Cell_o (l, prop, None) * ((l, "@primitiveValue") -> pv) *
     (#i == num_to_int (string_to_num prop)) * (! IsStringIndex(pv, prop, #i)) *
     types (pv : $$string_type);

pred Cell_s (l, prop, "SI", desc, pv) :
     Cell_o (l, prop, None) * ((l, "@primitiveValue") -> pv) *
     (#i == num_to_int (string_to_num prop)) * IsStringIndex(pv, prop, #i) *
     (#v == s-nth(pv, #i)) * types(#v : $$string_type, desc : $$list_type) *
     (desc == {{ "d", #v, $$f, $$t, $$f }}) * types (pv : $$string_type);

pred Cell_s (l, prop, "NSI", desc, pv) :
     Cell_o (l, prop, desc) * ((l, "@primitiveValue") -> pv) *
     (! (desc == None)) * types (pv : $$string_type);

(* Common and less common methods *)

pred CommonMethods (l) :
	((l, "@getProperty") -> "o__getProperty") *
    ((l, "@get")         -> "o__get");

pred Methods_String (l) :
	CommonMethods(l) * ((l, "@getOwnProperty") -> "s__getOwnProperty");

pred Methods_General (l) :
    CommonMethods(l) * ((l, "@getOwnProperty") -> "o__getOwnProperty");

(* Classes and methods *)
pred Class (l, "String") :
     ((l, "@class") -> "String") * Methods_String (l);
pred Class (l, "Object") :
     ((l, "@class") -> #c) * (!(#c == "String")) * Methods_General (l);

(* The PI predicate *)

pred Pi (l, prop, "base", "General", $$undefined, ls, ltf, lpv) :
	Class (l, "Object") * Cell_o (l, prop, None) * ((l, "@proto") -> $$null) *
    types(ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
    (ls == {{ l }}) * (ltf == {{ $$f }}) * (lpv == {{ "" }});

pred Pi (l, prop, "base", "General", d, ls, ltf, lpv) :
	Class (l, "Object") * Cell_o (l, prop, d) * DataDescriptor(d) *
    types(ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
    (ls == {{ l }}) * (ltf == {{ $$f }}) * (lpv == {{ "" }});

pred Pi (l, prop, "base", "String", $$undefined, ls, ltf, lpv) :
    Class (l, "String") * Cell_s (l, prop, "None", None, #pv) * ((l, "@proto") -> $$null) *
    types(ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
    (ls == {{ l }}) * (ltf == {{ $$t }}) * (lpv == {{ #pv }});

pred Pi (l, prop, "base", "StringSI", d, ls, ltf, lpv) :
	Class (l, "String") * Cell_s (l, prop, "SI", d, #pv) *
    types(ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
    (ls == {{ l }}) * (ltf == {{ $$t }}) * (lpv == {{ #pv }});

pred Pi (l, prop, "base", "StringNSI", d, ls, ltf, lpv) :
	Class (l, "String") * Cell_s (l, prop, "NSI", d, #pv) *
    types(ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
    (ls == {{ l }}) * (ltf == {{ $$t }}) * (lpv == {{ #pv }});

pred Pi (l, prop, "inductive", "General", d, ls, ltf, lpv) :
	Class (l, "Object") * Cell_o (l, prop, None) *
    ((l, "@proto") -> #lp) * (!(#lp == $$null)) * CommonMethods(#lp) *
    Pi (#lp, prop, #caseType, #class, d, #lsp, #ltfp, #lpvp) *
    types(  ls : $$list_type,   ltf : $$list_type,   lpv : $$list_type,
          #lsp : $$list_type, #ltfp : $$list_type, #lpvp : $$list_type) *
    (ls == l :: #lsp) * (ltf == $$f :: #ltfp) * (lpv == "" :: #lpvp);

pred Pi (l, prop, "inductive", "String", d, ls, ltf, lpv) :
	Class (l, "String") * Cell_s (l, prop, "None", None, #pv) *
    ((l, "@proto") -> #lp) * (!(#lp == $$null)) * CommonMethods(#lp) *
    Pi (#lp, prop, #caseType, #class, d, #lsp, #ltfp, #lpvp) *
    types(  ls : $$list_type,   ltf : $$list_type,   lpv : $$list_type,
          #lsp : $$list_type, #ltfp : $$list_type, #lpvp : $$list_type) *
    (ls == l :: #lsp) * (ltf == $$t :: #ltfp) * (lpv == #pv :: #lpvp);

(* **********************
   *** I__ISPRIMITIVE ***
   ********************** *)

spec i__isPrimitive (v)
   [[ v == $$undefined ]]
   [[ ret == $$t ]]
   normal;
   [[ v == $$null ]]
   [[ ret == $$t ]]
   normal;
   [[ types (v : $$string_type) ]]
   [[ (ret == $$t) ]]
   normal;
   [[ types (v : $$int_type) ]]
   [[ (ret == $$t) ]]
   normal;
   [[ types (v : $$boolean_type) ]]
   [[ (ret == $$t) ]]
   normal;
   [[ types (v : $$string_type) ]]
   [[ (ret == $$t) ]]
   normal;
   [[ types (v : $$object_type) ]]
   [[ (ret == $$f) ]]
   normal

proc i__isPrimitive (v) {
			tv := typeOf(v);

	iu:		goto [(v = $$undefined) or (v = $$null) or
	              (typeOf(v) = $$boolean_type) or (typeOf(v) <: $$number_type) or
	              (typeOf(v) = $$string_type)] rt rf;

	rt:		xret := $$t;
			goto rlab;

	rf:		xret := $$f;
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};


(* *******************
   *** i__toNumber ***
   ******************* *)

spec i__toNumber (v)
	[[ types(v : $$string_type, #v : $$string_type) * (v == #v) ]]
	[[ types(ret : $$number_type) * (ret == (string_to_num #v)) ]]
	normal

proc i__toNumber (v) {
    iu:		goto [v = $$undefined] undef in;
	undef:	xret := nan;
    		goto rlab;

    in:		goto [v = $$null] null ib;
	null:	xret := 0;
    		goto rlab;

    ib:		goto [typeOf(v) = $$boolean_type] bool inum;
	bool:	goto [v = $$t] is_t is_f;
    is_t:	xret := 1;
    		goto rlab;
    is_f:	xret := 0;
    		goto rlab;

    inum:	goto [typeOf(v) = $$number_type] num is;
    num:	xret := v;
    		goto rlab;

    is:		goto [typeOf(v) = $$string_type] str io;
    str:	xret := string_to_num v;
    		goto rlab;

    io:		goto [typeOf(v) = $$object_type] obj oops;
    obj:	xret := "i__toPrimitive" (v, "Number") with elab;
    		xret := "i__toNumber" (xret);
    		goto rlab;

    oops:	xret := "TypeError" ("ToNumber: This should not happen.");
            goto elab;

    rlab:	skip;
    elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* ********************
   *** i__toInteger ***
   ******************** *)

spec i__toInteger (v)
	[[ types(v : $$string_type, #v : $$string_type) * (v == #v) ]]
	[[ types(ret : $$int_type) * (ret == num_to_int (string_to_num #v)) ]]
	normal

proc i__toInteger (v) {
			xret := "i__toNumber" (v) with elab;
			xret := num_to_int (xret);

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *******************
   *** i__toString ***
   ******************* *)

spec i__toString (v)
	[[ types(v : $$int_type, #v : $$int_type) * (v == #v) ]]
	[[ types(ret : $$string_type) * (ret == (num_to_string #v)) ]]
	normal

proc i__toString (v) {
	iu:		goto [v = $$undefined] undef in;
	undef:	xret := "undefined";
			goto rlab;

	in:		goto [v = $$null] null ib;
	null:	xret := "null";
			goto rlab;

	ib:		goto [typeOf(v) = $$boolean_type] bool inum;
	bool:	goto [v = $$t] is_t is_f;
	is_t:	xret := "true";
			goto rlab;
	is_f:	xret := "false";
			goto rlab;

	inum:	goto [typeOf(v) <: $$number_type] num is;
	num:	xret := num_to_string v;
			goto rlab;

	is:		goto [typeOf(v) = $$string_type] str io;
	str:	xret := v;
			goto rlab;

	io:		goto [typeOf(v) = $$object_type] obj oops;
	obj:	xret := "i__toPrimitive" (v, "String") with elab;
			xret := "i__toString" (xret) with elab;
			goto rlab;

	oops:	xret := "TypeError" ("ToString: This should not happen.");
            goto elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *************************
   *** O__GETOWNPROPERTY ***
   ************************* *)

spec o__getOwnProperty (l, prop)
    [[ Cell_o (l, prop, None) ]]
    [[ Cell_o (l, prop, None) * (ret == $$undefined) ]]
    normal;
    [[ Cell_o (l, prop, #dx) * DataDescriptor(#dx) ]]
    [[ Cell_o (l, prop, #dx) * DataDescriptor(#dx) * (ret == #dx) ]]
    normal

proc o__getOwnProperty (l, prop) {
	(*
		l must be an object
		prop must be a non-empty string
		prop must not be an internal property
	*)
	ch0:	goto [typeOf(l) = $$object_type] ch1 elab;
	ch1:	goto [typeOf(prop) = $$string_type] ch2 elab;
	ch2:	goto [0 < s-len prop] ch3 elab;
	ch3:	goto [not (s-nth(prop, 0) = "@")] start elab;

    start:	x := hasField(l, prop);
            goto [x] hp nhp;

    nhp:    xret := $$undefined;
            goto rlab;

    hp:     xret := [l, prop];

    rlab:   skip;

	elab:	xret := "TypeError" ("Incorrect use of [[getOwnProperty]]")
}
with
{
    ret: 	xret, rlab;
	err:	xret, elab;
};

(* *************************
   *** S__GETOWNPROPERTY ***
   ************************* *)

spec s__getOwnProperty (l, prop)
    [[ Cell_s (l, prop, "None", None, #pv) ]]
    [[ Cell_s (l, prop, "None", None, #pv) * (ret == $$undefined) ]]
   	normal;
   	(* Same comment as in o__getOwnProperty applies *)
   	[[ Cell_s (l, prop, "SI", #u, #pv) ]]
   	[[ Cell_s (l, prop, "SI", #u, #pv) * (ret == #u) ]]
   	normal;
   	[[ Cell_s (l, prop, "NSI", #u, #pv) ]]
   	[[ Cell_s (l, prop, "NSI", #u, #pv) * (ret == #u) ]]
   	normal

proc s__getOwnProperty (l, prop) {

    ch0:	goto [typeOf(l) = $$object_type] ch1 elab;
    ch1:	goto [typeOf(prop) = $$string_type] ch2 elab;
    ch2:	goto [0 < s-len prop] ch3 elab;
    ch3:	goto [not (s-nth(prop, 0) = "@")] start elab;

   	start:	xret := "o__getOwnProperty" (l, prop);
   			goto [xret = $$undefined] str rlab;

   	str:	idx := "i__toInteger" (prop) with elab;
   			goto [idx < 0] rlab next;

   	next:	sidx := "i__toString" (idx);

   			goto [sidx = prop] index rlab;

   	index:	str := [l, "@primitiveValue"];
   			len := s-len (str);
   			goto [len <= idx] rlab return;

   	return: rstr := s-nth (str, idx);
   			xret := {{ "d", rstr, $$f, $$t, $$f }};

   	rlab: 	skip;
   	elab:	skip
}
with
{
    ret: 	xret, rlab;
   	err: 	xret, elab;
};

(* **********************
   *** O__GETPROPERTY ***
   ********************** *)

spec o__getProperty (l, prop)
	[[ Pi (l, prop, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4, #gp_aux_5, #gp_aux_6) ]]
	[[ Pi (l, prop, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4, #gp_aux_5, #gp_aux_6) * (ret == #gp_aux_3) ]]
	normal

proc o__getProperty (l, prop) {

			[* unfold Pi (l, prop, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4, #gp_aux_5, #gp_aux_6) *]
    ch0:	goto [typeOf(l) = $$object_type] ch1 elab;
    ch1:	goto [typeOf(prop) = $$string_type] ch2 elab;
    ch2:	goto [0 < s-len prop] ch3 elab;
    ch3:	goto [not (s-nth(prop, 0) = "@")] start elab;

	start:  gop := [l, "@getOwnProperty"];
			xret := gop (l, prop) with elab;
			goto [xret = $$undefined] next rlab;

	next:	proto := [l, "@proto"];
			goto [proto = $$null] rlab call;

	call:	gp := [proto, "@getProperty"];
			xret := gp (proto, prop) with elab;

			[* fold Pi (l, prop, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4, #gp_aux_5, #gp_aux_6) *]
    rlab:   skip;
    elab:	skip

}
with
{
    ret: 	xret, rlab;
    err:	xret, elab;
};

(* **************
   *** O__GET ***
   ************** *)

spec o__get (l, prop)
    [[ Pi (l, prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) * (#g_aux_3 == $$undefined) ]]
    [[ Pi (l, prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) * (#g_aux_3 == $$undefined) * (ret == $$undefined) ]]
    normal;
    [[ Pi (l, prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) * DataDescriptor (#g_aux_3) ]]
    [[ Pi (l, prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) * desc_val (#g_aux_3, #desc_val) * (ret == #desc_val) ]]
    normal

proc o__get (l, prop) {

            [* unfold Pi (l, prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) *]
    ch0:	goto [typeOf(l) = $$object_type] ch1 elab;
    ch1:	goto [typeOf(prop) = $$string_type] ch2 elab;
    ch2:    goto [0 < s-len prop] ch3 elab;
    ch3:	goto [not (s-nth(prop, 0) = "@")] start elab;

	start:  gp := [l, "@getProperty"];
            [* fold Pi (l, prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) *]
		    xret := gp (l, prop) with elab;
            [* unfold Pi (l, prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) *]
			goto [xret = $$undefined] rlab def;

	def:	d := l-nth (xret, 0);
			xret := l-nth (xret, 1);
			goto [d = "d"] rlab acc;

	acc:	goto [xret = $$undefined] rlab get;
	get:	xsc := [xret, "@scope"];
			fun := [xret, "@call"];
			xret := fun (xsc, l) with elab;
			goto [xret = $$empty] undef rlab;
	undef:	xret := $$undefined;

            [* fold Pi (l, prop, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4, #g_aux_5, #g_aux_6) *]
	rlab:	skip;
	elab:	skip
}
with
{
   ret: xret, rlab;
   err: xret, elab;
};

(* *******************
   *** I__GETVALUE ***
   ******************* *)

spec i__getValue (v)
    [[ v == $$undefined ]]
    [[ ret == $$undefined ]]
    normal;
    [[ v == $$null ]]
    [[ ret == $$null ]]
    normal;
    [[ types (v : $$string_type) ]]
    [[ (ret == v) ]]
    normal;
    [[ types (v : $$int_type) ]]
	[[ (ret == v) ]]
	normal;
    [[ types (v : $$boolean_type) ]]
    [[ (ret == v) ]]
    normal;
    [[ types (v : $$string_type) ]]
    [[ (ret == v) ]]
    normal;
    [[ (v == #r) * (#r == {{ #rt, #obj, #field }}) * (#rt == "o") *
       Methods_General(#obj) * types (#obj : $$object_type, #field : $$string_type) *
       Pi (#obj, #field, #g_aux_1, #g_aux_2, $$undefined, #g_aux_4, #g_aux_5, #g_aux_6) ]]
    [[ Methods_General(#obj) * Pi (#obj, #field, #g_aux_1, #g_aux_2, $$undefined, #g_aux_4, #g_aux_5, #g_aux_6) * (ret == $$undefined) ]]
    normal

proc i__getValue (v) {
			goto [(typeOf(v) = $$list_type)] rcand dflt;

    rcand:  rtype := l-nth (v, 0);
            goto [(rtype = "v") or (rtype = "o")] init dflt;

	init:	rbase := l-nth (v, 1);
			rfield := l-nth (v, 2);
			goto [rbase = $$undefined] throw prim;


	prim:	prim := "i__isPrimitive" (rbase);
            goto [prim and (not (rbase = $$undefined)) and (not (rbase = $$null))] is_pr ref;

	is_pr:	xret := "i__toObject" (rbase) with elab;
			gp := [xret, "@getProperty"];
			xret := gp (xret, rfield) with elab;
			goto [xret = $$undefined] rlab def;
	def:	d := l-nth (xret, 0);						(* Get the descriptor type *)
			xret := l-nth (xret, 1);					(* Get the value/getter *)
			goto [d = "d"] rlab acc;				(* Is it a data descriptor? *)

	acc:	goto [xret = $$undefined] rlab get;		(* Is the getter defined? *)
	get:	xsc := [xret, "@scope"];				(* Get the scope of the getter *)
			fun := [xret, "@call"];					(* Get the name of the getter *)
			xret := fun (xsc, rbase) with elab;		(* Call the getter, errors could happen *)
			goto [xret = $$empty] undef rlab;
	undef:	xret := $$undefined;

	ref:	goto [(l-nth (v, 0) = "o")] oref vref;

	oref:	gp := [rbase, "@get"];
			xret := gp (rbase, rfield) with elab;
			goto rlab;

	vref:	goto [rbase = $lg] lg er;

	lg:		gp := [$lg, "@get"];
			xret := gp (rbase, rfield) with elab;
			goto rlab;

	er:		xret := [rbase, rfield];
			goto rlab;

	dflt:	xret := v;

	rlab:	skip;

	throw:  xret := "ReferenceError" ();
    elab:   skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};
