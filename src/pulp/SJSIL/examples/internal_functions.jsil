(* ******************
   *** PREDICATES ***
   ****************** *)

(*
 * Predicate: standardObject
 *
 * Resource: Some
 *
 *)
pred standardObject (l) :
    types (l : $$object_type) *
	((l, "@proto") -> $lobj_proto) *
	((l, "@class") -> "Object") *
	((l, "@extensible") -> $$t);

(*
 * Predicate: dataField
 *
 * Resource: Some
 *
 *)
pred dataField (l, prop, v) :
    types (l : $$object_type, prop : $$string_type) *
	((l, prop) -> {{ "d", v, $$t, $$t, $$t }});

(*
 * Predicate: isInternalProperty
 *
 * Resource: None
 *
 *)
pred isInternalProperty (prop) :
    types (prop : $$string_type) * (0 <# s-len prop) * (s-nth (prop, 0) == "@");

(*
 * Predicate: isNamedProperty
 *
 * Resource: None
 *
 *)
pred isNamedProperty (prop) :
    types (prop : $$string_type) * (0 <# s-len prop) * (! (s-nth (prop, 0) == "@"));

(*
 * Predicate: DataDescriptor
 *
 * Resource: None
 *
 *)
pred DataDescriptor (d) :
    types (d : $$list_type, #dwrit : $$boolean_type, #denum : $$boolean_type, #dconf : $$boolean_type) *
	(d == {{ "d", #dval, #dwrit, #denum, #dconf }});

(*
 * Predicate: GenericDescriptor
 *
 * Resource: None
 *
 *)
pred GenericDescriptor (d) :
    types (d : $$list_type) * (d == {{ "g", #genum, #gconf, #gval, #gwrit, #gget, #gset }});

(*
 * Predicate: Projection functions for descriptors
 *
 * Resource: None
 *
 *)
pred desc_val (d, v) :
    types (d : $$list_type) * v == l-nth(d, 1);

pred desc_writ (d, v) :
    types (d : $$list_type) * v == l-nth(d, 2);

pred desc_get (d, v) :
    types (d : $$list_type) * v == l-nth(d, 1);

pred desc_set (d, v) :
    types (d : $$list_type) * v == l-nth(d, 2);

pred desc_enum (d, v) :
    types (d : $$list_type) * v == l-nth(d, 3);

pred desc_conf (d, v) :
    types (d : $$list_type) * v == l-nth(d, 4);

(*
 * Predicate: Cell_o(l, prop, X)
 *
 * Resource:
 *      (l, prop)
 *
 * Note: We are not allowing accessor descriptors in the heap yet
 *)
pred Cell_o (l, prop, None) :
    types(l : $$object_type) * isNamedProperty(prop) * ((l, prop) -> None);

pred Cell_o (l, prop, d) :
    types(l : $$object_type) * isNamedProperty(prop) * ((l, prop) -> d) * DataDescriptor(d);

(*
 * Predicate: IsStringIndex
 *
 * Resource: None
 *
 *)
pred IsStringIndex(S, prop, i) :
    types(S : $$string_type, prop : $$string_type, i : $$int_type) *
    (prop == num_to_string i) * (!(i <# 0)) * (i <# s-len S);

(*
 * Predicate: Cell_s(l, prop, _, X, primitiveValue)
 *
 * Resource:
 *      (l, prop)               via Cell_o
 *      (l, "@primitiveValue")
 *
 * Note: Must be used with String objects,
 *       otherwise (l, "@primitiveValue") WILL NOT EXIST OR BE STUPID
 *
 *)
pred Cell_s (l, prop, "None", None, pv) :
     types (l : $$object_type, prop : $$string_type, pv : $$string_type) *
	 Cell_o (l, prop, None) * ((l, "@primitiveValue") -> pv) *
     (#i == num_to_int (string_to_num prop)) * (! IsStringIndex(pv, prop, #i));

pred Cell_s (l, prop, "SI", desc, pv) :
     types(l : $$object_type, prop : $$string_type, desc : $$list_type, pv : $$string_type, #i : $$int_type, #v : $$string_type) *
	 Cell_o (l, prop, None) * ((l, "@primitiveValue") -> pv) *
     (desc == {{ "d", #v, $$f, $$t, $$f }}) *  (#v == s-nth(pv, #i)) *
	 (#i == num_to_int (string_to_num prop)) * IsStringIndex(pv, prop, #i);

pred Cell_s (l, prop, "NSI", desc, pv) :
	 types (l : $$object_type, prop : $$string_type, desc : $$list_type, pv : $$string_type, #i : $$int_type) *
	 Cell_o (l, prop, desc) * ((l, "@primitiveValue") -> pv) *
	 (#i == num_to_int (string_to_num prop)) * (! IsStringIndex(pv, prop, #i)) *
     (! (desc == None));

(*
 * Predicate: ErrorObject(l, pr)
 *
 * Resource:
 *      (l, "@proto")	(l, "@class")	(l, "@extensible")
 *
 *)

pred ErrorObject (l, pr) :
	types (l : $$object_type, pr : $$object_type) *
	((l, "@proto") -> pr) * ((l, "@class") -> "Error") * ((l, "@extensible") -> $$t);

pred isTypeError(l) :
    ErrorObject (l, $lterr_proto);

pred isSyntaxError(l) :
    ErrorObject (l, $lserr_proto);

pred isReferenceError(l) :
    ErrorObject (l, $lrferr_proto);

(*
 * Predicate: isClass(c, X)
 *
 * Resource:
 *      (l, "@class")
 *
 *)
pred isClass (c, "Array")      : types (c : $$string_type) * (c == "Array");
pred isClass (c, "String")     : types (c : $$string_type) * (c == "String");
pred isClass (c, "Non-String") : types (c : $$string_type) * (! (c == "String"));
pred isClass (c, "Non-Array")  : types (c : $$string_type) * (! (c == "Array"));

(*
 * The PI predicate
 *)

(*
 * Resource:
 *		(l, "@class")   via isClass
 *		(l, "@proto")	(l, "prop")
 *)
pred Pi (l, prop, lcls, $$undefined, ls, ltf, lpv) :
    types(l : $$object_type, prop : $$string_type, #cls : $$string_type, lcls : $$list_type, ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
	((l, "@proto") -> $$null) * ((l, "@class") -> #cls) *
	isClass (#cls, "Non-String") * Cell_o (l, prop, None) *
    (lcls == {{ #cls }}) * (ls == {{ l }}) * (ltf == {{ $$f }}) * (lpv == {{ "" }});

(*
 * Resource:
 *		(l, "@class")   via isClass
 *		(l, "@proto")	(l, "prop")
 *)
pred Pi (l, prop, lcls, d, ls, ltf, lpv) :
    types(l : $$object_type, prop : $$string_type, #cls : $$string_type, lcls : $$list_type, d : $$list_type, ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
	((l, "@class") -> #cls) *
	isClass (#cls, "Non-String") * Cell_o (l, prop, d) * (! (d == None)) *
    (lcls == {{ #cls }}) * (ls == {{ l }}) * (ltf == {{ $$f }}) * (lpv == {{ "" }});

(*
 * Resource:
 *		(l, "@class")   via isClass
 *		(l, "@proto")	(l, "prop")		(l, "@primitiveValue")
 *)
pred Pi (l, prop, lcls, $$undefined, ls, ltf, lpv) :
    types(l : $$object_type, prop : $$string_type, #cls : $$string_type, lcls : $$list_type, ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
	((l, "@proto") -> $$null) * ((l, "@class") -> #cls) *
    isClass (#cls, "String") * Cell_s (l, prop, "None", None, #pv) *
    (lcls == {{ #cls }}) * (ls == {{ l }}) * (ltf == {{ $$t }}) * (lpv == {{ #pv }});

(*
 * Resource:
 *		(l, "@class")   via isClass
 *		(l, "@proto")	(l, "prop")		(l, "@primitiveValue")
 *)
pred Pi (l, prop, lcls, d, ls, ltf, lpv) :
    types(l : $$object_type, prop : $$string_type, #cls : $$string_type, lcls : $$list_type, d : $$list_type, ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
	((l, "@class") -> #cls) *
	isClass (#cls, "String") * Cell_s (l, prop, "SI", d, #pv) *
	(lcls == {{ #cls }}) * (ls == {{ l }}) * (ltf == {{ $$t }}) * (lpv == {{ #pv }});

(*
 * Resource:
 *		(l, "@class")   via isClass
 *		(l, "@proto")	(l, "prop")		(l, "@primitiveValue")
 *)
pred Pi (l, prop, lcls, d, ls, ltf, lpv) :
    types(l : $$object_type, prop : $$string_type, #cls : $$string_type, lcls : $$list_type, d : $$list_type, ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
	((l, "@class") -> #cls) *
	isClass (#cls, "String") * Cell_s (l, prop, "NSI", d, #pv) *
    (lcls == {{ #cls }}) * (ls == {{ l }}) * (ltf == {{ $$t }}) * (lpv == {{ #pv }});

(*
 * Resource:
 *		(l, "@class")   via isClass
 *		(l, "@proto")	(l, "prop")		(l, "@primitiveValue")
 *
 *		Those five fields captured throughout the chain
 *)
pred Pi (l, prop, lcls, d, ls, ltf, lpv) :
    types(l : $$object_type, prop : $$string_type, lcls : $$list_type, ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
	types(#lp : $$object_type, #cls : $$string_type, #pcls : $$list_type, #lsp : $$list_type, #ltfp : $$list_type, #lpvp : $$list_type) *
	((l, "@class") -> #cls) * ((l, "@proto") -> #lp) * (! (#lp == $$null)) *
	isClass (#cls, "Non-String") * Cell_o (l, prop, None) *
    Pi (#lp, prop, #pcls, d, #lsp, #ltfp, #lpvp) *
	(lcls == #cls :: #pcls) * (ls == l :: #lsp) * (ltf == $$f :: #ltfp) * (lpv == "" :: #lpvp) *
    (0 <# l-len #lsp) * (0 <# l-len #ltfp) * (0 <# l-len #lpvp);

(*
 * Resource:
 *		(l, "@class")   via isClass
 *		(l, "@proto")	(l, "prop")		(l, "@primitiveValue")
 *
 *		Those five fields captured throughout the chain
 *)
pred Pi (l, prop, lcls, d, ls, ltf, lpv) :
    types(l : $$object_type, prop : $$string_type, lcls : $$list_type, ls : $$list_type, ltf : $$list_type, lpv : $$list_type) *
	types(#lp : $$object_type, #cls : $$string_type, #pcls : $$list_type, #lsp : $$list_type, #ltfp : $$list_type, #lpvp : $$list_type) *
	((l, "@class") -> #cls) * ((l, "@proto") -> #lp) * (! (#lp == $$null)) *
	isClass (#cls, "String") * Cell_s (l, prop, "None", None, #pv) *
    Pi (#lp, prop, #pcls, d, #lsp, #ltfp, #lpvp) *
	(lcls == #cls :: #pcls) * (ls == l :: #lsp) * (ltf == $$t :: #ltfp) * (lpv == #pv :: #lpvp) *
    (0 <# l-len #lsp) * (0 <# l-len #ltfp) * (0 <# l-len #lpvp);

(* *************
 * COPY_OBJECT *
 ***************)

spec copy_object (l, fields)

	[[ (l == #l) * (fields == #fields) *
	   (#fields == {{ #f }}) * isNamedProperty(#f) *
	   ((#l, #f) -> #v) * isNamedProperty (#f) ]]
	[[ ((#l, #f) -> #v) * ((ret, #f) -> #v) * ((ret, "@proto") -> $$null) ]]
	normal;

	[[ (l == #l) * (fields == #fields) *
	   (#fields == {{ #f1, "main" }}) * isNamedProperty(#f1) *
	   ((#l, #f1) -> #v1) * ((#l, "main") -> #v2) ]]
	[[ ((#l, #f1) -> #v1) * ((#l, "main") -> #v2) *
	   ((ret, #f1) -> #v1) * ((ret, "main") -> #v2) * ((ret, "@proto") -> $$null) ]]
	normal

proc copy_object (l, fields) {
			xret := new ();

	rlab:	xret := "copy_object_rec" (l, fields, xret)
}
with
{
	ret:	xret, rlab;
};

spec copy_object_rec (lf, fields, lt)

	[[ fields == {{ }} ]]
	[[ true * (ret == #lt) ]]
	normal;

	[[ (lf == #lf) * (fields == #fields) * (lt == #lt) *
	   (#fields == {{ #f }}) *
	   ((#lf, #f) -> #v) * ((#lt, #f) -> None) ]]
	[[ ((#lf, #f) -> #v) * ((#lt, #f) -> #v) * (ret == #lt) ]]
	normal;

	[[ (lf == #lf) * (fields == #fields) * (lt == #lt) *
	   (#fields == {{ #f1, "main" }}) * isNamedProperty(#f1) *
	   ((#lf, #f1) -> #v1)  * ((#lf, "main") -> #v2) *
	   ((#lt, #f1) -> None) * ((#lt, "main") -> None) ]]
	[[ ((#lf, #f1) -> #v1)  * ((#lf, "main") -> #v2) *
	   ((#lt, #f1) -> #v1)  * ((#lt, "main") -> #v2) * (ret == #lt) ]]
	normal

proc copy_object_rec (lf, fields, lt) {
			goto [fields = {{ }}] rlab next;

	next:	head := l-nth (fields, 0);
			tail := cdr fields;

			val := [lf, head];
			[lt, head] := val;

			xret := "copy_object_rec" (lf, tail, lt);

	rlab:	xret := lt
}
with
{
	ret:	xret, rlab;
};


(* ***********************
 * CREATE_DEFAULT_OBJECT *
 *************************)

spec create_default_object (l, pr, cl, ext)

    [[ (l == #l) * (pr == #pr) * (cl == #cl) * (ext == #ext) *
	   types(#l : $$object_type) * (#cl == $$undefined) * (#ext == $$undefined) *
	   ((#l, "@proto") -> #v1) * ((#l, "@class") -> #v2) * ((#l, "@extensible") -> #v3) ]]
    [[ ((#l, "@proto") -> #pr) * ((#l, "@class") -> "Object") * ((#l, "@extensible") -> $$t) *
	   (ret == #l) ]]
    normal;

    [[ (l == #l) * (pr == #pr) * (cl == #cl) * (ext == #ext) *
	   types(#l : $$object_type, #cl : $$string_type) * (ext == $$undefined) *
	   ((#l, "@proto") -> #v1) * ((#l, "@class") -> #v2) * ((#l, "@extensible") -> #v3) ]]
    [[ ((#l, "@proto") -> #pr) * ((#l, "@class") -> #cl) * ((#l, "@extensible") -> $$t) *
	   (ret == #l) ]]
    normal;

    [[ (l == #l) * (pr == #pr) * (cl == #cl) * (ext == #ext) *
	   types(#l : $$object_type, #ext : $$boolean_type) * (#cl == $$undefined) *
	   ((#l, "@proto") -> #v1) * ((#l, "@class") -> #v2) * ((#l, "@extensible") -> #v3) ]]
    [[ ((#l, "@proto") -> #pr) * ((#l, "@class") -> "Object") * ((#l, "@extensible") -> #ext) *
	   (ret == #l) ]]
    normal;

    [[ (l == #l) * (pr == #pr) * (cl == #cl) * (ext == #ext) *
	   types(#l : $$object_type, #cl : $$string_type, #ext : $$boolean_type) *
       ((#l, "@proto") -> #v1) * ((#l, "@class") -> #v2) * ((#l, "@extensible") -> #v3) ]]
    [[ ((#l, "@proto") -> #pr) * ((#l, "@class") -> #cl) * ((#l, "@extensible") -> #ext) *
	   (ret == #l) ]]
    normal

proc create_default_object (l, pr, cl, ext) {

 			goto [cl = $$undefined] scl text;
 	scl:	cl := "Object";
 	text:	goto [ext = $$undefined] sext setall;
 	sext:	ext := $$t;

 	setall:	[l, "@proto"] := pr;
 			[l, "@class"] := cl;
 			[l, "@extensible"] := ext;

 	rlab:	xret := l
}
with
{
	ret:	xret, rlab;
};

(* ****** *)
(* ERRORS *)
(* ****** *)

spec Error_construct (xsc, vthis, v)

    (* Error constructor without message *)
    [[ (v == $$undefined) * (vthis == #vthis) *
	   types (#vthis : $$object_type) *
       ((#vthis, "@class") -> #cls) * ((#vthis, "@extensible") -> #ext) ]]
    [[ (ret == #vthis) * ((#vthis, "@class") -> "Error") * ((#vthis, "@extensible") -> $$t) ]]
    normal

proc Error_construct (xsc, vthis, v) {
			xret := vthis;

			[vthis, "@class"] := "Error";
			[vthis, "@extensible"] := $$t;

			goto [v = $$undefined] rlab mess;

	mess:	xerr := "i__toString" (v) with elab;
			[xret, "message"] := {{ "d", xerr, $$t, $$f, $$t }};

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xerr, elab;
};

(* ********* *)
(* TYPEERROR *)
(* ********* *)

spec TypeError_call (xsc, vthis, v)

    [[ (v == $$undefined) ]]
    [[ isTypeError(ret) ]]
    normal

proc TypeError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lterr_proto, "Error", $$t);

			xret := "Error_construct" ($$undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec TypeError (v)

    [[ (v == $$undefined) ]]
    [[ isTypeError(ret) ]]
    normal

proc TypeError (v) {
			xret := "TypeError_call" ($$undefined, $$undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* ************** *)
(* REFERENCEERROR *)
(* ************** *)

spec ReferenceError_call (xsc, vthis, v)

    [[ (v == $$undefined) ]]
    [[ isReferenceError(ret) ]]
    normal

proc ReferenceError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lrferr_proto, "Error", $$t);

			xret := "Error_construct" ($$undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec ReferenceError (v)

    [[ (v == $$undefined) ]]
    [[ isReferenceError(ret) ]]
    normal

proc ReferenceError (v) {
			xret := "ReferenceError_call" ($$undefined, $$undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *********** *)
(* SYNTAXERROR *)
(* *********** *)

spec SyntaxError_call (xsc, vthis, v)

    [[ (v == $$undefined) ]]
    [[ isSyntaxError(ret) ]]
    normal

proc SyntaxError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lserr_proto, "Error", $$t);

			xret := "Error_construct" ($$undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec SyntaxError (v)

    [[ (v == $$undefined) ]]
    [[ isSyntaxError(ret) ]]
    normal

proc SyntaxError (v) {
			xret := "SyntaxError_call" ($$undefined, $$undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* ****************************************
   *** *** ***   INITIAL HEAP   *** *** ***
   **************************************** *)

pred initialHeapPre () :
    empty_fields( $lg : ) * empty_fields ( $lobj_proto : );

pred initialHeapPost () :
    (($lg,         "@class") -> "Object") * (($lg,         "@proto") -> $lobj_proto) * (($lg,         "@extensible") -> $$t) *
	(($lobj_proto, "@class") -> "Object") * (($lobj_proto, "@proto") -> $$null)      * (($lobj_proto, "@extensible") -> $$t);

spec setupInitialHeap ()

	[[ initialHeapPre() ]]
	[[ initialHeapPost() * (ret == $$empty) ]]
	normal

proc setupInitialHeap () {

			(* Global object *)

			xret := "create_default_object" ($lg, $lobj_proto, "Object", $$t);

			(* Object.prototype *)

			xret := "create_default_object" ($lobj_proto, $$null, "Object", $$t);

	rlab:	xret := $$empty
}
with
{
	ret:	xret, rlab;
};
