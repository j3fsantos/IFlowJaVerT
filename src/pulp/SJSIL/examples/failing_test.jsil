(******************* TYPE CONVERSION *******************)

spec i__toNumber (v)
	[[ types(v : $$string_type, #v : $$string_type) * (v == #v) ]]
	[[ types(#v : $$string_type, ret : $$number_type) * (ret == (string_to_num #v)) ]]
	normal
proc i__toNumber (v) {
	iu:		goto [v = $$undefined] undef in;
	undef:	xret := nan;
			goto rlab;
	
	in:		goto [v = $$null] null ib;
	null:	xret := 0;
			goto rlab;
			
	ib:		goto [typeOf(v) = $$boolean_type] bool inum;
	bool:	goto [v = $$t] is_t is_f;
	is_t:	xret := 1;
			goto rlab;
	is_f:	xret := 0;
			goto rlab;
			
	inum:	goto [typeOf(v) = $$number_type] num is;
	num:	xret := v;
			goto rlab;
			
	is:		goto [typeOf(v) = $$string_type] str io;
	str:	xret := string_to_num v;
			goto rlab;
			
	io:		goto [typeOf(v) = $$object_type] obj oops;
	obj:	xret := "i__toPrimitive" (v, "Number") with elab;
			xret := "i__toNumber" (xret);
			goto rlab;
	
	oops:	xret := "ToNumber: This should not happen.";
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};


spec i__toInteger (v)
	[[ types(v : $$string_type, #v : $$string_type) * (v == #v) ]]
	[[ types(v : $$string_type, #v : $$string_type, ret : $$int_type) * (ret == num_to_int (string_to_num #v)) ]]
	normal
proc i__toInteger (v) {
			xret := "i__toNumber" (v) with elab;
			xret := num_to_int (xret);

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};



spec i__toString (v)
	[[ types(v : $$int_type, #v : $$int_type) * (v == #v) ]]
	[[ types(ret : $$string_type, #v : $$int_type) * (ret == (num_to_string #v)) ]]
	normal
proc i__toString (v) {
	iu:		goto [v = $$undefined] undef in;
	undef:	xret := "undefined";
			goto rlab;
	
	in:		goto [v = $$null] null ib;
	null:	xret := "null";
			goto rlab;
			
	ib:		goto [typeOf(v) = $$boolean_type] bool inum;
	bool:	goto [v = $$t] is_t is_f;
	is_t:	xret := "true";
			goto rlab;
	is_f:	xret := "false";
			goto rlab;
			
	inum:	goto [typeOf(v) <: $$number_type] num is;
	num:	xret := num_to_string v;
			goto rlab;
			
	is:		goto [typeOf(v) = $$string_type] str io;
	str:	xret := v;
			goto rlab;
			
	io:		goto [typeOf(v) = $$object_type] obj oops;
	obj:	xret := "i__toPrimitive" (v, "String") with elab;
			xret := "i__toString" (xret) with elab;
			goto rlab;
	
	oops:	xret := "ToString: This should not happen.";
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};


(******************* GETOWNPROPERTY *******************)

pred Cell_o (l, prop, v) :
	types(l : $$object_type, prop : $$string_type) * ((l, prop) -> v);  	

spec o__getOwnProperty (l, prop)
	[[ Cell_o (l, prop, None) ]]
	[[ Cell_o (l, prop, None) * (ret == $$undefined) ]]
	normal;
	(* Note: we need (!(#d == None)), in my report it's not there cos we know it from the type of #d *)
	[[ Cell_o (l, prop, #d) * types(#d : $$list_type) ]]
	[[ Cell_o (l, prop, #d) * types(#d : $$list_type) * (ret == #d) ]]
	normal
proc o__getOwnProperty (l, prop) {
            x := hasField(l, prop);		
            goto [x] hp nhp; 			(* Does the field exist? *)
            
    nhp:    xret := $$undefined;		(* Field doesn't exist; return undefined *)
            goto rlab;					
            
    hp:     xret := [l, prop];			(* Field exists; return the descriptor *)
    
    rlab:   skip
}
with
{
    ret: 	xret, rlab;
};


pred IsStringIndex(S, prop, i) :
	types(S : $$string_type, prop : $$string_type, i : $$int_type)
	* (prop == num_to_string i) * (!(i <# 0)) * (i <# s-len S);

(*   (! (v == None)) *)
pred Cell_s (l, prop, 0, None) :
	Cell_o (l, prop, None) * ((l, "@primitiveValue") -> #S) * (#i == num_to_int (string_to_num prop)) * (! IsStringIndex(#S, prop, #i));
pred Cell_s (l, prop, 1, v) :
	Cell_o (l, prop, None) * ((l, "@primitiveValue") -> #S) * (#i == num_to_int (string_to_num prop)) * IsStringIndex(#S, prop, #i) * (v == s-nth(#S, #i)) * types(v : $$string_type); 
pred Cell_s (l, prop, 2, v) :	
	Cell_o (l, prop, v) * (!(v == None));

spec s__getOwnProperty (l, prop)
	[[ Cell_s (l, prop, 0, None) ]]
	[[ Cell_s (l, prop, 0, None) * (ret == $$undefined) ]]
	normal;
	(* Same comment as in o__getOwnProperty applies *)
	[[ Cell_s (l, prop, 1, #u) ]]
	[[ Cell_s (l, prop, 1, #u) * (ret == {{ "d", #u, $$f, $$t, $$f }}) * types(ret : $$list_type) ]]
	normal; 
	[[ Cell_s (l, prop, 2, #u) ]]
	[[ Cell_s (l, prop, 2, #u) * (ret == #u) * types(#u : $$list_type) ]]
	normal
proc s__getOwnProperty (l, prop) {
			xret := "o__getOwnProperty" (l, prop);
			goto [xret = $$undefined] str rlab;
			
	str:	idx := "i__toInteger" (prop) with elab;
			goto [idx < 0] rlab next;
			
	next:	sidx := "i__toString" (idx);
	
			goto [sidx = prop] index rlab;
	
	index:	str := [l, "@primitiveValue"];
			len := s-len (str);
			goto [len <= idx] rlab return;
			
	return: rstr := s-nth (str, idx);
			xret := {{ "d", rstr, $$f, $$t, $$f }};
	
	rlab: 	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};


(******************* GETPROPERTY *******************)

pred CommonMethods (l) :
	((l, "@getProperty") -> "o__getProperty");

pred SpecificMethods_o (l) :
	((l, "@getOwnProperty") -> "o__getOwnProperty");
pred SpecificMethods_s (l) :
	((l, "@getOwnProperty") -> "s__getOwnProperty");

pred Class (l, "o") : ((l, "@class") -> #c) * (!(#c == "String")) * SpecificMethods_o (l);
pred Class (l, "s") : ((l, "@class") -> "String") * SpecificMethods_s (l);


pred Pi (l, prop, "base", "o", $$undefined) :
	Class (l, "o") * Cell_o (l, prop, None) * ((l, "@proto") -> $$null); 
pred Pi (l, prop, "base", "s", $$undefined) : 
	Class (l, "s") * Cell_s (l, prop, 0, None) * ((l, "@proto") -> $$null);
pred Pi (l, prop, "base", "o", d) :
	Class (l, "o") * Cell_o (l, prop, #d) * (! (#d == $$undefined)) * types(#d : $$list_type) * (d == #d); 
pred Pi (l, prop, "base", "s1", d) : 
	Class (l, "s") * Cell_s (l, prop, 1, #u) * types(#u : $$string_type) * (d == {{"d", #u, $$f, $$t, $$f}}); 
pred Pi (l, prop, "base", "s2", d) : 
	Class (l, "s") * Cell_s (l, prop, 2, #d) * types(#d : $$list_type) * (d == #d);
pred Pi (l, prop, "inductive", "o", d) : 
	Class (l, "o") * Cell_o (l, prop, None) * ((l, "@proto") -> #lp)  * (!(#lp == $$null)) * CommonMethods(#lp) * (d == #d) * Pi(#lp, prop, #caseType, #class, #d);
pred Pi (l, prop, "inductive", "s", d) : 
	Class (l, "s") * Cell_s (l, prop, 0, None) * ((l, "@proto") -> #lp)  * (!(#lp == $$null)) * CommonMethods(#lp) * (d == #d) * Pi(#lp, prop, #caseType, #class, #d);  


spec o__getProperty (l, prop)
	[[ Pi (l, prop, #banana1, #banana2, #banana3) ]]
	[[ Pi (l, prop, #banana1, #banana2, #banana3) * (ret == #banana3) ]]
	normal
proc o__getProperty (l, prop) {
			skip;
			[* unfold Pi (l, prop, #banana1, #banana2, #banana3) *]
			gop := [l, "@getOwnProperty"];
			xret := gop (l, prop) with elab;
			goto [xret = $$undefined] next rlab;
			
	next:	proto := [l, "@proto"];
			goto [proto = $$null] rlab call;
			
	call:	gp := [proto, "@getProperty"];
			xret := gp (proto, prop) with elab;
			[* fold Pi (l, prop, #banana1, #banana2, #banana3) *]
    rlab:   skip;
    elab:	skip
}
with 
{
    ret: 	xret, rlab;
    err:	xret, elab;
};