(** Totals: 0 fails and 2 passes **)

(** Tested feature: field assignment 1               **)
(** Expected result: YES                             **)
spec test0 (x)
   [[ (x == {{ #y, 2, 3, 1 }}) * (#y == 1) * types(#y: $$int_type)  ]]
   [[  (x == #z) * (#z == {{ 4, 2, 3, 1 }}) * types(x: $$list_type, #z: $$list_type) ]]
   normal
proc test0 (x) {
		   x := {{ 4, l-nth(x, 1) , 3, 1 }};
   rlab:   skip
} with { ret: x, rlab; };


pred my_list (x, alpha, size) : 
	(x == #x) * (#x == $$null) * (alpha == #alpha) * (#alpha == {{ }}) * (size == #size) * 
		(#size == 0) * types(#alpha: $$list_type, #size: $$int_type), 
		
	((x, "value") -> #y) * ((x, "next") -> #z) * ((x, "@proto") -> $$null) * (alpha == #alpha) *  
		(#alpha == (#y :: #beta)) * my_list(#z, #beta, #size_beta) * (size == #size) * (#size == (#size_beta + 1)) * 
		types(#y: $$int_type, #alpha: $$list_type, #beta: $$list_type, #size: $$int_type, #size_beta: $$int_type);


(** Expected result: YES                             **)
spec list_count (x)
   [[ (x == #x) * my_list(#x, #alpha, #size) * types(#size: $$int_type, #alpha: $$list_type) ]]
   [[ my_list(#x, #alpha, #size) * types(#size: $$int_type) * (ret == #size) ]]
   normal
proc list_count (x) {
		   [* unfold(my_list(x, #alpha, #size)) *]
		   goto [ x = $$null ] then else;
   then:   count := 0; 
           goto rlab;   
   else:   z := [x, "next"];
   		   (* [x, "value"] := 3; *)
           count := "list_count"(z);
           count := count + 1;  
           [* fold(my_list(x, #alpha, #size)) *]
   rlab:   skip
} with { ret: count, rlab; };






