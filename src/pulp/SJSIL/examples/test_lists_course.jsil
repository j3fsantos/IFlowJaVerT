(** Totals: 0 fails and 2 passes **)

pred my_list (x, alpha) : 
	(x == $$null) * (alpha == {{ }}) * types(alpha: $$list_type), 
		
	((x, "value") -> #y) * ((x, "next") -> #z) * ((x, "@proto") -> $$null) *  
		(alpha == (#y :: #beta)) * my_list(#z, #beta) * 
		types(#y: $$int_type, alpha: $$list_type, #beta: $$list_type);


(** Expected result: YES                             **)
spec list_count (x)
   [[ my_list(x, #alpha) * types(#alpha: $$list_type) ]]
   [[ my_list(x, #alpha) * types(#alpha: $$list_type, ret: $$int_type) * (ret == l-len(#alpha)) ]]
   normal
proc list_count (x) {
		   [* unfold(my_list(x, #alpha)) *]
		   goto [ x = $$null ] then else;
   then:   count := 0; 
           goto rlab;   
   else:   z := [x, "next"];
   		   count := "list_count"(z);
           count := count + 1;  
           [* fold(my_list(x, #alpha)) *]
   rlab:   skip
} with { ret: count, rlab; };



(** Expected result: YES                             **)
spec list_rec_unfold_1 (x)
   [[ my_list(x, {{1, 2}}) ]]
   [[ my_list(#y, {{2}}) ]]
   normal
proc list_rec_unfold_1 (x) {
		   [* unfold* my_list *]
		   y := [x, "next"]; 
		   delete(x, "value"); 
		   delete(x, "@proto"); 
		   delete(x, "next"); 
		   [* fold(my_list(y, #alpha)) *]
   rlab:   skip
} with { ret: y, rlab; };




