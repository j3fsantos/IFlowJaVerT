import Internals, Object;

(* *** DEFAULT *** *)

proc FP_default () {
			xret := $$undefined;
			
	rlab:	skip
}
with
{
	ret: 	xret, rlab;
};

(* *** CONSTRUCT *** *)

proc Function_call () {
			xret := "Function_construct" ("args") with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};

(* *** CALL *** *)

proc FP_call () {
					
			arguments := args;
			len := length (arguments);
			vthis  := nth (arguments, 1); 
			
			xret := "i__isCallable" (vthis);
			goto [xret] this te;
	
	this:	xthis := $$undefined;
			goto [len < 3] params sthis;
	sthis:	xthis := nth (arguments, 2);
	
	params:	pars := {{ }};
			goto [3 < len] spar body;
	spar:	pars := cdr (cdr (cdr arguments));	
		
	body:	body   := [vthis, "@call"]; 
			xscope := [vthis, "@scope"]; 
			
			xret := apply (body, xscope, xthis, pars) with elab;
			
			goto [xret = $$empty] undef rlab;
	
	undef:	xret := $$undefined;
			goto rlab;
	
	te:		xret := "TypeError" ();
			goto elab;	

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};

(* *** APPLY *** *)

proc FP_apply (xsc, vthis, this_arg, arg_array) {

			xsc := xsc;
			vthis := vthis;
			this_arg := this_arg;
			arg_array := arg_array;
			
			params := {{ }};
			
			xret := "i__isCallable" (vthis);
			goto [xret] array te;
	
	array:	goto [(arg_array = $$null) or (arg_array = $$undefined)] call obj;
			
	isobj:	goto [typeOf (arg_array) = $$object_type] obj te;
	
	obj:	g := [arg_array, "@get"];
			xret := g (arg_array, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;
			index := 0;
	
	loop:	goto [index < len] head call;
	
	head:	xret := "i__toString" (index) with elab;
			xret := g (arg_array, xret) with elab;
			params :=  params ++ {{ xret }};
			index := index + 1;
			goto loop;
			
	call:	xthis := this_arg;
			body   := [vthis, "@call"]; 
			xscope := [vthis, "@scope"];
			
			new_args := xscope :: xthis :: params;
			
			xret := apply (body, new_args) with elab;
			goto rlab;
	
	te:		xret := "TypeError" ();
			goto elab;	

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};



(* *** TOSTRING *** *)

proc FP_toString (xsc, vthis) {			
			goto [typeOf (vthis) = $$object_type] ofun throw;
	ofun:	xret := [vthis, "@class"];
			goto [xret = "Function"] retfun throw;
	retfun:	xret := "function () {}";
			
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* *** HASINSTANCE AFTER BIND *** *)

proc FP_hasInstanceAfterBind (v1, v2) {

			target := [v1, "@targetFunction"];
			
			hi := [target, "@hasInstance"];
			goto [hi = $$empty] throw cont;
			
	cont:	xret := "i__hasInstance" (target, v2);

	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* *** BIND *** *)

proc FP_bind (xsc, vthis, thisArg) {

			arguments := args;

			(* Is the this callable? *)
			Target := vthis;
			xret := "i__isCallable" (Target);
			goto [xret] cont1 throw;
			
	cont1:	A := {{ }};
			goto [(length arguments) < 4] cont2 setarg;
	setarg:	A := cdr (cdr (cdr arguments));
	
	cont2:	xret := new ();
			xret := "create_default_object" (xret, $lfun_proto, "Function", $$t);
			F := xret;
			
			(* Set up properties *)
			[F, "@get"] := "f__get";
			[F, "@targetFunction"] := Target;
			[F, "@boundThis"] := thisArg;
			[F, "@boundArguments"] := A;
			
			(* Adapting for our call *)
			field_call := [Target, "@call"];
			[F, "@call"] := field_call;
			
			(* Adapting for our construct *)
			field_constr := [Target, "@construct"];
			[F, "@construct"] := field_constr;
			
			[F, "@hasInstance"] := "FP_hasInstance_after_bind";
			
			(* Step 15 onward *)
			targetClass := [Target, "@class"];
			goto [targetClass = "Function"] fun nofun;
	
	fun:	g := [Target, "@get"];
			xret := g (Target, "length") with elab;
			L := xret - (length A);
			xret := "M_max" ($$empty, $$empty, L, 0);
			[F, "length"] := {{ "d", xret, $$f, $$f, $$f }};
			goto tterr;

	nofun:	[F, "length"] := {{ "d", 0, $$f, $$f, $$f }};
	
	tterr:	[F, "caller"]    := {{ "a", $lthrow_type_error, $lthrow_type_error, $$f, $$f }};
			[F, "arguments"] := {{ "a", $lthrow_type_error, $lthrow_type_error, $$f, $$f }};
	
	rlab:	xret := F;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
}