import Internals, Init;

(* ***************** *) 
(* THE ERROR LIBRARY *)
(* ***************** *) 

proc Error_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lerr_proto, "Error", $$t);
			
			xret := "Error_construct" ($$empty, xret, v) with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

proc Error_construct (xsc, vthis, v) {			
			xret := vthis;
			
			[vthis, "@class"] := "Error";
			[vthis, "@extensible] := $$t;
			
			goto [v = $$empty] rlab mess;
			
	mess:	xerr := "i__toString" (v) with elab;
			[xret, "message"] := xerr;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xerr, elab;
}

proc Error (v) {
			xret := "Error_call" ($$empty, $$undefined, v) with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};


(* *** TOSTRING *** *)

proc EP_toString(xsc, vthis) {
			goto [typeOf(vthis) = $$object_type] init throw;
			
	init:	g := [vthis, "@get"];
			
			name := "";
			xret := g (vthis, "name") with elab;
			goto [xret = $$undefined] msg ndef;
		
	ndef:	xret := "i__toString" (xret) with elab;
			name := xret;
			
	msg:	msg := "";
			xret := g (vthis, "message") with elab;
			goto [xret = $$undefined] ccat mdef;

	mdef:	xret := "i__toString" (xret) with elab;
			msg := xret;
			
	ccat:	goto [name = ""] nemp cmsg;
			
	nemp:	xret := msg;
			goto rlab;
	
	cmsg:	goto [msg = ""] memp cc;
	
	memp:	xret := name;
			goto rlab;
			
	cc:		xret := name :: ": " :: msg;

	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* ***************** *) 
(* THE NATIVE ERRORS *)
(* ***************** *) 

(* *** EVALERROR *** *)

proc EvalError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $leerr_proto, "Error", $$t);
			
			xret := "Error_construct" ($$empty, xret, v) with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

proc EvalError (v) {
			xret := "EvalError_call" ($$empty, $$undefined, v) with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** RANGEERROR *** *)

proc RangeError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lrgerr_proto, "Error", $$t);
			
			xret := "Error_construct" ($$empty, xret, v) with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

proc RangeError (v) {
			xret := "RangeError_call" ($$empty, $$undefined, v) with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** REFERENCEERROR *** *)

proc ReferenceError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lrferr_proto, "Error", $$t);
			
			xret := "Error_construct" ($$empty, xret, v) with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

proc ReferenceError (v) {
			xret := "ReferenceError_call" ($$empty, $$undefined, v) with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** SYNTAXERROR *** *)

proc SyntaxError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lserr_proto, "Error", $$t);
			
			xret := "Error_construct" ($$empty, xret, v) with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

proc SyntaxError (v) {
			xret := "SyntaxError_call" ($$empty, $$undefined, v) with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** TYPEERROR *** *)

proc TypeError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lterr_proto, "Error", $$t);
			
			xret := "Error_construct" ($$empty, xret, v) with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

proc TypeError (v) {
			xret := "TypeError_call" ($$empty, $$undefined, v) with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};



(* *** URIERROR *** *)

proc URIError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $luerr_proto, "Error", $$t);
			
			xret := "Error_construct" ($$empty, xret, v) with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

proc URIError (v) {
			xret := "URIError_call" ($$empty, $$undefined, v) with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};