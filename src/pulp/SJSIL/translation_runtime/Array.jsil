import Internals;

(* ***************** *) 
(* THE ARRAY LIBRARY *)
(* ***************** *) 

(* *** CONSTRUCT *** *)

proc Array_call () {
			xret := "Array_construct" ("args") with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};

proc Array_construct () {

			la := args;
			len := length (la);
			
			xret := new ();
			xret := "create_default_object" (xret, $larr_proto, "Array", $$t);
			
			[xret, "@defineOwnProperty"] := "a__defineOwnProperty";
			[xret, "length"] := {{ "d", 0, $$t, $$t, $$t }};
			array := xret;
			
			goto [len < 3] rtrn ltest;
			
	ltest:	goto [len = 3] len3 other;
	
	len3:	len := nth (la, 2);
			goto [typeOf(len) = $$number_type] len0 setl;
	len0:	xret := "i__toUint32" (len) with elab;
			goto [len = xret] dop re;
	dop:	prop := "length";
			goto set;
			
	setl:	prop := "0";
	set:	xret := "a__defineOwnProperty" (array, prop, {{ "d", len, $$t, $$t, $$t }}, $$t) with elab; 
			goto rtrn;
	
	other:	n := 2;
	loop:	goto [n < len] head rtrn;
	head:	prop := "i__toString" (n - 2) with elab;
			xret := "a__defineOwnProperty" (array, prop, {{ "d", nth (la, n), $$t, $$t, $$t }}, $$t) with elab; 
			n := n + 1;
			goto loop;
			
	rtrn:	xret := array;
	rlab:	skip;
	
	re:		xret := "RangeError" ();
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};

(* *** ISIDX *** *)

proc a__isIdx (s) {
			xret := "i__toUint32" (s) with elab;
			xret := "i__toString" (xret) with elab;
			
			goto [xret = s] check ret_f;
	
	check:	xret := not (xret = "4294967295");
			goto rlab;
			
	ret_f:	xret := $$f;
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** DEFINEOWNPROPERTY *** *)

proc a__defineOwnProperty (l, prop, desc, throw) {

			gop := [l, "@getOwnProperty"];
			oldLenDesc := gop (l, "length");
			oldLen := nth (oldLenDesc, 1);
			xret := "i__toUint32" (oldLen) with elab;
			oldLenNum := xret;
			
			goto [prop = "length"] getall is_idx;
			
	is_idx:	idxp := "a__isIdx" (prop);
			goto [idxp] idx norm;
			
	idx:	index := "i__toUint32" (prop);
			index := index;
			oldLen := oldLen;
			xret := nth (oldLenDesc, 2);
			goto [(not (index < oldLenNum)) and (not (nth (oldLenDesc, 2)))] reject idop;
	idop:	xret := "o__defineOwnProperty" (l, prop, desc, $$f) with elab;
			goto [xret = $$f] reject ilen;
	ilen:	goto [not (index < oldLenNum)] setl rlab;
	setl:	xret := "o__defineOwnProperty" (l, "length", {{ "d", (index + 1), nth (oldLenDesc, 2), nth (oldLenDesc, 3), nth (oldLenDesc, 4) }}, $$f);
			goto rlab;
			
	norm:	xret := "o__defineOwnProperty" (l, prop, desc, throw) with elab;
			goto rlab;
	
	getall:	goto [nth (desc, 0) = "d"] ddd odd;
	
			(* Data *)
	ddd:	de := nth (desc, 3);
			dc := nth (desc, 4);
			dv := nth (desc, 1);
			dw := nth (desc, 2);
			dg := $$empty;
			ds := $$empty;
			goto sla;
			
	odd:	goto [nth (desc, 0) = "a"] add gdd;

			(* Accessor *)
	add:	de := nth (desc, 3);
			dc := nth (desc, 4);
			dv := $$empty;
			dw := $$empty;
			dg := nth (desc, 1);
			ds := nth (desc, 2);
			goto sla;
			
			(* Generic *)
	gdd:	de := nth (desc, 1);
			dc := nth (desc, 2);
			dv := nth (desc, 3);
			dw := nth (desc, 4);
			dg := nth (desc, 5);
			ds := nth (desc, 6);
	
	sla:	goto [dv = $$empty] slai slb;
	
	slai:	xret := "o__defineOwnProperty" (l, "length", desc, throw) with elab;
			goto rlab;
			
	slb:	xret := "i__toUint32" (dv) with elab;
			newLen := xret;
			xret := "i__toNumber" (dv) with elab;
			goto [not (newLen = xret)] rgerr sle;
			
	sle:	dv := newLen;
			goto [not (newLen < oldLenNum)] slfi slg;
			
	slfi:	xret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, throw) with elab;
			goto rlab;
			
	slg:	goto [nth (oldLenDesc, 2) = $$f] reject slh;
	
	slh:	goto [dw = $$f] sli slh1;
	
	slh1:	newWritable := $$t;
			goto slj;
	
	sli:	newWritable := $$f;
			dw := $$t;
	
	slj:	xret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, throw) with elab;
			goto [xret = $$f] tf sll;
	
	sll:	dp := [l, "@deleteProperty"];
	loop:	goto [newLen < oldLen] head slm;
	head:	oldLen := oldLen - 1;
			xret := "i__toString" (oldLen) with elab;
			xret := dp (l, xret, $$f) with elab;
			goto [xret = $$f] fix next;
			
	fix:	dv := oldLen + 1;
			goto [newWritable = $$f] setwr defl;
	setwr:	dw := $$f;
	defl:	xret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, throw) with elab;
			goto reject;
			
	next:	goto sll;
	
	slm:	goto [newWritable = $$f] slmi sln;
	
	slmi:	xret := "o__defineOwnProperty" (l, "length", {{ "g", $$empty, $$empty, $$empty, $$f, $$empty, $$empty }}, $$f) with elab;
	
	sln:	xret := $$t;
	rlab:	skip;
	
	rgerr:	xret := "RangeError" ();
			goto elab;
	
	reject:	goto [throw] tt tf;
	
	tt:		xret := "TypeError" ();
	elab:	skip;
	
	tf:		xret := $$f;
			goto rlab
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** ISARRAY *** *)

proc Array_isArray (xsc, vthis, array) {
			xret := $$f;
			
			goto [typeOf (array) = $$object_type] cls rlab;
	cls:	class := [array, "@class"];
			goto [class = "Array"] rt rlab; 
	
	rt:		xret := $$t;
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** TOSTRING *** *)

proc AP_toString (xsc, vthis) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			g := [vthis, "@get"];
			xret := g (vthis, "join") with elab;
			func := xret;
			
			xret := "i__isCallable" (func);
			goto [xret] norm setfun;
			
	setfun:	func := $lop_toString;
	
	norm:	xsc := [func, "@scope"];				
			fun := [func, "@call"];					
			xret := fun (xsc, vthis) with elab;	
			goto [xret = $$empty] undef rlab;
	undef:	xret := $$undefined;
			
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* *** JOIN *** *)

proc AP_join (xsc, vthis, sep) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			g := [vthis, "@get"];
			xret := g (vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;
			
			goto [sep = $$undefined] ssep len0;
	ssep:	sep := ",";
			
	len0:	goto [len = 0] xemp non0;
	
	non0:	xret := g (vthis, "0") with elab;
			goto [(xret = $$null) or (xret = $$undefined)] r0 rs;
	
	r0:		R := "";
			goto prep;
	
	rs:		xret := "i__toString" (xret) with elab;
			R := xret; 
			
	prep:	k := 1;
	
	loop:	goto [k < len] head end;
	head:	R := R concat sep;
			
			next := "";
			xret := "i__toString" (k) with elab;
			xret := g (vthis, xret) with elab;
			
			goto [(xret = $$undefined) or (xret = $$null)] cc def;		
	def:	xret := "i__toString" (xret) with elab;
			next := xret;
			
	cc:		R := R concat next;
			k := k + 1;
			goto loop;
	
	
	end:	xret := R;
			goto rlab;
	
	xemp:	xret := "";
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* *** POP *** *)
proc AP_pop (xsc, vthis) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			g := [vthis, "@get"];
			xret := g (vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;
			
			p := [vthis, "@put"];
			goto [len = 0] zero nz;
	
	zero:	xret := p (vthis, "length", 0, $$t) with elab;
			xret := $$undefined;
			goto rlab;
	
	nz:		indx := "i__toString" (len - 1);
			elem := g (vthis, indx) with elab;
			d := [vthis, "@deleteProperty"];
			xret := d (vthis, indx, $$t) with elab;
			xret := p (vthis, "length", indx, $$t) with elab;
			xret := elem;
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** PUSH *** *)
proc AP_push() {
			arguments := args;
			vthis := nth (arguments, 1);
			
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			g := [vthis, "@get"];
			xret := g (vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;
			
			n := 2;
			num := length (arguments);
			p := [vthis, "@put"];

	loop:	goto [n < num] add stop;
	
	add:	elem := nth (arguments, n);
			strn := "i__toString" (len);
			xret := p (vthis, strn, elem, $$t) with elab;
			n := n + 1;
			len := len + 1;
			goto loop;
				
	stop:	xret := p (vthis, "length", len, $$t) with elab;
			xret := len;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};


(* *** TOLOCALESTRING *** *)
proc AP_toLocaleString(xsc, vthis) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			g := [vthis, "@get"];
			xret := g (vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			sep := ",";
			k := 0;
			goto [len = 0] empty fill;
	
	empty:	xret := "";
			goto rlab;
	
	fill:	xret := "i__toString" (k) with elab;
			xret := g (vthis, xret) with elab;
			goto [ (xret = $$undefined) or (xret = $$null) ] un def;
			
	un:		R := "";
			goto next;
			
	def:	xret := "i__toObject" (xret) with elab;
			eothis := xret;
			xret := g (eothis, "toLocaleString") with elab;
			func := xret;
			
			xret := "i__isCallable" (func);
			goto [xret] call throw;
			
	call:	xsc := [func, "@scope"];				
			fun := [func, "@call"];					
			R := fun (xsc, eothis) with elab;
	
	next:	goto [k = 0] fe ne;
	ne:		R := S concat R;
	fe:		k := k + 1;
			goto loop;
			
	loop:	goto [k < len] lp end;
	
	lp:		S := R concat sep;
			goto fill;
	
	end:	xret := R;
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** CONCAT *** *)
proc AP_concat() {
			arguments := args;
			vthis := nth (arguments, 1);
			
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			xret := "Array_construct" () with elab;
			A := xret;
			
			n := 0;
			idx := 2;
			num := length (arguments);
			
			elem := vthis;
			f := 0;
			goto cont;
			
	loop:	goto [idx < num] add end;
	
	add:	elem := nth (arguments, idx);
			f := 1;
			xret := "i__toObject" (elem) with elab;
			elem := xret;
			
	cont:	c := [elem, "@class"];
			goto [c = "Array"] arr narr;
			
	arr:	k := 0;
			g := [elem, "@get"];
			xret := g (elem, "length") with elab;
			len := xret;
			
	lp:		goto [k < len] loop2 loop;
			
	loop2:	xret := "i__toString" (k) with elab;
			p := xret;
			
			hp := [elem, "@hasProperty"];
			xret := hp (elem, p) with elab;
			goto [xret] tt next;
	
	tt:		xret := g (elem, p) with elab;
			se := xret;
			xret := "i__toString" (n) with elab;
			strn := xret;
			xret := "a__defineOwnProperty" (A, strn, {{ "d", se, $$t, $$t, $$t }}, $$f) with elab;
			
	next:	n := n + 1;
			k := k + 1;
			goto [f = 0] lp inc;		
	inc:	idx := idx + 1;
			goto lp;
	
	narr:	xret := "i__toString" (n) with elab;
			xret := "a__defineOwnProperty" (A, xret, {{ "d", elem, $$t, $$t, $$t }}, $$f) with elab;
			n := n + 1;
			goto [f = 0] loop iinc;
	iinc:	idx := idx + 1;
			goto loop;

	end:	xret := A;
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** REVERSE *** *)
proc AP_reverse(xsc, vthis) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			g := [vthis, "@get"];
			xret := g (vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;
			
			mid := m_floor len / 2;
			lower := 0;
			
	loop:	goto [not (mid = lower)] rev end;
	
	rev:	upper := len - lower;
			upper := upper - 1;
			xret := "i__toString" (upper) with elab;
			upperP := xret;
			xret := "i__toString" (lower) with elab;
			lowerP := xret;
			xret := g (vthis, upperP) with elab;
			upperV := xret;
			xret := g (vthis, lowerP) with elab;
			lowerV := xret;
			
			hp := [vthis, "@hasProperty"];
			xret := hp (vthis, upperP) with elab;
			upperE := xret;
			xret := hp (vthis, lowerP) with elab;
			lowerE := xret;
			
			p := [vthis, "@put"];
			goto [lowerE and upperE] tt el1;
			
	tt:		xret := p (vthis, lowerP, upperV, $$t) with elab;
			xret := p (vthis, upperP, lowerV, $$t) with elab;
			goto inc;
	
	el1:	d := [vthis, "@deleteProperty"];
			goto [upperE] ft el2;
	
	ft:		xret := p (vthis, lowerP, upperV, $$t) with elab;
			xret := d (vthis, upperP, $$t) with elab;
			goto inc;
	
	el2:	goto [lowerE] tf inc;
	
	tf:		xret := d (vthis, lowerP, $$t) with elab;
			xret := p (vthis, upperP, lowerV, $$t) with elab;

	inc:	lower := lower + 1;
			goto loop;
			
	end:	xret := vthis;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** SHIFT *** *)
proc AP_shift(xsc, vthis) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			g := [vthis, "@get"];
			xret := g (vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;
			
			p := [vthis, "@put"];
			goto [len = 0] zero nz;
			
	zero:	xret := p (vthis, "length", 0, $$t) with elab;
			xret := $$undefined;
			goto rlab;
	
	nz:		xret := g (vthis, "0") with elab;
			first := xret;
			
			k := 1;
			d := [vthis, "@deleteProperty"];
	loop:	goto [k < len] less end;
	less:	xret := "i__toString" (k) with elab;
			from := xret;
			kk := k - 1;
			xret := "i__toString" (kk) with elab;
			to := xret;
			hp := [vthis, "@hasProperty"];
			xret := hp (vthis, from) with elab;
			goto [xret] t f;
			
	t:		xret := g (vthis, from) with elab;
			xret := p (vthis, to, xret, $$t) with elab;
			goto inc;
	
	f:		xret := d (vthis, to, $$t) with elab;
	inc:	k := k + 1;
			goto loop;
	
	end:	len := len - 1;
			xret := "i__toString" (len) with elab;
			xret := d (vthis, xret, $$t) with elab;
			xret := p (vthis, "length", len, $$t) with elab;
			xret := first;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** SLICE *** *)
proc AP_slice(xsc, vthis, start, end) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			xret := "Array_construct" () with elab;
			A := xret;			
			
			g := [vthis, "@get"];
			xret := g (vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;
			
			xret := "i__toInteger" (start) with elab;
			rs := xret;
			
	if1:	goto [rs < 0] if1t if1f;
	if1t:	lrs := len + rs;
			goto [not (lrs < 0)] gr ls;		
	gr:		k := lrs;
			goto if2;
	ls:		k := 0;
			goto if2;
			
	if1f:	goto [rs <= len] ls1 gr1;
	gr1:	k := len;
			goto if2;
	ls1:	k := rs;

	if2:	goto [end = $$undefined] if2t if2f;
	if2t:	re := len;
			goto if3;
	if2f:	xret := "i__toInteger" (end) with elab;
			re := xret;
	
	if3:	goto [re < 0] if3t if3f;
	
	if3t:	lre := len + re;
			goto [not (lre < 0)] gr2 ls2;
	gr2:	final := lre;
			goto setn;
	ls2:	final := 0;
			goto setn;
	
	if3f:	goto [re <= len] ls3 gr3;
	ls3:	final := re;
			goto setn;
	gr3:	final := len;
	
	setn:	n := 0;
	loop:	goto [k < final] next end;
	
	next:	xret := "i__toString" (k) with elab;
			pk := xret;
			
			hp := [vthis, "@hasProperty"];
			xret := hp (vthis, pk) with elab;
			kpres := xret;
			goto [kpres] tt ff;
			
	tt:		xret := g (vthis, pk) with elab;
			kval := xret;
			xret := "i__toString" (n) with elab;
			strn := xret;
			xret := "a__defineOwnProperty" (A, strn, {{ "d", kval, $$t, $$t, $$t }}, $$f) with elab;
			
	ff:		k := k + 1;
			n := n + 1;
			goto loop;
		
	end:	xret := A;
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** UNSHIFT *** *)
proc AP_unshift() {
			arguments := args;
			vthis := nth (arguments, 1);
			
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			g := [vthis, "@get"];
			xret := g (vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;
			k := len;
			
			num := length (arguments);
			argc := num - 2;
			p := [vthis, "@put"];
			
	loop1:	goto [not (k <= 0)] next1 end1;
	next1:	xret := k - 1;
			xret := "i__toString" (xret) with elab;
			from := xret;
			
			xret := k + argc;
			xret := xret - 1;
			xret := "i__toString" (xret) with elab;
			to := xret;
			
			hp := [vthis, "@hasProperty"];
			xret := hp (vthis, from) with elab;
			fromp := xret;
			
			goto [fromp] fpt fpf;
			
	fpt:	xret := g (vthis, from) with elab;
			fromv := xret;
			xret := p (vthis, to, fromv, $$t) with elab;
			goto dec;
	
	fpf:	d := [vthis, "@deleteProperty"];
			xret := d (vthis, to, $$t) with elab;
	
	dec:	k := k - 1;
			goto loop1;
			
	end1:	j := 0;
			nm := 2;
			
	loop:	goto [nm < num] next end;
	next:	elem := nth(arguments, nm);
			xret := "i__toString" (j) with elab;
			strj := xret;
			xret := p (vthis, strj, elem, $$t) with elab;
			j := j + 1;
			nm := nm + 1;
			goto loop;
	
	end:	lac := len + argc;
			xret := p (vthis, "length", lac, $$t) with elab;
			xret := lac;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** SPLICE *** *)
proc AP_splice() {
			arguments := args;
			vthis := nth (arguments, 1);
			start := nth (arguments, 2);
			deleteCount := nth (arguments, 3);
			
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			xret := "Array_construct" () with elab;
			A := xret;

			g := [vthis, "@get"];
			xret := g (vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;
			hp := [vthis, "@hasProperty"];
			p := [vthis, "@put"];
			d := [vthis, "@deleteProperty"];
			
			xret := "i__toInteger" (start) with elab;
			rs := xret;
			
			goto [rs < 0] ift iff;
	ift:	lrs := len + rs;
			goto [not (lrs < 0)] gr ls;		
	gr:		acs := lrs;
			goto delc;
	ls:		acs := 0;
			goto delc;
			
	iff:	goto [rs <= len] ls1 gr1;
	gr1:	acs := len;
			goto delc;
	ls1:	acs := rs;

	delc:	xret := "i__toInteger" (deleteCount) with elab;
			dc := xret;
			goto [not (dc < 0)] gr2 ls2;		
	gr2:	max := dc;
			goto min;
	ls2:	max := 0;
	min:	las := len - acs;
			goto [max <= las] ls3 gr3;
	ls3:	adc := max;
			goto cont;
	gr3:	adc := las;
	cont:	k := 0;
	loop1:	goto [k < adc] next1 end1;
	next1:	ask := acs + k;
			xret := "i__toString" (ask) with elab;
			from := xret;
			xret := hp (vthis, from) with elab;
			fromp := xret;
			goto [fromp] fpt fpf;
			
	fpt:	xret := g (vthis, from) with elab;
			fromv := xret;
			xret := "i__toString" (k) with elab;
			strk := xret;
			xret := "a__defineOwnProperty" (A, strk, {{ "d", fromv, $$t, $$t, $$t }}, $$f) with elab;
	
	fpf:	k := k + 1;
			goto loop1;
	
	end1:	num := length (arguments);
			itemc := num - 4;
			ladcic := len - adc;
			ladcic := ladcic + itemc;
			goto [itemc < adc] less nless;
			
	less:	k := acs;
			ladc := len - adc;
	loop2:	goto [k < ladc] next2 end2;
	next2:	kadc := k + adc;
			xret := "i__toString" (kadc) with elab;
			from := xret;
			kic := k + itemc;
			xret := "i__toString" (kic) with elab;
			to := xret;
			xret := hp (vthis, from) with elab;
			fromp := xret;
			goto [fromp] fptt fpff;
			
	fptt:	xret := g (vthis, from) with elab;
			fromv := xret;
			xret := p (vthis, to, fromv, $$t) with elab;
			goto cont1;
	fpff:	xret := d (vthis, to, $$t) with elab;
	cont1:	k := k + 1;
			goto loop2;
	
	end2:	k := len;
			
	loop3:	goto [not (k <= ladcic)] next3 end3;
	next3:	k1 := k - 1;
			xret := "i__toString" (k1) with elab;
			k1 := xret;
			xret := d (vthis, k1, $$t) with elab;
			k := k - 1;
			goto loop3;
	
	nless:	goto [not (itemc <= adc)] more end3;
	
	more:	k := len - adc;
	loop4:	goto [not (k <= acs)] next4 end3;
	next4:	kadc1 := k + adc;
			kadc1 := kadc1 - 1;
			xret := "i__toString" (kadc1) with elab;
			from := xret;
			kic1 := k + itemc;
			kic1 := kic1 - 1;
			xret := "i__toString" (kic1) with elab;
			to := xret;
			xret := hp (vthis, from) with elab;
			fromp := xret;
			goto [fromp] fpttt fpfff;
	fpttt:	xret := g (vthis, from) with elab;
			fromv := xret;
			xret := p (vthis, to, fromv, $$t) with elab;
			goto dec;
	
	fpfff:	xret := d (vthis, to, $$t) with elab;
			
	dec:	k := k - 1;
			goto loop4;

	end3:	k := acs;
			nm := 4;
	loop5:	goto [nm < num] next5 end5;
	
	next5:	elem := nth (arguments, nm);
			xret := "i__toString" (k) with elab;
			strk := xret;
			xret := p (vthis, strk, elem, $$t) with elab;
			k := k + 1;
			nm := nm + 1;
			goto loop5;
	
	end5:	xret := p (vthis, "length", ladcic, $$t) with elab;
			xret := A;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** INDEXOF *** *)
proc AP_indexOf() {
			arguments := args;
			vthis  := nth (arguments, 1);
			
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			g := [vthis, "@get"];
			xret := g (vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;



	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
}


