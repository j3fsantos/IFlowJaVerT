import Internals;

(* ***************** *) 
(* THE ARRAY LIBRARY *)
(* ***************** *) 

(* *** CONSTRUCT *** *)

proc Array_call () {
			xret := "Array_construct" ("args") with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};

proc Array_construct () {

			la := args;
			len := length (la);
			
			xret := new ();
			xret := "create_default_object" (xret, $larr_proto, "Array", $$t);
			
			[xret, "@defineOwnProperty"] := "a__defineOwnProperty";
			[xret, "length"] := {{ "d", 0, $$t, $$t, $$t }};
			array := xret;
			
			goto [len < 3] rtrn ltest;
			
	ltest:	goto [len = 3] len3 other;
	
	len3:	len := nth (la, 2);
			goto [typeOf(len) = $$number_type] len0 setl;
	len0:	xret := "i__toUint32" (len) with elab;
			goto [len = xret] dop re;
	dop:	prop := "length";
			goto set;
			
	setl:	prop := "0";
	set:	xret := "a__defineOwnProperty" (array, prop, {{ "d", len, $$t, $$t, $$t }}, $$t) with elab; 
			goto rtrn;
	
	other:	n := 2;
	loop:	goto [n < len] head rtrn;
	head:	prop := "i__toString" (n - 2) with elab;
			xret := "a__defineOwnProperty" (array, prop, {{ "d", nth (la, n), $$t, $$t, $$t }}, $$t) with elab; 
			n := n + 1;
			goto loop;
			
	rtrn:	xret := array;
	rlab:	skip;
	
	re:		xret := "RangeError" ();
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};

(* *** ISIDX *** *)

proc a__isIdx (s) {
			xret := "i__toUint32" (s) with elab;
			xret := "i__toString" (xret) with elab;
			
			goto [xret = s] check ret_f;
	
	check:	xret := not (xret = "4294967295");
			goto rlab;
			
	ret_f:	xret := $$f;
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** DEFINEOWNPROPERTY *** *)

proc a__defineOwnProperty (l, prop, desc, throw) {

			gop := [l, "@getOwnProperty"];
			oldLenDesc := gop (l, "length");
			oldLen := nth (oldLenDesc, 1);
			xret := "i__toUint32" (oldLen) with elab;
			oldLenNum := xret;
			
			goto [prop = "length"] getall is_idx;
			
	is_idx:	idxp := "a__isIdx" (prop);
			goto [idxp] idx norm;
			
	idx:	index := "i__toUint32" (prop);
			index := index;
			oldLen := oldLen;
			xret := nth (oldLenDesc, 2);
			goto [(not (index < oldLenNum)) and (not (nth (oldLenDesc, 2)))] reject idop;
	idop:	xret := "o__defineOwnProperty" (l, prop, desc, $$f) with elab;
			goto [xret = $$f] reject ilen;
	ilen:	goto [not (index < oldLenNum)] setl rlab;
	setl:	xret := "o__defineOwnProperty" (l, "length", {{ "d", (index + 1), nth (oldLenDesc, 2), nth (oldLenDesc, 3), nth (oldLenDesc, 4) }}, $$f);
			goto rlab;
			
	norm:	xret := "o__defineOwnProperty" (l, prop, desc, throw) with elab;
			goto rlab;
	
	getall:	goto [nth (desc, 0) = "d"] ddd odd;
	
			(* Data *)
	ddd:	de := nth (desc, 3);
			dc := nth (desc, 4);
			dv := nth (desc, 1);
			dw := nth (desc, 2);
			dg := $$empty;
			ds := $$empty;
			goto sla;
			
	odd:	goto [nth (desc, 0) = "a"] add gdd;

			(* Accessor *)
	add:	de := nth (desc, 3);
			dc := nth (desc, 4);
			dv := $$empty;
			dw := $$empty;
			dg := nth (desc, 1);
			ds := nth (desc, 2);
			goto sla;
			
			(* Generic *)
	gdd:	de := nth (desc, 1);
			dc := nth (desc, 2);
			dv := nth (desc, 3);
			dw := nth (desc, 4);
			dg := nth (desc, 5);
			ds := nth (desc, 6);
	
	sla:	goto [dv = $$empty] slai slb;
	
	slai:	xret := "o__defineOwnProperty" (l, "length", desc, throw) with elab;
			goto rlab;
			
	slb:	xret := "i__toUint32" (dv) with elab;
			newLen := xret;
			xret := "i__toNumber" (dv) with elab;
			goto [not (newLen = xret)] rgerr sle;
			
	sle:	dv := newLen;
			goto [not (newLen < oldLenNum)] slfi slg;
			
	slfi:	xret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, throw) with elab;
			goto rlab;
			
	slg:	goto [nth (oldLenDesc, 2) = $$f] reject slh;
	
	slh:	goto [dw = $$f] sli slh1;
	
	slh1:	newWritable := $$t;
			goto slj;
	
	sli:	newWritable := $$f;
			dw := $$t;
	
	slj:	xret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, throw) with elab;
			goto [xret = $$f] tf sll;
	
	sll:	dp := [l, "@deleteProperty"];
	loop:	goto [newLen < oldLen] head slm;
	head:	oldLen := oldLen - 1;
			xret := "i__toString" (oldLen) with elab;
			xret := dp (l, xret, $$f) with elab;
			goto [xret = $$f] fix next;
			
	fix:	dv := oldLen + 1;
			goto [newWritable = $$f] setwr defl;
	setwr:	dw := $$f;
	defl:	xret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, throw) with elab;
			goto reject;
			
	next:	goto sll;
	
	slm:	goto [newWritable = $$f] slmi sln;
	
	slmi:	xret := "o__defineOwnProperty" (l, "length", {{ "g", $$empty, $$empty, $$empty, $$f, $$empty, $$empty }}, $$f) with elab;
	
	sln:	xret := $$t;
	rlab:	skip;
	
	rgerr:	xret := "RangeError" ();
			goto elab;
	
	reject:	goto [throw] tt tf;
	
	tt:		xret := "TypeError" ();
	elab:	skip;
	
	tf:		xret := $$f;
			goto rlab
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** ISARRAY *** *)

proc Array_isArray (xsc, vthis, array) {
			xret := $$f;
			
			goto [typeOf (array) = $$object_type] cls rlab;
	cls:	class := [array, "@class"];
			goto [class = "Array"] rt rlab; 
	
	rt:		xret := $$t;
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** TOSTRING *** *)

proc AP_toString (xsc, vthis) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			g := [vthis, "@get"];
			xret := g (vthis, "join") with elab;
			func := xret;
			
			xret := "i__isCallable" (func);
			goto [xret] norm setfun;
			
	setfun:	func := $lop_toString;
	
	norm:	xsc := [func, "@scope"];				
			fun := [func, "@call"];					
			xret := fun (xsc, vthis) with elab;	
			goto [xret = $$empty] undef rlab;
	undef:	xret := $$undefined;
			
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* *** JOIN *** *)

proc AP_join (xsc, vthis, sep) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			g := [vthis, "@get"];
			xret := g (vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;
			
			goto [sep = $$undefined] ssep len0;
	ssep:	sep := ",";
			
	len0:	goto [len = 0] xemp non0;
	
	non0:	xret := g (vthis, "0") with elab;
			goto [(xret = $$null) or (xret = $$undefined)] r0 rs;
	
	r0:		R := "";
			goto prep;
	
	rs:		xret := "i__toString" (xret) with elab;
			R := xret; 
			
	prep:	k := 1;
	
	loop:	goto [k < len] head end;
	head:	R := R concat sep;
			
			next := "";
			xret := "i__toString" (k) with elab;
			xret := g (vthis, xret) with elab;
			
			goto [(xret = $$undefined) or (xret = $$null)] cc def;		
	def:	xret := "i__toString" (xret) with elab;
			next := xret;
			
	cc:		R := R concat next;
			k := k + 1;
			goto loop;
	
	
	end:	xret := R;
			goto rlab;
	
	xemp:	xret := "";
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* *** POP *** *)
proc AP_pop (xsc, vthis) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			g := [vthis, "@get"];
			xret := g (vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;
			
			p := [vthis, "@put"];
			goto [len = 0] zero nz;
	
	zero:	xret := p (vthis, "length", 0, $$t) with elab;
			xret := $$undefined;
			goto rlab;
	
	nz:		indx := "i__toString" (len - 1);
			elem := g (vthis, indx) with elab;
			d := [vthis, "@deleteProperty"];
			xret := d (vthis, indx, $$t) with elab;
			xret := p (vthis, "length", indx, $$t) with elab;
			xret := elem;
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** PUSH *** *)
proc AP_push() {
			arguments := args;
			vthis  := nth (arguments, 1);
			
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			g := [vthis, "@get"];
			xret := g (vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;
			
			n := 2;
			num := length (arguments);
			p := [vthis, "@put"];

	loop:	goto [n < num] add stop;
	
	add:	elem := nth (arguments, n);
			strn := "i__toString" (len);
			xret := p (vthis, strn, elem, $$t) with elab;
			n := n + 1;
			len := len + 1;
			goto loop;
				
	stop:	xret := p (vthis, "length", len, $$t) with elab;
			xret := len;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
}


(* *** TOLOCALESTRING *** *)
(*
proc AP_toLocaleString(xsc, vthis) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;
			
			g := [vthis, "@get"];
			xret := g (vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
}
*)


