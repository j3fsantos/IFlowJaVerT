import Internals;

(* ***************** *) 
(* THE ARRAY LIBRARY *)
(* ***************** *) 

(* *** CONSTRUCT *** *)

proc Array_construct (xsc, vthis, len) {

			xret := new ();
			xret := "create_default_object" (xret, $larr_proto, "Array", $$t);
			
			[xret, "@defineOwnProperty"] := "a__defineOwnProperty";
			[xret, "length"] := {{ "d", 0, $$t, $$t, $$t }};
			array := xret;
				
			(* ONE PARAMETER ONLY AVAILABLE FOR NOW *)
			goto [typeOf(len) = $$number_type] len0 setl;
	len0:	xret := "i__toUint32" (len) with elab;
			goto [len = xret] dop re;
	dop:	prop := "length";
			goto set;
			
	setl:	prop := "0";
	set:	xret := "a__defineOwnProperty" (array, prop, {{ "d", len, $$t, $$t, $$t }}, $$t) with elab; 
			
	rtrn:	xret := array;
	rlab:	skip;
	
	re:		xret := "RangeError" ();
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};

(* *** ISIDX *** *)

proc a__isIdx (s) {
			xret := "i__toUint32" (s) with elab;
			xret := "i__toString" (xret) with elab;
			
			goto [xret = s] ret_t ret_f;
			
	ret_t:	xret := $$t;
			goto rlab;
			
	ret_f:	xret := $$f;
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** DEFINEOWNPROPERTY *** *)

proc a__defineOwnProperty (l, prop, desc, throw) {

			gop := [l, "@getOwnProperty"];
			oldLenDesc := gop (l, "length");
			oldLen := nth (oldLenDesc, 1);
			
			goto [prop = "length"] getall is_idx;
			
	is_idx:	idxp := "a__isIdx" (prop);
			goto [idxp] idx norm;
			
	idx:	index := "i__toUint32" (prop);
			index := index;
			oldLen := oldLen;
			xret := nth (oldLenDesc, 2);
			goto [(not (index < oldLen)) and (not (nth (oldLenDesc, 2)))] reject idop;
	idop:	xret := "o__defineOwnProperty" (l, prop, desc, $$f) with elab;
			goto [xret = $$f] reject ilen;
	ilen:	xret := "o__defineOwnProperty" (l, "length", {{ "d", (index + 1), nth (oldLenDesc, 2), nth (oldLenDesc, 3), nth (oldLenDesc, 4) }}, $$f);
			goto rlab;
			
	norm:	xret := "o__defineOwnProperty" (l, prop, desc, throw) with elab;
			goto rlab;
	
	getall:	goto [nth (desc, 0) = "d"] ddd odd;
	
			(* Data *)
	ddd:	de := nth (desc, 3);
			dc := nth (desc, 4);
			dv := nth (desc, 1);
			dw := nth (desc, 2);
			dg := $$empty;
			ds := $$empty;
			goto sla;
			
	odd:	goto [nth (desc, 0) = "a"] add gdd;

			(* Accessor *)
	add:	de := nth (desc, 3);
			dc := nth (desc, 4);
			dv := $$empty;
			dw := $$empty;
			dg := nth (desc, 1);
			ds := nth (desc, 2);
			goto sla;
			
			(* Generic *)
	gdd:	de := nth (desc, 1);
			dc := nth (desc, 2);
			dv := nth (desc, 3);
			dw := nth (desc, 4);
			dg := nth (desc, 5);
			ds := nth (desc, 6);
	
	sla:	goto [dv = $$empty] slai slb;
	
	slai:	xret := "o__defineOwnProperty" (l, "length", desc, throw) with elab;
			goto rlab;
			
	slb:	xret := "i__toUint32" (dv) with elab;
			newLen := xret;
			xret := "i__toNumber" (dv) with elab;
			goto [not (newLen = xret)] rgerr sle;
			
	sle:	dv := newLen;
			goto [not (newLen < oldLen)] slfi slg;
			
	slfi:	xret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, throw) with elab;
			goto rlab;
			
	slg:	goto [nth (oldLenDesc, 2) = $$f] reject slh;
	
	slh:	goto [dw = $$f] sli slh1;
	
	slh1:	newWritable := $$t;
			goto slj;
	
	sli:	newWritable := $$f;
			dw := $$t;
	
	slj:	xret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, throw) with elab;
			goto [xret = $$f] tf sll;
	
	sll:	dp := [l, "@deleteProperty"];
	loop:	goto [newLen < oldLen] head slm;
	head:	oldLen := oldLen - 1;
			xret := "i__toString" (oldLen) with elab;
			xret := dp (l, xret, $$f) with elab;
			goto [xret = $$f] fix next;
			
	fix:	dv := oldLen + 1;
			goto [newWritable = $$f] setwr defl;
	setwr:	dw := $$f;
	defl:	xret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, throw) with elab;
			goto reject;
			
	next:	goto sll;
	
	slm:	goto [newWritable = $$f] slmi sln;
	
	slmi:	xret := "o__defineOwnProperty" (l, "length", {{ "g", $$empty, $$empty, $$empty, $$f, $$empty, $$empty }}, $$f) with elab;
	
	sln:	xret := $$t;
	rlab:	skip;
	
	rgerr:	xret := "RangeError" ();
			goto elab;
	
	reject:	goto [throw] tt tf;
	
	tt:		xret := "TypeError" ();
	elab:	skip;
	
	tf:		xret := $$f;
			goto rlab
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** ISARRAY *** *)

proc Array_isArray (xsc, vthis, array) {
			xret := $$f;
			
			goto [typeOf (array) = $$object_type] cls rlab;
	cls:	class := [array, "@class"];
			goto [class = "Array"] rt rlab; 
	
	rt:		xret := $$t;
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
}