spec getOwnProperty (l, prop)
	[[ (l, prop) -> None ]]
	[[ ((l, prop) -> None) * xret == $$empty ]]
	normal;
	
	[[ exists _v. ((l, prop) -> _v) * (~ _v == None) ]]
	[[ exists _v. ((l, prop) -> _v) * xret == _v ]]
	normal
	
proc getOwnProperty (l, prop) {
            x := hasField(l, prop);
            goto [x] hp nhp; 
    hp:     xret := [l, prop];
            goto rlab;
    nhp:    xret := $$empty;
    rlab:   skip
}
with
{
    ret: xret, rlab;
};

proc getProperty (l, prop) {
            xret := protoField(l, prop);
            goto [xret = $$undefined] ndef rlab;
    ndef:   xret := $$undefined;
    rlab:   skip
}
with 
{
    ret: xret, rlab;
}

(*
proc get(l, prop) {
    rlab:   xret := "getProperty" (l, prop);
}
with
{
    ret: xret, rlab;
}

proc canPut (l, prop) {
            xret := hasField(l, prop);
            goto [xret] rlab nhf;
    nhf:    xret := [l, "#extensible"];
    rlab:   skip;
}
with
{
    ret: xret, rlab;
}

proc put(l, prop, value, throw) {
            x := "canPut" (l, prop);
            goto [x] t f;
    t:      [l, prop] := value;
    tf:     xret := $$empty;
    rlab:   skip;
    f:      goto [throw] tt tf;
    tt:     xerr := "TypeError" ();
    elab:   skip;
}
with
{
    ret: xret, rlab;
    err: xerr, elab;
}

proc hasProperty(l, prop) {
            x := "getProperty" (l, prop);
            goto [x = $$undefined] ndef def;
    def:    xret := true;
            goto rlab;
    ndef:   xret := false;
    rlab:   skip;
}
with
{
    ret: xret, rlab;
}

proc delete(l, prop, throw) {
            x := "getOwnProperty" (l, prop);
            goto [x = $$undefined] ndef def;   
    ndef:   xret := true; 
            goto rlab;
    def:    delete(prop, l);
            xret := true;
    rlab:   skip;
}
with
{
    ret: xret, rlab;
}

proc isPrimitive(v) {
            goto [typeof(v) = Num] p next1;
    next1:  goto [typeof(v) = Bool] p next2;
    next2:  goto [typeof(v) = Str] p next3;
    next3:  goto [typeof(v) = "undefined"] p next4;
    next4:  goto [typeof(v) = "null"] p np;
    p:      xret := true;
            goto rlab;
    np:     xret := false;
    rlab:   skip;
}
with
{
    ret: xret, rlab;
}

proc defaultValue(l, hint) {
            goto [hint = "String"] s n;
    s:      to_s := "get" (l, "toString");
            x_s := "isCallable" (to_s);
            goto [x_s] str n;
    str:    st := to_s (l);
            goto [hint = "String"] str1 str2;
    str1:   goto ["isPrimitive"(st)] prim_s n;
    str2:   goto ["isPrimitive"(st)] prim_s throw;
    prim_s: xret := st;
            goto rlab;
    throw:  xerr := "TypeError" ();
            goto elab;
    n:      v_of := "get" (l, "valueOf");
            x_v := "isCallable" (v_of);
            goto [x_v] val s;
    val:    vl := v_of (l);
            goto [hint = "Number"] val1 val2;   
    val1:   goto ["isPrimitive"(vl)] prim_n s;
    val2:   goto ["isPrimitive"(vl)] prim_n throw;
    prim_n: xret := vl;
    rlab:   skip;
    elab:   skip;
}
with
{
    ret: xret, rlab;
    err: xerr, elab;
}

proc defineOwnProperty(l, prop, value, throw) {
            c := "getOwnProperty" (l, prop);
            e := [l, "#extensible"];
            goto [c = "undefined"] next t;
    next:   goto [e] f t;
    f:      goto [throw] tt tf;
    tt:     xerr := "TypeError" ();
            goto elab;
    tf:     xret := false;
            goto rlab;
    t:      [l, prop] := value;
            xret := true;
    rlab:   skip;
}
with{
    ret: xret, rlab;
    err: xerr, elab;
}

proc isReference(v) {
            goto [typeof(v) = Refo] r next1;
    next1:  goto [typeof(v) = Refv] r nr;
    r:      xret := true;
            goto rlab;
    nr:     xret := false;
    rlab:   skip;
}
with{
    ret: xret, rlab;
}

proc specialGet(l, prop) {
            o := "toObject" (l);
    rlab:   xret := "getProperty" (o, prop);
}
with
{
    ret: xret, rlab;
}

proc getValue(l, v) {
            goto ["isReference"(v)] ref nref;
    ref:    b := base(v);
            f := field(v);
            goto [b = "$$undefined"] e ne;
    e:      xerr := "ReferenceError" ();
            goto elab;
    ne:     goto [typeof(v) = Refo] pr er;
    pr:     p := "isPrimitive" (b);
            goto [p] spe_g norm_g;
    norm_g: xret := "get" (b, f);
            goto rlab;
    spe_g:  xret := "specialGet" (b, f);
            goto rlab;
    er:     xret := [b, f];
            goto rlab;
    nref:   xret := v;
    rlab:   skip;
    elab:   skip;
}
with{
    ret: xret, rlab;
    err: xerr, elab;
}

proc specialPut(l, prop, value, throw) {
            o := "toObject" (l);
            x := "canPut" (o, prop);
            goto [x] t f;
    t:      xret := $$empty;
    rlab:   skip;
    f:      goto [throw] th t;
    th:     xerr := "TypeError" ();
    elab:   skip;
}
with{
    ret: xret, rlab;
    err: xerr, elab;
}

proc putValue(l, v, w) {
            goto ["isReference"(v)] ref nref;
    ref:    b := base(v);
            f := field(v);
            goto [b = "$$undefined"] nref pref;
    pref:   goto [typeof(v) = Refo] pr er;
    pr:     p := "isPrimitive" (b);
            goto [p] spe_p norm_p;
    spe_p:  c := "specialPut" (b, f, w, true);
            xret := $$empty;
            goto rlab;
    norm_p: c := "put" (b, f, w, true);
            xret := $$empty;
            goto rlab;
    er:     [b, f] := w;
            xret := $$empty;
            goto rlab;
    nref:   xerr := "ReferenceError" ();
            goto elab;
    rlab:   skip;
    elab:   skip;
}
with
{
    ret: xret, rlab;
    err: xerr, elab;
} *)