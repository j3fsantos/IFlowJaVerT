(* ************** *) 
(* GETOWNPROPERTY *)
(* ************** *) 
	
proc o__getOwnProperty (l, prop) {
            x := hasField(l, prop);		
            goto [x] hp nhp; 			(* Does the field exist? *)
            
    nhp:    xret := $$undefined;		(* Field doesn't exist; return undefined *)
            goto rlab;					
            
    hp:     xret := [l, prop];			(* Field exists; return the descriptor *)
    
    rlab:   skip
}
with
{
    ret: 	xret, rlab;
};

(* *********** *) 
(* GETPROPERTY *)
(* *********** *) 

proc o__getProperty (l, prop) {
			
			gop := [l, "@getOwnProperty"];
			xret := gop (l, prop) with elab;
			goto [xret = $$undefined] next rlab;
			
	next:	proto := [l, "@proto"];
			goto [proto = $$null] rlab call;
			
	call:	gp := [proto, "@getProperty"];
			xret := gp (proto, prop) with elab;
	
    rlab:   skip;
    elab:	skip
}
with 
{
    ret: 	xret, rlab;
    err:	xret, elab;
};

(* *** *) 
(* GET *)
(* *** *) 

proc o__get (l, prop) {
			gp := [l, "@getProperty"];
			xret := gp (l, prop) with elab;	
			goto [xret = $$undefined] rlab def;		(* Does the field exist? *)
			
	def:	d := nth (xret, 0);						(* Get the descriptor type *)
			xret := nth (xret, 1);					(* Get the value/getter *)
			goto [d = "d"] rlab acc;				(* Is it a data descriptor? *)
			
	acc:	goto [xret = $$undefined] rlab get;		(* Is the getter defined? *)
	get:	xsc := [xret, "@scope"];				(* Get the scope of the getter *)
			fun := [xret, "@body"];					(* Get the name of the getter *)
			xret := fun (xsc, l) with elab;			(* Call the getter, errors could happen *)
			
	rlab:	skip;
	elab:	skip
}
with
{
    ret: xret, rlab;
    err: xret, elab;
};

(* ****** *) 
(* CANPUT *)
(* ****** *) 

proc o__canPut (l, prop) {
			gop := [l, "@getOwnProperty"];
            xret := gop (l, prop) with elab;		
	op:		goto [xret = $$undefined] nop odesc; 	(* Does the own property exist? *)
	
	odesc:	d := nth (xret, 0);						(* It does; get the descriptor type *)
			goto [d = "d"] odd nop;					(* Is the descriptor a data descriptor? *)
			
	odd:	xret := nth (xret, 2);					(* It is; return the Writable attribute *)
			goto rlab;
			
	nop:	e := [l, "@extensible"];				(* Get the extensible property *)
			gp := [l, "@getProperty"];
			xret := gp (l, prop) with elab;			(* Does the property exist? *)
			goto [xret = $$undefined] ext desc;		(* It doesn't; return extensible *)
			
	desc:	d := nth (xret, 0);						(* Get the descriptor type *)
			v := nth (xret, 2);						(* Get the writable/setter *)
			goto [d = "d"] dd ad;					(* Is it a data descriptor? *)
			
	dd:		goto [e] wr ext;						(* Yes; is the object extensible? *)
	wr:		xret := v;								(* Yes; return writable *)
			goto rlab;
			
	ad:		xret := not (v = $$undefined); 			(* Accessor descriptor *)
			goto rlab;
			
	ext:	xret := e;								(* Return extensible *)
	
    rlab:   skip;
    elab:	skip
}
with
{
    ret: 	xret, rlab;
    err:	xret, elab;
};

(* *** *) 
(* PUT *)
(* *** *) 

proc o__put (l, prop, value, throw) {
			cp := [l, "@canPut"];
            xret := cp (l, prop) with elab;
            goto [xret] cp reject;
            
    cp:     gop := [l, "@getOwnProperty"];
    		xret := gop (l, prop) with elab;
    		dd := "i__isDataDescriptor" (xret);
    		goto [dd] dd gp;
    		
    dd:		desc := {{ "g", $$empty, $$empty, value, $$empty, $$empty, $$empty }};
    		dop := [l, "@defineOwnProperty"];
    		xret := dop (l, prop, desc, throw) with elab;
    		goto remp;
    		
    gp:		gp := [l, "@getProperty"];
    		xret := gp (l, prop) with elab;
    		ad := "i__isAccessorDescriptor" (xret);
    		goto [ad] ad def;
    		
    ad:		s := nth (xret, 2);
    		xsc := [s, "@scope"];
    		fun := [s, "@body"];
    		xret := fun (xsc, l, value) with elab;
    		goto remp;
    		
    def:	desc := {{ "g", $$t, $$t, value, $$t, $$empty, $$empty }};
    		xret := "o__defineOwnProperty" (l, prop, desc, throw) with elab;

    remp:   xret := $$empty;
    rlab:   skip;
    
    reject: goto [throw] tt remp;
    tt:     xerr := "TypeError" ();
    elab:   skip
}
with
{
    ret: xret, rlab;
    err: xret, elab;
};

(* *********** *) 
(* HASPROPERTY *)
(* *********** *) 

proc o__hasProperty (l, prop) {
			gp := [l, "@getProperty"];
			xret := gp (l, prop) with elab;
			
	rlab:	xret := not (xret = $$undefined);
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};

(* ************** *) 
(* DELETEPROPERTY *)
(* ************** *) 

proc o__deleteProperty (l, prop, throw) {
			gop := [l, "@getOwnProperty"];
			xret := gop (l, prop) with elab;
			goto [xret = $$undefined] dt cont;
			
	cont:	c := nth (x, 4);
			goto [c] del reject;
	del:	delete (l, prop);
	
	dt:		xret := $$t;
			goto rlab;
			
	df:		xret := $$f;
	rlab:	skip;
	
    reject: goto [throw] tt df;
    
    tt:     xerr := "TypeError" ();
    elab:   skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* ************ *) 
(* DEFAULTVALUE *)
(* ************ *) 

proc o__defaultValue (l, hint) {
			goto [hint = $$empty] hint init;
			
	hint:	hint := "Number";
			class := [l, "@class"];
			goto [class = "Date"] hs init;
	hs:		hint := "String";

	init:	pass := 0;
            goto [hint = "String"] s n;

	main:	goto [pass = 2] throw cc;
	
    cc:		pass := pass + 1;
    		g := [l, "@get"];
    		xret := g (l, proc_name) with elab;
    		goto [xret = $$undefined] next is_c;
    		
    is_c:	c := "i__isCallable" (xret);
            goto [c] call next;
            xsc := [xret, "@scope"];
            fun := [xret, "@body"];
            
    call:   xret := fun (xsc, l) with elab;            
			goto [is_primitive xret] rlab next;
			
    next:   goto [proc_name = "toString"] n s;
    rlab:   skip;

    s:		proc_name := "toString";
    		goto main;
    n:		proc_name := "valueOf";
    		goto main;

    throw:  xret := "TypeError" ();
    elab:   skip
}
with
{
    ret: xret, rlab;
    err: xret, elab;
};

(* ***************** *) 
(* DEFINEOWNPROPERTY *)
(* ***************** *) 

proc o__defineOwnProperty (l, prop, desc, throw) {
	
			xret := $$t;
	
			gop := [l, "@getOwnProperty"];
			current := gop (l, prop) with celab;
			extensible := [l, "@extensible"];
			
			goto [(current = $$undefined) and (extensible = $$f)] reject l4;
	l4:		goto [(current = $$undefined) and (extensible = $$t)] l4a getall;
	
	l4a:	gd := "i__isGenericDescriptor" (desc);
			dd := "i__isDataDescriptor" (desc);
			
			goto [gd or dd] l4a1 l4b;
			
	l4a1:	ndesc := "i__toDataDescriptor" (desc);
			[l, prop] := ndesc;
			goto acc_t;
	
	l4b:	ndesc := "i__toAccessorDescriptor" (desc);
			[l, prop] := ndesc;
			goto acc_t;
	
	getall:	goto [nth (desc, 0) = "d"] ddd odd;
	
			(* Data *)
	ddd:	de := nth (desc, 3);
			dc := nth (desc, 4);
			dv := nth (desc, 1);
			dw := nth (desc, 2);
			dg := $$empty;
			ds := $$empty;
			goto l5;
			
	odd:	goto [nth (desc, 0) = "a"] add gdd;

			(* Accessor *)
	add:	de := nth (desc, 3);
			dc := nth (desc, 4);
			dv := $$empty;
			dw := $$empty;
			dg := nth (desc, 1);
			ds := nth (desc, 2);
			goto l5;
			
			(* Generic *)
	gdd:	de := nth (desc, 1);
			dc := nth (desc, 2);
			dv := nth (desc, 3);
			dw := nth (desc, 4);
			dg := nth (desc, 5);
			ds := nth (desc, 6);
			
	l5:		goto [(de = $$empty) and (dc = $$empty) and (dv = $$empty) and 
			      (dw = $$empty) and (dg = $$empty) and (ds = $$empty)] acc_t l6;
	
	l6:		goto [nth (current, 0) = "d"] chd cha;
	
	chd:	goto [(dv = nth(current, 1)) and (dw = nth(current, 2)) and
			      (de = nth(current, 3)) and (dc = nth(current, 4)) and
			      (dg = $$empty) and (ds = $$empty)] acc_t l7;
			
	cha:	goto [(dg = nth(current, 1)) and (ds = nth(current, 2)) and
			      (de = nth(current, 3)) and (dc = nth(current, 4)) and
			      (dv = $$empty) and (dw = $$empty)] acc_t l7;
	
	l7:		cvg := nth (current, 1);
			cws := nth (current, 2);
			ce := nth (current, 3);
			cc := nth (current, 4);
			
			goto [(cc = $$f) and ((dc = $$t) or ((not (de = $$empty)) and (not (ce = de))))] reject l8;
	
	l8:		gd := "i__isGenericDescriptor" (desc);
			goto [gd] acc_t l9;
			
	l9:		cdd := "i__isDataDescriptor" (current);
			ddd := "i__isDataDescriptor" (desc);
			
			goto [not (cdd = ddd)] l9a l10;
			
	l9a:	goto [cc = $$f] reject change;
	change:	goto [cdd = $$t] toa tod;
	toa:	[l, prop] := {{ "a", $$undefined, $$undefined, ce, cc }};
			goto acc_t;
	tod:	[l, prop] := {{ "d", $$undefined, $$f, ce, cc }};
			goto acc_t;
	
	l10:	goto [cdd = $$t] l10a l11;
	
	l10a:	goto [cc = $$f] l10ai l12;
	l10ai:	goto [not (cws = dw)] reject l10aii;
	l10aii:	goto [(not (dv = $$empty)) and (not (cvg = dv))] reject l12;
	
	l11: 	goto [(cc = $$f) and 
	             (((not (dg = $$empty)) and (not (dg = nth (current, 1)))) or 
	              ((not (ds = $$empty)) and (not (ds = nth (current, 2)))))] reject l12;
	
	l12:	re := de;
			rc := dc;
			goto [de = $$empty] rec red;
	rec:	re := nth (current, 3);
	red:	goto [dc = $$empty] rcd rd;
	rcd:	rc := nth (current, 4);
	
	rd: 	goto [nth (current, 0) = "d"] l12d l12a;
	
	l12d:	rv := dv;
			rw := dw;
			goto [dv = $$empty] rvc rvd;
	rvc:	rv := nth (current, 1);
	rvd:	goto [dw = $$empty] rwd setd;
	rwd:	rc := nth (current, 2);
	setd:	[l, prop] := {{ "d", rv, rw, re, rc }};	
			goto acc_t;
	
	l12a:	rg := dg;
			rs := ds;
			goto [dg = $$empty] rgc rgd;
	rgc:	rg := nth (current, 1);
	rgd:	goto [ds = $$empty] rsd seta;
	rsd:	rs := nth (current, 2);
	seta:	[l, prop] := {{ "a", rg, rs, re, rc }};	
			goto acc_t;
	
	acc_t:	xret := $$t;
			goto rlab;
	acc_f:	xret := $$f;
	rlab:	skip;
	
	celab:	xerr := current;
			goto elab;
	
    reject: goto [throw] tt acc_f;
    tt:     xerr := "TypeError" ();
    elab:   skip
}
with
{
	ret: xret, rlab;
	err: xerr, elab;
};

(* ************** *) 
(* ON DESCRIPTORS *)
(* ************** *) 

(* *** ISDATADESCRIPTOR *** *)

proc i__isDataDescriptor (desc) {
			goto [desc = $$undefined] rf cont;
	cont:	d := nth (desc, 0);
			goto [d = "d"] rt gen;
	gen:	goto [d = "g"] test rf;
	test:	v := nth (desc, 3);
			w := nth (desc, 4);
			goto [(v = $$empty) and (w = $$empty)] rf rt;
	rt:		xret := $$t;
			goto rlab;
	rf:		xret := $$f;
	rlab:	skip
}
with
{
	ret : xret, rlab;
};

(* *** ISACCESSORDESCRIPTOR *** *)

proc i__isAccessorDescriptor (desc) {
			goto [desc = $$undefined] rf cont;
	cont:	d := nth (desc, 0);
			goto [d = "a"] rt gen;
	gen:	goto [d = "g"] test rf;
	test:	g := nth (desc, 5);
			s := nth (desc, 6);
			goto [(g = $$empty) and (s = $$empty)] rf rt;
	rt:		xret := $$t;
			goto rlab;
	rf:		xret := $$f;
	rlab:	skip
}
with
{
	ret : xret, rlab;
};

(* *** ISGENERICDESCRIPTOR *** *)

proc i__isGenericDescriptor (desc) {
			dd := "i__isDataDescriptor" (desc);
			ad := "i__isAccessorDescriptor" (desc);
			xret := not (dd or ad);
	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* *** TODATADESCRIPTOR *** *)

proc i__toDataDescriptor (desc) {
			d := nth (desc, 0);
			goto [d = "d"] rd cstr;
	
	cstr:	goto [d = "a"] ra gen;
	
	ra:		xret := {{ "d", $$undefined, $$f, nth (d, 3), nth (d, 4) }};
			goto rlab;
	
	gen:	e := nth (desc, 1);
			c := nth (desc, 2);
			v := nth (desc, 3);
			w := nth (desc, 4);
			
			goto [e = $$empty] fixe c;
	fixe:	e := $$f;
	c:		goto [c = $$empty] fixc v;
	fixc:	c := $$f;
	v:		goto [v = $$empty] fixv w;
	fixv:	v := $$undefined;
	w:		goto [w = $$empty] fixw fixed;
	fixw:	w := $$f;	
			
	fixed:	xret := {{ "d", v, w, e, c }};
			goto rlab;
	
	rd:		xret := desc;
	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* *** TOACCESSORDESCRIPTOR *** *)

proc i__toAccessorDescriptor (desc) {
			d := nth (desc, 0);
			goto [d = "a"] rd cstr;
	
	cstr:	goto [d = "d"] ac gen;
	
	ac:		xret := {{ "a", $$undefined, $$undefined, nth (d, 3), nth (d, 4) }};
			goto rlab;
	
	gen:	e := nth (desc, 1);
			c := nth (desc, 2);
			g := nth (desc, 5);
			s := nth (desc, 6);
			
			goto [e = $$empty] fixe c;
	fixe:	e := $$f;
	c:		goto [c = $$empty] fixc v;
	fixc:	c := $$f;
	v:		goto [g = $$empty] fixg w;
	fixg:	g := $$undefined;
	w:		goto [s = $$empty] fixs fixed;
	fixs:	s := $$undefined;	
			
	fixed:	xret := {{ "a", g, s, e, c }};
			goto rlab;
	
	rd:		xret := desc;
	rlab:	skip
}
with
{
	ret: 	xret, rlab;
};

(* *** FROMPROPERTYDESCRIPTOR *** *)

proc i__fromPropertyDescriptor (desc) {
			goto [desc = $$undefined] undef def;
	
	def:	xret := "Object_construct" ();
	
			dop := [xret, "@defineOwnProperty"];
	
			dd := "i__isDataDescriptor" (desc);
			goto [dd] dd is_ac;
			
	dd:		res := dop (xret, "value",    {{ "d", nth (desc, 1), $$t, $$t, $$t}}, $$f);
			res := dop (xret, "writable", {{ "d", nth (desc, 2), $$t, $$t, $$t}}, $$f);
			goto ec;
	
	is_ac:	ad := "i__isAccessorDescriptor" (desc);
			goto [ad] ad oops;
	
	ad:		res := dop (xret, "get", {{ "d", nth (desc, 1), $$t, $$t, $$t}}, $$f);
			res := dop (xret, "set", {{ "d", nth (desc, 2), $$t, $$t, $$t}}, $$f);
			
	ec:		res := dop (xret, "enumerable",   {{ "d", nth (desc, 3), $$t, $$t, $$t}}, $$f);
			res := dop (xret, "configurable", {{ "d", nth (desc, 4), $$t, $$t, $$t}}, $$f);
			goto rlab;
			
	oops:	xret := "fromPropertyDescriptor: This should not happen";
			goto rlab;
	
	undef:	xret := $$undefined;
	rlab:	skip
}
with
{
	ret: 	xret, rlab;
};

(* *** TOPROPERTYDESCRIPTOR *** *)

proc i__toPropertyDescriptor (v) {
			goto [typeOf(v) = $$object_type] init throw;
			
	init:	dv := $$empty;
			dw := $$empty;
			dg := $$empty;
			ds := $$empty;
			de := $$empty;
			dc := $$empty;
			
			hp := [v, "@hasProperty"];
			gt := [v, "@get"];
			
	has_de:	res := hp (v, "enumerable");
			goto [res] de has_dc;
	de:		xret := gt (v, "enumerable") with elab;
			de := xret;
			
	has_dc:	res := hp (v, "configurable");
			goto [res] dc has_dv;
	dc:		xret := gt (v, "configurable") with elab;
			dc := xret;
			
	has_dv:	res := hp (v, "value");
			goto [res] dv has_dw;
	dv:		xret := gt (v, "value") with elab;
			dv := xret;

	has_dw:	res := hp (v, "writable");
			goto [res] dw has_dg;
	dw:		xret := gt (v, "writable") with elab;
			dw := xret;

	has_dg:	res := hp (v, "get");
			goto [res] dg has_ds;
	dg:		xret := gt (v, "get") with elab;
			dg := xret;
			
	has_ds:	res := hp (v, "set");
			goto [res] ds check;
	ds:		xret := gt (v, "set") with elab;
			ds := xret;
			
	check:	goto [(not (dg = $$empty)) or (not (ds = $$empty))] vw return;
	vw:		goto [(not (dv = $$empty)) or (not (dw = $$empty))] throw return;
	
	return:	xret := {{ "g", de, dc, dv, dw, dg, ds }};
	
	rlab:	skip;
	
	throw:  xret := "TypeError" ();
    elab:   skip
	
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};





(* ******** *) 
(* GETVALUE *)
(* ******** *) 

proc i__getValue (v) {

			goto [(typeOf(v) = $$v-reference_type) or (typeOf(v) = $$o-reference_type)] init dflt;
	
	init:	rbase := base (v);
			rfield := field (v);
			goto [rbase = $$undefined] throw prim;
	
	prim:	goto [(is_primitive rbase) and (not (rbase = $$undefined)) and (not (rbase = $$null))] is_pr ref;
	
	is_pr:	xret := "i__toObject" (rbase) with elab;
			gp := [xret, "@get"];
			xret := gp (xret, rfield) with elab;
			goto rlab;
	
	ref:	goto [typeOf(v) = $$o-reference_type] oref vref;
	
	oref:	gp := [rbase, "@get"];
			xret := gp (rbase, rfield) with elab;
			goto rlab;
			
	vref:	goto [rbase = $lg] lg er;
	
	lg:		gp := [$lg, "@get"];
			xret := gp (rbase, rfield) with elab;
			goto rlab;
			
	er:		xret := [rbase, rfield];
			goto rlab;
	
	dflt:	xret := v;
	rlab:	skip;
	
	throw:  xret := "ReferenceError" ();
    elab:   skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* ******** *) 
(* PUTVALUE *)
(* ******** *) 

proc i__putValue (v, w) {

			goto [(typeOf(v) = $$v-reference_type) or (typeOf(v) = $$o-reference_type)] init throw;
	
	init:	rbase := base (v);
			rfield := field (v);
			goto [rbase = $$undefined] throw prim;
	
	prim:	goto [(is_primitive rbase) and (not (rbase = $$undefined)) and (not (rbase = $$null))] is_pr ref;
	
	ref:	goto [typeOf(v) = $$o-reference_type] oref vref;
	
	oref:	p := [rbase, "@put"];
			xret := p (rbase, rfield, w, $$t) with elab;
			goto dflt;
			
	vref:	goto [rbase = $lg] lg er;
	
	lg:		p := [$lg, "@put"];
			xret := p (rbase, rfield, w, $$t) with elab;
			goto dflt;
			
	er:		[rbase, rfield] := w;
			goto rlab;
	
	dflt:	xret := $$empty;
	rlab:	skip;
	
	throw:  xret := "ReferenceError" ();
    elab:   skip;
    
    		(* WHY GOD, WHY THIS? *)
    		
	is_pr:	xret := "i__toObject" (rbase) with elab;
			l := xret;
    		cp := [l, "@canPut"];
            xret := cp (l, rfield) with elab;
            goto [xret] cp reject;
            
    cp:     gp := [l, "@getProperty"];
    		xret := gp (l, rfield) with elab;
    		dd := "i__isDataDescriptor" (xret);
    		goto [dd] reject is_ad;
    		    		
   	is_ad: 	ad := "i__isAccessorDescriptor" (xret);
    		goto [ad] ad reject;
    		
    ad:		s := nth (xret, 2);
    		xsc := [s, "@scope"];
    		fun := [s, "@body"];
    		xret := fun (xsc, rbase, w) with elab;
    		goto dflt;
    
    reject: xret := "TypeError" ();
    		goto elab
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};






(* ********************** *) 
(* CONVERSIONS AND CHECKS *)
(* ********************** *) 

(* *** TOPRIMITIVE *** *)

proc i__toPrimitive (v, hint) {
			xret := v;

	iu:		goto [(v = $$undefined) or (v = $$null) or
	              (typeOf(v) = $$boolean_type) or (typeOf(v) = $$number_type) or
	              (typeOf(v) = $$string_type)] rlab is_obj;

	is_obj:	goto [typeOf(v) = $$object_type] obj oops;
	obj:	dv := [v, "@defaultValue"];
			xret := dv (v, hint) with elab;
			goto rlab;
	
	oops:	xret := "ToPrimitive: This should not happen.";
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** TOBOOLEAN *** *)

proc i__toBoolean (v) {
	iu:		goto [v = $$undefined] undef in;
	undef:	xret := $$f;
			goto rlab;
	
	in:		goto [v = $$null] null ib;
	null:	xret := $$f;
			goto rlab;
			
	ib:		goto [typeOf(v) = $$boolean_type] bool inum;
	bool:	xret := v;
			goto rlab;
			
	inum:	goto [typeOf(v) = $$number_type] num is;
	num:	goto [(v = 0) or (v = nan)] is_f is_t;
			
	is:		goto [typeOf(v) = $$string_type] str io;
	str:	goto [v = ""] is_f is_t;
			goto rlab;
			
	io:		goto [typeOf(v) = $$object_type] obj oops;
	obj:	xret := $$t;
			goto rlab;
	
	is_t:	xret := "true";
			goto rlab;
	is_f:	xret := "false";
			goto rlab;
			
	oops:	xret := "ToBoolean: This should not happen.";
	
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* *** TONUMBER *** *)

proc i__toNumber (v) {
	iu:		goto [v = $$undefined] undef in;
	undef:	xret := nan;
			goto rlab;
	
	in:		goto [v = $$null] null ib;
	null:	xret := 0;
			goto rlab;
			
	ib:		goto [typeOf(v) = $$boolean_type] bool inum;
	bool:	goto [v = $$t] is_t is_f;
	is_t:	xret := 1;
			goto rlab;
	is_f:	xret := 0;
			goto rlab;
			
	inum:	goto [typeOf(v) = $$number_type] num is;
	num:	xret := v;
			goto rlab;
			
	is:		goto [typeOf(v) = $$string_type] str io;
	str:	xret := string_to_num v;
			goto rlab;
			
	io:		goto [typeOf(v) = $$object_type] obj oops;
	obj:	xret := "i__toPrimitive" (v, "String") with elab;
			xret := "i__toNumber" (xret);
			goto rlab;
	
	oops:	xret := "ToNumber: This should not happen.";
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** TOSTRING *** *)

proc i__toString (v) {
	iu:		goto [v = $$undefined] undef in;
	undef:	xret := "undefined";
			goto rlab;
	
	in:		goto [v = $$null] null ib;
	null:	xret := "null";
			goto rlab;
			
	ib:		goto [typeOf(v) = $$boolean_type] bool inum;
	bool:	goto [v = $$t] is_t is_f;
	is_t:	xret := "true";
			goto rlab;
	is_f:	xret := "false";
			goto rlab;
			
	inum:	goto [typeOf(v) = $$number_type] num is;
	num:	xret := num_to_string v;
			goto rlab;
			
	is:		goto [typeOf(v) = $$string_type] str io;
	str:	xret := v;
			goto rlab;
			
	io:		goto [typeOf(v) = $$object_type] obj oops;
	obj:	xret := "i__toPrimitive" (v, "String") with elab;
			xret := "i__toString" (xret) with elab;
			goto rlab;
	
	oops:	xret := "ToString: This should not happen.";
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** TOOBJECT *** *)

proc i__toObject (v) {
	iu:		goto [v = $$undefined] throw in;
	
	in:		goto [v = $$null] throw ib;
			
	ib:		goto [typeOf(v) = $$boolean_type] bool inum;
	bool:	xret := "Boolean_construct" (v);
			goto rlab;
			
	inum:	goto [typeOf(v) = $$number_type] num is;
	num:	xret := "Number_construct" (v);
			goto rlab;
			
	is:		goto [typeOf(v) = $$string_type] str io;
	str:	xret := "String_construct" (v);
			goto rlab;
			
	io:		goto [typeOf(v) = $$object_type] obj oops;
	obj:	xret := v;
			goto rlab;
	
	oops:	xret := "ToObject: This should not happen.";
	
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* ******************** *) 
(* CHECKOBJECTCOERCIBLE *)
(* ******************** *) 

proc i__checkObjectCoercible (l) {

			xret := $$empty;

	iu:		goto [v = $$undefined] throw in;
	
	in:		goto [v = $$null] throw other;
			
	other:	goto [(typeOf(v) = $$boolean_type) or (typeOf(v) = $$number_type) or 
	              (typeOf(v) = $$string_type) or (typeOf(v) = $$object_type)] rlab oops;
	
	oops:	xret := "CheckObjectCoercible: This should not happen.";
	
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* ********** *) 
(* ISCALLABLE *)
(* ********** *) 

proc i__isCallable (l) {
			goto [typeOf (l) = $$object_type] obj endf; 
	obj:	xret := hasField (l, "@body");
			goto rlab;
	endf:	xret := $$f;
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};







(* ***************** *) 
(* THE GLOBAL OBJECT *)
(* ***************** *) 

(* *** ISNAN *** *)

proc Object_isNan (xsc, vthis, v) {
			xret := "i__toNumber" (v) with elab;
			goto [not (xret = xret)] r_t r_f;
			
	r_t:	xret := $$t;
			goto rlab;
			
	r_f:	xret := $$f;
			
	rlab:	skip;
	elab:	skip
} 
with 
{
	ret:	xret, rlab;
	err:	xret, rlab;
};


(* *** ISFINITE *** *)

proc Object_isFinite (xsc, vthis, v) {
			xret := "i__toNumber" (v) with elab;
			goto [(not (xret = xret)) or (xret = inf) or (xret = -inf)] r_f r_t;
			
	r_t:	xret := $$t;
			goto rlab;
			
	r_f:	xret := $$f;
			
	rlab:	skip;
	elab:	skip
} 
with 
{
	ret:	xret, rlab;
	err:	xret, rlab;
};



(* ****************** *) 
(* THE OBJECT LIBRARY *)
(* ****************** *) 

(* *** GETFIELDS *** *)

proc i__getFields (l) {
			xret := getFields (l);
			
			class := [l, "@class"];
			goto [class = "String"] add rlab;

	add:	str := [l, "@primitiveValue"];
			len := length (str);
			
			n := len - 1;
			
			gop := [l, "@getOwnProperty"];
						
	loop:	goto [n < 0] rlab head;
	head:	sn := num_to_string n;
			xret := sn :: xret;
			n := n - 1;
			goto loop;
			
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* *** GETOWNFIELDS *** *)

proc i__getOwnFields (l) {
			prop_list := "i__getFields" (l);
			xret := "i__getOwnFieldsIter" (prop_list);
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* *** GETOWNFIELDSITER *** *)

proc i__getOwnFieldsIter (prop_list) {
			goto [prop_list = $$nil] nil init;
			
	nil:	xret := $$nil;
			goto rlab;	
	
	init:	xh := car prop_list;
			xt := cdr prop_list;
			
			goto [nth (xh, 0) = "@"] no yes;
	
	no:		fh := $$nil;
			goto rcall;	
			
	yes:	fh := xh;
			
	rcall:	ft := "i__getOwnFieldsIter" (xt);
			
			xret := fh :: ft;
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* *** GETENUMERABLEFIELDS *** *)

proc i__getEnumerableFields (l) {
			prop_list := "i__getOwnFields" (l);
			
			gop := [l, "@getOwnProperty"];			
			xret := "i__getEnumerableFieldsIter" (l, prop_list, gop);
	
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* *** GETENUMERABLEFIELDSITER *** *)

proc i__getEnumerableFieldsIter (l, prop_list, gop) {
			goto [prop_list = $$nil] nil init;
			
	nil:	xret := $$nil;
			goto rlab;	
	
	init:	xh := car prop_list;
			xt := cdr prop_list;
			
			prop := gop (l, xh);
			goto [nth (prop, 3) = $$t] yes no;
	
	no:		fh := $$nil;
			goto rcall;	
			
	yes:	fh := xh;
			
	rcall:	ft := "i__getEnumerableFieldsIter" (l, xt, gop);
			
			xret := fh :: ft;
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* *** GETENUMERABLEFIELDSWITHVALUES *** *)

proc i__getEnumerableFieldsWithValues (l) {
			prop_list := "i__getEnumerableFields" (l);
			
			g := [l, "@get"];			
			xret := "i__getEnumerableFieldsWithValuesIter" (l, prop_list, g) with elab;
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** GETENUMERABLEFIELDSWITHVALUESITER *** *)

proc i__getEnumerableFieldsWithValuesIter (l, prop_list, g) {
			goto [prop_list = $$nil] nil init;
			
	nil:	xret := {{ $$nil, $$nil }};
			goto rlab;
	
	init:	xh := car prop_list;
			xt := cdr prop_list;
			
			xret := g (l, xh) with elab;
			xret := "i__toPropertyDescriptor" (xret) with elab;
			
			fh := xret;
			
	rcall:	xret := "i__getEnumerableFieldsIter" (l, xt, gop) with elab;
			
			xret := {{ prop_list , (fh :: nth (xret, 1)) }};
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};



(* *** CALL *** *)

proc Object_call (v) {
			goto [(v = $$undefined) or (v = $$null) or (v = $$empty)] cons to_obj;
	
	cons:	xret := "Object_construct" (v);
			goto rlab;
	
	to_obj:	xret := "i__toObject" (v);

	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* *** CONSTRUCT *** *)

proc Object_construct (l) {
			goto [typeOf(l) = $$object_type] obj l1b;
	obj:	xret := l;
			goto rlab;
			
	l1b:	goto [(typeOf(l) = $$boolean_type) or (typeOf(l) = $$number_type) or (typeOf(l) = $$string_type)] to_obj norm;
	to_obj:	xret := "i__toObject" (l);
			goto rlab;

	norm:	xret := new ();
			xret := "create_default_object" (xret, $lobj_proto, "Object", $$t);		
	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* *** GETPROTOTYPEOF *** *)

proc Object_getPrototypeOf (xsc, vthis, o) {
			goto [typeOf(o) = $$object_type] proto throw;
			
	proto:	xret := [o, "@proto"];
			
	rlab:	skip;
	
	throw:	xerr := "TypeError" ();
	elab:	skip
} 
with 
{
	ret:	xret, rlab;
	err:	xerr, rlab;
};

(* *** GETOWNPROPERTYDESCRIPTOR *** *)

proc Object_getOwnPropertyDescriptor (xsc, vthis, o, prop) {
			goto [typeOf(o) = $$object_type] start throw;
			
	start:	xret := "i__toString" (prop) with elab;
			gop := [o, "@getOwnProperty"];
			xret := gop (o, xret) with elab;
			
			xret := "i__fromPropertyDescriptor" (xret) with elab;
			
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
} 
with 
{
	ret:	xret, rlab;
	err:	xret, rlab;
};

(* *** GETOWNPROPERTYNAMES *** *)

proc Object_getOwnPropertyNames (xsc, vthis, o) {
			goto [not (typeOf(o) = $$object_type)] throw start;

	start:	xret := "Array_construct" () with elab;
			
			n := 0;
			l := xret;
			props := "i__getOwnFields" (o);
			len := length (props);
			
			dop := [xret, "@defineOwnProperty"];
			
	loop:	goto [n < len] head end;
	head:	xret := dop (l, num_to_string n, {{ "d", nth (props, n), $$t, $$t, $$t }}, $$f) with elab;
			n := n + 1;
			goto loop;

	end:	xret := l;
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** CREATE *** *)

proc Object_create (xsc, vthis, o, props) {
			goto [(typeOf(o) = $$object_type) or (o = $$null)] main throw;
			
	main:	xret := "Object_construct" () with elab;
			[xret, "@prototype"] := o;
			
			goto [props = $$empty] rlab props;
			
	props:	xret := "Object_defineProperties" (xret, props) with elab;
			
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** DEFINEPROPERTY *** *)

proc Object_defineProperty (xsc, vthis, o, prop, attr) {
			goto [typeOf(o) = $$object_type] main throw;
			
	main:	xret := "i__toString" (prop) with elab;
			prop := xret;
			
			xret := "i__toPropertyDescriptor" (attr) with elab;
			
			dop := [o, "@defineOwnProperty"];
			xret := dop (o, prop, xret, $$t) with elab;
	
	end:	xret := o;
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** DEFINEPROPERTIES *** *)

proc Object_defineProperties (xsc, vthis, o, props) {
			goto [not (typeOf(o) = $$object_type)] throw start;

	start:	xret := "i__toObject" (props) with elab;
			props := xret;
			
			xret := "i__getEnumerableFieldsWithValues" (props) with elab;
			
			props := nth (xret, 0);
			descs := nth (xret, 1);
			
			n := 0;
			len := length (props);
			
	loop:	goto [n < len] head end;
	head:	xret := dop (l, nth (props, n), nth (descs, n), $$t) with elab;
			n := n + 1;
			goto loop;

	end:	xret := o;
	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** PREVENTEXTENSIONS *** *)

proc Object_preventExtensions (xsc, vthis, o) {
			goto [typeOf(o) = $$object_type] start throw;
	
	start:	[o, "@extensible"] := $$f;
			xret := o;
			
	rlab: 	skip;
	 
	throw:	xerr := "TypeError" ();
	elab: 	skip
}
with
{
	ret: 	xret, rlab;
	err:	xerr, elab;
};


(* *** ISEXTENSIBLE *** *)

proc Object_isExtensible (xsc, vthis, o) {
			goto [typeOf(o) = $$object_type] start throw;
			
	start: 	xret := [o, "@extensible"];
	rlab:	skip;		

	throw:	xerr := "TypeError" ();
	elab: 	skip
}
with
{
	ret: 	xret, rlab;
	err:	xerr, elab;
};

(* *** KEYS *** *)

proc Object_keys (xsc, vthis, o) {
			goto [not (typeOf(o) = $$object_type)] throw start;

	start:	xret := "Array_construct" () with elab;
			
			n := 0;
			l := xret;
			props := "i__getEnumerableFields" (o);
			len := length (props);
			
			dop := [xret, "@defineOwnProperty"];
			
	loop:	goto [n < len] head end;
	head:	xret := dop (l, num_to_string n, {{ "d", nth (props, n), $$t, $$t, $$t }}, $$f) with elab;
			n := n + 1;
			goto loop;

	end:	xret := l;
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};




(* ***************** *) 
(* THE ARRAY LIBRARY *)
(* ***************** *) 

(* *** CALL *** *)

proc Array_call () {
			xret := "Array_construct" () with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};

(* *** CONSTRUCT *** *)

proc Array_construct () {

			xret := new ();
			xret := "create_default_object" (xret, $larr_proto, "Array", $$t);
			
			x := "o__defineOwnProperty" (xret, "length", {{ "d", 0, $$f, $$f, $$f }}, $$t); 
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};






(* ****************** *) 
(* THE STRING LIBRARY *)
(* ****************** *) 

(* *** GETOWNPROPERTY *** *)

proc s__getOwnProperty (l, prop) {
			xret := "o__getOwnProperty" (l, prop);
			goto [xret = $$undefined] str rlab;
			
	str:	idx := num_to_int (string_to_num prop);
			sidx := num_to_string (idx);
	
			goto [sidx = prop] index rlab;
	
	index:	str := [l, "@primitiveValue"];
			len := "o__get" (l, "length");
			goto [len <= idx] rlab return;
			
	return: rstr := nth (str, idx);
			xret := {{ "d", rstr, $$f, $$t, $$f }};
	
	rlab: 	skip
}
with
{
	ret: xret, rlab;
};

(* *** CALL *** *)

proc String_call (s) {
			goto [s = $$empty] empty to_str;
	
	empty:	xret := "";
			goto rlab;
	
	to_str:	xret := "i__toString" (s);
			
	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* *** CONSTRUCT *** *)

proc String_construct (s) {
			goto [s = $$empty] empty to_str;
	empty:	pv := ""; 
			goto norm;
	to_str:	pv := "i__toString" (s) with elab;

	norm:	xret := new ();
			xret := "create_default_object" (xret, $lstr_proto, "String", $$t);
			
			[xret, "@getOwnProperty"] := "s__getOwnProperty";
			[xret, "@primitiveValue"] := pv;
			
			x := "o__defineOwnProperty" (xret, "length", {{ "d", (length pv), $$f, $$f, $$f }}, $$t); 
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};











(* ******************* *) 
(* THE BOOLEAN LIBRARY *)
(* ******************* *) 

(* *** CALL *** *)

proc Boolean_call (v) {
	rlab:	xret := "i__toBoolean" (v)
}
with
{
	ret: xret, rlab;
};

(* *** CONSTRUCT *** *)

proc Boolean_construct (v) {
			pv := "i__toBoolean" (v);
			
			xret := new ();
			xret := "create_default_object" (xret, $lbool_proto, "Boolean", $$t);
			
			[xret, "@primitiveValue"] := pv;
						
	rlab:	skip
}
with
{
	ret: xret, rlab;
};









(* ****************** *) 
(* THE NUMBER LIBRARY *)
(* ****************** *) 

(* *** CALL *** *)

proc Number_call (v) {
			goto [v = $$empty] zero rlab;
	zero:	v := 0;
			
	rlab:	xret := "i__toNumber" (v) with elab;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* *** CONSTRUCT *** *)

proc Number_construct (v) {
			goto [v = $$empty] zero init;
	zero:	v := 0;
			
	init:	pv := "i__toNumber" (v) with elab;
			
			xret := new ();
			xret := "create_default_object" (xret, $lnum_proto, "Number", $$t);
			
			[xret, "@primitiveValue"] := pv;
						
	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: pv, elab;
};











(* **** *) 
(* MAIN *)
(* **** *) 

proc create_default_object (l, pr, cl, ext) {
			
			[l, "@proto"] := pr;
			[l, "@class"] := cl;
			[l, "@extensible"] := ext;
			
			[l, "@getOwnProperty"]    := "o__getOwnProperty";
			[l, "@getProperty"]       := "o__getProperty";
			[l, "@get"]               := "o__get";
			[l, "@canPut"]            := "o__canPut";
			[l, "@put"]               := "o__put";
			[l, "@hasProperty"]       := "o__hasProperty";
			[l, "@deleteProperty"]    := "o__deleteProperty";
			[l, "@defaultValue"]      := "o__defaultValue";
			[l, "@defineOwnProperty"] := "o__defineOwnProperty";
			
			[l, "@primitiveValue"]   := $$empty;
			[l, "@construct"]        := $$empty;
			[l, "@call"]             := $$empty;
			[l, "@hasInstance"]      := $$empty;
			[l, "@scope"]            := $$empty;
			[l, "@formalParameters"] := $$empty;
			[l, "@body"]             := $$empty;
			[l, "@targetFunction"]   := $$empty;
			[l, "@boundThis"]        := $$empty;
			[l, "@boundArguments"]   := $$empty;
			[l, "@match"]            := $$empty;
			[l, "@parameterMap"]     := $$empty;

	rlab:	xret := l
}
with
{
	ret:	xret, rlab;
};

proc create_object_with_body (l, proc_body, len) {
			
			xret := "create_default_object" (l, $lfun_proto, "Function", $$t);
			
			[xret, "length"] := {{ "d", len, $$f, $$f, $$f }};

	ibody:	goto [proc_body = $$empty] rlab body;
	body:	[xret, "@body"] := proc_body;

	rlab:	xret := l
}
with
{
	ret:	xret, rlab;
};

proc setupInitialHeap () {

			(* Global object *)
			
			xret := "create_default_object" ($lg, $$null, "Object", $$t);
			
  			[$lg, "NaN"]                := {{ "d", nan, $$f, $$f, $$f }};
  			[$lg, "Infinity"]           := {{ "d", inf, $$f, $$f, $$f }};
  			[$lg, "undefined"]          := {{ "d", $$undefined, $$f, $$f, $$f }};
  			
  			[$lg, "eval"]               := {{ "d", $lg_eval, $$t, $$f, $$t }};
  			[$lg, "parseInt"]           := {{ "d", $lg_parseInt, $$t, $$f, $$t }};
  			[$lg, "parseFloat"]         := {{ "d", $lg_parseFloat, $$t, $$f, $$t }};
  			[$lg, "isNaN"]              := {{ "d", $lg_isNan, $$t, $$f, $$t }};
  			[$lg, "isFinite"]           := {{ "d", $lg_isFinite, $$t, $$f, $$t }};
  			[$lg, "decodeURI"]          := {{ "d", $lg_decodeURI, $$t, $$f, $$t }};
  			[$lg, "decodeURIComponent"] := {{ "d", $lg_decodeURIComponent, $$t, $$f, $$t }};
  			[$lg, "encodeURI"]          := {{ "d", $lg_encodeURI, $$t, $$f, $$t }};
  			[$lg, "encodeURIComponent"] := {{ "d", $lg_encodeURIComponent, $$t, $$f, $$t }};
  			[$lg, "Object"]             := {{ "d", $lobj, $$t, $$f, $$t }};
  			[$lg, "Function"]           := {{ "d", $lfun, $$t, $$f, $$t }};
 			[$lg, "Array"]              := {{ "d", $larr, $$t, $$f, $$t }};
  			[$lg, "String"]             := {{ "d", $lstr, $$t, $$f, $$t }};
  			[$lg, "Boolean"]            := {{ "d", $lbool, $$t, $$f, $$t }};
  			[$lg, "Number"]             := {{ "d", $lnum, $$t, $$f, $$t }};
  			[$lg, "Math"]               := {{ "d", $lmath, $$t, $$f, $$t }};
  			[$lg, "Date"]               := {{ "d", $ldate, $$t, $$f, $$t }}; 
 			[$lg, "RegExp"]             := {{ "d", $lregexp, $$t, $$f, $$t }}; 
  			[$lg, "Error"]              := {{ "d", $lerr, $$t, $$f, $$t }};
			[$lg, "EvalError"]          := {{ "d", $lerr_e, $$t, $$f, $$t }};
  			[$lg, "RangeError"]         := {{ "d", $lerr_rg, $$t, $$f, $$t }};
  			[$lg, "ReferenceError"]     := {{ "d", $lerr_rf, $$t, $$f, $$t }};
  			[$lg, "SyntaxError"]        := {{ "d", $lerr_s, $$t, $$f, $$t }};
  			[$lg, "TypeError"]          := {{ "d", $lerr_t, $$t, $$f, $$t }};
  			[$lg, "URIError"]           := {{ "d", $lerr_u, $$t, $$f, $$t }};
  			[$lg, "JSON"]               := {{ "d", $ljson, $$t, $$f, $$t }};
  			
  			xret := "create_object_with_body" ($lg_isNan, "Object_isNan", 1);
  			xret := "create_object_with_body" ($lg_isFinite, "Object_isFinite", 1);
  			
  			(* Object object *)
    			
  			xret := "create_object_with_body" ($lobj, $$empty, 1);
  			
  			[$lobj, "prototype"]                := {{ "d", $lobj_proto, $$f, $$f, $$f }};
			[$lobj, "getPrototypeOf"]           := {{ "d", $lobj_getPrototypeOf, $$t, $$f, $$t }};
			[$lobj, "getOwnPropertyDescriptor"] := {{ "d", $lobj_getOwnPropertyDescriptor, $$t, $$f, $$t }};
			[$lobj, "getOwnPropertyNames"]      := {{ "d", $lobj_getOwnPropertyNames, $$t, $$f, $$t }};
			[$lobj, "create"]                   := {{ "d", $lobj_create, $$t, $$f, $$t }};
			[$lobj, "defineProperty"]           := {{ "d", $lobj_defineProperty, $$t, $$f, $$t }};
			[$lobj, "defineProperties"]         := {{ "d", $lobj_defineProperties, $$t, $$f, $$t }};
			[$lobj, "seal"]                     := {{ "d", $lobj_seal, $$t, $$f, $$t }};
			[$lobj, "freeze"]                   := {{ "d", $lobj_freeze, $$t, $$f, $$t }};
			[$lobj, "preventExtensions"]        := {{ "d", $lobj_preventExtensions, $$t, $$f, $$t }};
			[$lobj, "isSealed"]                 := {{ "d", $lobj_isSealed, $$t, $$f, $$t }};
			[$lobj, "isFrozen"]                 := {{ "d", $lobj_isFrozen, $$t, $$f, $$t }};
			[$lobj, "isExtensible"]             := {{ "d", $lobj_isExtensible, $$t, $$f, $$t }};
			[$lobj, "keys"]                     := {{ "d", $lobj_keys, $$t, $$f, $$t }};
			
			xret := "create_object_with_body" ($lobj_getPrototypeOf, "Object_getPrototypeOf", 1);
  			xret := "create_object_with_body" ($lobj_getOwnPropertyNames, "Object_getOwnPropertyNames", 1);
			xret := "create_object_with_body" ($lobj_create, "Object_create", 1);
  			xret := "create_object_with_body" ($lobj_defineProperty, "Object_defineProperty", 1);
 			xret := "create_object_with_body" ($lobj_defineProperties, "Object_defineProperty", 1);
  			xret := "create_object_with_body" ($lobj_seal, "Object_seal", 1);
 			xret := "create_object_with_body" ($lobj_freeze, "Object_freeze", 1);
  			xret := "create_object_with_body" ($lobj_preventExtensions, "Object_preventExtensions", 1);
  			xret := "create_object_with_body" ($lobj_isSealed, "Object_isSealed", 1);
 			xret := "create_object_with_body" ($lobj_isFrozen, "Object_isFrozen", 1);
  			xret := "create_object_with_body" ($lobj_isExtensible, "Object_isExtensible", 1);
  			xret := "create_object_with_body" ($lobj_keys, "Object_keys", 1);
			
			(* Object.prototype *)
			
			xret := "create_default_object" ($lobj_proto, $$null, "Object", $$t);
			
			[$lobj_proto, "constructor"]          := {{ "d", $lop_constructor, $$t, $$f, $$t }};
			[$lobj_proto, "toString"]             := {{ "d", $lop_toString, $$t, $$f, $$t }};
			[$lobj_proto, "toLocaleString"]       := {{ "d", $lop_toLocaleString, $$t, $$f, $$t }};
			[$lobj_proto, "valueOf"]              := {{ "d", $lop_valueOf, $$t, $$f, $$t }};
			[$lobj_proto, "hasOwnProperty"]       := {{ "d", $lop_hasOwnProperty, $$t, $$f, $$t }};
			[$lobj_proto, "isPrototypeOf"]        := {{ "d", $lop_isPrototypeOf, $$t, $$f, $$t }};
			[$lobj_proto, "propertyIsEnumerable"] := {{ "d", $lop_propertyIsEnumerable, $$t, $$f, $$t }};

			xret := "create_object_with_body" ($lop_constructor, "Object_construct", 1);
			xret := "create_object_with_body" ($lop_toString, "OP_toString", 0);
  			xret := "create_object_with_body" ($lop_toLocaleString, "OP_toLocaleString", 0);
			xret := "create_object_with_body" ($lop_valueOf, "OP_valueOf", 0);
  			xret := "create_object_with_body" ($lop_hasOwnProperty, "OP_hasOwnProperty", 1);
 			xret := "create_object_with_body" ($lop_isPrototypeOf, "OP_isPrototypeOf", 1);
  			xret := "create_object_with_body" ($lop_propertyIsEnumerable, "OP_propertyIsEnumerable", 1);
  			
  			
  			
  			(* Array object *)
    			
  			xret := "create_object_with_body" ($larr, $$empty, 1);
  			
  			[$larr, "prototype"] := {{ "d", $larr_proto, $$f, $$f, $$f }};
  			[$larr, "isArray"]   := {{ "d", $larr_isArray, $$t, $$f, $$t }};
			
			xret := "create_object_with_body" ($larr_isArray, "Array_isArray", 1);
			
			(* Array.prototype *)
			
			xret := "create_default_object" ($larr_proto, $lobj_proto, "Array", $$t);
			
			[$larr_proto, "constructor"]    := {{ "d", $lap_constructor, $$t, $$f, $$t }};
			[$larr_proto, "toString"]       := {{ "d", $lap_toString, $$t, $$f, $$t }};
			[$larr_proto, "toLocaleString"] := {{ "d", $lap_toLocaleString, $$t, $$f, $$t }};
			[$larr_proto, "concat"]         := {{ "d", $lap_concat, $$t, $$f, $$t }};
			[$larr_proto, "join"]           := {{ "d", $lap_join, $$t, $$f, $$t }};
			[$larr_proto, "pop"]            := {{ "d", $lap_pop, $$t, $$f, $$t }};
			[$larr_proto, "push"]           := {{ "d", $lap_push, $$t, $$f, $$t }};
			[$larr_proto, "reverse"]        := {{ "d", $lap_reverse, $$t, $$f, $$t }};
			[$larr_proto, "shift"]          := {{ "d", $lap_shift, $$t, $$f, $$t }};
			[$larr_proto, "slice"]          := {{ "d", $lap_slice, $$t, $$f, $$t }};
			[$larr_proto, "sort"]           := {{ "d", $lap_sort, $$t, $$f, $$t }};
			[$larr_proto, "splice"]         := {{ "d", $lap_splice, $$t, $$f, $$t }};
			[$larr_proto, "unshift"]        := {{ "d", $lap_unshift, $$t, $$f, $$t }};
			[$larr_proto, "indexOf"]        := {{ "d", $lap_indexOf, $$t, $$f, $$t }};
			[$larr_proto, "lastIndexOf"]    := {{ "d", $lap_lastIndexOf, $$t, $$f, $$t }};
			[$larr_proto, "every"]          := {{ "d", $lap_every, $$t, $$f, $$t }};
			[$larr_proto, "some"]           := {{ "d", $lap_some, $$t, $$f, $$t }};
			[$larr_proto, "forEach"]        := {{ "d", $lap_forEach, $$t, $$f, $$t }};
			[$larr_proto, "map"]            := {{ "d", $lap_map, $$t, $$f, $$t }};
			[$larr_proto, "filter"]         := {{ "d", $lap_filter, $$t, $$f, $$t }};
			[$larr_proto, "reduce"]         := {{ "d", $lap_reduce, $$t, $$f, $$t }};
			[$larr_proto, "reduceRight"]    := {{ "d", $lap_reduceRight, $$t, $$f, $$t }};
			
			xret := "create_object_with_body" ($lop_constructor, "Array_construct", 1);
			
			xret := "create_object_with_body" ($lap_constructor, "Array_construct", 1);
			xret := "create_object_with_body" ($lap_toString, "AP_toString", 1);
			xret := "create_object_with_body" ($lap_toLocaleString, "AP_toLocaleString", 1);
			xret := "create_object_with_body" ($lap_concat, "AP_concat", 1);
			xret := "create_object_with_body" ($lap_join, "AP_join", 1);
			xret := "create_object_with_body" ($lap_pop, "AP_pop", 1);
			xret := "create_object_with_body" ($lap_push, "AP_push", 1);
			xret := "create_object_with_body" ($lap_reverse, "AP_reverse", 1);
			xret := "create_object_with_body" ($lap_shift, "AP_shift", 1);
			xret := "create_object_with_body" ($lap_slice, "AP_slice", 1);
			xret := "create_object_with_body" ($lap_sort, "AP_sort", 1);
			xret := "create_object_with_body" ($lap_splice, "AP_splice", 1);
			xret := "create_object_with_body" ($lap_unshift, "AP_unshift", 1);
			xret := "create_object_with_body" ($lap_indexOf, "AP_indexOf", 1);
			xret := "create_object_with_body" ($lap_lastIndexOf, "AP_lastIndexOf", 1);
			xret := "create_object_with_body" ($lap_every, "AP_every", 1);
			xret := "create_object_with_body" ($lap_some, "AP_some", 1);
			xret := "create_object_with_body" ($lap_forEach, "AP_forEach", 1);
			xret := "create_object_with_body" ($lap_map, "AP_map", 1);
			xret := "create_object_with_body" ($lap_filter, "AP_filter", 1);
			xret := "create_object_with_body" ($lap_reduce, "AP_reduce", 1);
			xret := "create_object_with_body" ($lap_reduceRight, "AP_reduceRight", 1);



			(* Boolean object *)
			
			xret := "create_object_with_body" ($lbool, $$empty, 1);
			
			[$lbool, "prototype"] := {{ "d", $lbool_proto, $$f, $$f, $$f }};

			(* Boolean.prototype *)
			
			xret := "create_default_object" ($lbool_proto, $lobj_proto, "Boolean", $$t);
			
			[$lbool_proto, "constructor"] := {{ "d", $lbp_constructor, $$t, $$f, $$t }};
			[$lbool_proto, "toString"]    := {{ "d", $lbp_toString, $$t, $$f, $$t }};
			[$lbool_proto, "valueOf"]     := {{ "d", $lbp_valueOf, $$t, $$f, $$t }};
			
			
			
			(* Number object *)
			
			xret := "create_object_with_body" ($lnum, $$empty, 1);

			[$lnum, "prototype"]         := {{ "d", $lnum_proto, $$f, $$f, $$f }};
			[$lnum, "MAX_VALUE"]         := {{ "d", 0, $$f, $$f, $$f }};
			[$lnum, "MIN_VALUE"]         := {{ "d", 0, $$f, $$f, $$f }};
			[$lnum, "NaN"]               := {{ "d", nan, $$f, $$f, $$f }};
			[$lnum, "POSITIVE_INFINITY"] := {{ "d", inf, $$f, $$f, $$f }};
			[$lnum, "NEGATIVE_INFINITY"] := {{ "d", -inf, $$f, $$f, $$f }};
			
			(* Number.prototype *)
			
			xret := "create_default_object" ($lnum_proto, $lobj_proto, "Number", $$t);
			
			[$lnum_proto, "constructor"]          := {{ "d", $lnp_constructor, $$t, $$f, $$t }};
			[$lnum_proto, "toString"]             := {{ "d", $lnp_toString, $$t, $$f, $$t }};
			[$lnum_proto, "toLocaleString"]       := {{ "d", $lnp_toLocaleString, $$t, $$f, $$t }};
			[$lnum_proto, "valueOf"]              := {{ "d", $lnp_valueOf, $$t, $$f, $$t }};
			[$lnum_proto, "toFixed"]              := {{ "d", $lnp_toFixed, $$t, $$f, $$t }};
			[$lnum_proto, "toExponential"]        := {{ "d", $lnp_toExponential, $$t, $$f, $$t }};
			[$lnum_proto, "toPrecision"]          := {{ "d", $lnp_toPrecision, $$t, $$f, $$t }};
			
			
			
			(* String object *)
			
			xret := "create_object_with_body" ($lstr, $$empty, 1);
			
			[$lstr, "prototype"]    := {{ "d", $lstr_proto, $$f, $$f, $$f }};
			[$lstr, "fromCharCode"] := {{ "d", $lstr_fromCharCode, $$t, $$f, $$t }};
			
			(* String.prototype *)
			
			xret := "create_default_object" ($lstr_proto, $lobj_proto, "String", $$t);
			
			[$lstr_proto, "constructor"]       := {{ "d", $lsp_constructor, $$t, $$f, $$t }};
			[$lstr_proto, "toString"]          := {{ "d", $lsp_toString, $$t, $$f, $$t }};
			[$lstr_proto, "valueOf"]           := {{ "d", $lsp_valueOf, $$t, $$f, $$t }};
			[$lstr_proto, "charAt"]            := {{ "d", $lsp_charAt, $$t, $$f, $$t }};
			[$lstr_proto, "charCodeAt"]        := {{ "d", $lsp_charCodeAt, $$t, $$f, $$t }};
			[$lstr_proto, "concat"]            := {{ "d", $lsp_concat, $$t, $$f, $$t }};
			[$lstr_proto, "indexOf"]           := {{ "d", $lsp_indexOf, $$t, $$f, $$t }};
			[$lstr_proto, "lastIndexOf"]       := {{ "d", $lsp_lastIndexOf, $$t, $$f, $$t }};
			[$lstr_proto, "localeCompare"]     := {{ "d", $lsp_localeCompare, $$t, $$f, $$t }};
			[$lstr_proto, "match"]             := {{ "d", $lsp_match, $$t, $$f, $$t }};
			[$lstr_proto, "replace"]           := {{ "d", $lsp_replace, $$t, $$f, $$t }};
			[$lstr_proto, "search"]            := {{ "d", $lsp_search, $$t, $$f, $$t }};
			[$lstr_proto, "slice"]             := {{ "d", $lsp_slice, $$t, $$f, $$t }};
			[$lstr_proto, "split"]             := {{ "d", $lsp_split, $$t, $$f, $$t }};
			[$lstr_proto, "substring"]         := {{ "d", $lsp_substring, $$t, $$f, $$t }};
			[$lstr_proto, "toLowerCase"]       := {{ "d", $lsp_toLowerCase, $$t, $$f, $$t }};
			[$lstr_proto, "toLocaleLowerCase"] := {{ "d", $lso_toLocaleLowerCase, $$t, $$f, $$t }};
			[$lstr_proto, "toUpperCase"]       := {{ "d", $lsp_toUpperCase, $$t, $$f, $$t }};
			[$lstr_proto, "toLocaleUpperCase"] := {{ "d", $lsp_toLocaleUpperCase, $$t, $$f, $$t }};
			[$lstr_proto, "trim"]              := {{ "d", $lsp_trim, $$t, $$f, $$t }};
			
	rlab:	xret := $$empty
}
with
{
	ret:	xret, rlab;
};





proc test_set (scp, l, v)
{
			[$lg, "oopsie"] := v;
	rlab:	xret := $$t
}
with
{
	ret:	xret, rlab;
};

proc main () {

			xret := "setupInitialHeap" ();
			
			l := "String_construct" ("abc");
			
			[l, "value"] := {{ "d", 256, $$t, $$t, $$t }};
			[l, "writable"] := {{ "d", $$f, $$t, $$f, $$t }};
			[l, "configurable"] := {{ "d", $$t, $$t, $$f, $$t }};

			(*
			
			xret := "o__put" ($lobj_proto, "test", "oogaBooga");
						
			[$lg, "@proto"] := $lobj_proto;
			
			xret := "o__defineOwnProperty" ($lobj_proto, "test_put", {{ "a", $$undefined, lfun, $$t, $$t, $$t }}, $$f);
			
			xret := "i__getValue" (v-ref($lg, "test"));
			
			xret := "i__putValue" (v-ref($$t, "test_put"), 2);
			
			xret := "i__getValue" (o-ref($lnum, "POSITIVE_INFINITY"));
			
			xret := "Object_isFinite" (3 - inf);
			
			xret := "Object_getOwnPropertyDescriptor" ($$empty, $$empty, $lobj_proto, "toString"); 
			
			xret := "i__getEnumerableFields" (l);
			
			xret := "Object_preventExtensions" ($$empty, $$empty, $lg);
			*)
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
}