import Internals;

(* ****************** *) 
(* THE STRING LIBRARY *)
(* ****************** *) 

(* *** GETOWNPROPERTY *** *)

proc s__getOwnProperty (l, prop) {
			xret := "o__getOwnProperty" (l, prop);
			goto [xret = $$undefined] str rlab;
			
	str:	idx := "i__toInteger" (prop) with elab;
			goto [idx < 0] rlab next;
			
	next:	sidx := "i__toString" (idx);
	
			goto [sidx = prop] index rlab;
	
	index:	str := [l, "@primitiveValue"];
			len := s-len (str);
			goto [len <= idx] rlab return;
			
	return: rstr := s-nth (str, idx);
			xret := {{ "d", rstr, $$f, $$t, $$f }};
	
	rlab: 	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** CALL *** *)

proc String_call (xsc, vthis, s) {
			la := args;
			len := l-len (la);
			
			goto [len < 3] empty to_str;
	
	empty:	xret := "";
			goto rlab;
	
	to_str:	xret := "i__toString" (s) with elab;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** CONSTRUCT *** *)

proc String_construct (xsc, vthis, s) {
			la := args;
			len := l-len (la);
			
			goto [len < 3] empty to_str;
	empty:	pv := ""; 
			goto norm;
	to_str:	xret := "i__toString" (s) with elab;
			pv := xret;

	norm:	xret := new ();
			xret := "create_default_object" (xret, $lstr_proto, "String", $$t);
			s := xret;
			
			[s, "@getOwnProperty"] := "s__getOwnProperty";
			[s, "@primitiveValue"] := pv;
			
			len := s-len (pv);
			
			dop := [s, "@defineOwnProperty"];
			xret := dop (s, "length", {{ "d", len, $$f, $$f, $$f }}, $$t) with elab; 
			xret := s;
			
	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* *** VALUEOF *** *)

proc SP_valueOf (xsc, vthis) {
			goto [typeOf (vthis) = $$string_type] str iostr;
	str:	xret := vthis;
			goto rlab;
			
	iostr:	goto [typeOf (vthis) = $$object_type] ostr throw;
	ostr:	xret := [vthis, "@class"];
			goto [xret = "String"] retstr throw;
	retstr:	xret := [vthis, "@primitiveValue"];
			
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* *** TOSTRING *** *)

proc SP_toString (xsc, vthis) {
			goto [typeOf (vthis) = $$string_type] str iostr;
	str:	xret := vthis;
			goto rlab;
			
	iostr:	goto [typeOf (vthis) = $$object_type] ostr throw;
	ostr:	xret := [vthis, "@class"];
			goto [xret = "String"] retstr throw;
	retstr:	xret := [vthis, "@primitiveValue"];
			
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* *** CHARAT *** *)
proc SP_charAt (xsc, vthis, position) {
			xret := "i__checkObjectCoercible" (vthis) with elab;
			xret := "i__toString" (vthis) with elab;
			S := xret;
			xret := "i__toInteger" (position) with elab;
			pos := xret;
			size := s-len (S);
			goto [pos < 0] empt next;
			
	next:	goto [size <= pos] empt fll;
			
	empt:	xret := "";
			goto rlab;
	
	fll:	xret := s-nth (S, pos);
	rlab:	skip;
	
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** CONCAT *** *)
proc SP_concat () {
			arguments := args;
			vthis := l-nth (arguments, 1);
			num := l-len (arguments);
			
			xret := "i__checkObjectCoercible" (vthis) with elab;
			xret := "i__toString" (vthis) with elab;
			R := xret;
			idx := 2;
			
			
	loop:	goto [idx < num] add end;
	
	add:	next := l-nth (arguments, idx);
			xret := "i__toString" (next) with elab;
			nStr := xret;
			R := R ++ nStr;
			idx := idx + 1;
			goto loop;
	
	end:	xret := R;
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};


(* *** INDEXOF *** *)
proc SP_indexOf (xsc, vthis, searchString, position) {
			xret := "i__checkObjectCoercible" (vthis) with elab;
			xret := "i__toString" (vthis) with elab;
			S := xret;
			
			xret := "i__toString" (searchString) with elab;
			sStr := xret;
			
			goto [position = $$undefined] zero nzero;
	zero:	pos := 0;
			goto leng;
	
	nzero:	xret := "i__toInteger" (position) with elab;
			pos := xret;
	leng:	len := s-len (S);

			xret := "M_max" ($$empty, $$empty, pos, 0) with elab;
			max := xret;
			xret := "M_min" ($$empty, $$empty, max, len) with elab;
			start := xret;
			slen := s-len (sStr);
			
			goto [slen = 0] empts nempt;
	empts:	xret := start;
			goto rlab;
			
	nempt:	k := start;
			fink := -1;
			
	loop:	kslen := k + slen;
			j := 0;
			goto [kslen <= len] iloop end;
			
	iloop:	kj := k + j;
			skj := s-nth (S, kj);
			ssj := s-nth (sStr, j);
			goto [skj = ssj] checkj next;
	
	checkj:	j := j + 1;
			goto [not (j < slen)] fin inext;
	inext:	goto iloop;
	
	next:	k := k + 1;
			goto loop;
			
	fin:	fink := k;
	
	end:	xret := fink;
	rlab:	skip;
	elab:	skip
	
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** LASTINDEXOF *** *)
proc SP_lastIndexOf (xsc, vthis, searchString, position) {
			xret := "i__checkObjectCoercible" (vthis) with elab;
			xret := "i__toString" (vthis) with elab;
			S := xret;
			
			len := s-len (S);
			
			xret := "i__toString" (searchString) with elab;
			sStr := xret;
			
			xret := "i__toNumber" (position) with elab;
			npos := xret;
			
			(* NaN test! *)
			goto [not (npos = npos)] pnan npnan;
	pnan:	pos := len + 1;
			goto sta;
	
	npnan:	xret := "i__toInteger" (npos) with elab;
			pos := xret;
			
	sta:	xret := "M_max" ($$empty, $$empty, pos, 0) with elab;
			max := xret;
			xret := "M_min" ($$empty, $$empty, max, len) with elab;
			start := xret;
			slen := s-len (sStr);
			fink := -1;
	
			goto [slen = 0] empts nempt;
	empts:	xret := len;
			goto rlab;
			
	nempt:	goto [len < slen] short nshort;
	
	short:	xret := fink;
			goto rlab;
			
	nshort:	goto [len = slen] eqlen norm;
	
	eqlen:	k := 0;
			goto loop;
			
	norm:	k := start - slen;
			
	loop:	j := 0;
			goto [k < 0] end iloop;
			
	iloop:	kj := k + j;
			skj := s-nth (S, kj);
			ssj := s-nth (sStr, j);
			goto [skj = ssj] checkj next;
	
	checkj:	j := j + 1;
			goto [not (j < slen)] fin inext;
	inext:	goto iloop;
	
	next:	k := k - 1;
			goto loop;
			
	fin:	fink := k;
			
	end:	xret := fink;		
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};


(* *** SLICE *** *)
proc SP_slice (xsc, vthis, start, end) {
			xret := "i__checkObjectCoercible" (vthis) with elab;
			xret := "i__toString" (vthis) with elab;
			S := xret;
			len := s-len (S);
			
			goto [start = $$undefined] sund snull;
	sund:	start := 0;
			goto sdef;
	
	snull:	goto [start = $$null] sund sdef;	
			
	sdef:	xret := "i__toInteger" (start) with elab;
			intS := xret;
			goto [end = $$undefined] undef def;
	undef:	intE := len;
			goto st;
	
	def:	xret := "i__toInteger" (end) with elab;
			intE := xret;
			
	st:		goto [intS < 0] negS posS;
	negS:	lis := len + intS;
			xret := "M_max" ($$empty, $$empty, lis, 0) with elab;
			from := xret;
			goto endd;
	
	posS:	xret := "M_min" ($$empty, $$empty, intS, len) with elab;
			from := xret;
	
	endd:	goto [intE < 0] negE posE;
	negE:	lie := len + intE;
			xret := "M_max" ($$empty, $$empty, lie, 0) with elab;
			to := xret;
			goto sp;
	
	posE:	xret := "M_min" ($$empty, $$empty, intE, len) with elab;
			to := xret;
	
	sp:		tfr := to - from;
			xret := "M_max" ($$empty, $$empty, tfr, 0) with elab;
			span := xret;
			
			R := "";
			cnt := 0;
	loop:	goto [cnt < span] add stop;
			
	add:	next := s-nth (S, from);
			xret := "i__toString" (next) with elab;
			nStr := xret;
			R := R ++ nStr;
			cnt := cnt + 1;
			from := from + 1;
			goto loop;
	
	stop:	xret := R;
	rlab:	skip;
	
	elab: 	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** SUBSTRING *** *)
proc SP_substring (xsc, vthis, start, end) {
			xret := "i__checkObjectCoercible" (vthis) with elab;
			xret := "i__toString" (vthis) with elab;
			S := xret;
			len := s-len (S);
			
			xret := "i__toInteger" (start) with elab;
			intS := xret;
			goto [end = $$undefined] undef def;
	undef:	intE := len;
			goto fst;
	
	def:	xret := "i__toInteger" (end) with elab;
			intE := xret;
			
	fst:	xret := "M_max" ($$empty, $$empty, intS, 0) with elab;
			xret := "M_min" ($$empty, $$empty, xret, len) with elab;
			finS := xret;
			
			xret := "M_max" ($$empty, $$empty, intE, 0) with elab;
			xret := "M_min" ($$empty, $$empty, xret, len) with elab;
			finE := xret;
			
			xret := "M_min" ($$empty, $$empty, finS, finE) with elab;
			from := xret;
			xret := "M_max" ($$empty, $$empty, finS, finE) with elab;
			to := xret;
			
			span := to - from;
			R := "";
			cnt := 0;
	loop:	goto [cnt < span] add stop;
			
	add:	next := s-nth (S, from);
			xret := "i__toString" (next) with elab;
			nStr := xret;
			R := R ++ nStr;
			cnt := cnt + 1;
			from := from + 1;
			goto loop;
	
	stop:	xret := R;
	rlab:	skip;
	
	elab: 	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};
