(* ************** *) 
(* GETOWNPROPERTY *)
(* ************** *) 
	
proc o__getOwnProperty (l, prop) {
            x := hasField(l, prop);		
            goto [x] hp nhp; 			(* Does the field exist? *)
            
    nhp:    xret := $$undefined;		(* Field doesn't exist; return undefined *)
            goto rlab;					
            
    hp:     xret := [l, prop];			(* Field exists; return the descriptor *)
    
    rlab:   skip
}
with
{
    ret: 	xret, rlab;
};

(* *********** *) 
(* GETPROPERTY *)
(* *********** *) 

proc o__getProperty (l, prop) {
			
			gop := [l, "@getOwnProperty"];
			xret := gop (l, prop) with elab;
			goto [xret = $$undefined] next rlab;
			
	next:	proto := [l, "@proto"];
			goto [proto = $$null] rlab call;
			
	call:	gp := [proto, "@getProperty"];
			xret := gp (proto, prop) with elab;
	
    rlab:   skip;
    elab:	skip
}
with 
{
    ret: 	xret, rlab;
    err:	xret, elab;
};

(* *** *) 
(* GET *)
(* *** *) 

proc o__get (l, prop) {
			gp := [l, "@getProperty"];
			xret := gp (l, prop) with elab;	
			goto [xret = $$undefined] rlab def;		(* Does the field exist? *)
			
	def:	d := nth (xret, 0);						(* Get the descriptor type *)
			xret := nth (xret, 1);					(* Get the value/getter *)
			goto [d = "d"] rlab acc;				(* Is it a data descriptor? *)
			
	acc:	goto [xret = $$undefined] rlab get;		(* Is the getter defined? *)
	get:	xsc := [xret, "@scope"];				(* Get the scope of the getter *)
			fun := [xret, "@call"];					(* Get the name of the getter *)
			xret := fun (xsc, l) with elab;			(* Call the getter, errors could happen *)
			goto [xret = $$empty] undef rlab;
	undef:	xret := $$undefined;
			
	rlab:	skip;
	elab:	skip
}
with
{
    ret: xret, rlab;
    err: xret, elab;
};

(* ****** *) 
(* CANPUT *)
(* ****** *) 

proc o__canPut (l, prop) {
			gop := [l, "@getOwnProperty"];
            xret := gop (l, prop) with elab;		
	op:		goto [xret = $$undefined] nop odesc; 	(* Does the own property exist? *)
	
	odesc:	d := nth (xret, 0);						(* It does; get the descriptor type *)
			goto [d = "d"] odd nop;					(* Is the descriptor a data descriptor? *)
			
	odd:	xret := nth (xret, 2);					(* It is; return the Writable attribute *)
			goto rlab;
			
	nop:	e := [l, "@extensible"];				(* Get the extensible property *)
			gp := [l, "@getProperty"];
			xret := gp (l, prop) with elab;			(* Does the property exist? *)
			goto [xret = $$undefined] ext desc;		(* It doesn't; return extensible *)
			
	desc:	d := nth (xret, 0);						(* Get the descriptor type *)
			v := nth (xret, 2);						(* Get the writable/setter *)
			goto [d = "d"] dd ad;					(* Is it a data descriptor? *)
			
	dd:		goto [e] wr ext;						(* Yes; is the object extensible? *)
	wr:		xret := v;								(* Yes; return writable *)
			goto rlab;
			
	ad:		xret := not (v = $$undefined); 			(* Accessor descriptor *)
			goto rlab;
			
	ext:	xret := e;								(* Return extensible *)
	
    rlab:   skip;
    elab:	skip
}
with
{
    ret: 	xret, rlab;
    err:	xret, elab;
};

(* *** *) 
(* PUT *)
(* *** *) 

proc o__put (l, prop, value, throw) {
			cp := [l, "@canPut"];
            xret := cp (l, prop) with elab;
            goto [xret] cp reject;
            
    cp:     gop := [l, "@getOwnProperty"];
    		xret := gop (l, prop) with elab;
    		dd := "i__isDataDescriptor" (xret);
    		goto [dd] dd gp;
    		
    dd:		desc := {{ "g", $$empty, $$empty, value, $$empty, $$empty, $$empty }};
    		dop := [l, "@defineOwnProperty"];
    		xret := dop (l, prop, desc, throw) with elab;
    		goto remp;
    		
    gp:		gp := [l, "@getProperty"];
    		xret := gp (l, prop) with elab;
    		ad := "i__isAccessorDescriptor" (xret);
    		goto [ad] ad def;
    		
    ad:		s := nth (xret, 2);
    		xsc := [s, "@scope"];
    		fun := [s, "@call"];
    		xret := fun (xsc, l, value) with elab;
    		goto remp;
    		
    def:	dop := [l, "@defineOwnProperty"];
    		desc := {{ "g", $$t, $$t, value, $$t, $$empty, $$empty }};
    		xret := dop (l, prop, desc, throw) with elab;

    remp:   xret := $$empty;
    rlab:   skip;
    
    reject: goto [throw] tt remp;
    tt:     xret := "TypeError" ();
    elab:   skip
}
with
{
    ret: xret, rlab;
    err: xret, elab;
};

(* *********** *) 
(* HASPROPERTY *)
(* *********** *) 

proc o__hasProperty (l, prop) {
			gp := [l, "@getProperty"];
			xret := gp (l, prop) with elab;
			
	rlab:	xret := not (xret = $$undefined);
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};

(* ************** *) 
(* DELETEPROPERTY *)
(* ************** *) 

proc o__deleteProperty (l, prop, throw) {
			gop := [l, "@getOwnProperty"];
			xret := gop (l, prop) with elab;
			goto [xret = $$undefined] dt cont;
			
	cont:	c := nth (xret, 4);
			goto [c] del reject;
	del:	delete (l, prop);
	
	dt:		xret := $$t;
			goto rlab;
			
	df:		xret := $$f;
	rlab:	skip;
	
    reject: goto [throw] tt df;
    
    tt:     xret := "TypeError" ();
    elab:   skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* ************ *) 
(* DEFAULTVALUE *)
(* ************ *) 

proc o__defaultValue (l, hint) {
			goto [hint = $$empty] hint init;
			
	hint:	hint := "Number";
			class := [l, "@class"];
			goto [class = "Date"] hs init;
	hs:		hint := "String";

	init:	pass := 0;
            goto [hint = "String"] s n;

	main:	goto [pass = 2] throw cc;
	
    cc:		pass := pass + 1;
    		g := [l, "@get"];
    		xret := g (l, proc_name) with elab;
    		goto [xret = $$undefined] next is_c;
    		
    is_c:	c := "i__isCallable" (xret);
            goto [c] call next;
            
    call:	xsc := [xret, "@scope"];
            fun := [xret, "@call"];
            xret := fun (xsc, l) with elab;
			goto [xret = $$empty] undef ispr;
	undef:	xret := $$undefined;                    
	ispr:	goto [is_primitive xret] rlab next;
			
    next:   goto [proc_name = "toString"] n s;
    rlab:   skip;

    s:		proc_name := "toString";
    		goto main;
    n:		proc_name := "valueOf";
    		goto main;

    throw:  xret := "TypeError" ();
    elab:   skip
}
with
{
    ret: xret, rlab;
    err: xret, elab;
};

(* ***************** *) 
(* DEFINEOWNPROPERTY *)
(* ***************** *) 

proc o__defineOwnProperty (l, prop, desc, throw) {
		
			xret := $$t;
	
			gop := [l, "@getOwnProperty"];
			current := gop (l, prop) with celab;
			extensible := [l, "@extensible"];
			
			goto [(current = $$undefined) and (extensible = $$f)] reject l4;
	l4:		goto [(current = $$undefined) and (extensible = $$t)] l4a getall;
	
	l4a:	gd := "i__isGenericDescriptor" (desc);
			dd := "i__isDataDescriptor" (desc);
			
			goto [gd or dd] l4a1 l4b;
			
	l4a1:	ndesc := "i__toDataDescriptor" (desc);
			[l, prop] := ndesc;
			goto acc_t;
	
	l4b:	ndesc := "i__toAccessorDescriptor" (desc);
			[l, prop] := ndesc;
			goto acc_t;
	
	getall:	goto [nth (desc, 0) = "d"] ddd odd;
	
			(* Data *)
	ddd:	de := nth (desc, 3);
			dc := nth (desc, 4);
			dv := nth (desc, 1);
			dw := nth (desc, 2);
			dg := $$empty;
			ds := $$empty;
			goto l5;
			
	odd:	goto [nth (desc, 0) = "a"] add gdd;

			(* Accessor *)
	add:	de := nth (desc, 3);
			dc := nth (desc, 4);
			dv := $$empty;
			dw := $$empty;
			dg := nth (desc, 1);
			ds := nth (desc, 2);
			goto l5;
			
			(* Generic *)
	gdd:	de := nth (desc, 1);
			dc := nth (desc, 2);
			dv := nth (desc, 3);
			dw := nth (desc, 4);
			dg := nth (desc, 5);
			ds := nth (desc, 6);
			
	l5:		goto [(de = $$empty) and (dc = $$empty) and (dv = $$empty) and 
			      (dw = $$empty) and (dg = $$empty) and (ds = $$empty)] acc_t l6;
	
	l6:		goto [nth (current, 0) = "d"] chd cha;
	
	chd:	t1 := "i__sameValue" (dv, nth (current, 1));
			t2 := "i__sameValue" (dw, nth (current, 2));
			t3 := "i__sameValue" (de, nth (current, 3));
			t4 := "i__sameValue" (dc, nth (current, 4));
	
			goto [t1 and t2 and t3 and t4 and
			      (dg = $$empty) and (ds = $$empty)] acc_t l7;
			
	cha:	t1 := "i__sameValue" (dg, nth (current, 1));
			t2 := "i__sameValue" (ds, nth (current, 2));
			t3 := "i__sameValue" (de, nth (current, 3));
			t4 := "i__sameValue" (dc, nth (current, 4));
			
			goto [t1 and t2 and t3 and t4 and
			      (dv = $$empty) and (dw = $$empty)] acc_t l7;
	
	l7:		ct := nth (current, 0);
			cvg := nth (current, 1);
			cws := nth (current, 2);
			ce := nth (current, 3);
			cc := nth (current, 4);
			
			goto [(cc = $$f) and ((dc = $$t) or ((not (de = $$empty)) and (not (ce = de))))] reject l8;
	
	l8:		gd := "i__isGenericDescriptor" (desc);
			goto [gd] l12 l9;
			
	l9:		cdd := "i__isDataDescriptor" (current);
			ddd := "i__isDataDescriptor" (desc);
			
			goto [not (cdd = ddd)] l9a l10;
			
	l9a:	goto [cc = $$f] reject change;
	change:	goto [cdd = $$t] toa tod;
	toa:	goto [dg = $$empty] sg gs;
	sg:		dg := $$undefined;
	gs:		goto [ds = $$empty] ss ge1;
	ss:		ds := $$undefined;
	ge1:	goto [de = $$empty] se1 gc1;
	se1:	de := ce;
	gc1:	goto [dc = $$empty] sc1 spa;
	sc1:	dc := cc;
	spa:	[l, prop] := {{ "a", dg, ds, de, dc }};
			goto acc_t;
				
	tod:	goto [dv = $$empty] sv gw;
	sv:		dv := $$undefined;
	gw:		goto [dw = $$empty] sw ge2;
	sw:		dw := $$f;
	ge2:	goto [de = $$empty] se2 gc2;
	se2:	de := ce;
	gc2:	goto [dc = $$empty] sc2 spd;
	sc2:	dc := cc;
	spd:	[l, prop] := {{ "d", dv, dw, de, dc }};
			goto acc_t;
	
	l10:	goto [cdd = $$t] l10a l11;
	
	l10a:	goto [cc = $$f] l10ai l12;
	l10ai:	goto [(not (dw = $$empty)) and ((cws = $$f) and (dw = $$t))] reject l10aii;
	l10aii:	t1 := "i__sameValue" (cvg, dv);
			goto [(cws = $$f) and (not (dv = $$empty)) and (not t1)] reject l12;
	
	l11: 	t1 := "i__sameValue" (dg, nth (current, 1));
			t2 := "i__sameValue" (ds, nth (current, 2));
			goto [(cc = $$f) and 
	             (((not (dg = $$empty)) and (not t1)) or 
	              ((not (ds = $$empty)) and (not t2)))] reject l12;
	
	l12:	re := de;
			rc := dc;
			goto [de = $$empty] rec red;
	rec:	re := nth (current, 3);
	red:	goto [dc = $$empty] rcd rd;
	rcd:	rc := nth (current, 4);
	
	rd: 	goto [ct = "d"] l12d l12a;
	
	l12d:	rv := dv;
			rw := dw;
			goto [dv = $$empty] rvc rvd;
	rvc:	rv := nth (current, 1);
	rvd:	goto [dw = $$empty] rwd setd;
	rwd:	rw := nth (current, 2);
	setd:	[l, prop] := {{ "d", rv, rw, re, rc }};	
			goto acc_t;
	
	l12a:	rg := dg;
			rs := ds;
			goto [dg = $$empty] rgc rgd;
	rgc:	rg := nth (current, 1);
	rgd:	goto [ds = $$empty] rsd seta;
	rsd:	rs := nth (current, 2);
	seta:	[l, prop] := {{ "a", rg, rs, re, rc }};	
			goto acc_t;
	
	acc_t:	xret := $$t;
			goto rlab;
			
	acc_f:	xret := $$f;
	rlab:	skip;
	
	celab:	xerr := current;
			goto elab;
	
    reject: goto [throw] tt acc_f;
    tt:     xerr := "TypeError" ();
    elab:   skip
}
with
{
	ret: xret, rlab;
	err: xerr, elab;
};

(* ************** *) 
(* ON DESCRIPTORS *)
(* ************** *) 

(* *** ISDATADESCRIPTOR *** *)

proc i__isDataDescriptor (desc) {
			goto [desc = $$undefined] rf cont;
	cont:	d := nth (desc, 0);
			goto [d = "d"] rt gen;
	gen:	goto [d = "g"] test rf;
	test:	v := nth (desc, 3);
			w := nth (desc, 4);
			goto [(v = $$empty) and (w = $$empty)] rf rt;
	rt:		xret := $$t;
			goto rlab;
	rf:		xret := $$f;
	rlab:	skip
}
with
{
	ret : xret, rlab;
};

(* *** ISACCESSORDESCRIPTOR *** *)

proc i__isAccessorDescriptor (desc) {
			goto [desc = $$undefined] rf cont;
	cont:	d := nth (desc, 0);
			goto [d = "a"] rt gen;
	gen:	goto [d = "g"] test rf;
	test:	g := nth (desc, 5);
			s := nth (desc, 6);
			goto [(g = $$empty) and (s = $$empty)] rf rt;
	rt:		xret := $$t;
			goto rlab;
	rf:		xret := $$f;
	rlab:	skip
}
with
{
	ret : xret, rlab;
};

(* *** ISGENERICDESCRIPTOR *** *)

proc i__isGenericDescriptor (desc) {
			dd := "i__isDataDescriptor" (desc);
			ad := "i__isAccessorDescriptor" (desc);
			xret := not (dd or ad);
	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* *** TODATADESCRIPTOR *** *)

proc i__toDataDescriptor (desc) {
			d := nth (desc, 0);
			goto [d = "d"] rd cstr;
	
	cstr:	goto [d = "a"] ra gen;
	
	ra:		xret := {{ "d", $$undefined, $$f, nth (d, 3), nth (d, 4) }};
			goto rlab;
	
	gen:	e := nth (desc, 1);
			c := nth (desc, 2);
			v := nth (desc, 3);
			w := nth (desc, 4);
			
			goto [e = $$empty] fixe c;
	fixe:	e := $$f;
	c:		goto [c = $$empty] fixc v;
	fixc:	c := $$f;
	v:		goto [v = $$empty] fixv w;
	fixv:	v := $$undefined;
	w:		goto [w = $$empty] fixw fixed;
	fixw:	w := $$f;	
			
	fixed:	xret := {{ "d", v, w, e, c }};
			goto rlab;
	
	rd:		xret := desc;
	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* *** TOACCESSORDESCRIPTOR *** *)

proc i__toAccessorDescriptor (desc) {
			d := nth (desc, 0);
			goto [d = "a"] rd cstr;
	
	cstr:	goto [d = "d"] ac gen;
	
	ac:		xret := {{ "a", $$undefined, $$undefined, nth (d, 3), nth (d, 4) }};
			goto rlab;
	
	gen:	e := nth (desc, 1);
			c := nth (desc, 2);
			g := nth (desc, 5);
			s := nth (desc, 6);
			
			goto [e = $$empty] fixe c;
	fixe:	e := $$f;
	c:		goto [c = $$empty] fixc v;
	fixc:	c := $$f;
	v:		goto [g = $$empty] fixg w;
	fixg:	g := $$undefined;
	w:		goto [s = $$empty] fixs fixed;
	fixs:	s := $$undefined;	
			
	fixed:	xret := {{ "a", g, s, e, c }};
			goto rlab;
	
	rd:		xret := desc;
	rlab:	skip
}
with
{
	ret: 	xret, rlab;
};

(* *** FROMPROPERTYDESCRIPTOR *** *)

proc i__fromPropertyDescriptor (desc) {
			goto [desc = $$undefined] undef def;
	
	def:	xret := "Object_construct" ();
	
			dop := [xret, "@defineOwnProperty"];
	
			dd := "i__isDataDescriptor" (desc);
			goto [dd] dd is_ac;
			
	dd:		res := dop (xret, "value",    {{ "d", nth (desc, 1), $$t, $$t, $$t}}, $$f);
			res := dop (xret, "writable", {{ "d", nth (desc, 2), $$t, $$t, $$t}}, $$f);
			goto ec;
	
	is_ac:	ad := "i__isAccessorDescriptor" (desc);
			goto [ad] ad oops;
	
	ad:		res := dop (xret, "get", {{ "d", nth (desc, 1), $$t, $$t, $$t}}, $$f);
			res := dop (xret, "set", {{ "d", nth (desc, 2), $$t, $$t, $$t}}, $$f);
			
	ec:		res := dop (xret, "enumerable",   {{ "d", nth (desc, 3), $$t, $$t, $$t}}, $$f);
			res := dop (xret, "configurable", {{ "d", nth (desc, 4), $$t, $$t, $$t}}, $$f);
			goto rlab;
			
	oops:	xret := "fromPropertyDescriptor: This should not happen";
			goto rlab;
	
	undef:	xret := $$undefined;
	rlab:	skip
}
with
{
	ret: 	xret, rlab;
};

(* *** TOPROPERTYDESCRIPTOR *** *)

proc i__toPropertyDescriptor (v) {
			goto [typeOf(v) = $$object_type] init throw;
			
	init:	dv := $$empty;
			dw := $$empty;
			dg := $$empty;
			ds := $$empty;
			de := $$empty;
			dc := $$empty;
			
			hp := [v, "@hasProperty"];
			gt := [v, "@get"];
			
	has_de:	res := hp (v, "enumerable");
			goto [res] de has_dc;
	de:		xret := gt (v, "enumerable") with elab;
			xret := "i__toBoolean" (xret);
			de := xret;
			
	has_dc:	res := hp (v, "configurable");
			goto [res] dc has_dv;
	dc:		xret := gt (v, "configurable") with elab;
			xret := "i__toBoolean" (xret);
			dc := xret;
			
	has_dv:	res := hp (v, "value");
			goto [res] dv has_dw;
	dv:		xret := gt (v, "value") with elab;
			dv := xret;

	has_dw:	res := hp (v, "writable");
			goto [res] dw has_dg;
	dw:		xret := gt (v, "writable") with elab;
			xret := "i__toBoolean" (xret);
			dw := xret;

	has_dg:	res := hp (v, "get");
			goto [res] dg has_ds;
	dg:		xret := gt (v, "get") with elab;
			call := "i__isCallable" (xret);
			goto [call or (xret = $$undefined)] get throw; 
	get:	dg := xret;
			
	has_ds:	res := hp (v, "set");
			goto [res] ds check;
	ds:		xret := gt (v, "set") with elab;
			call := "i__isCallable" (xret);
			goto [call or (xret = $$undefined)] set throw; 
	set:	ds := xret;
			
	check:	goto [(not (dg = $$empty)) or (not (ds = $$empty))] vw return;
	vw:		goto [(not (dv = $$empty)) or (not (dw = $$empty))] throw return;
	
	return:	xret := {{ "g", de, dc, dv, dw, dg, ds }};
	
	rlab:	skip;
	
	throw:  xret := "TypeError" ();
    elab:   skip
	
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};





(* ******** *) 
(* GETVALUE *)
(* ******** *) 

proc i__getValue (v) {

			goto [(typeOf(v) = $$v-reference_type) or (typeOf(v) = $$o-reference_type)] init dflt;
	
	init:	rbase := base (v);
			rfield := field (v);
			goto [rbase = $$undefined] throw prim;
	
	prim:	goto [(is_primitive rbase) and (not (rbase = $$undefined)) and (not (rbase = $$null))] is_pr ref;
	
	is_pr:	xret := "i__toObject" (rbase) with elab;
			gp := [xret, "@getProperty"];
			xret := gp (xret, rfield) with elab;
			goto [xret = $$undefined] rlab def;
	def:	d := nth (xret, 0);						(* Get the descriptor type *)
			xret := nth (xret, 1);					(* Get the value/getter *)
			goto [d = "d"] rlab acc;				(* Is it a data descriptor? *)
			
	acc:	goto [xret = $$undefined] rlab get;		(* Is the getter defined? *)
	get:	xsc := [xret, "@scope"];				(* Get the scope of the getter *)
			fun := [xret, "@call"];					(* Get the name of the getter *)
			xret := fun (xsc, rbase) with elab;		(* Call the getter, errors could happen *)
			goto [xret = $$empty] undef rlab;
	undef:	xret := $$undefined;
	
	ref:	goto [typeOf(v) = $$o-reference_type] oref vref;
	
	oref:	gp := [rbase, "@get"];
			xret := gp (rbase, rfield) with elab;
			goto rlab;
			
	vref:	goto [rbase = $lg] lg er;
	
	lg:		gp := [$lg, "@get"];
			xret := gp (rbase, rfield) with elab;
			goto rlab;
			
	er:		xret := [rbase, rfield];
			goto rlab;
	
	dflt:	xret := v;
	rlab:	skip;
	
	throw:  xret := "ReferenceError" ();
    elab:   skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* ******** *) 
(* PUTVALUE *)
(* ******** *) 

proc i__putValue (v, w) {

			goto [(typeOf(v) = $$v-reference_type) or (typeOf(v) = $$o-reference_type)] init throw;
	
	init:	rbase := base (v);
			rfield := field (v);
			goto [rbase = $$undefined] throw prim;
	
	prim:	goto [(is_primitive rbase) and (not (rbase = $$undefined)) and (not (rbase = $$null))] is_pr refr;
	
	refr:	goto [typeOf(v) = $$o-reference_type] oref vref;
	
	oref:	p := [rbase, "@put"];
			xret := p (rbase, rfield, w, $$t) with elab;
			goto dflt;
			
	vref:	goto [rbase = $lg] lg er;
	
	lg:		p := [$lg, "@put"];
			xret := p (rbase, rfield, w, $$t) with elab;
			goto dflt;
			
	er:		[rbase, rfield] := w;
	
	dflt:	xret := $$empty;
	rlab:	skip;
	
	throw:  xret := "ReferenceError" ();
    elab:   skip;
    
    		(* WHY GOD, WHY THIS? *)
    		
	is_pr:	xret := "i__toObject" (rbase) with elab;
			l := xret;
    		cp := [l, "@canPut"];
            xret := cp (l, rfield) with elab;
            goto [xret] cp reject;
            
    cp:     gp := [l, "@getProperty"];
    		xret := gp (l, rfield) with elab;
    		dd := "i__isDataDescriptor" (xret);
    		goto [dd] reject is_ad;
    		    		
   	is_ad: 	ad := "i__isAccessorDescriptor" (xret);
    		goto [ad] ad reject;
    		
    ad:		s := nth (xret, 2);
    		xsc := [s, "@scope"];
    		fun := [s, "@call"];
    		xret := fun (xsc, rbase, w) with elab;
    		goto dflt;
    
    reject: xret := "TypeError" ();
    		goto elab
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};






(* ********************** *) 
(* CONVERSIONS AND CHECKS *)
(* ********************** *) 

(* *** TOPRIMITIVE *** *)

proc i__toPrimitive (v, hint) {
			xret := v;

	iu:		goto [(v = $$undefined) or (v = $$null) or
	              (typeOf(v) = $$boolean_type) or (typeOf(v) = $$number_type) or
	              (typeOf(v) = $$string_type)] rlab is_obj;

	is_obj:	goto [typeOf(v) = $$object_type] obj oops;
	obj:	dv := [v, "@defaultValue"];
			xret := dv (v, hint) with elab;
			goto rlab;
	
	oops:	xret := "ToPrimitive: This should not happen.";
			goto elab;
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** TOBOOLEAN *** *)

proc i__toBoolean (v) {
	iu:		goto [v = $$undefined] undef in;
	undef:	xret := $$f;
			goto rlab;
	
	in:		goto [v = $$null] null ib;
	null:	xret := $$f;
			goto rlab;
			
	ib:		goto [typeOf(v) = $$boolean_type] bool inum;
	bool:	xret := v;
			goto rlab;
			
	inum:	goto [typeOf(v) = $$number_type] num is;
	num:	goto [(v = 0) or (not (v = v))] is_f is_t;
			
	is:		goto [typeOf(v) = $$string_type] str io;
	str:	goto [v = ""] is_f is_t;
			goto rlab;
			
	io:		goto [typeOf(v) = $$object_type] obj oops;
	obj:	xret := $$t;
			goto rlab;
	
	is_t:	xret := $$t;
			goto rlab;
	is_f:	xret := $$f;
			goto rlab;
			
	oops:	xret := "ToBoolean: This should not happen.";
	
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* *** TONUMBER *** *)

proc i__toNumber (v) {
	iu:		goto [v = $$undefined] undef in;
	undef:	xret := nan;
			goto rlab;
	
	in:		goto [v = $$null] null ib;
	null:	xret := 0;
			goto rlab;
			
	ib:		goto [typeOf(v) = $$boolean_type] bool inum;
	bool:	goto [v = $$t] is_t is_f;
	is_t:	xret := 1;
			goto rlab;
	is_f:	xret := 0;
			goto rlab;
			
	inum:	goto [typeOf(v) = $$number_type] num is;
	num:	xret := v;
			goto rlab;
			
	is:		goto [typeOf(v) = $$string_type] str io;
	str:	xret := string_to_num v;
			goto rlab;
			
	io:		goto [typeOf(v) = $$object_type] obj oops;
	obj:	xret := "i__toPrimitive" (v, "Number") with elab;
			xret := "i__toNumber" (xret);
			goto rlab;
	
	oops:	xret := "ToNumber: This should not happen.";
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** TOINTEGER *** *)

proc i__toInteger (v) {
			xret := "i__toNumber" (v) with elab;
			xret := num_to_int (xret);

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** TOINT32 *** *)

proc i__toInt32 (v) {
			xret := "i__toNumber" (v) with elab;
			xret := num_to_int32 (xret);

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** TOUINT32 *** *)

proc i__toUint32 (v) {
			xret := "i__toNumber" (v) with elab;
			xret := num_to_uint32 (xret);

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** TOUINT16 *** *)

proc i__toUint16 (v) {
			xret := "i__toNumber" (v) with elab;
			xret := num_to_uint16 (xret);

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** TOSTRING *** *)

proc i__toString (v) {
	iu:		goto [v = $$undefined] undef in;
	undef:	xret := "undefined";
			goto rlab;
	
	in:		goto [v = $$null] null ib;
	null:	xret := "null";
			goto rlab;
			
	ib:		goto [typeOf(v) = $$boolean_type] bool inum;
	bool:	goto [v = $$t] is_t is_f;
	is_t:	xret := "true";
			goto rlab;
	is_f:	xret := "false";
			goto rlab;
			
	inum:	goto [typeOf(v) = $$number_type] num is;
	num:	xret := num_to_string v;
			goto rlab;
			
	is:		goto [typeOf(v) = $$string_type] str io;
	str:	xret := v;
			goto rlab;
			
	io:		goto [typeOf(v) = $$object_type] obj oops;
	obj:	xret := "i__toPrimitive" (v, "String") with elab;
			xret := "i__toString" (xret) with elab;
			goto rlab;
	
	oops:	xret := "ToString: This should not happen.";
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** TOOBJECT *** *)

proc i__toObject (v) {
	iu:		goto [v = $$undefined] throw in;
	
	in:		goto [v = $$null] throw ib;
			
	ib:		goto [typeOf(v) = $$boolean_type] bool inum;
	bool:	xret := "Boolean_construct" ($$undefined, $$undefined, v);
			goto rlab;
			
	inum:	goto [typeOf(v) = $$number_type] num is;
	num:	xret := "Number_construct" ($$undefined, $$undefined, v);
			goto rlab;
			
	is:		goto [typeOf(v) = $$string_type] str io;
	str:	xret := "String_construct" ($$undefined, $$undefined, v);
			goto rlab;
			
	io:		goto [typeOf(v) = $$object_type] obj oops;
	obj:	xret := v;
			goto rlab;
	
	oops:	xret := "ToObject: This should not happen.";
	
	rlab:	skip;
	
	throw:	xret := "Here!";
			xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* ******************** *) 
(* CHECKOBJECTCOERCIBLE *)
(* ******************** *) 

proc i__checkObjectCoercible (v) {

			xret := $$empty;

	iu:		goto [v = $$undefined] throw in;
	
	in:		goto [v = $$null] throw other;
			
	other:	goto [(typeOf(v) = $$boolean_type) or (typeOf(v) = $$number_type) or 
	              (typeOf(v) = $$string_type) or (typeOf(v) = $$object_type)] rlab oops;
	
	oops:	xret := "CheckObjectCoercible: This should not happen.";
	
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* ********** *) 
(* ISCALLABLE *)
(* ********** *) 

proc i__isCallable (l) {
			goto [typeOf (l) = $$object_type] obj endf; 
	obj:	xret := [l, "@call"];
			goto [xret = $$empty] endf endt;
	endt:	xret := $$t;
			goto rlab;
	endf:	xret := $$f;
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* ********** *) 
(* ISRESERVED *)
(* ********** *) 

proc i__isReserved (v) {
			xret := $$f;

	next00:	goto [v = "break"] is next01;
	next01:	goto [v = "case"] is next02;
	next02:	goto [v = "catch"] is next03;
	next03:	goto [v = "continue"] is next04;
	next04:	goto [v = "debugger"] is next05;
	next05:	goto [v = "default"] is next06;
	next06:	goto [v = "delete"] is next07;
	next07:	goto [v = "do"] is next08;
	next08:	goto [v = "else"] is next09;
	next09:	goto [v = "finally"] is next10;
	next10:	goto [v = "for"] is next11;
	next11:	goto [v = "function"] is next12;
	next12:	goto [v = "if"] is next13;
	next13:	goto [v = "in"] is next14;
	next14:	goto [v = "instanceof"] is next15;
	next15:	goto [v = "new"] is next16;
	next16:	goto [v = "return"] is next17;
	next17:	goto [v = "switch"] is next18;
	next18:	goto [v = "this"] is next19;
	next19:	goto [v = "throw"] is next20;
	next20:	goto [v = "try"] is next21;
	next21:	goto [v = "typeof"] is next22;
	next22:	goto [v = "var"] is next23;
	next23:	goto [v = "void"] is next24;
	next24:	goto [v = "while"] is next25;
	next25:	goto [v = "with"] is next26;
	next26:	goto [v = "class"] is next27;
	next27:	goto [v = "const"] is next28;
	next28:	goto [v = "enum"] is next29;
	next29:	goto [v = "export"] is next30;
	next30:	goto [v = "extends"] is next31;
	next31:	goto [v = "import"] is next32;
	next32:	goto [v = "super"] is next33;
	next33:	goto [v = "implements"] is next34;
	next34:	goto [v = "interface"] is next35;
	next35:	goto [v = "let"] is next36;
	next36:	goto [v = "package"] is next37;
	next37:	goto [v = "private"] is next38;
	next38:	goto [v = "protected"] is next39;
	next39:	goto [v = "public"] is next40;
	next40:	goto [v = "static"] is next41;
	next41:	goto [v = "yield"] is rlab;

	is:		xret := $$t;
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* ******************* *) 
(* ABSTRACT COMPARISON *)
(* ******************* *) 

proc i__abstractComparison (v1, v2, leftFirst) {
			goto [(leftFirst = $$empty) or (leftFirst = $$t)] eleft eright;
			
	eleft:	xret := "i__toPrimitive" (v1, "Number") with elab;
			px := xret;
			xret := "i__toPrimitive" (v2, "Number") with elab;
			py := xret;
			goto is_str;
	
	eright:	xret := "i__toPrimitive" (v2, "Number") with elab;
			py := xret;
			xret := "i__toPrimitive" (v1, "Number") with elab;
			px := xret;

	is_str:	goto [(typeOf(px) = $$string_type) and (typeOf(py) = $$string_type)] str num;
	
	str:	xret := (px <s py);
			goto rlab;
			
	num:	xret := "i__toNumber" (px) with elab;
			nx := xret;
			xret := "i__toNumber" (py) with elab;
			ny := xret;
				
			goto [(not (nx = nx)) or (not (ny = ny))] ru eq;
	
	eq:	goto [nx = ny] rf sh;
		
	sh:		goto [nx = inf] rf si;
	si:		goto [ny = inf] rt sj;
	sj:		goto [ny = -inf] rf sk;
	sk:		goto [nx = -inf] rt sl;	
	sl:		xret := (nx < ny);
			goto rlab;
			
	ru:		xret := $$undefined;
			goto rlab;
			
	rt:		xret := $$t;
			goto rlab;
			
	rf:		xret := $$f;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* ****** *) 
(* TYPEOF *)
(* ****** *) 

proc i__typeOf (v) {
	iu:		goto [v = $$undefined] undef in;
	undef:	xret := "undefined";
			goto rlab;
	
	in:		goto [v = $$null] null ib;
	null:	xret := "object";
			goto rlab;
			
	ib:		goto [typeOf(v) = $$boolean_type] bool inum;
	bool:	xret := "boolean";
			goto rlab;
			
	inum:	goto [typeOf(v) = $$number_type] num is;
	num:	xret := "number";
			goto rlab;
			
	is:		goto [typeOf(v) = $$string_type] str io;
	str:	xret := "string";
			goto rlab;
			
	io:		goto [typeOf(v) = $$object_type] obj oops;
	obj:	xret := [v, "@call"];
			goto [xret = $$empty] isobj isfun;
			
	isobj:	xret := "object";
			goto rlab;
	
	isfun:	xret := "function";
			goto rlab;
	
	oops:	xret := "typeOf: This should not happen.";
			goto elab;
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* **************** *) 
(* ABSTRACTEQUALITY *)
(* **************** *) 

proc i__abstractEquality (v1, v2) {
			tv1 := typeOf(v1);
			tv2 := typeOf(v2);

			goto [tv1 = tv2] same diff;
				
	same:	goto [(tv1 = $$undefined_type) or (tv1 = $$null_type) or
	              (tv1 = $$boolean_type)   or (tv1 = $$number_type) or
	              (tv1 = $$string_type)    or (tv1 = $$object_type)] ieq oops;
	ieq:	xret := (v1 = v2); 
			goto rlab;
			
	diff:	goto [((tv1 = $$undefined_type) and (tv2 = $$null_type)) or
			      ((tv1 = $$null_type) and (tv2 = $$undefined_type))] rt dns;
			      
	dns:	goto [(tv1 = $$number_type) and (tv2 = $$string_type)] tn2 dsn;
	tn2:	xret := "i__toNumber" (v2) with elab;
			xret := "i__abstractEquality" (v1, xret) with elab;
			goto rlab;
			
	dsn:	goto [(tv1 = $$string_type) and (tv2 = $$number_type)] tn1 s1b;
	tn1:	xret := "i__toNumber" (v1) with elab;
			xret := "i__abstractEquality" (xret, v2) with elab;
			goto rlab;

	s1b:	goto [tv1 = $$boolean_type] tn1 s2b;
	s2b:	goto [tv2 = $$boolean_type] tn2 s2o;
	
	s2o:	goto [((tv1 = $$number_type) or (tv1 = $$string_type)) and (tv2 = $$object_type)] tp2 s1o;
	tp2:	xret := "i__toPrimitive" (v2) with elab;
			xret := "i__abstractEquality" (v1, xret) with elab;
			goto rlab;
	
	s1o:	goto [(tv1 = $$object_type) and ((tv2 = $$number_type) or (tv2 = $$string_type))] tp1 rf;
	tp1:	xret := "i__toPrimitive" (v1) with elab;
			xret := "i__abstractEquality" (xret, v2) with elab;
			goto rlab;

	rt:		xret := $$t;
			goto rlab;

	rf:		xret := $$f;
			goto rlab;
			
	oops:	xret := "AbstractEquality: This should not happen.";
			goto elab;
	
	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

proc i__strictEquality (v1, v2) {
			xret := (v1 = v2);
	
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* ********* *) 
(* SAMEVALUE *)
(* ********* *) 

proc i__sameValue (v1, v2) {
			v1 := v1;
			v2 := v2;
			xret := (v1 = v2);
			
			goto [(typeOf(v1) = $$number_type) and (typeOf(v2) = $$number_type)] inan rlab;
			
	inan:	goto [(not (v1 = v1)) and (not (v2 = v2))] rt zero;
	zero:	goto [(v1 = 0) and (v2 = 0)] fix rlab;
	
	fix:	sv1 := m_sgn (v1);
			sv2 := m_sgn (v2);
			
			xret := (sv1 = sv2);
			goto rlab;
	
	rt:		xret := $$t;
	
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* ********************* *) 
(* CHECKASSIGNMENTERRORS *)
(* ********************* *)

proc i__checkAssignmentErrors (v) {
			tv := typeOf (v);
			goto [(tv = $$v-reference_type) or (tv = $$o-reference_type)] prep rlab;
			
	prep:	bv := base (v);
			fv := field (v);
			
	csyn:	goto [((tv = $$v-reference_type) or (v = $lg)) and ((fv = "eval") or (fv = "arguments"))] se cref;
	
			(* Can anything else happen here? *)
	cref:	goto [(bv = $$undefined)] re ctyp;
	
	ctyp:	goto [tv = $$o-reference_type] c1 rlab;
	
	c1:		xret := hasField (bv, fv);
			goto [xret] c2 c1a;
	c1a:	xret := [bv, "@extensible"];
			goto [xret] rlab te;
			
	c2:		xret := [bv, fv];
			goto [(nth (xret, 2) = $$f) or (nth (xret, 2) = $$undefined)] te rlab;
	
	rlab:	xret := $$t;
	
	se:		xret := "SyntaxError" ();
			goto elab;
			
	re:		xret := "ReferenceError" ();
			goto elab;
			
	te:		xret := "TypeError" ();
	
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *********** *) 
(* HASINSTANCE *)
(* *********** *)

proc f__hasInstance(v1, v2) {		
			v1 := v1;
			v2 := v2;	
			goto [not (typeOf (v2) = $$object_type)] rf s2;
	
	s2:		g := [v1, "@get"];
			xret := g (v1, "prototype") with elab;
			goto [not (typeOf (xret) = $$object_type)] throw s4;
			
	s4:		v2 := [v2, "@proto"];
			goto [v2 = $$null] rf s4c;
	s4c:	goto [xret = v2] rt s4;
	
	rt:		xret := $$t;
			goto rlab;
			
	rf:		xret := $$f;
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* ************ *) 
(* FUNCTION GET *)
(* ************ *)

proc f__get(o, prop) {		
			xret := "o__get" (o, prop) with elab;
			goto [prop = "caller"] elab rlab;
			
	rlab:	skip;
	
	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
}