(* ******************
   *** PREDICATES ***
   ****************** *)

import javert_js_predicates.jsil;


(*******************
 *******************
 ***** OBJECTS *****
 *******************
 *******************)    

(* ***********************
 * CREATE_DEFAULT_OBJECT *
 *************************)

spec create_default_object (l, pr, cl, ext)

    [[ (l == #l) * (pr == #pr) * (cl == undefined) * (ext == undefined) *
	   MetaData(l, #md) * Extensible(l, true) *
	   ((#md, "@proto")      -> _) *
	   ((#md, "@class")      -> _) *
	   ((#md, "@extensible") -> _) *
	   MetaData(#md, null) * Extensible(#md, true) ]]
    [[ MetaData(l, #md) * Extensible(l, true) *
	   ((#md, "@proto")      -> #pr) *
	   ((#md, "@class")      -> "Object") *
	   ((#md, "@extensible") -> true) *
	   MetaData(#md, null) * Extensible(#md, true) * 
	   (ret == #l) ]]
    normal;
    
    [[ (l == #l) * (pr == #pr) * (cl == #cl) * (ext == #ext) *
	   types(#cl:Str, #ext:Bool) *
       MetaData(l, #md) * Extensible(l, true) *
	   ((#md, "@proto")      -> _) *
	   ((#md, "@class")      -> _) *
	   ((#md, "@extensible") -> _) *
	   MetaData(#md, null) * Extensible(#md, true) ]]
    [[ MetaData(l, #md) * Extensible(l, true) *
	   ((#md, "@proto")      -> #pr) *
	   ((#md, "@class")      -> #cl) *
	   ((#md, "@extensible") -> #ext) *
	   MetaData(#md, null) * Extensible(#md, true) * 
	   (ret == #l) ]]
    normal

proc create_default_object (l, pr, cl, ext) {

			goto [cl = undefined] scl text;
	scl:	cl := "Object";
	text:	goto [ext = undefined] sext setall;
	sext:	ext := true;

			(* Get the metadata, creating the object in the process *)
	setall:	m := metadata(l);
			
			(* Set the internal properties in the metadata *)
			[m, "@proto"] := pr;
			[m, "@class"] := cl;
			[m, "@extensible"] := ext;

	rlab:	xret := l
}
with
{
	ret:	xret, rlab;
};

(* ******************
 * OBJECT_CONSTRUCT *
 ********************)

spec Object_construct (xsc, vthis, l)
    
    [[ (l == #l) * types(#l:Undefined) ]]
    [[ JSObject(ret) * empty_fields(ret : -{ }-) ]]
    normal
    
    (* TODO: for Object, Boolean, Number, String *)

proc Object_construct (xsc, vthis, l) {

			goto [typeOf(l) = Obj] obj l1b;
	obj:	xret := l;
			goto rlab;

	l1b:	goto [(typeOf(l) = Bool) or (typeOf(l) = Num) or (typeOf(l) = Str)] to_obj norm;
	to_obj:	xret := "i__toObject" (l);
			goto rlab;

	norm:	xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lobj_proto, "Object", true);
	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* ***********************************
 * CREATE_OBJECT_WITH_CALL_CONSTRUCT *
 *************************************)

spec create_object_with_call_construct (l, call, construct, len)

    [[ (l == #l) * (call == #call) * (construct == empty) * (len == #len) *
	   types(#call:Str, #len:Num) *
	   ((#l, "length") -> _) * 
       MetaData(#l, #md) * Extensible(#l, true) *
	   ((#md, "@proto")      -> _) *
	   ((#md, "@class")      -> _) *
	   ((#md, "@extensible") -> _) *
	   ((#md, "@scope")      -> _) * 
	   ((#md, "@call")       -> _) *
	   MetaData(#md, null) * Extensible(#md, true) ]]
    [[ ((#l, "length") -> {{ "d", #len, false, false, false }}) *  
       MetaData(#l, #md) * Extensible(#l, true) *
       ((#md, "@proto")      -> $lfun_proto) *
	   ((#md, "@class")      -> "Function") *
	   ((#md, "@extensible") -> true) *
	   ((#md, "@scope")      -> empty) * 
	   ((#md, "@call")       -> #call) *
	   MetaData(#md, null) * Extensible(#md, true) *
	   (ret == #l) ]]
    normal;

    [[ (l == #l) * (call == #call) * (construct == #construct) * (len == #len) *
	   types(#call:Str, #construct:Str, #len:Num) *
	   ((#l, "length") -> _) * 
       MetaData(#l, #md) * Extensible(#l, true) *
	   ((#md, "@proto")      -> _) *
	   ((#md, "@class")      -> _) *
	   ((#md, "@extensible") -> _) *
	   ((#md, "@scope")      -> _) * 
	   ((#md, "@call")       -> _) *
	   ((#md, "@construct")  -> _) *
	   MetaData(#md, null) * Extensible(#md, true) ]]
    [[ ((#l, "length") -> {{ "d", #len, false, false, false }}) *  
       MetaData(#l, #md) * Extensible(#l, true) *
       ((#md, "@proto")      -> $lfun_proto) *
	   ((#md, "@class")      -> "Function") *
	   ((#md, "@extensible") -> true) *
	   ((#md, "@scope")      -> empty) * 
	   ((#md, "@call")       -> #call) *
	   ((#md, "@construct")  -> #construct) *
	   MetaData(#md, null) * Extensible(#md, true) *
	   (ret == #l) ]]
    normal
    
proc create_object_with_call_construct (l, call, construct, len) {

			xret := "create_default_object" (l, $lfun_proto, "Function", true);

			[xret, "length"] := {{ "d", len, false, false, false }};

			(* Get the metadata *)
			m := metadata(xret);
			
			(* Set the internal scope, call and construct properties *)
			[m, "@scope"] := empty;
			[m, "@call"] := call;
			
			goto [construct = empty] rlab cstr;

	cstr:	[m, "@construct"] := construct;

	rlab:	xret := l
}
with
{
	ret:	xret, rlab;
};

(* ************************
 * CREATE_FUNCTION_OBJECT *
 **************************)

spec create_function_object (xsc, call, construct, params)

    [[ (xsc == #xsc) * (call == #call) * (construct == #construct) * (params == #params) * (#call == #construct) *
       types(#xsc:List, #call:Str, #construct:Str, #params:List) ]]
    [[ JSFunctionObject(ret, #call, #xsc, #len, #prototype) * 
       empty_fields(ret : -{ "arguments", "caller", "length", "prototype" }-) *
       (#len == l-len #params) *
	   JSObject(#prototype) *
	   ((#prototype, "constructor") -> {{ "d", ret, true, false, true }}) *
	   empty_fields(#prototype : -{ "constructor" }-) ]]
    normal

proc create_function_object (xsc, call, construct, params) {
			len := l-len (params);
			m := new (null);
			l := new (m);
			l := "create_object_with_call_construct" (l, call, construct, len);

			[m, "@scope"] := xsc;

			prototype := "Object_construct" ();
			[prototype, "constructor"] := {{ "d", l, true, false, true }};
			[l, "prototype"]           := {{ "d", prototype, true, false, false }};

			(* Strict mode only *)
			[l, "caller"]    := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};
			[l, "arguments"] := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};

			xret := l;

	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(************************
 ***** INITIAL HEAP *****
 ************************)
 
spec setupInitialHeap ()

	[[ initialHeapPre() ]]
	[[ initialHeapPost( -{ }- ) * (ret == empty) ]]
	normal

proc setupInitialHeap () {

			(* Global object *)

			xret := "create_default_object" ($lg, $lobj_proto, "Object", true);

			(* Object.prototype *)

			xret := "create_default_object" ($lobj_proto, null, "Object", true);
			
			[$lobj_proto, "hasOwnProperty"] := {{ "d", $lop_hasOwnProperty, true, false, true }};
  			
  			xret := "create_object_with_call_construct" ($lop_hasOwnProperty, "OP_hasOwnProperty", empty, 1);

			(* Function.prototype *)
			
			xret := "create_object_with_call_construct" ($lfun_proto, "FP_default", empty, 0);
			m := metadata($lfun_proto); 
   			[m, "@proto"] := $lobj_proto;
   			
			(* Boolean.prototype *)

			xret := "create_default_object" ($lbool_proto, $lobj_proto, "Boolean", true);
			
			m := metadata($lbool_proto); 
			[m, "@primitiveValue"] := false;

			[$lbool_proto, "constructor"] := {{ "d", $lbool, true, false, true }};
			[$lbool_proto, "toString"]    := {{ "d", $lbp_toString, true, false, true }};
			[$lbool_proto, "valueOf"]     := {{ "d", $lbp_valueOf, true, false, true }};
			
			(* Number.prototype *)

			xret := "create_default_object" ($lnum_proto, $lobj_proto, "Number", true);

			m := metadata($lnum_proto);
			[m,           "@primitiveValue"]      := 0;
			[$lnum_proto, "constructor"]          := {{ "d", $lnum, true, false, true }};
			[$lnum_proto, "toString"]             := {{ "d", $lnp_toString, true, false, true }};
			[$lnum_proto, "toLocaleString"]       := {{ "d", $lnp_toLocaleString, true, false, true }};
			[$lnum_proto, "valueOf"]              := {{ "d", $lnp_valueOf, true, false, true }};
			[$lnum_proto, "toFixed"]              := {{ "d", $lnp_toFixed, true, false, true }};
			[$lnum_proto, "toExponential"]        := {{ "d", $lnp_toExponential, true, false, true }};
			[$lnum_proto, "toPrecision"]          := {{ "d", $lnp_toPrecision, true, false, true }};
			
			(* Error object *)

			xret := "create_object_with_call_construct" ($lerr, "Error_call", "Error_construct", 1);
			[$lg, "Error"] := {{ "d", $lerr, true, false, true }};
			[$lerr, "prototype"] := {{ "d", $lerr_proto, false, false, false }};

			(* Error.prototype *)

			xret := "create_default_object" ($lerr_proto, $lobj_proto, "Error", true);
			[$lerr_proto, "message"]     := {{ "d", "", true, false, true }};

	rlab:	xret := empty
}
with
{
	ret:	xret, rlab;
};

(***********************
 ***********************
 ***** CONVERSIONS *****
 ***********************
 ***********************)  

(* *************
 * I__TOSTRING *
 ***************)

spec i__toString (v)

	[[ v == undefined ]]
	[[ ret == "undefined" ]]
	normal;

	[[ v == null ]]
	[[ ret == "null" ]]
	normal;
	
	[[ v == true ]]
	[[ ret == "true" ]]
	normal;
	
	[[ v == false ]]
	[[ ret == "false" ]]
	normal;

	[[ (v == #v) * types(#v:Num) ]]
	[[ types(ret:Str) * (ret == (num_to_string #v)) ]]
	normal;
	
	[[ (v == #v) * types(#v:Str) ]]
	[[ types(ret:Str) * (ret == #v) ]]
	normal
	
	(* TODO: for Object [HO] *)

proc i__toString (v) {
	iu:		goto [v = undefined] undef in;
	undef:	xret := "undefined";
			goto rlab;

	in:		goto [v = null] nul ib;
	nul:	xret := "null";
			goto rlab;

	ib:		goto [typeOf(v) = Bool] bool inum;
	bool:	goto [v = true] is_t is_f;
	is_t:	xret := "true";
			goto rlab;
	is_f:	xret := "false";
			goto rlab;

	inum:	goto [typeOf(v) = Num] num is;
	num:	xret := num_to_string v;
			goto rlab;

	is:		goto [typeOf(v) = Str] str io;
	str:	xret := v;
			goto rlab;

	io:		goto [typeOf(v) = Obj] obj oops;
	obj:	xret := "i__toPrimitive" (v, "String") with elab;
			xret := "i__toString" (xret) with elab;
			goto rlab;

	oops:	xret := "TypeError" ("ToString: This should not happen.");
            goto elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *************
 * I__TONUMBER *
 ***************)

spec i__toNumber (v)

	[[ v == null ]]
	[[ ret == 0 ]]
	normal;

	[[ v == true ]]
	[[ ret == 1 ]]
	normal;

	[[ v == false ]]
	[[ ret == 0 ]]
	normal;

	[[ (v == #v) * types(#v:Num) ]]
	[[ ret == #v ]]
	normal;

	[[ (v == #v) * types(#v:Str) ]]
	[[ ret == (string_to_num #v) ]]
	normal

proc i__toNumber (v) {
    iu:		goto [v = undefined] undef in;
	undef:	xret := nan;
    		goto rlab;

    in:		goto [v = null] nul ib;
	nul:	xret := 0;
    		goto rlab;

    ib:		goto [typeOf(v) = Bool] bool inum;
	bool:	goto [v = true] is_t is_f;
    is_t:	xret := 1;
    		goto rlab;
    is_f:	xret := 0;
    		goto rlab;

    inum:	goto [typeOf(v) = Num] num is;
    num:	xret := v;
    		goto rlab;

    is:		goto [typeOf(v) = Str] str io;
    str:	xret := string_to_num v;
    		goto rlab;

    io:		goto [typeOf(v) = Obj] obj oops;
    obj:	xret := "i__toPrimitive" (v, "Number") with elab;
    		xret := "i__toNumber" (xret);
    		goto rlab;

    oops:	xret := "TypeError" ("ToNumber: This should not happen.");
            goto elab;

    rlab:	skip;
    elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *************
 * I__TOOBJECT *
 ***************)

spec i__toObject (v) 

	[[ (v == #v) * types(#v:Obj) ]]
	[[ (ret == #v) ]]
	normal;

	[[ (v == #v) * types(#v:Bool) ]]
	[[ BooleanObject(ret, #v) * empty_fields(ret : -{ }-) ]]
	normal;
	
	[[ (v == #v) * types(#v:Num) ]]
	[[ NumberObject(ret, #v) * empty_fields(ret : -{ }-) ]]
	normal

proc i__toObject (v) {
	iu:		goto [v = undefined] throw in;

	in:		goto [v = null] throw ib;

	ib:		goto [typeOf(v) = Bool] bool inum;
	bool:	xret := "Boolean_construct" (undefined, undefined, v);
			goto rlab;

	inum:	goto [typeOf(v) = Num] num is;
	num:	xret := "Number_construct" (undefined, undefined, v);
			goto rlab;

	is:		goto [typeOf(v) = Str] str io;
	str:	xret := "String_construct" (undefined, undefined, v);
			goto rlab;

	io:		goto [typeOf(v) = Obj] obj oops;
	obj:	xret := v;
			goto rlab;

	oops:	xret := "ToObject: This should not happen.";

	rlab:	skip;

	throw:	xret := "Here!";
			xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *************
 * I_TOBOOLEAN *
 ***************)

spec i__toBoolean (v)

	[[ v == undefined ]]
	[[ ret == false ]]
	normal;

	[[ v == null ]]
	[[ ret == false ]]
	normal;

	[[ (v == #v) * types(#v:Bool) ]]
	[[ ret == #v ]]
	normal; 

	[[ v == 0 ]]
	[[ ret == false ]]
	normal;
	
	[[ (v == #v) * types(#v:Num) * (! (#v == 0)) ]]
	[[ (ret == true) ]]
	normal;
	
	[[ v == "" ]]
	[[ ret == false ]]
	normal;
	
	[[ (v == #v) * types(#v:Str) * (! (#v == "")) ]]
	[[ ret == true ]]
	normal;
	
	[[ (v == #v) * types(#v:Obj) ]]
	[[ ret == true ]]
	normal

	(* TODO: for NaN *)

proc i__toBoolean (v) {
	iu:		goto [v = undefined] undef in;
	undef:	xret := false;
			goto rlab;

	in:		goto [v = null] nul ib;
	nul:	xret := false;
			goto rlab;

	ib:		goto [typeOf(v) = Bool] bool inum;
	bool:	xret := v;
			goto rlab;

	inum:	goto [typeOf(v) = Num] num is;
	num:	goto [(v = 0) or (not (v = v))] is_f is_t;

	is:		goto [typeOf(v) = Str] str io;
	str:	goto [v = ""] is_f is_t;
			goto rlab;

	io:		goto [typeOf(v) = Obj] obj oops;
	obj:	xret := true;
			goto rlab;

	is_t:	xret := true;
			goto rlab;
	is_f:	xret := false;
			goto rlab;

	oops:	xret := "ToBoolean: This should not happen.";

	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(******************
 ******************
 ***** ERRORS *****
 ******************
 ******************)  

(*******************
 * ERROR_CONSTRUCT *
 *******************)

spec Error_construct (xsc, vthis, v)

    (* Error constructor without message *)
    [[ (v == undefined) * (vthis == #vthis) *
       MetaData(#vthis, #mvt) * Extensible(#vthis, true) *
       ((#mvt, "@class") -> #oc) * ((#mvt, "@extensible") -> #oe) *
       MetaData(#mvt, null) * Extensible(#mvt, true) ]]
    [[ (ret == #vthis) * 
       MetaData(#vthis, #mvt) * Extensible(#vthis, true) *
       ((#mvt, "@class") -> "Error") * ((#mvt, "@extensible") -> true) *
       MetaData(#mvt, null) * Extensible(#mvt, true) ]]
    normal;
    
    (* Error constructor with message of type string *)
    [[ (v == #m) * (vthis == #vthis) *
	   types (#m:Str) * 
       ((#vthis, "message") -> #om) * 
       MetaData(#vthis, #mvt) *
       ((#mvt, "@class") -> #oc) * ((#mvt, "@extensible") -> #oe) ]]
    [[ (ret == #vthis) * 
       ((#vthis, "message") -> {{ "d", #m, true, false, true }}) *
       MetaData(#vthis, #mvt) *
       ((#mvt, "@class") -> "Error") * ((#mvt, "@extensible") -> true) ]]
    normal

proc Error_construct (xsc, vthis, v) {
			xret := vthis;

			m := metadata(vthis);
			[m, "@class"] := "Error";
			[m, "@extensible"] := true;

			goto [v = undefined] rlab mess;

	mess:	xerr := "i__toString" (v) with elab;
			[xret, "message"] := {{ "d", xerr, true, false, true }};

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xerr, elab;
};

(*********************************)
(* TYPEERROR_CALL and _CONSTRUCT *)
(*********************************)

spec TypeError_call (xsc, vthis, v)

    [[ v == undefined ]]
    [[ isTypeError(ret) ]]
    normal

proc TypeError_call (xsc, vthis, v) {
			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lterr_proto, "Error", true);

			xret := "Error_construct" (undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec TypeError (v)

    [[ v == undefined ]]
    [[ isTypeError(ret) ]]
    normal

proc TypeError (v) {
			xret := "TypeError_call" (undefined, undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(**************************************)
(* REFERENCEERROR_CALL and _CONSTRUCT *)
(**************************************)

spec ReferenceError_call (xsc, vthis, v)

    [[ v == undefined ]]
    [[ isReferenceError(ret) ]]
    normal

proc ReferenceError_call (xsc, vthis, v) {
			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lrferr_proto, "Error", true);

			xret := "Error_construct" (undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec ReferenceError (v)

    [[ v == undefined ]]
    [[ isReferenceError(ret) ]]
    normal

proc ReferenceError (v) {
			xret := "ReferenceError_call" (undefined, undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(***********************************)
(* SYNTAXERROR_CALL and _CONSTRUCT *)
(***********************************)

spec SyntaxError_call (xsc, vthis, v)

    [[ v == undefined ]]
    [[ isSyntaxError(ret) * empty_fields(ret : -{ }-) *
       MetaData(ret, #md) * empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc SyntaxError_call (xsc, vthis, v) {
			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lserr_proto, "Error", true);

			xret := "Error_construct" (undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec SyntaxError (v)

    [[ v == undefined ]]
    [[ isSyntaxError(ret) * empty_fields(ret : -{ }-) *
       MetaData(ret, #md) * empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc SyntaxError (v) {
			xret := "SyntaxError_call" (undefined, undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(***********************
 ***********************
 ***** AUXILIARIES *****
 ***********************
 ***********************)  
 
 (* ********************* *)
(* CHECKASSIGNMENTERRORS *)
(* ********************* *)

spec i__checkAssignmentErrors (v)

    [[ v == undefined ]]
    [[ ret == true ]]
    normal;

    [[ v == null ]]
    [[ ret == true ]]
    normal;

	[[ types (v:Num) ]]
	[[ (ret == true) ]]
	normal;

    [[ types (v:Bool) ]]
    [[ ret == true ]]
    normal;

    [[ types (v:Str) ]]
    [[ ret == true ]]
    normal;

    [[ types (v:Obj) ]]
    [[ ret == true ]]
    normal;

    [[ (v == #v) * types (#v:List) * (#v == {{ "v", #l, #prop }}) * types(#l:Obj, #prop:Str) *
	   (! (#prop == "eval")) * (! (#prop == "arguments"))]]
    [[ ret == true ]]
    normal;

    [[ (v == #v) * types (#v:List, #l:Obj) * (#v == {{ "v", #l, "eval" }}) ]]
    [[ isSyntaxError(ret) * empty_fields(ret : -{ }-) ]]
    error;

    [[ (v == #v) * types (#v:List, #l:Obj) * (#v == {{ "v", #l, "arguments" }}) ]]
    [[ isSyntaxError(ret) * empty_fields(ret : -{ }-) ]]
    error;

    [[ (v == #v) * types (#v:List, #base:Obj, #field:Str) * (#v == {{ "o", #base, #field }}) ]]
    [[ ret == true ]]
    normal

proc i__checkAssignmentErrors (v) {
			tv := typeOf (v);
			goto [(tv = List) and ((l-nth (v, 0) = "v") or (l-nth (v, 0) = "o"))] prep rlab;

	prep:	fv := l-nth (v, 2);

	csyn:	goto [(l-nth (v, 0) = "v") and ((fv = "eval") or (fv = "arguments"))] se rlab;

	rlab:	xret := true;

	se:		xret := "SyntaxError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};
 
(* **********************
   *** I__ISPRIMITIVE ***
   ********************** *)

spec i__isPrimitive (v)

   [[ v == undefined ]]
   [[ ret == true ]]
   normal;

   [[ v == null ]]
   [[ ret == true ]]
   normal;

   [[ types (v:Num) ]]
   [[ (ret == true) ]]
   normal;

   [[ types (v:Bool) ]]
   [[ (ret == true) ]]
   normal;

   [[ types (v:Str) ]]
   [[ (ret == true) ]]
   normal;

   [[ types (v:Obj) ]]
   [[ (ret == false) ]]
   normal

proc i__isPrimitive (v) {
			tv := typeOf(v);

	iu:		goto [(v = undefined) or (v = null) or
	              (typeOf(v) = Bool) or (typeOf(v) = Num) or
	              (typeOf(v) = Str)] rt rf;

	rt:		xret := true;
			goto rlab;

	rf:		xret := false;
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* **********************************************
   **********************************************
   ***********   INTERNAL FUNCTIONS   ***********
   **********************************************
   ********************************************** *)

(* *************************
   *** O__GETOWNPROPERTY ***
   ************************* *)

(*
 *    Name: o__getOwnProperty 
 * Purpose: Get own property of a non-String object
 *
 *   Specs:
 *
 * 01 - Property not defined, return undefined
 * 02 - Property defined, return property descriptor
 *
 *)

spec o__getOwnProperty (l, prop)

    [[ (l == #l) * (prop == #prop) * Cell_o (#l, #prop, none) ]]
    [[ Cell_o (#l, #prop, none) * (ret == undefined) ]]
    normal;

    [[ (l == #l) * (prop == #prop) * Cell_o (#l, #prop, #dx) * Descriptor(#dx) ]]
    [[ Cell_o (#l, #prop, #dx) * (ret == #dx) ]]
    normal

proc o__getOwnProperty (l, prop) {
            x := hasField(l, prop);
            goto [x] hp nhp; 			(* Does the field exist? *)

    nhp:    xret := undefined;			(* Field doesn't exist; return undefined *)
            goto rlab;

    hp:     xret := [l, prop];			(* Field exists; return the descriptor *)

    rlab:   skip
}
with
{
    ret: 	xret, rlab;
};

(*
 *    Name: s__getOwnProperty 
 * Purpose: Get own property of a String object
 *
 *   Specs:
 *
 * 01 - Property defined, return property descriptor
 *
 *)

spec s__getOwnProperty (l, prop) 

    [[ (l == #l) * (prop == #prop) * Cell_s (#l, #prop, #dx) * Descriptor(#dx) ]]
    [[ Cell_s (#l, #prop, #dx) * (ret == #dx) ]]
    normal

proc s__getOwnProperty (l, prop) {
			xret := "o__getOwnProperty" (l, prop);
			goto [xret = undefined] str rlab;

	str:	idx := "i__toInteger" (prop) with elab;
			goto [idx < 0] rlab next;

	next:	sidx := "i__toString" (idx);

			goto [sidx = prop] index rlab;

	index:	m := metadata(l);
			str := [m, "@primitiveValue"];
			len := s-len (str);
			goto [len <= idx] rlab return;

	return: rstr := s-nth (str, idx);
			xret := {{ "d", rstr, false, true, false }};

	rlab: 	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* **********************
   *** GETOWNPROPERTY ***
   ********************** *)

(*
 *    Name: getOwnProperty 
 * Purpose: Get own property of a (general) object
 *
 *   Specs:
 *
 * 01 - Non-string object, property not defined, return undefined
 * 02 - Any object, property defined, return property descriptor
 *
 *)

spec getOwnProperty (l, prop)

    [[ (l == #l) * (prop == #prop) * Cell_o (#l, #prop, none) *
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-String") ]]
    [[ Cell_o (#l, #prop, none) * 
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * (ret == undefined) ]]
    normal;

    [[ (l == #l) * (prop == #prop) * Cell_o (#l, #prop, #dx) * Descriptor(#dx) *
       MetaData(#l, #md) * ((#md, "@class") -> #cls) ]]
    [[ Cell_o (#l, #prop, #dx) * 
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * (ret == #dx) ]]
    normal

proc getOwnProperty (l, prop) {

			m := metadata(l);
			class := [m, "@class"];

			goto [class = "String"] sgop ogop;

	sgop:	xret := "s__getOwnProperty" (l, prop) with elab;
			goto rlab;

	ogop:	xret := "o__getOwnProperty" (l, prop) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(*
 *    Name: getProperty 
 * Purpose: Get property of a (general) object, considering prototype inheritance
 *
 *   Specs:
 *
 * 01 - Get the heap value associated with the appropriate Pi
 *)

spec getProperty (l, prop)

	[[ (l == #l) * (prop == #prop) * Pi (#l, #prop, #d, #ls, #cls, #pv) ]]
	[[ Pi (#l, #prop, #d, #ls, #cls, #pv) * (ret == #d) ]]
	normal

proc getProperty (l, prop) {

			[* unfold Pi (#l, #prop, #d, #ls, #cls, #pv) *]
			xret := "getOwnProperty" (l, prop) with elab;
			goto [xret = undefined] next rlab;

	next:	m := metadata(l);
			proto := [m, "@proto"];
			goto [proto = null] rlab call;

	call:	xret := "getProperty" (proto, prop) with elab;

			[* fold Pi (#l, #prop, #d, #ls, #cls, #pv) *]
    rlab:   skip;
    elab:	skip
}
with
{
    ret: 	xret, rlab;
    err:	xret, elab;
};

(* *********** *)
(* *** GET *** *)
(* *********** *)

(*
 *    Name: get 
 * Purpose: Get the value of a property of a (general) object in the entire prototype chain
 *
 *   Specs:
 *
 * 01 - Property not defined in the prototype chain, return undefined ]
 * 02 - Property defined, data descriptor, get value of the descriptor 
 *)

spec get (l, prop)

    [[ (l == #l) * (prop == #prop) *
	   Pi (#l, #prop, #d, #ls, #cls, #pv) * (#d == undefined) ]]
    [[ Pi (#l, #prop, #d, #ls, #cls, #pv) * (ret == undefined) ]]
    normal;
    
    [[ (l == #l) * (prop == #prop) *
	   Pi (#l, #prop, #d, #ls, #cls, #pv) * DataDescriptor (#d) ]]
    [[ Pi (#l, #prop, #d, #ls, #cls, #pv) * desc_val (#d, #desc_val) * (ret == #desc_val) ]]
    normal

proc get (l, prop) {

			xret := "getProperty" (l, prop) with elab;
			goto [xret = undefined] rlab def;		(* Does the field exist?    *)

	def:	d := l-nth (xret, 0);					(* Get the descriptor type  *)
			xret := l-nth (xret, 1);				(* Get the value/getter     *)
			goto [d = "d"] rlab acc;				(* Is it a data descriptor? *)

	acc:	goto [xret = undefined] rlab get;		(* Is the getter defined?               *)
	get:	m := metadata(xret);
			xsc := [m, "@scope"];				    (* Get the scope of the getter          *)
			fun := [m, "@call"];					(* Get the name of the getter           *)
			xret := fun (xsc, l) with elab;			(* Call the getter, errors could happen *)
			goto [xret = empty] undef rlab;
	undef:	xret := undefined;

	rlab:	skip;
	elab:	skip
}
with
{
    ret: xret, rlab;
    err: xret, elab;
};

(* ******************* *)
(* *** I__GETVALUE *** *)
(* ******************* *)

(*
 *    Name: getValue
 * Purpose: Get the value of SOMETHING
 *
 *   Specs:
 *
 * 01-06 - Something is not a reference, just return something
 * 07 - Object reference, undefined
 * 08 - Object reference, defined
 * 09 - Variable reference, lg, undefined
 * 10 - Variable reference, lg, defined
 * 11 - Variable reference, non-lg, directly from the heap
 * 12-13 - Base undefined for both variable and object references, return a reference error 
 *
 * Remaining:
 *
 * Object conversion:
 * 
 * 14-19 - Conversion to Number, String, Boolean, property exists or doesn't 
 *
 * Unsupported:
 *
 * 20-?? - Getters
 *)

spec i__getValue (v)

    [[ v == undefined ]]
    [[ ret == undefined ]]
    normal;
    
    [[ v == null ]]
    [[ ret == null ]]
    normal;

    [[ (v == #v) * types (#v : Obj) ]]
	[[ (ret == #v) ]]
	normal;

    [[ (v == #v) * types (#v : Num) ]]
	[[ (ret == #v) ]]
	normal;

    [[ (v == #v) * types (#v : Bool) ]]
	[[ (ret == #v) ]]
	normal;

    [[ (v == #v) * types (#v : Str) ]]
	[[ (ret == #v) ]]
	normal;

    [[ (v == {{ "o", #obj, #field }}) * 
       Pi (#obj, #field, #d, #ls, #lcls, #lpv) * (#d == undefined) ]]
    [[ Pi (#obj, #field, #d, #ls, #lcls, #lpv) * (ret == undefined) ]]
    normal;

    [[ (v == {{ "o", #obj, #field }}) * 
       Pi (#obj, #field, #d, #ls, #lcls, #lpv) * DataDescriptor (#d)  ]]
    [[ Pi (#obj, #field, #d, #ls, #lcls, #lpv) * desc_val (#d, #desc_val) * (ret == #desc_val) ]]
    normal;

    [[ (v == {{ "v", $lg, #field }}) * 
       Pi ($lg, #field, #d, #ls, #lcls, #lpv) * (#d == undefined) ]]
    [[ Pi ($lg, #field, #d, #ls, #lcls, #lpv) * (ret == undefined) ]]
    normal;

    [[ (v == {{ "v", $lg, #field }}) *
       Pi ($lg, #field, #d, #ls, #lcls, #lpv) * DataDescriptor (#d)  ]]
    [[ Pi ($lg, #field, #d, #ls, #lcls, #lpv) * desc_val (#d, #desc_val) * (ret == #desc_val) ]]
    normal;

    [[ (v == {{ "v", #obj, #field }}) * (! (#obj == $lg)) * ((#obj, #field) -> #value) ]]
    [[ ((#obj, #field) -> #value) * (ret == #value) ]]
    normal;

	[[ (v == {{ "v", undefined, #field }}) * types (#field:Str) ]]
    [[ isReferenceError(err) ]]
    error;

	[[ (v == {{ "o", undefined, #field }}) * types (#field:Str) ]]
    [[ isReferenceError(err) ]]
    error;
    
    (* Now come the more involved specs *)
    
    [[ (v == {{ "o", #b, #field }}) * types(#b:Bool) * Pi($lbool_proto, #field, #d, #pls, #plcls, #plpv) * (#d == undefined) ]]
    [[ (xobj == #o) * BooleanObject(#o, #b) * empty_fields(#o : -{ }-) * Pi($lbool_proto, #field, #d, #pls, #plcls, #plpv) * (ret == undefined) ]]
    normal;

    [[ (v == {{ "o", #b, #field }}) * types(#b:Bool) * Pi($lbool_proto, #field, #d, #pls, #plcls, #plpv) * DataDescriptor(#d) ]]
    [[ (xobj == #o) * BooleanObject(#o, #b) * empty_fields(#o : -{ }-) * Pi($lbool_proto, #field, #d, #pls, #plcls, #plpv) * desc_val(#d, #dval) * (ret == #dval) ]]
    normal;
    
    [[ (v == {{ "o", #n, #field }}) * types(#n:Num) * Pi($lnum_proto, #field, #d, #pls, #plcls, #plpv) * (#d == undefined) ]]
    [[ (xobj == #o) * NumberObject(#o, #n) * empty_fields(#o : -{ }-) * Pi($lnum_proto, #field, #d, #pls, #plcls, #plpv) * (ret == undefined) ]]
    normal;

    [[ (v == {{ "o", #n, #field }}) * types(#n:Num) * Pi($lnum_proto, #field, #d, #pls, #plcls, #plpv) * DataDescriptor(#d) ]]
    [[ (xobj == #o) * NumberObject(#o, #n) * empty_fields(#o : -{ }-) * Pi($lnum_proto, #field, #d, #pls, #plcls, #plpv) * desc_val(#d, #dval) * (ret == #dval) ]]
    normal

proc i__getValue (v) {

			goto [(typeOf(v) = List)] rcand dflt;

   	rcand:  rtype := l-nth (v, 0);
           	goto [(rtype = "v") or (rtype = "o")] init dflt;

	init:	rbase := l-nth (v, 1);
			rfield := l-nth (v, 2);
			goto [rbase = undefined] throw prim;

	prim:	prim := "i__isPrimitive" (rbase);
      	    goto [prim] is_pr ref;

	is_pr:	xobj := "i__toObject" (rbase) with pelab;
	
			[* fold Pi(xobj, #field, #d, #ls, #lcls, #lpv) *]
			xret := "getProperty" (xobj, rfield) with pelab;
			[* unfold Pi(xobj, #field, #d, #ls, #lcls, #lpv) *]
			goto [xret = undefined] rlab def;
	def:	d := l-nth (xret, 0);	(* Get the descriptor type *)
			xret := l-nth (xret, 1);	(* Get the value/getter *)
			goto [d = "d"] rlab acc;	(* Is it a data descriptor? *)

	acc:	goto [xret = undefined] rlab get;	(* Is the getter defined? *)
	get:	m := metadata(xret);
			xsc := [m, "@scope"];	(* Get the scope of the getter *)
			fun := [m, "@call"];	(* Get the name of the getter *)
			xret := fun (xsc, rbase) with pelab; (* Call the getter, errors could happen *)
			goto [xret = empty] undef rlab;
	undef:	xret := undefined;

	ref:	goto [(typeOf(v) = List) and (l-nth (v, 0) = "o")] oref vref;

	oref:	xret := "get" (rbase, rfield) with pelab;
			goto rlab;

	vref:	goto [rbase = $lg] lg er;

	lg:		xret := "get" (rbase, rfield) with pelab;
			goto rlab;

	er:		xret := [rbase, rfield];
			goto rlab;

	dflt:	xret := v;
	rlab:	skip;

	throw:  xret := "ReferenceError" ();
   	pelab:  xret := PHI(xobj, xret, xret, xret, xret, xret);
   	 elab:  skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *********** *)
(* HASPROPERTY *)
(* *********** *)

spec hasProperty (l, prop)

	[[ (l == #l) * (prop == #prop) *
	   Pi (#l, #prop, undefined, #ls, #cls, #pv) ]]
	[[ Pi (#l, #prop, undefined, #ls, #cls, #pv) * (ret == false) ]]
	normal;

	[[ (l == #l) * (prop == #prop) *
	   Pi (#l, #prop, #d, #ls, #cls, #pv) * Descriptor(#d) ]]
	[[ Pi (#l, #prop, #d, #ls, #cls, #pv) * (ret == true) ]]
	normal

proc hasProperty (l, prop) {
			xret := "getProperty" (l, prop) with elab;

	rlab:	xret := not (xret = undefined);
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};

(* ************** *)
(* DELETEPROPERTY *)
(* ************** *)

spec deleteProperty (l, prop, throw)

    [[ (l == #l) * (prop == #prop) * Cell_o (#l, #prop, none) *
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-String") ]]
    [[ Cell_o (#l, #prop, none) * 
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * (ret == true) ]]
    normal;
    
	[[ (l == #l) * (prop == #prop) *
	   Cell_o(#l, #prop, #d) * Descriptor(#d) * desc_conf(#d, true) * 
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-String") ]]
	[[ Cell_o(#l, #prop, none) * 
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * (ret == true) ]]
	normal;

	[[ (l == #l) * (prop == #prop) * (throw == false) *
	   Cell_o(#l, #prop, #d) * Descriptor(#d) * desc_conf(#d, false) * 
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-String") ]]
	[[ Cell_o(#l, #prop, #d) * 
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * (ret == false) ]]
	normal;

	[[ (l == #l) * (prop == #prop) * (throw == true) *
	   Cell_o(#l, #prop, #d) * Descriptor(#d) * desc_conf(#d, false) * 
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-String") ]]
	[[ Cell_o(#l, #prop, #d) * 
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * isTypeError(err) ]]
	error

proc deleteProperty (l, prop, throw) {

			xret := "getOwnProperty" (l, prop) with elab;
			goto [xret = undefined] dt cont;

	cont:	c := l-nth (xret, 4);
			goto [c] del reject;

	del:	delete (l, prop);

	dt:		xret := true;
			goto rlab;

	df:		xret := false;
	rlab:	skip;

    reject: goto [throw] tt df;

    tt:     xret := "TypeError" ();
    elab:   skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* *********************************************************
   *********************************************************
   ***********   BUILT-IN LIBRARY CONSTRUCTORS   ***********
   *********************************************************
   ********************************************************* *)
  
(* ************************* *)
(* *** BOOLEAN_CONSTRUCT *** *)
(* ************************* *)  

spec Boolean_construct (xsc, vthis, v) 

	[[ (v == #v) * types(v:Bool) ]]
	[[ BooleanObject(ret, #v) * empty_fields(ret : -{ }-) ]]
	normal

proc Boolean_construct (xsc, vthis, v) {
			pv := "i__toBoolean" (v);

			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lbool_proto, "Boolean", true);

			m := metadata(xret);
			[m, "@primitiveValue"] := pv;

	rlab:	skip
}
with
{
	ret: 	xret, rlab;
};

(* ************************ *)
(* *** NUMBER_CONSTRUCT *** *)
(* ************************ *)

spec Number_construct (xsc, vthis, v) 

	[[ (v == #v) * types(v:Num) ]]
	[[ NumberObject(ret, #v) * empty_fields(ret : -{ }-) ]]
	normal

proc Number_construct (xsc, vthis, v) {

	init:	pv := "i__toNumber" (v) with elab;

			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lnum_proto, "Number", true);

			m := metadata(xret);
			[m, "@primitiveValue"] := pv;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: pv, elab;
};