(* ******************
   *** PREDICATES ***
   ****************** *)

import javert_js_predicates.jsil;


(*******************
 *******************
 ***** OBJECTS *****
 *******************
 *******************)    

(* ***********************
 * CREATE_DEFAULT_OBJECT *
 *************************)

spec create_default_object (l, pr, cl, ext)

    [[ (l == #l) * (pr == #pr) * (cl == undefined) * (ext == undefined) *
	   MetaData(l, #md) * Extensible(l, true) *
	   ((#md, "@proto")      -> _) *
	   ((#md, "@class")      -> _) *
	   ((#md, "@extensible") -> _) *
	   MetaData(#md, null) * Extensible(#md, true) ]]
    [[ MetaData(l, #md) * Extensible(l, true) *
	   ((#md, "@proto")      -> #pr) *
	   ((#md, "@class")      -> "Object") *
	   ((#md, "@extensible") -> true) *
	   MetaData(#md, null) * Extensible(#md, true) * 
	   (ret == #l) ]]
    normal;
    
    [[ (l == #l) * (pr == #pr) * (cl == #cl) * (ext == #ext) *
	   types(#cl:Str, #ext:Bool) *
       MetaData(l, #md) * Extensible(l, true) *
	   ((#md, "@proto")      -> _) *
	   ((#md, "@class")      -> _) *
	   ((#md, "@extensible") -> _) *
	   MetaData(#md, null) * Extensible(#md, true) ]]
    [[ MetaData(l, #md) * Extensible(l, true) *
	   ((#md, "@proto")      -> #pr) *
	   ((#md, "@class")      -> #cl) *
	   ((#md, "@extensible") -> #ext) *
	   MetaData(#md, null) * Extensible(#md, true) * 
	   (ret == #l) ]]
    normal

proc create_default_object (l, pr, cl, ext) {

			goto [cl = undefined] scl text;
	scl:	cl := "Object";
	text:	goto [ext = undefined] sext setall;
	sext:	ext := true;

			(* Get the metadata, creating the object in the process *)
	setall:	m := metadata(l);
			
			(* Set the internal properties in the metadata *)
			[m, "@proto"] := pr;
			[m, "@class"] := cl;
			[m, "@extensible"] := ext;

	rlab:	xret := l
}
with
{
	ret:	xret, rlab;
};

(* ******************
 * OBJECT_CONSTRUCT *
 ********************)

spec Object_construct (xsc, vthis, l)
    
    [[ (l == #l) * types(#l:Undefined) ]]
    [[ JSObject(ret) * empty_fields(ret : -{ }-) ]]
    normal
    
    (* TODO: for Object, Boolean, Number, String *)

proc Object_construct (xsc, vthis, l) {

			goto [typeOf(l) = Obj] obj l1b;
	obj:	xret := l;
			goto rlab;

	l1b:	goto [(typeOf(l) = Bool) or (typeOf(l) = Num) or (typeOf(l) = Str)] to_obj norm;
	to_obj:	xret := "i__toObject" (l);
			goto rlab;

	norm:	xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lobj_proto, "Object", true);
	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* ***********************************
 * CREATE_OBJECT_WITH_CALL_CONSTRUCT *
 *************************************)

spec create_object_with_call_construct (l, call, construct, len)

    [[ (l == #l) * (call == #call) * (construct == empty) * (len == #len) *
	   types(#call:Str, #len:Num) *
	   ((#l, "length") -> _) * 
       MetaData(#l, #md) * Extensible(#l, true) *
	   ((#md, "@proto")      -> _) *
	   ((#md, "@class")      -> _) *
	   ((#md, "@extensible") -> _) *
	   ((#md, "@scope")      -> _) * 
	   ((#md, "@call")       -> _) *
	   MetaData(#md, null) * Extensible(#md, true) ]]
    [[ ((#l, "length") -> {{ "d", #len, false, false, false }}) *  
       MetaData(#l, #md) * Extensible(#l, true) *
       ((#md, "@proto")      -> $lfun_proto) *
	   ((#md, "@class")      -> "Function") *
	   ((#md, "@extensible") -> true) *
	   ((#md, "@scope")      -> empty) * 
	   ((#md, "@call")       -> #call) *
	   MetaData(#md, null) * Extensible(#md, true) *
	   (ret == #l) ]]
    normal;

    [[ (l == #l) * (call == #call) * (construct == #construct) * (len == #len) *
	   types(#call:Str, #construct:Str, #len:Num) *
	   ((#l, "length") -> _) * 
       MetaData(#l, #md) * Extensible(#l, true) *
	   ((#md, "@proto")      -> _) *
	   ((#md, "@class")      -> _) *
	   ((#md, "@extensible") -> _) *
	   ((#md, "@scope")      -> _) * 
	   ((#md, "@call")       -> _) *
	   ((#md, "@construct")  -> _) *
	   MetaData(#md, null) * Extensible(#md, true) ]]
    [[ ((#l, "length") -> {{ "d", #len, false, false, false }}) *  
       MetaData(#l, #md) * Extensible(#l, true) *
       ((#md, "@proto")      -> $lfun_proto) *
	   ((#md, "@class")      -> "Function") *
	   ((#md, "@extensible") -> true) *
	   ((#md, "@scope")      -> empty) * 
	   ((#md, "@call")       -> #call) *
	   ((#md, "@construct")  -> #construct) *
	   MetaData(#md, null) * Extensible(#md, true) *
	   (ret == #l) ]]
    normal
    
proc create_object_with_call_construct (l, call, construct, len) {

			xret := "create_default_object" (l, $lfun_proto, "Function", true);

			[xret, "length"] := {{ "d", len, false, false, false }};

			(* Get the metadata *)
			m := metadata(xret);
			
			(* Set the internal scope, call and construct properties *)
			[m, "@scope"] := empty;
			[m, "@call"] := call;
			
			goto [construct = empty] rlab cstr;

	cstr:	[m, "@construct"] := construct;

	rlab:	xret := l
}
with
{
	ret:	xret, rlab;
};

(* ************************
 * CREATE_FUNCTION_OBJECT *
 **************************)

spec create_function_object (xsc, call, construct, params)

    [[ (xsc == #xsc) * (call == #call) * (construct == #construct) * (params == #params) * (#call == #construct) *
       types(#xsc:List, #call:Str, #construct:Str, #params:List) ]]
    [[ JSFunctionObject(ret, #call, #xsc, #len, #prototype) * 
       empty_fields(ret : -{ "arguments", "caller", "length", "prototype" }-) *
       (#len == l-len #params) *
	   JSObject(#prototype) *
	   ((#prototype, "constructor") -> {{ "d", ret, true, false, true }}) *
	   empty_fields(#prototype : -{ "constructor" }-) ]]
    normal

proc create_function_object (xsc, call, construct, params) {
			len := l-len (params);
			m := new (null);
			l := new (m);
			l := "create_object_with_call_construct" (l, call, construct, len);

			[m, "@scope"] := xsc;

			prototype := "Object_construct" ();
			[prototype, "constructor"] := {{ "d", l, true, false, true }};
			[l, "prototype"]           := {{ "d", prototype, true, false, false }};

			(* Strict mode only *)
			[l, "caller"]    := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};
			[l, "arguments"] := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};

			xret := l;

	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(************************
 ***** INITIAL HEAP *****
 ************************)
 
spec setupInitialHeap ()

	[[ initialHeapPre() ]]
	[[ initialHeapPost( -{ }- ) * (ret == empty) ]]
	normal

proc setupInitialHeap () {

			(* Global object *)

			xret := "create_default_object" ($lg, $lobj_proto, "Object", true);

			(* Object.prototype *)

			xret := "create_default_object" ($lobj_proto, null, "Object", true);
			
			[$lobj_proto, "hasOwnProperty"] := {{ "d", $lop_hasOwnProperty, true, false, true }};
  			
  			xret := "create_object_with_call_construct" ($lop_hasOwnProperty, "OP_hasOwnProperty", empty, 1);

			(* Function.prototype *)
			
			xret := "create_object_with_call_construct" ($lfun_proto, "FP_default", empty, 0);
			m := metadata($lfun_proto); 
   			[m, "@proto"] := $lobj_proto;
   			
			(* Boolean.prototype *)

			xret := "create_default_object" ($lbool_proto, $lobj_proto, "Boolean", true);
			
			m := metadata($lbool_proto); 
			[m, "@primitiveValue"] := false;

			[$lbool_proto, "constructor"] := {{ "d", $lbool, true, false, true }};
			[$lbool_proto, "toString"]    := {{ "d", $lbp_toString, true, false, true }};
			[$lbool_proto, "valueOf"]     := {{ "d", $lbp_valueOf, true, false, true }};
			
			(* Number.prototype *)

			xret := "create_default_object" ($lnum_proto, $lobj_proto, "Number", true);

			m := metadata($lnum_proto);
			[m,           "@primitiveValue"]      := 0;
			[$lnum_proto, "constructor"]          := {{ "d", $lnum, true, false, true }};
			[$lnum_proto, "toString"]             := {{ "d", $lnp_toString, true, false, true }};
			[$lnum_proto, "toLocaleString"]       := {{ "d", $lnp_toLocaleString, true, false, true }};
			[$lnum_proto, "valueOf"]              := {{ "d", $lnp_valueOf, true, false, true }};
			[$lnum_proto, "toFixed"]              := {{ "d", $lnp_toFixed, true, false, true }};
			[$lnum_proto, "toExponential"]        := {{ "d", $lnp_toExponential, true, false, true }};
			[$lnum_proto, "toPrecision"]          := {{ "d", $lnp_toPrecision, true, false, true }};
			
			(* Error object *)

			xret := "create_object_with_call_construct" ($lerr, "Error_call", "Error_construct", 1);
			[$lg, "Error"] := {{ "d", $lerr, true, false, true }};
			[$lerr, "prototype"] := {{ "d", $lerr_proto, false, false, false }};

			(* Error.prototype *)

			xret := "create_default_object" ($lerr_proto, $lobj_proto, "Error", true);
			[$lerr_proto, "message"]     := {{ "d", "", true, false, true }};

	rlab:	xret := empty
}
with
{
	ret:	xret, rlab;
};

(***********************
 ***********************
 ***** CONVERSIONS *****
 ***********************
 ***********************)  

(* *************
 * I__TOSTRING *
 ***************)

spec i__toString (v)

	[[ v == undefined ]]
	[[ ret == "undefined" ]]
	normal;

	[[ v == null ]]
	[[ ret == "null" ]]
	normal;
	
	[[ v == true ]]
	[[ ret == "true" ]]
	normal;
	
	[[ v == false ]]
	[[ ret == "false" ]]
	normal;

	[[ (v == #v) * types(#v:Num) ]]
	[[ types(ret:Str) * (ret == (num_to_string #v)) ]]
	normal;
	
	[[ (v == #v) * types(#v:Str) ]]
	[[ types(ret:Str) * (ret == #v) ]]
	normal
	
	(* TODO: for Object [HO] *)

proc i__toString (v) {
	iu:		goto [v = undefined] undef in;
	undef:	xret := "undefined";
			goto rlab;

	in:		goto [v = null] nul ib;
	nul:	xret := "null";
			goto rlab;

	ib:		goto [typeOf(v) = Bool] bool inum;
	bool:	goto [v = true] is_t is_f;
	is_t:	xret := "true";
			goto rlab;
	is_f:	xret := "false";
			goto rlab;

	inum:	goto [typeOf(v) = Num] num is;
	num:	xret := num_to_string v;
			goto rlab;

	is:		goto [typeOf(v) = Str] str io;
	str:	xret := v;
			goto rlab;

	io:		goto [typeOf(v) = Obj] obj oops;
	obj:	xret := "i__toPrimitive" (v, "String") with elab;
			xret := "i__toString" (xret) with elab;
			goto rlab;

	oops:	xret := "TypeError" ("ToString: This should not happen.");
            goto elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *************
 * I__TONUMBER *
 ***************)

spec i__toNumber (v)

	[[ v == null ]]
	[[ ret == 0 ]]
	normal;

	[[ v == true ]]
	[[ ret == 1 ]]
	normal;

	[[ v == false ]]
	[[ ret == 0 ]]
	normal;

	[[ (v == #v) * types(#v:Num) ]]
	[[ ret == #v ]]
	normal;

	[[ (v == #v) * types(#v:Str) ]]
	[[ ret == (string_to_num #v) ]]
	normal

proc i__toNumber (v) {
    iu:		goto [v = undefined] undef in;
	undef:	xret := nan;
    		goto rlab;

    in:		goto [v = null] nul ib;
	nul:	xret := 0;
    		goto rlab;

    ib:		goto [typeOf(v) = Bool] bool inum;
	bool:	goto [v = true] is_t is_f;
    is_t:	xret := 1;
    		goto rlab;
    is_f:	xret := 0;
    		goto rlab;

    inum:	goto [typeOf(v) = Num] num is;
    num:	xret := v;
    		goto rlab;

    is:		goto [typeOf(v) = Str] str io;
    str:	xret := string_to_num v;
    		goto rlab;

    io:		goto [typeOf(v) = Obj] obj oops;
    obj:	xret := "i__toPrimitive" (v, "Number") with elab;
    		xret := "i__toNumber" (xret);
    		goto rlab;

    oops:	xret := "TypeError" ("ToNumber: This should not happen.");
            goto elab;

    rlab:	skip;
    elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *************
 * I__TOOBJECT *
 ***************)

spec i__toObject (v) 

	[[ (v == #v) * types(#v:Obj) ]]
	[[ (ret == #v) ]]
	normal;

	[[ (v == #v) * types(#v:Bool) ]]
	[[ BooleanObject(ret, #v) * empty_fields(ret : -{ }-) ]]
	normal;
	
	[[ (v == #v) * types(#v:Num) ]]
	[[ NumberObject(ret, #v) * empty_fields(ret : -{ }-) ]]
	normal

proc i__toObject (v) {
	iu:		goto [v = undefined] throw in;

	in:		goto [v = null] throw ib;

	ib:		goto [typeOf(v) = Bool] bool inum;
	bool:	xret := "Boolean_construct" (undefined, undefined, v);
			goto rlab;

	inum:	goto [typeOf(v) = Num] num is;
	num:	xret := "Number_construct" (undefined, undefined, v);
			goto rlab;

	is:		goto [typeOf(v) = Str] str io;
	str:	xret := "String_construct" (undefined, undefined, v);
			goto rlab;

	io:		goto [typeOf(v) = Obj] obj oops;
	obj:	xret := v;
			goto rlab;

	oops:	xret := "ToObject: This should not happen.";

	rlab:	skip;

	throw:	xret := "Here!";
			xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *************
 * I_TOBOOLEAN *
 ***************)

spec i__toBoolean (v)

	[[ v == undefined ]]
	[[ ret == false ]]
	normal;

	[[ v == null ]]
	[[ ret == false ]]
	normal;

	[[ (v == #v) * types(#v:Bool) ]]
	[[ ret == #v ]]
	normal; 

	[[ v == 0 ]]
	[[ ret == false ]]
	normal;
	
	[[ (v == #v) * types(#v:Num) * (! (#v == 0)) ]]
	[[ (ret == true) ]]
	normal;
	
	[[ v == "" ]]
	[[ ret == false ]]
	normal;
	
	[[ (v == #v) * types(#v:Str) * (! (#v == "")) ]]
	[[ ret == true ]]
	normal;
	
	[[ (v == #v) * types(#v:Obj) ]]
	[[ ret == true ]]
	normal

	(* TODO: for NaN *)

proc i__toBoolean (v) {
	iu:		goto [v = undefined] undef in;
	undef:	xret := false;
			goto rlab;

	in:		goto [v = null] nul ib;
	nul:	xret := false;
			goto rlab;

	ib:		goto [typeOf(v) = Bool] bool inum;
	bool:	xret := v;
			goto rlab;

	inum:	goto [typeOf(v) = Num] num is;
	num:	goto [(v = 0) or (not (v = v))] is_f is_t;

	is:		goto [typeOf(v) = Str] str io;
	str:	goto [v = ""] is_f is_t;
			goto rlab;

	io:		goto [typeOf(v) = Obj] obj oops;
	obj:	xret := true;
			goto rlab;

	is_t:	xret := true;
			goto rlab;
	is_f:	xret := false;
			goto rlab;

	oops:	xret := "ToBoolean: This should not happen.";

	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(******************
 ******************
 ***** ERRORS *****
 ******************
 ******************)  

(*******************
 * ERROR_CONSTRUCT *
 *******************)

spec Error_construct (xsc, vthis, v)

    (* Error constructor without message *)
    [[ (v == undefined) * (vthis == #vthis) *
       MetaData(#vthis, #mvt) * Extensible(#vthis, true) *
       ((#mvt, "@class") -> #oc) * ((#mvt, "@extensible") -> #oe) *
       MetaData(#mvt, null) * Extensible(#mvt, true) ]]
    [[ (ret == #vthis) * 
       MetaData(#vthis, #mvt) * Extensible(#vthis, true) *
       ((#mvt, "@class") -> "Error") * ((#mvt, "@extensible") -> true) *
       MetaData(#mvt, null) * Extensible(#mvt, true) ]]
    normal;
    
    (* Error constructor with message of type string *)
    [[ (v == #m) * (vthis == #vthis) *
	   types (#m:Str) * 
       ((#vthis, "message") -> #om) * 
       MetaData(#vthis, #mvt) *
       ((#mvt, "@class") -> #oc) * ((#mvt, "@extensible") -> #oe) ]]
    [[ (ret == #vthis) * 
       ((#vthis, "message") -> {{ "d", #m, true, false, true }}) *
       MetaData(#vthis, #mvt) *
       ((#mvt, "@class") -> "Error") * ((#mvt, "@extensible") -> true) ]]
    normal

proc Error_construct (xsc, vthis, v) {
			xret := vthis;

			m := metadata(vthis);
			[m, "@class"] := "Error";
			[m, "@extensible"] := true;

			goto [v = undefined] rlab mess;

	mess:	xerr := "i__toString" (v) with elab;
			[xret, "message"] := {{ "d", xerr, true, false, true }};

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xerr, elab;
};

(*********************************)
(* TYPEERROR_CALL and _CONSTRUCT *)
(*********************************)

spec TypeError_call (xsc, vthis, v)

    [[ v == undefined ]]
    [[ isTypeError(ret) ]]
    normal

proc TypeError_call (xsc, vthis, v) {
			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lterr_proto, "Error", true);

			xret := "Error_construct" (undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec TypeError (v)

    [[ v == undefined ]]
    [[ isTypeError(ret) ]]
    normal

proc TypeError (v) {
			xret := "TypeError_call" (undefined, undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(**************************************)
(* REFERENCEERROR_CALL and _CONSTRUCT *)
(**************************************)

spec ReferenceError_call (xsc, vthis, v)

    [[ v == undefined ]]
    [[ isReferenceError(ret) ]]
    normal

proc ReferenceError_call (xsc, vthis, v) {
			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lrferr_proto, "Error", true);

			xret := "Error_construct" (undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec ReferenceError (v)

    [[ v == undefined ]]
    [[ isReferenceError(ret) ]]
    normal

proc ReferenceError (v) {
			xret := "ReferenceError_call" (undefined, undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(***********************************)
(* SYNTAXERROR_CALL and _CONSTRUCT *)
(***********************************)

spec SyntaxError_call (xsc, vthis, v)

    [[ v == undefined ]]
    [[ isSyntaxError(ret) * empty_fields(ret : -{ }-) *
       MetaData(ret, #md) * empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc SyntaxError_call (xsc, vthis, v) {
			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lserr_proto, "Error", true);

			xret := "Error_construct" (undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec SyntaxError (v)

    [[ v == undefined ]]
    [[ isSyntaxError(ret) * empty_fields(ret : -{ }-) *
       MetaData(ret, #md) * empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc SyntaxError (v) {
			xret := "SyntaxError_call" (undefined, undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(***********************
 ***********************
 ***** AUXILIARIES *****
 ***********************
 ***********************)  

(* ********************
   *** I__SAMEVALUE ***
   ******************** *)

spec i__sameValue (v1, v2)

	[[ (v1 == 0) * (v2 == 0) ]]
	[[ ret == true ]]
	normal;

	[[ (v1 == -0) * (v2 == -0) ]]
	[[ ret == true ]]
	normal;

	[[ (v1 == -0) * (v2 == 0) ]]
	[[ ret == false ]]
	normal;
	
	[[ (v1 == 0) * (v2 == -0) ]]
	[[ ret == false ]]
	normal;

	[[ (v1 == v2) ]]
	[[ ret == true ]]
	normal;

	[[ ! (v1 == v2) ]]
	[[ ret == false ]]
	normal

proc i__sameValue (v1, v2) {

			goto [(typeOf(v1) = Num)] test2 nonum;
	test2:	goto [(typeOf(v2) = Num)] inan1 nonum;

	inan1:	goto [(not (v1 = v1))] inan2 zero1;
	inan2:	goto [(not (v2 = v2))] rt    zero1;
	zero1:	goto [v1 = 0] zero2 nonum;
	zero2:	goto [v2 = 0] fix   nonum;

	fix:	sv1 := m_sgn (v1);
			sv2 := m_sgn (v2);

			goto [sv1 = sv2] rt rf;
			goto rlab;

	nonum:  goto [v1 = v2] rt rf; 

	rt:		xret := true;
	        goto rlab;
	        
	rf:     xret := false;
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};
 
(* ********************************
   *** I__CHECKASSIGNMENTERRORS ***
   ******************************** *)

spec i__checkAssignmentErrors (v)

    [[ v == undefined ]]
    [[ ret == true ]]
    normal;

    [[ v == null ]]
    [[ ret == true ]]
    normal;

	[[ types (v:Num) ]]
	[[ (ret == true) ]]
	normal;

    [[ types (v:Bool) ]]
    [[ ret == true ]]
    normal;

    [[ types (v:Str) ]]
    [[ ret == true ]]
    normal;

    [[ types (v:Obj) ]]
    [[ ret == true ]]
    normal;

    [[ (v == #v) * types (#v:List) * (#v == {{ "v", #l, #prop }}) * types(#l:Obj, #prop:Str) *
	   (! (#prop == "eval")) * (! (#prop == "arguments"))]]
    [[ ret == true ]]
    normal;

    [[ (v == #v) * types (#v:List, #l:Obj) * (#v == {{ "v", #l, "eval" }}) ]]
    [[ isSyntaxError(ret) * empty_fields(ret : -{ }-) ]]
    error;

    [[ (v == #v) * types (#v:List, #l:Obj) * (#v == {{ "v", #l, "arguments" }}) ]]
    [[ isSyntaxError(ret) * empty_fields(ret : -{ }-) ]]
    error;

    [[ (v == #v) * types (#v:List, #base:Obj, #field:Str) * (#v == {{ "o", #base, #field }}) ]]
    [[ ret == true ]]
    normal

proc i__checkAssignmentErrors (v) {
			tv := typeOf (v);
			goto [(tv = List) and ((l-nth (v, 0) = "v") or (l-nth (v, 0) = "o"))] prep rlab;

	prep:	fv := l-nth (v, 2);

	csyn:	goto [(l-nth (v, 0) = "v") and ((fv = "eval") or (fv = "arguments"))] se rlab;

	rlab:	xret := true;

	se:		xret := "SyntaxError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};
 
(* *******************************
   *** I__CHECKOBJECTCOERCIBLE ***
   ******************************* *)

spec i__checkObjectCoercible (v)

	[[ v == undefined ]]
	[[ isTypeError(ret) ]]
	normal;

	[[ v == null ]]
	[[ isTypeError(ret) ]]
	normal;

	[[ types (v:Num) ]]
	[[ ret == empty ]]
	normal;

	[[ types (v:Bool) ]]
	[[ ret == empty ]]
	normal;

	[[ types (v:Str) ]]
	[[ ret == empty ]]
	normal;

	[[ types (v:Obj) ]]
	[[ ret == empty ]]
	normal

proc i__checkObjectCoercible (v) {

			xret := empty;

	iu:		goto [v = undefined] throw in;

	in:		goto [v = null] throw other;

	other:	goto [(typeOf(v) = Bool) or (typeOf(v) = Num) or
	              (typeOf(v) = Str) or (typeOf(v) = Obj)] rlab oops;

	oops:	xret := "CheckObjectCoercible: This should not happen.";

	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* **********************
   *** I__ISPRIMITIVE ***
   ********************** *)

spec i__isPrimitive (v)

   [[ v == undefined ]]
   [[ ret == true ]]
   normal;

   [[ v == null ]]
   [[ ret == true ]]
   normal;

   [[ types (v:Num) ]]
   [[ (ret == true) ]]
   normal;

   [[ types (v:Bool) ]]
   [[ (ret == true) ]]
   normal;

   [[ types (v:Str) ]]
   [[ (ret == true) ]]
   normal;

   [[ types (v:Obj) ]]
   [[ (ret == false) ]]
   normal

proc i__isPrimitive (v) {
			tv := typeOf(v);

	iu:		goto [(v = undefined) or (v = null) or
	              (typeOf(v) = Bool) or (typeOf(v) = Num) or
	              (typeOf(v) = Str)] rt rf;

	rt:		xret := true;
			goto rlab;

	rf:		xret := false;
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* ******************************
   *** I__ISGENERICDESCRIPTOR ***
   ****************************** *)

proc i__isGenericDescriptor (desc) {
			goto [desc = undefined] rf cont;

	cont:	dd := "i__isDataDescriptor" (desc);
			ad := "i__isAccessorDescriptor" (desc);
			xret := not (dd or ad);
			goto rlab;

	rf:		xret := false;
	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* ***************************
   *** I__ISDATADESCRIPTOR ***
   *************************** *)

proc i__isDataDescriptor (desc) {
			goto [desc = undefined] rf cont;
	cont:	d := l-nth (desc, 0);
			goto [d = "d"] rt gen;
	gen:	goto [d = "g"] test rf;
	test:	v := l-nth (desc, 3);
			w := l-nth (desc, 4);
			goto [(v = empty) and (w = empty)] rf rt;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
	rlab:	skip
}
with
{
	ret : xret, rlab;
};

(* *******************************
   *** I__ISACCESSORDESCRIPTOR ***
   ******************************* *)

proc i__isAccessorDescriptor (desc) {
			goto [desc = undefined] rf cont;
	cont:	d := l-nth (desc, 0);
			goto [d = "a"] rt gen;
	gen:	goto [d = "g"] test rf;
	test:	g := l-nth (desc, 5);
			s := l-nth (desc, 6);
			goto [(g = empty) and (s = empty)] rf rt;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
	rlab:	skip
}
with
{
	ret : xret, rlab;
};

(* ***************************
   *** I__TODATADESCRIPTOR ***
   *************************** *)

proc i__toDataDescriptor (desc) {
			d := l-nth (desc, 0);
			goto [d = "d"] rd cstr;

	cstr:	goto [d = "a"] ra gen;

	ra:		xret := {{ "d", undefined, false, l-nth (desc, 3), l-nth (desc, 4) }};
			goto rlab;

	gen:	e := l-nth (desc, 1);
			c := l-nth (desc, 2);
			v := l-nth (desc, 3);
			w := l-nth (desc, 4);

			goto [e = empty] fixe c;
	fixe:	e := false;
	c:		goto [c = empty] fixc v;
	fixc:	c := false;
	v:		goto [v = empty] fixv w;
	fixv:	v := undefined;
	w:		goto [w = empty] fixw fixed;
	fixw:	w := false;

	fixed:	xret := {{ "d", v, w, e, c }};
			goto rlab;

	rd:		xret := desc;
	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* **********************************************
   **********************************************
   ***********   INTERNAL FUNCTIONS   ***********
   **********************************************
   ********************************************** *)

(* *************************
   *** O__GETOWNPROPERTY ***
   ************************* *)

(*
 *    Name: o__getOwnProperty 
 * Purpose: Get own property of a non-String object
 *
 *   Specs:
 *
 * 01 - Property not defined, return undefined
 * 02 - Property defined, return property descriptor
 *
 *)

spec o__getOwnProperty (l, prop)

    [[ (l == #l) * (prop == #prop) * Cell_o (#l, #prop, none) ]]
    [[ Cell_o (#l, #prop, none) * (ret == undefined) ]]
    normal;

    [[ (l == #l) * (prop == #prop) * Cell_o (#l, #prop, #dx) * Descriptor(#dx) ]]
    [[ Cell_o (#l, #prop, #dx) * (ret == #dx) ]]
    normal

proc o__getOwnProperty (l, prop) {
            x := hasField(l, prop);
            goto [x] hp nhp; 			(* Does the field exist? *)

    nhp:    xret := undefined;			(* Field doesn't exist; return undefined *)
            goto rlab;

    hp:     xret := [l, prop];			(* Field exists; return the descriptor *)

    rlab:   skip
}
with
{
    ret: 	xret, rlab;
};

(*
 *    Name: s__getOwnProperty 
 * Purpose: Get own property of a String object
 *
 *   Specs:
 *
 * 01 - Property defined, return property descriptor
 *
 *)

spec s__getOwnProperty (l, prop) 

    [[ (l == #l) * (prop == #prop) * Cell_s (#l, #prop, #dx) * Descriptor(#dx) ]]
    [[ Cell_s (#l, #prop, #dx) * (ret == #dx) ]]
    normal

proc s__getOwnProperty (l, prop) {
			xret := "o__getOwnProperty" (l, prop);
			goto [xret = undefined] str rlab;

	str:	idx := "i__toInteger" (prop) with elab;
			goto [idx < 0] rlab next;

	next:	sidx := "i__toString" (idx);

			goto [sidx = prop] index rlab;

	index:	m := metadata(l);
			str := [m, "@primitiveValue"];
			len := s-len (str);
			goto [len <= idx] rlab return;

	return: rstr := s-nth (str, idx);
			xret := {{ "d", rstr, false, true, false }};

	rlab: 	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* **********************
   *** GETOWNPROPERTY ***
   ********************** *)

(*
 *    Name: getOwnProperty 
 * Purpose: Get own property of a (general) object
 *
 *   Specs:
 *
 * 01 - Non-string object, property not defined, return undefined
 * 02 - Any object, property defined, return property descriptor
 *
 *)

spec getOwnProperty (l, prop)

    [[ (l == #l) * (prop == #prop) * Cell_o (#l, #prop, none) *
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-String") ]]
    [[ Cell_o (#l, #prop, none) * 
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * (ret == undefined) ]]
    normal;

    [[ (l == #l) * (prop == #prop) * Cell_o (#l, #prop, #dx) * Descriptor(#dx) *
       MetaData(#l, #md) * ((#md, "@class") -> #cls) ]]
    [[ Cell_o (#l, #prop, #dx) * 
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * (ret == #dx) ]]
    normal

proc getOwnProperty (l, prop) {

			m := metadata(l);
			class := [m, "@class"];

			goto [class = "String"] sgop ogop;

	sgop:	xret := "s__getOwnProperty" (l, prop) with elab;
			goto rlab;

	ogop:	xret := "o__getOwnProperty" (l, prop) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(*
 *    Name: getProperty 
 * Purpose: Get property of a (general) object, considering prototype inheritance
 *
 *   Specs:
 *
 * 01 - Get the heap value associated with the appropriate Pi
 *)

spec getProperty (l, prop)

	[[ (l == #l) * (prop == #prop) * Pi (#l, #prop, #d, #ls, #cls, #pv) ]]
	[[ Pi (#l, #prop, #d, #ls, #cls, #pv) * (ret == #d) ]]
	normal

proc getProperty (l, prop) {

			[* unfold Pi (#l, #prop, #d, #ls, #cls, #pv) *]
			xret := "getOwnProperty" (l, prop) with elab;
			goto [xret = undefined] next rlab;

	next:	m := metadata(l);
			proto := [m, "@proto"];
			goto [proto = null] rlab call;

	call:	xret := "getProperty" (proto, prop) with elab;

			[* fold Pi (#l, #prop, #d, #ls, #cls, #pv) *]
    rlab:   skip;
    elab:	skip
}
with
{
    ret: 	xret, rlab;
    err:	xret, elab;
};

(* *********** *)
(* *** GET *** *)
(* *********** *)

(*
 *    Name: get 
 * Purpose: Get the value of a property of a (general) object in the entire prototype chain
 *
 *   Specs:
 *
 * 01 - Property not defined in the prototype chain, return undefined ]
 * 02 - Property defined, data descriptor, get value of the descriptor 
 *)

spec get (l, prop)

    [[ (l == #l) * (prop == #prop) *
	   Pi (#l, #prop, #d, #ls, #cls, #pv) * (#d == undefined) ]]
    [[ Pi (#l, #prop, #d, #ls, #cls, #pv) * (ret == undefined) ]]
    normal;
    
    [[ (l == #l) * (prop == #prop) *
	   Pi (#l, #prop, #d, #ls, #cls, #pv) * DataDescriptor (#d) ]]
    [[ Pi (#l, #prop, #d, #ls, #cls, #pv) * desc_val (#d, #desc_val) * (ret == #desc_val) ]]
    normal

proc get (l, prop) {

			xret := "getProperty" (l, prop) with elab;
			goto [xret = undefined] rlab def;		(* Does the field exist?    *)

	def:	d := l-nth (xret, 0);					(* Get the descriptor type  *)
			xret := l-nth (xret, 1);				(* Get the value/getter     *)
			goto [d = "d"] rlab acc;				(* Is it a data descriptor? *)

	acc:	goto [xret = undefined] rlab get;		(* Is the getter defined?               *)
	get:	m := metadata(xret);
			xsc := [m, "@scope"];				    (* Get the scope of the getter          *)
			fun := [m, "@call"];					(* Get the name of the getter           *)
			xret := fun (xsc, l) with elab;			(* Call the getter, errors could happen *)
			goto [xret = empty] undef rlab;
	undef:	xret := undefined;

	rlab:	skip;
	elab:	skip
}
with
{
    ret: xret, rlab;
    err: xret, elab;
};

(* ******************* *)
(* *** I__GETVALUE *** *)
(* ******************* *)

(*
 *    Name: getValue
 * Purpose: Get the value of SOMETHING
 *
 *   Specs:
 *
 * 01-06 - Something is not a reference, just return something
 * 07 - Object reference, undefined
 * 08 - Object reference, defined
 * 09 - Variable reference, lg, undefined
 * 10 - Variable reference, lg, defined
 * 11 - Variable reference, non-lg, directly from the heap
 * 12-13 - Base undefined for both variable and object references, return a reference error 
 *
 * Remaining:
 *
 * Object conversion:
 * 
 * 14-19 - Conversion to Number, String, Boolean, property exists or doesn't 
 *
 * Unsupported:
 *
 * 20-?? - Getters
 *)

spec i__getValue (v)

    [[ v == undefined ]]
    [[ ret == undefined ]]
    normal;
    
    [[ v == null ]]
    [[ ret == null ]]
    normal;

    [[ (v == #v) * types (#v : Obj) ]]
	[[ (ret == #v) ]]
	normal;

    [[ (v == #v) * types (#v : Num) ]]
	[[ (ret == #v) ]]
	normal;

    [[ (v == #v) * types (#v : Bool) ]]
	[[ (ret == #v) ]]
	normal;

    [[ (v == #v) * types (#v : Str) ]]
	[[ (ret == #v) ]]
	normal;

    [[ (v == {{ "o", #obj, #field }}) * 
       Pi (#obj, #field, #d, #ls, #lcls, #lpv) * (#d == undefined) ]]
    [[ Pi (#obj, #field, #d, #ls, #lcls, #lpv) * (ret == undefined) ]]
    normal;

    [[ (v == {{ "o", #obj, #field }}) * 
       Pi (#obj, #field, #d, #ls, #lcls, #lpv) * DataDescriptor (#d)  ]]
    [[ Pi (#obj, #field, #d, #ls, #lcls, #lpv) * desc_val (#d, #desc_val) * (ret == #desc_val) ]]
    normal;

    [[ (v == {{ "v", $lg, #field }}) * 
       Pi ($lg, #field, #d, #ls, #lcls, #lpv) * (#d == undefined) ]]
    [[ Pi ($lg, #field, #d, #ls, #lcls, #lpv) * (ret == undefined) ]]
    normal;

    [[ (v == {{ "v", $lg, #field }}) *
       Pi ($lg, #field, #d, #ls, #lcls, #lpv) * DataDescriptor (#d)  ]]
    [[ Pi ($lg, #field, #d, #ls, #lcls, #lpv) * desc_val (#d, #desc_val) * (ret == #desc_val) ]]
    normal;

    [[ (v == {{ "v", #obj, #field }}) * (! (#obj == $lg)) * ((#obj, #field) -> #value) ]]
    [[ ((#obj, #field) -> #value) * (ret == #value) ]]
    normal;

	[[ (v == {{ "v", undefined, #field }}) * types (#field:Str) ]]
    [[ isReferenceError(err) ]]
    error;

	[[ (v == {{ "o", undefined, #field }}) * types (#field:Str) ]]
    [[ isReferenceError(err) ]]
    error;
    
    (* Now come the more involved specs, which are a bit difficult for the solver. *)
    
    [[ (v == {{ "o", #b, #field }}) * types(#b:Bool) * Pi($lbool_proto, #field, #d, #pls, #plcls, #plpv) * (#d == undefined) ]]
    [[ (xobj == #o) * BooleanObject(#o, #b) * empty_fields(#o : -{ }-) * Pi($lbool_proto, #field, #d, #pls, #plcls, #plpv) * (ret == undefined) ]]
    normal;

    [[ (v == {{ "o", #b, #field }}) * types(#b:Bool) * Pi($lbool_proto, #field, #d, #pls, #plcls, #plpv) * DataDescriptor(#d) ]]
    [[ (xobj == #o) * BooleanObject(#o, #b) * empty_fields(#o : -{ }-) * Pi($lbool_proto, #field, #d, #pls, #plcls, #plpv) * desc_val(#d, #dval) * (ret == #dval) ]]
    normal;
    
    [[ (v == {{ "o", #n, #field }}) * types(#n:Num) * Pi($lnum_proto, #field, #d, #pls, #plcls, #plpv) * (#d == undefined) ]]
    [[ (xobj == #o) * NumberObject(#o, #n) * empty_fields(#o : -{ }-) * Pi($lnum_proto, #field, #d, #pls, #plcls, #plpv) * (ret == undefined) ]]
    normal;

    [[ (v == {{ "o", #n, #field }}) * types(#n:Num) * Pi($lnum_proto, #field, #d, #pls, #plcls, #plpv) * DataDescriptor(#d) ]]
    [[ (xobj == #o) * NumberObject(#o, #n) * empty_fields(#o : -{ }-) * Pi($lnum_proto, #field, #d, #pls, #plcls, #plpv) * desc_val(#d, #dval) * (ret == #dval) ]]
    normal 

proc i__getValue (v) {

			goto [(typeOf(v) = List)] rcand dflt;

   	rcand:  rtype := l-nth (v, 0);
           	goto [(rtype = "v") or (rtype = "o")] init dflt;

	init:	rbase := l-nth (v, 1);
			rfield := l-nth (v, 2);
			goto [rbase = undefined] throw prim;

	prim:	prim := "i__isPrimitive" (rbase);
      	    goto [prim] is_pr ref;

	is_pr:	xobj := "i__toObject" (rbase) with pelab;
	
			[* fold Pi(xobj, #field, #d, #ls, #lcls, #lpv) *]
			xret := "getProperty" (xobj, rfield) with pelab;
			[* unfold Pi(xobj, #field, #d, #ls, #lcls, #lpv) *]
			goto [xret = undefined] rlab def;
	def:	d := l-nth (xret, 0);	(* Get the descriptor type *)
			xret := l-nth (xret, 1);	(* Get the value/getter *)
			goto [d = "d"] rlab acc;	(* Is it a data descriptor? *)

	acc:	goto [xret = undefined] rlab get;	(* Is the getter defined? *)
	get:	m := metadata(xret);
			xsc := [m, "@scope"];	(* Get the scope of the getter *)
			fun := [m, "@call"];	(* Get the name of the getter *)
			xret := fun (xsc, rbase) with pelab; (* Call the getter, errors could happen *)
			goto [xret = empty] undef rlab;
	undef:	xret := undefined;

	ref:	goto [(typeOf(v) = List) and (l-nth (v, 0) = "o")] oref vref;

	oref:	xret := "get" (rbase, rfield) with pelab;
			goto rlab;

	vref:	goto [rbase = $lg] lg er;

	lg:		xret := "get" (rbase, rfield) with pelab;
			goto rlab;

	er:		xret := [rbase, rfield];
			goto rlab;

	dflt:	xret := v;
	rlab:	skip;

	throw:  xret := "ReferenceError" ();
   	pelab:  xret := PHI(xobj, xret, xret, xret, xret, xret);
   	 elab:  skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* ******************* *)
(* *** HASPROPERTY *** *)
(* ******************* *)

spec hasProperty (l, prop)

	[[ (l == #l) * (prop == #prop) *
	   Pi (#l, #prop, undefined, #ls, #cls, #pv) ]]
	[[ Pi (#l, #prop, undefined, #ls, #cls, #pv) * (ret == false) ]]
	normal;

	[[ (l == #l) * (prop == #prop) *
	   Pi (#l, #prop, #d, #ls, #cls, #pv) * Descriptor(#d) ]]
	[[ Pi (#l, #prop, #d, #ls, #cls, #pv) * (ret == true) ]]
	normal

proc hasProperty (l, prop) {
			xret := "getProperty" (l, prop) with elab;

	rlab:	xret := not (xret = undefined);
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};

(* ********************** *)
(* *** DELETEPROPERTY *** *)
(* ********************** *)

spec deleteProperty (l, prop, throw)

    [[ (l == #l) * (prop == #prop) * Cell_o (#l, #prop, none) *
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-String") ]]
    [[ Cell_o (#l, #prop, none) * 
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * (ret == true) ]]
    normal;
    
	[[ (l == #l) * (prop == #prop) *
	   Cell_o(#l, #prop, #d) * Descriptor(#d) * desc_conf(#d, true) * 
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-String") ]]
	[[ Cell_o(#l, #prop, none) * 
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * (ret == true) ]]
	normal;

	[[ (l == #l) * (prop == #prop) * (throw == false) *
	   Cell_o(#l, #prop, #d) * Descriptor(#d) * desc_conf(#d, false) * 
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-String") ]]
	[[ Cell_o(#l, #prop, #d) * 
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * (ret == false) ]]
	normal;

	[[ (l == #l) * (prop == #prop) * (throw == true) *
	   Cell_o(#l, #prop, #d) * Descriptor(#d) * desc_conf(#d, false) * 
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-String") ]]
	[[ Cell_o(#l, #prop, #d) * 
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * isTypeError(err) ]]
	error

proc deleteProperty (l, prop, throw) {

			xret := "getOwnProperty" (l, prop) with elab;
			goto [xret = undefined] dt cont;

	cont:	c := l-nth (xret, 4);
			goto [c] del reject;

	del:	delete (l, prop);

	dt:		xret := true;
			goto rlab;

	df:		xret := false;
	rlab:	skip;

    reject: goto [throw] tt df;

    tt:     xret := "TypeError" ();
    elab:   skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* ************** *)
(* *** CANPUT *** *)
(* ************** *)

spec canPut (l, prop)

    (* Property not defined at all, returning "@extensible" *)
    [[ (l == #l) * (prop == #prop) * types(#ext:Bool) *
	   Pi (#l, #prop, undefined, #ls, #lcls, #lpv) *
       MetaData(#l, #md) * ((#md, "@extensible") -> #ext) ]]
    [[ Pi (#l, #prop, undefined, #ls, #lcls, #lpv) *
       MetaData(#l, #md) * ((#md, "@extensible") -> #ext) *
	   (ret == #ext) ]]
    normal;

	(* Property defined in the object itself, data descriptor, returning writable *)
	[[ (l == #l) * (prop == #prop) *
	   Pi (#l, #prop, #d, {{ #l }}, #lcls, #lpv) * DataDescriptor(#d) * desc_writ(#d, #writ) ]]
	[[ Pi (#l, #prop, #d, {{ #l }}, #lcls, #lpv) * (ret == #writ) ]]
	normal;
	
	(* Property defined as a data descriptor outside, but object not extensible, return false *)
	[[ (l == #l) * (prop == #prop) *
      Pi (#l, #prop, #d, #ls, #lcls, #lpv) * DataDescriptor(#d) * (#ls == (#l :: #lp :: #other)) * 
      MetaData(#l, #md) * ((#md, "@extensible") -> false) ]]
	[[ Pi (#l, #prop, #d, #ls, #lcls, #lpv) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> false) * (ret == false) ]]
	normal;

	(* Property defined as a data descriptor outside, object extensible, return writable *)
	[[ (l == #l) * (prop == #prop) *
	   Pi (#l, #prop, #d, #ls, #lcls, #lpv) * DataDescriptor(#d) * desc_writ(#d, #writ) * (#ls == (#l :: #lp :: #other)) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> true) ]]
	[[ Pi (#l, #prop, #d, #ls, #lcls, #lpv) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> true) * (ret == #writ) ]]
	normal

proc canPut (l, prop) {
			[* unfold Pi (#l, #prop, #d, #ls, #lcls, #lpv) *]
            xret := "getOwnProperty" (l, prop) with elab;
            [* fold Pi (#l, #prop, #d, #ls, #lcls, #lpv) *]
	op:		goto [xret = undefined] nop odesc; 	(* Does the own property exist? *)

	odesc:	d := l-nth (xret, 0);						(* It does; get the descriptor type *)
			goto [d = "d"] odd nop;					    (* Is the descriptor a data descriptor? *)

	odd:	xret := l-nth (xret, 2);					(* It is; return the Writable attribute *)
			goto rlab;

	nop:	m := metadata(l);
			e := [m, "@extensible"];				   (* Get the extensible property *)
			xret := "getProperty" (l, prop) with elab; (* Does the property exist? *)
			goto [xret = undefined] ext desc;		   (* It doesn't; return extensible *)

	desc:	d := l-nth (xret, 0);					(* Get the descriptor type *)
			v := l-nth (xret, 2);					(* Get the writable/setter *)
			goto [d = "d"] dd ad;					(* Is it a data descriptor? *)

	dd:		goto [e] wr ext;						(* Yes; is the object extensible? *)
	wr:		xret := v;								(* Yes; return writable *)
			goto rlab;

	ad:		xret := not (v = undefined); 			(* Accessor descriptor *)
			goto rlab;

	ext:	xret := e;								(* Return extensible *)

    rlab:   skip;
    elab:	skip
}
with
{
    ret: 	xret, rlab;
    err:	xret, elab;
};

(* **************************** *)
(* *** O__DEFINEOWNPROPERTY *** *)
(* **************************** *)

proc o__defineOwnProperty (l, prop, desc, throw) {

			xret := true;

			current := "getOwnProperty" (l, prop) with celab;
			m := metadata(l);
			extensible := [m, "@extensible"];

			goto [(current = undefined) and (extensible = false)] reject l4;
	l4:		goto [(current = undefined) and (extensible = true)] l4a getall;

	l4a:	gd := "i__isGenericDescriptor" (desc);
			dd := "i__isDataDescriptor" (desc);

			goto [gd or dd] l4a1 l4b;

	l4a1:	ndesc := "i__toDataDescriptor" (desc);
			[l, prop] := ndesc;
			goto acc_t;

	l4b:	ndesc := "i__toAccessorDescriptor" (desc);
			[l, prop] := ndesc;
			goto acc_t;

	getall:	goto [l-nth (desc, 0) = "d"] ddd odd;

			(* Data *)
	ddd:	de := l-nth (desc, 3);
			dc := l-nth (desc, 4);
			dv := l-nth (desc, 1);
			dw := l-nth (desc, 2);
			dg := empty;
			ds := empty;
			goto l5;

	odd:	goto [l-nth (desc, 0) = "a"] add gdd;

			(* Accessor *)
	add:	de := l-nth (desc, 3);
			dc := l-nth (desc, 4);
			dv := empty;
			dw := empty;
			dg := l-nth (desc, 1);
			ds := l-nth (desc, 2);
			goto l5;

			(* Generic *)
	gdd:	de := l-nth (desc, 1);
			dc := l-nth (desc, 2);
			dv := l-nth (desc, 3);
			dw := l-nth (desc, 4);
			dg := l-nth (desc, 5);
			ds := l-nth (desc, 6);

	l5:		goto [(de = empty) and (dc = empty) and (dv = empty) and
			      (dw = empty) and (dg = empty) and (ds = empty)] acc_t l6;

	l6:		goto [l-nth (current, 0) = "d"] chd cha;

	chd:	t1 := "i__sameValue" (dv, l-nth (current, 1));
			t2 := "i__sameValue" (dw, l-nth (current, 2));
			t3 := "i__sameValue" (de, l-nth (current, 3));
			t4 := "i__sameValue" (dc, l-nth (current, 4));

			goto [t1 and t2 and t3 and t4 and
			      (dg = empty) and (ds = empty)] acc_t l7;

	cha:	t1 := "i__sameValue" (dg, l-nth (current, 1));
			t2 := "i__sameValue" (ds, l-nth (current, 2));
			t3 := "i__sameValue" (de, l-nth (current, 3));
			t4 := "i__sameValue" (dc, l-nth (current, 4));

			goto [t1 and t2 and t3 and t4 and
			      (dv = empty) and (dw = empty)] acc_t l7;

	l7:		ct := l-nth (current, 0);
			cvg := l-nth (current, 1);
			cws := l-nth (current, 2);
			ce := l-nth (current, 3);
			cc := l-nth (current, 4);

			goto [(cc = false) and ((dc = true) or ((not (de = empty)) and (not (ce = de))))] reject l8;

	l8:		gd := "i__isGenericDescriptor" (desc);
			goto [gd] l12 l9;

	l9:		cdd := "i__isDataDescriptor" (current);
			ddd := "i__isDataDescriptor" (desc);

			goto [not (cdd = ddd)] l9a l10;

	l9a:	goto [cc = false] reject change;
	change:	goto [cdd = true] toa tod;
	toa:	goto [dg = empty] sg gs;
	sg:		dg := undefined;
	gs:		goto [ds = empty] ss ge1;
	ss:		ds := undefined;
	ge1:	goto [de = empty] se1 gc1;
	se1:	de := ce;
	gc1:	goto [dc = empty] sc1 spa;
	sc1:	dc := cc;
	spa:	[l, prop] := {{ "a", dg, ds, de, dc }};
			goto acc_t;

	tod:	goto [dv = empty] sv gw;
	sv:		dv := undefined;
	gw:		goto [dw = empty] sw ge2;
	sw:		dw := false;
	ge2:	goto [de = empty] se2 gc2;
	se2:	de := ce;
	gc2:	goto [dc = empty] sc2 spd;
	sc2:	dc := cc;
	spd:	[l, prop] := {{ "d", dv, dw, de, dc }};
			goto acc_t;

	l10:	goto [cdd = true] l10a l11;

	l10a:	goto [cc = false] l10ai l12;
	l10ai:	goto [(not (dw = empty)) and ((cws = false) and (dw = true))] reject l10aii;
	l10aii:	t1 := "i__sameValue" (cvg, dv);
			goto [(cws = false) and (not (dv = empty)) and (not t1)] reject l12;

	l11: 	t1 := "i__sameValue" (dg, l-nth (current, 1));
			t2 := "i__sameValue" (ds, l-nth (current, 2));
			goto [(cc = false) and
	             (((not (dg = empty)) and (not t1)) or
	              ((not (ds = empty)) and (not t2)))] reject l12;

	l12:	re := de;
			rc := dc;
			goto [de = empty] rec red;
	rec:	re := l-nth (current, 3);
	red:	goto [dc = empty] rcd rd;
	rcd:	rc := l-nth (current, 4);

	rd: 	goto [ct = "d"] l12d l12a;

	l12d:	rv := dv;
			rw := dw;
			goto [dv = empty] rvc rvd;
	rvc:	rv := l-nth (current, 1);
	rvd:	goto [dw = empty] rwd setd;
	rwd:	rw := l-nth (current, 2);
	setd:	[l, prop] := {{ "d", rv, rw, re, rc }};
			goto acc_t;

	l12a:	rg := dg;
			rs := ds;
			goto [dg = empty] rgc rgd;
	rgc:	rg := l-nth (current, 1);
	rgd:	goto [ds = empty] rsd seta;
	rsd:	rs := l-nth (current, 2);
	seta:	[l, prop] := {{ "a", rg, rs, re, rc }};
			goto acc_t;

	acc_t:	xret := true;
			goto rlab;

	acc_f:	xret := false;
	rlab:	skip;

	celab:	xerr := current;
			goto elab;

    reject: goto [throw] tt acc_f;
    tt:     xerr := "TypeError" ();
    elab:   skip
}
with
{
	ret: xret, rlab;
	err: xerr, elab;
};

(* ************************* *)
(* *** DEFINEOWNPROPERTY *** *)
(* ************************* *)

spec defineOwnProperty(l, prop, desc, throw)

	(* Current is undefined, object is extensible, non-string, data descriptor, success *)
    [[ (l == #l) * (prop == #prop) * 
       (desc == #desc) * DataDescriptor(#desc) * 
       (throw == #throw) * types (#throw : Bool) *
	   Cell_o (#l, #prop, none) * MetaData(#l, #md) * 
	   ((#md, "@class") -> #cls) * isClass(#cls, "Non-Array") * isClass(#cls, "Non-String") *
	   ((#md, "@extensible") -> true) ]]
    [[ Cell_o (#l, #prop, #desc) * MetaData(#l, #md) * 
	   ((#md, "@class") -> #cls) * ((#md, "@extensible") -> true) ]]
    normal;
    
    (* Current is defined, data descriptor, writable, sending only value, success *)
    [[ (l == #l) * (prop == #prop) * (desc == #desc) * (throw == #throw) *
	   Cell_o (#l, #prop, #dcur) * DataDescriptor(#dcur) * 
	   desc_writ(#dcur, true) * desc_enum(#dcur, #dec) * desc_conf(#dcur, #dcc) *
	   (#desc == {{ "g", empty, empty, #gval, empty, empty, empty }}) * (! (#gval == empty)) *
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-Array") *
       ((#md, "@extensible") -> #ext) * types(#ext:Bool) ]]
    [[ Cell_o (#l, #prop, {{ "d", #gval, true, #dec, #dcc }}) *
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) *
       ((#md, "@extensible") -> #ext) *
	   (ret == true) ]]
	normal;
    
    (* Current is defined, configurable is true, data descriptor, non-string, success *)
    [[ (l == #l) * (prop == #prop) * (throw == #throw) *
       (desc == #desc) * DataDescriptor(#desc) * 
       Cell_o (#l, #prop, #dcur) * DataDescriptor(#dcur) * desc_conf(#dcur, true) *
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-Array") *
       ((#md, "@extensible") -> #ext) * types(#ext:Bool) ]]
    [[ Cell_o (#l, #prop, #desc) *
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-Array") *
       ((#md, "@extensible") -> #ext) *
	   (ret == true) ]]
    normal;

	(* Current is defined, configurables are false, enumerables are same, writable is true, non-string, success *)
    [[ (l == #l) * (prop == #prop) * (desc == #desc) * (throw == #throw) *
	   Cell_o (#l, #prop, #dcur) * DataDescriptor(#dcur) * DataDescriptor(#desc) * 
	   desc_conf(#desc, false) * desc_conf(#dcur, false) *
	   desc_enum(#desc, #enum) * desc_enum(#dcur, #enum) *
	   desc_writ(#dcur, true) * 
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-Array") *
       ((#md, "@extensible") -> #ext) * types(#ext:Bool) ]]
    [[ Cell_o (#l, #prop, #desc) *
	   MetaData(#l, #md) * ((#md, "@class") -> #cls) *
       ((#md, "@extensible") -> #ext) *
	   (ret == true) ]]
	normal;

    (* Current is undefined, object is not extensible, non-array, throw *)
    [[ (l == #l) * (prop == #prop) * (desc == #desc) * (throw == true) *
	   Cell_o (#l, #prop, none) * MetaData(#l, #md) * 
	   ((#md, "@class") -> #cls) * isClass(#cls, "Non-Array") *
	   ((#md, "@extensible") -> false) ]]
    [[ Cell_o (#l, #prop, none) * MetaData(#l, #md) *
       ((#md, "@class") -> #cls) * ((#md, "@extensible") -> false) *
	   isTypeError(err) ]]
    error;
    
    (* Current is undefined, object is not extensible, non-array, don't throw *)
    [[ (l == #l) * (prop == #prop) * (desc == #desc) * (throw == false) *
       Cell_o (#l, #prop, none) * MetaData(#l, #md) * 
	   ((#md, "@class") -> #cls) * isClass(#cls, "Non-Array") *
	   ((#md, "@extensible") -> false) ]]
    [[ Cell_o (#l, #prop, none) * MetaData(#l, #md) *
       ((#md, "@class") -> #cls) * ((#md, "@extensible") -> false) *
	   (ret == false) ]]
    normal;

	(* Current is defined, configurable is false, data descriptor, configurable is true, non-array, throw *)
    [[ (l == #l) * (prop == #prop) * (desc == #desc) * (throw == true) *
       Cell_o (#l, #prop, #dcur) * Descriptor(#dcur) * desc_conf(#dcur, false) *
       DataDescriptor(#desc) * desc_conf(#desc, true) *
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-Array") * 
       ((#md, "@extensible") -> #ext) * types(#ext:Bool) ]]
    [[ Cell_o (#l, #prop, #dcur) * MetaData(#l, #md) * 
       ((#md, "@class") -> #cls) * ((#md, "@extensible") -> #ext) *
	   isTypeError(err) ]]
	error;

	(* Current is defined, configurable is false, data descriptor, configurable is true, non-array, don't throw *)
    [[ (l == #l) * (prop == #prop) * (desc == #desc) * (throw == false) *
       Cell_o (#l, #prop, #dcur) * Descriptor(#dcur) * desc_conf(#dcur, false) *
       DataDescriptor(#desc) * desc_conf(#desc, true) *
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-Array") * 
       ((#md, "@extensible") -> #ext) * types(#ext:Bool) ]]
    [[ Cell_o (#l, #prop, #dcur) * MetaData(#l, #md) * 
       ((#md, "@class") -> #cls) * ((#md, "@extensible") -> #ext) *
	   (ret == false) ]]
	normal;

	(* Current is defined, configurable is false, data descriptor, configurable is false, enumerables are different, non-array, throw *)
    [[ (l == #l) * (prop == #prop) * (desc == #desc) * (throw == true) *
	   Cell_o (#l, #prop, #dcur) * Descriptor(#dcur) * desc_conf(#dcur, false) *
       DataDescriptor(#desc) * desc_conf(#desc, false) *
       desc_enum(#desc, #ed) * desc_enum(#dcur, #ec) * (! (#ed == #ec)) *
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-Array") * 
       ((#md, "@extensible") -> #ext) * types(#ext:Bool) ]]
    [[ Cell_o (#l, #prop, #dcur) * MetaData(#l, #md) * 
       ((#md, "@class") -> #cls) * ((#md, "@extensible") -> #ext) *
	   isTypeError(err) ]]
	error;

	(* Current is defined, configurable is false, data descriptor, configurable is false, enumerables are different, non-array, don't throw *)
    [[ (l == #l) * (prop == #prop) * (desc == #desc) * (throw == false) *
	   Cell_o (#l, #prop, #dcur) * Descriptor(#dcur) * desc_conf(#dcur, false) *
       DataDescriptor(#desc) * desc_conf(#desc, false) *
       desc_enum(#desc, #ed) * desc_enum(#dcur, #ec) * (! (#ed == #ec)) *
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-Array") * 
       ((#md, "@extensible") -> #ext) * types(#ext:Bool) ]]
    [[ Cell_o (#l, #prop, #dcur) * MetaData(#l, #md) * 
       ((#md, "@class") -> #cls) * ((#md, "@extensible") -> #ext) *
	   (ret == false) ]]
	normal;
	
	(* Current is defined, configurables are false, enumerables are same, writables false and true, throw *)
    [[ (l == #l) * (prop == #prop) * (desc == #desc) * (throw == true) *
       Cell_o (#l, #prop, #dcur) * DataDescriptor(#dcur) * DataDescriptor(#desc) * 
	   desc_conf(#desc, false) * desc_conf(#dcur, false) *
	   desc_enum(#desc, #en)   * desc_enum(#dcur, #en)   *
	   desc_writ(#desc, true)  * desc_writ(#dcur, false) *
	   MetaData(#l, #md) *
       ((#md, "@class") -> #cls) * isClass(#cls, "Non-Array") *
       ((#md, "@extensible") -> #ext) * types (#ext : Bool) ]]
    [[ Cell_o (#l, #prop, #dcur) * MetaData(#l, #md) *
       ((#md, "@class") -> #cls) * ((#md, "@extensible") -> #ext) *
	   isTypeError(err) ]]
	error;

	(* Current is defined, configurables are false, enumerables are same, writables false and true, throw *)
    [[ (l == #l) * (prop == #prop) * (desc == #desc) * (throw == false) *
       Cell_o (#l, #prop, #dcur) * DataDescriptor(#dcur) * DataDescriptor(#desc) * 
	   desc_conf(#desc, false) * desc_conf(#dcur, false) *
	   desc_enum(#desc, #en)   * desc_enum(#dcur, #en)   *
	   desc_writ(#desc, true)  * desc_writ(#dcur, false) *
	   MetaData(#l, #md) *
       ((#md, "@class") -> #cls) * isClass(#cls, "Non-Array")  * 
       ((#md, "@extensible") -> #ext) * types (#ext : Bool) ]]
    [[ Cell_o (#l, #prop, #dcur) * MetaData(#l, #md) *
       ((#md, "@class") -> #cls) * ((#md, "@extensible") -> #ext) *
	   (ret == false) ]]
	normal

proc defineOwnProperty (l, prop, desc, throw) {

			m := metadata(l);
			class := [m, "@class"];

			goto [class = "Array"] adop odop;

	adop:	xret := "a__defineOwnProperty" (l, prop, desc, throw) with elab;
			goto rlab;

	odop:	xret := "o__defineOwnProperty" (l, prop, desc, throw) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *********** *)
(* *** PUT *** *)
(* *********** *)
	 
	(* ******* SUCCESSFUL PUT ******* *)

	(*
	 *  1. Property is not defined in the prototype chain at all, prototype chain of length > 1, object is extensible
	 *	2. Property is defined in the object (DD), data descriptor is writable
	 *  3. Property is defined in the prototype chain, not in the object (DD), object is extensible, data descriptor is writable
	 *  4. Property is not defined in the prototype chain at all, prototype chain of length = 1, object is extensible
	 *)

	(* ******* UNSUCCESSFUL PUT ******* *)
 
	(*
	 *	5. Property is not defined in the prototype chain at all, object is not extensible, throw
	 *  6. Property is defined in the object (DD), data descriptor is not writable, throw
	 *  7. Property is defined in the prototype chain, not in the object (DD), object is not extensible, throw
	 *  8. Property is defined in the prototype chain, not in the object (DD), object is extensible, data descriptor is not writable, throw
	 *)

spec put (l, prop, value, throw)

	(* 1. Property is not defined within the prototype chain, more than one element, non-string
		   Must reform the prototype chain manually in the post-condition, extra tricky *)
	[[ (l == #l) * (prop == #prop) * (value == #value) * (! (#value == empty)) *
	   (throw == #throw) * types (#throw:Bool) *
	   Pi (#l, #prop, undefined, (#l :: (#lp :: #lllp)), (#cls :: (#ccls :: #llcls)), ("" :: (#pv :: #llpv))) *
	   isClass(#cls, "Non-String") * isClass(#cls, "Non-Array") * types (#lp:Obj, #ccls:Str, #pv:Str) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> true) ]]
	[[ Pi (#l, #prop, {{ "d", #value, true, true, true }}, {{ #l }}, {{ #cls }}, {{ "" }}) * 
	   MetaData(#l, #md) * ((#md, "@proto") -> #lp) * ((#md, "@extensible") -> true) * 
	   Pi (#lp, #prop, undefined, (#lp :: #lllp), (#ccls :: #llcls), (#pv :: #llpv)) *
	   (ret == empty) ]]
	normal;
	
	(* 2. Property is defined in the object, data descriptor that is writable, success *)
	[[ (l == #l) * (prop == #prop) * (value == #value) * (! (#value == empty)) *
	   (throw == #throw) * types (#throw:Bool) *
	   Pi (#l, #prop, {{ "d", #dval, true, #denum, #dconf }}, {{ #l }}, {{ #cls }}, #lpv) *
	   (! (#dval == empty)) * types(#denum:Bool, #dconf:Bool) *
	   isClass(#cls, "Non-String") * isClass(#cls, "Non-Array") *
	   MetaData(#l, #md) * ((#md, "@extensible") -> #ext) * types(#ext:Bool) ]]
	[[ Pi (#l, #prop, {{ "d", #value, true, #denum, #dconf }}, {{ #l }}, {{ #cls }}, #lpv) * 
	   MetaData(#l, #md) * ((#md, "@extensible") -> #ext) *
	   (ret == empty) ]]
	normal;

	(* 3. Property is defined in the prototype chain, not in the object (DD), object is extensible, data descriptor is writable *)
    [[ (l == #l) * (prop == #prop) * (value == #value) * (! (#value == empty)) *
	   (throw == #throw) * types (#throw:Bool) *
	   Pi (#l, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, (#l :: (#lp :: #lllp)), (#cls :: (#pcls :: #ocls)), ("" :: (#pv :: #llpv))) *
	   (! (#dcval == empty)) * types (#dcenum:Bool, #dcconf:Bool) * types (#lp:Obj, #pcls:Str, #pv:Str) *
	   isClass(#cls, "Non-String") * isClass(#cls, "Non-Array") * 
	   MetaData(#l, #md) * ((#md, "@extensible") -> true) ]]
	[[ Pi (#l, #prop, {{ "d", #value, true, true, true }}, {{ #l }}, {{ #cls }}, {{ "" }}) *
	   Pi (#lp, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, (#lp :: #lllp), (#pcls :: #ocls), (#pv :: #llpv)) *
       MetaData(#l, #md) * ((#md, "@proto") -> #lp) * ((#md, "@extensible") -> true) *
	   (ret == empty) ]]
    normal;

	(* 4. Property is not defined within the prototype chain, only one element, non-string *)
	[[ (l == #l) * (prop == #prop) * (value == #value) * (! (#value == empty)) * (throw == #throw) * types(#throw:Bool) * 
	   Pi (#l, #prop, undefined, {{ #l }}, {{ #cls }}, {{ "" }}) * isClass(#cls, "Non-String") * isClass(#cls, "Non-Array") *
	   MetaData(#l, #md) * ((#md, "@extensible") -> true) ]]
	[[ Pi (#l, #prop, {{ "d", #value, true, true, true }}, {{ #l }}, {{ #cls }}, {{ "" }}) * 
	   MetaData(#l, #md) * ((#md, "@proto") -> null) * ((#md, "@extensible") -> true) *
	   (ret == empty) ]]
	normal;

	(* 5. Property is not defined within the prototype chain at all, object not extensible, throw *)
	[[ (l == #l) * (prop == #prop) * (value == #value) * (throw == true) *
	   Pi (#l, #prop, undefined, #ls, #lcls, #lpv) * 
	   MetaData(#l, #md) * ((#md, "@extensible") -> false) ]]
	[[ Pi (#l, #prop, undefined, #ls, #lcls, #lpv) * 
	   MetaData(#l, #md) * ((#md, "@extensible") -> false) *
	   isTypeError(err) ]]
	error;

	(* 6. Property is defined in the object, data descriptor that is not writable, throw *)
	[[ (l == #l) * (prop == #prop) * (value == #value) * (throw == true) * 
	   Pi (#l, #prop, #d, {{ #l }}, #lcls, #lpv) * 
	   MetaData(#l, #md) * ((#md, "@extensible") -> #ext) * types(#ext:Bool) * 
	   DataDescriptor(#d) * desc_writ(#d, false) ]]
	[[ Pi (#l, #prop, #d, {{ #l }}, #lcls, #lpv) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> #ext) *
	   isTypeError(err) ]]
	error;
	
	(* 7. Property is defined in the prototype chain, not in the object, object not extensible, throw *)
	[[ (l == #l) * (prop == #prop) * (value == #value) * (throw == true) * 
	   Pi (#l, #prop, #d, #ls, #lcls, #lpv) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> false) *
	   DataDescriptor(#d) * (#ls == (#l :: #lp :: #other)) * types(#lp:Obj) ]]
	[[ Pi (#l, #prop, #d, #ls, #lcls, #lpv) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> false) *
	   isTypeError(err) ]]
	error;

	(* 8. Property is defined in the prototype chain, not in the object, object extensible, property not writable, throw *)
	[[ (l == #l) * (prop == #prop) * (value == #value) * (throw == true) *
	   Pi (#l, #prop, #d, #ls, #lcls, #lpv) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> true) *
	   DataDescriptor(#d) * desc_writ(#d, false) * (#ls == (#l :: #lp :: #other)) * types (#lp:Obj) ]]
	[[ Pi (#l, #prop, #d, #ls, #lcls, #lpv) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> true) *
	   isTypeError(err) ]]
	error

proc put (l, prop, value, throw) {
            xret := "canPut" (l, prop) with elab;
            goto [xret] cp reject;

			[* unfold Pi (#l, #prop, #d, #ls, #lcls, #lpv) *]
    cp:     xret := "getOwnProperty" (l, prop) with elab;
    		dd := "i__isDataDescriptor" (xret);
    		goto [dd] dd gp;

    dd:		desc := {{ "g", empty, empty, value, empty, empty, empty }};
    		xret := "defineOwnProperty" (l, prop, desc, throw) with elab;
			[* fold Pi (#l, #prop, {{ "d", #value, true, #denum, #dconf }}, {{ #l }}, _, _) *]
    		goto remp;

			[* fold Pi (#l, #prop, #d, #ls, #lcls, #lpv) *]
    gp:		xret := "getProperty" (l, prop) with elab;
    		ad := "i__isAccessorDescriptor" (xret);
    		goto [ad] ad def;

    ad:		s := l-nth (xret, 2);
    		xsc := [s, "@scope"];
    		fun := [s, "@call"];
    		xret := fun (xsc, l, value) with elab;
    		goto remp;

    def:	desc := {{ "d", value, true, true, true }};
			[* unfold Pi (#l, #prop, #d, #ls, #lcls, #lpv) *]
    		xret := "defineOwnProperty" (l, prop, desc, throw) with elab;
			[* fold Pi (#l, #prop, {{ "d", #value, true, true, true }}, {{ #l }}, _, _) *]
			skip;

    remp:   xret := empty;
    rlab:   skip;

    reject: xret := empty;
			goto [throw] tt rlab;

    tt:     xret := "TypeError" ();
    elab:   skip
}
with
{
    ret: xret, rlab;
    err: xret, elab;
};

(* ******************* *)
(* *** I__PUTVALUE *** *)
(* ******************* *)  

spec i__putValue (v, w)

    [[ v == undefined ]]
    [[ isReferenceError(err) ]]
    error;

    [[ v == null ]]
    [[ isReferenceError(err) ]]
    error;

    [[ types (v:Num) ]]
	[[ isReferenceError(err) ]]
	error;

    [[ types (v:Bool) ]]
    [[ isReferenceError(err) ]]
    error;

    [[ types (v:Str) ]]
    [[ isReferenceError(err) ]]
    error;

    [[ types (v:Obj) ]]
    [[ isReferenceError(err) ]]
    error;
   
    (* Variable reference, environment record, directly put in heap *)
    [[ (v == {{ "v", #obj, #field }}) * (w == #w) * (! (#w == empty)) * 
       (! (#obj == $lg)) * ((#obj, #field) -> _) ]]
    [[ ((#obj, #field) -> #w) * (ret == empty) ]]
    normal;
    
	(* Object reference, non-string object, property not defined, prototype chain of length > 1 *)
    [[ (v == {{ "o", #l, #prop }}) * (w == #w) * (! (#w == empty)) * 
	   Pi (#l, #prop, undefined, (#l :: (#lp :: #lllp)), (#cls :: (#pcls :: #ocls)), ("" :: (#pv :: #llpv))) *
	   isClass(#cls, "Non-String") * isClass(#cls, "Non-Array") * types (#lp:Obj, #pcls:Str, #pv:Str) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> true) ]]
	[[ Pi (#l, #prop, {{ "d", #w, true, true, true }}, {{ #l }}, {{ #cls }},  {{ "" }}) * 
	   Pi (#lp, #prop, undefined, (#lp :: #lllp), (#pcls :: #ocls), (#pv :: #llpv)) *
	   MetaData(#l, #md) * ((#md, "@proto") -> #lp) * ((#md, "@extensible") -> true) *
	   (ret == empty) ]]
    normal;

	(* Variable reference, $lg, property not defined, prototype chain of length > 1 *)
    [[ (v == {{ "v", $lg, #prop }}) * (w == #w) * (! (#w == empty)) * 
	   Pi ($lg, #prop, undefined, ($lg :: (#lp :: #lllp)), (#cls :: (#pcls :: #ocls)), ("" :: (#pv :: #llpv))) *
	   isClass(#cls, "Non-String") * isClass(#cls, "Non-Array") * types (#lp:Obj, #pcls:Str, #pv:Str) *
	   MetaData($lg, #md) * ((#md, "@extensible") -> true) ]]
	[[ Pi ($lg, #prop, {{ "d", #w, true, true, true }}, {{ $lg }}, {{ #cls }},  {{ "" }}) * 
	   Pi (#lp, #prop, undefined, (#lp :: #lllp), (#pcls :: #ocls), (#pv :: #llpv)) *
	   MetaData($lg, #md) * ((#md, "@proto") -> #lp) * ((#md, "@extensible") -> true) *
	   (ret == empty) ]]
    normal;
    
	(* Object reference, property is defined in the object, data descriptor that is writable, success *)
    [[ (v == {{ "o", #l, #prop }}) * (w == #w) * (! (#w == empty)) * 
       Pi (#l, #prop, {{ "d", #dval, true, #denum, #dconf }}, {{ #l }}, {{ #cls }}, {{ "" }}) *
       types (#denum:Bool, #dconf:Bool) * (! (#dval == empty)) * isClass(#cls, "Non-String") * isClass(#cls, "Non-Array") *
	   MetaData(#l, #md) * ((#md, "@extensible") -> #ext) * types (#ext:Bool) ]]
	[[ Pi (#l, #prop, {{ "d", #w, true, #denum, #dconf }}, {{ #l }}, {{ #cls }}, {{ "" }}) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> #ext) *
	   (ret == empty) ]]
    normal;

	(* Variable reference, $lg, property is defined in the object, data descriptor that is writable, success *)
    [[ (v == {{ "v", $lg, #prop }}) * (w == #w) * (! (#w == empty)) * 
       Pi ($lg, #prop, {{ "d", #dval, true, #denum, #dconf }}, {{ $lg }}, {{ #cls }}, {{ "" }}) *
       types (#denum:Bool, #dconf:Bool) * (! (#dval == empty)) * isClass(#cls, "Non-String") * isClass(#cls, "Non-Array") *
	   MetaData($lg, #md) * ((#md, "@extensible") -> #ext) * types (#ext:Bool) ]]
	[[ Pi ($lg, #prop, {{ "d", #w, true, #denum, #dconf }}, {{ $lg }}, {{ #cls }}, {{ "" }}) *
	   MetaData($lg, #md) * ((#md, "@extensible") -> #ext) *
	   (ret == empty) ]]
    normal;
    
    (* Object reference, property is defined in the prototype chain, not in the object (DD), object is extensible, data descriptor is writable *)
    [[ (v == {{ "o", #l, #prop }}) * (w == #w) * (! (#w == empty)) *
	   Pi (#l, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, (#l :: (#lp :: #lllp)), (#cls :: (#pcls :: #ocls)),  ("" :: (#pv :: #llpv))) * 
	   types (#lp:Obj, #pcls:Str, #pv:Str) * (! (#dcval == empty)) * types (#dcenum:Bool, #dcconf:Bool) * 
       isClass(#cls, "Non-String") * isClass(#cls, "Non-Array") *
       MetaData(#l, #md) * ((#md, "@extensible") -> true) ]]
	[[ Pi (#l, #prop, {{ "d", #w, true, true, true }}, {{ #l }}, {{ #cls }}, {{ "" }}) * 
	   Pi (#lp, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, (#lp :: #lllp), (#pcls :: #ocls), (#pv :: #llpv)) * 
       MetaData(#l, #md) * ((#md, "@proto") -> #lp) * ((#md, "@extensible") -> true) *
	   (ret == empty) ]]
    normal;

	(* Variable reference, $lg, property is defined in the prototype chain, not in the object (DD), object is extensible, data descriptor is writable *)
    [[ (v == {{ "v", $lg, #prop }}) * (w == #w) * (! (#w == empty)) * 
	   Pi ($lg, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, ($lg :: (#lp :: #lllp)), (#cls :: (#pcls :: #ocls)),  ("" :: (#pv :: #llpv))) * 
	   types (#lp:Obj, #pcls:Str, #pv:Str) * (! (#dcval == empty)) * types (#dcenum:Bool, #dcconf:Bool) * 
       isClass(#cls, "Non-String") * isClass(#cls, "Non-Array") *
       MetaData($lg, #md) * ((#md, "@extensible") -> true) ]]
	[[ Pi ($lg, #prop, {{ "d", #w, true, true, true }}, {{ $lg }}, {{ #cls }}, {{ "" }}) * 
	   Pi (#lp, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, (#lp :: #lllp), (#pcls :: #ocls), (#pv :: #llpv)) * 
       MetaData($lg, #md) * ((#md, "@proto") -> #lp) * ((#md, "@extensible") -> true) *
	   (ret == empty) ]]
    normal;
    
    (* Object reference, non-string object, property not defined, prototype chain of length 1 *)
    [[ (v == {{ "o", #l, #prop }}) * (w == #w) * (! (#w == empty)) * 
       Pi (#l, #prop, undefined, {{ #l }}, {{ #cls }}, {{ "" }}) *
	   isClass(#cls, "Non-String") * isClass(#cls, "Non-Array") * 
	   MetaData(#l, #md) * ((#md, "@extensible") -> true) ]]
    [[ Pi (#l, #prop, {{ "d", #w, true, true, true }}, {{ #l }}, {{ #cls }}, {{ "" }}) * 
       MetaData(#l, #md) * ((#md, "@proto") -> null) * ((#md, "@extensible") -> true) *
	   (ret == empty) ]]
    normal;
    
	(* Object reference, property is not defined within the prototype chain at all, object not extensible, throw *)
    [[ (v == {{ "o", #l, #prop }}) * (w == #w) * 
       Pi (#l, #prop,  undefined, #ls, #lcls, #lpv) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> false) ]]
	[[ Pi (#l, #prop,  undefined, #ls, #lcls, #lpv) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> false) *
	   isTypeError(err) ]]
    error;

	(* Object reference, property is defined in the object, data descriptor that is not writable, throw *)
	[[ (v == {{ "o", #l, #prop }}) * (w == #w) * 
	   Pi (#l, #prop, #d, {{ #l }}, #lcls, #lpv) *
	   DataDescriptor(#d) * desc_writ(#d, false) * 
	   MetaData(#l, #md) * ((#md, "@extensible") -> #ext) * types(#ext:Bool) ]]
	[[ Pi (#l, #prop, #d, {{ #l }}, #lcls, #lpv) * 
	   MetaData(#l, #md) * ((#md, "@extensible") -> #ext) *
	   isTypeError(err) ]]
	error;

	(* Object reference, property is defined in the prototype chain, not in the object, object not extensible, throw *)
	[[ (v == {{ "o", #l, #prop }}) * (w == #w) * 
	   types (#l : Obj, #prop : Str, #cls : List) *
	   Pi (#l, #prop, #d, #ls, #cls, #lpv) *
	   DataDescriptor(#d) * (#ls == (#l :: #lp :: #other)) * types (#lp:Obj) * 
	   MetaData(#l, #md) * ((#md, "@extensible") -> false) ]]
	[[ Pi (#l, #prop, #d, #ls, #cls, #lpv) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> false) *
	   isTypeError(err) ]]
	error;

	(* Object reference, property is defined in the prototype chain, not in the object, object extensible, property not writable, throw *)
	[[ (v == {{ "o", #l, #prop }}) * (w == #w) * types (#lp:Obj) *
	   Pi (#l, #prop, #d, #ls, #lcls, #lpv) * DataDescriptor(#d) * desc_writ(#d, false) * (#ls == (#l :: #lp :: #other)) * types (#lp:Obj) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> false) ]]
	[[ Pi (#l, #prop, #d, #ls, #lcls, #lpv) *
	   MetaData(#l, #md) * ((#md, "@extensible") -> false) *
	   isTypeError(err) ]]
	error;

	(* Variable reference, $lg, property is not defined within the prototype chain at all, object not extensible, throw *)
    [[ (v == {{ "v", $lg, #prop }}) * (w == #w) *
       Pi ($lg, #prop, undefined, #ls, #lcls, #lpv) *
	   MetaData($lg, #md) * ((#md, "@extensible") -> false) ]]
	[[ Pi ($lg, #prop, undefined, #ls, #lcls, #lpv) *
	   MetaData($lg, #md) * ((#md, "@extensible") -> false) *
	   isTypeError(err) ]]
    error

proc i__putValue (v, w) {

			goto [(typeOf(v) = List) and ((l-nth (v, 0) = "v") or (l-nth (v, 0) = "o"))] init throw;

	init:	rbase := l-nth (v, 1);
			rfield := l-nth (v, 2);
			goto [rbase = undefined] throw prim;

	prim:	prim := "i__isPrimitive" (rbase);
      	    goto [prim] is_pr refr; 

	refr:	goto [(typeOf(v) = List) and (l-nth (v, 0) = "o")] oref vref;

	oref:	xret := "put" (rbase, rfield, w, true) with elab;
			goto dflt;

	vref:	goto [rbase = $lg] lg er;

	lg:		xret := "put" (rbase, rfield, w, true) with elab;
			goto dflt;

	er:		[rbase, rfield] := w;

	dflt:	xret := empty;
	rlab:	skip;

	throw:  xret := "ReferenceError" ();
    elab:   skip;

    		(* WHY GOD, WHY THIS? *)

	is_pr:	xret := "i__toObject" (rbase) with elab;
			l := xret;
    		xret := "canPut" (l, rfield) with elab;
            goto [xret] cp reject;

    cp:     xret := "getProperty" (l, rfield) with elab;
    		dd := "i__isDataDescriptor" (xret);
    		goto [dd] reject is_ad;

   	is_ad: 	ad := "i__isAccessorDescriptor" (xret);
    		goto [ad] ad reject;

    ad:		s := l-nth (xret, 2);
    		m := metadata(s);
    		xsc := [m, "@scope"];
    		fun := [m, "@call"];
    		xret := fun (xsc, rbase, w) with elab;
    		goto dflt;

    reject: xret := "TypeError" ();
    		goto elab
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *********************************************************
   *********************************************************
   ***********   BUILT-IN LIBRARY CONSTRUCTORS   ***********
   *********************************************************
   ********************************************************* *)
  
(* ************************* *)
(* *** BOOLEAN_CONSTRUCT *** *)
(* ************************* *)  

spec Boolean_construct (xsc, vthis, v) 

	[[ (v == #v) * types(v:Bool) ]]
	[[ BooleanObject(ret, #v) * empty_fields(ret : -{ }-) ]]
	normal

proc Boolean_construct (xsc, vthis, v) {
			pv := "i__toBoolean" (v);

			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lbool_proto, "Boolean", true);

			m := metadata(xret);
			[m, "@primitiveValue"] := pv;

	rlab:	skip
}
with
{
	ret: 	xret, rlab;
};

(* ************************ *)
(* *** NUMBER_CONSTRUCT *** *)
(* ************************ *)

spec Number_construct (xsc, vthis, v) 

	[[ (v == #v) * types(v:Num) ]]
	[[ NumberObject(ret, #v) * empty_fields(ret : -{ }-) ]]
	normal

proc Number_construct (xsc, vthis, v) {

	init:	pv := "i__toNumber" (v) with elab;

			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lnum_proto, "Number", true);

			m := metadata(xret);
			[m, "@primitiveValue"] := pv;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: pv, elab;
};