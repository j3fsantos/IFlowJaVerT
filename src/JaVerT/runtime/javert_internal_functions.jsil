(* ******************
   *** PREDICATES ***
   ****************** *)

import javert_js_predicates.jsil;


(*******************
 *******************
 ***** OBJECTS *****
 *******************
 *******************)    

(* ***********************
 * CREATE_DEFAULT_OBJECT *
 *************************)

spec create_default_object (l, pr, cl, ext)

    [[ (l == #l) * (pr == #pr) * (cl == #cl) * (ext == #ext) *
       (#cl == undefined) * (#ext == undefined) *
	   JSObjGeneralWeak(#l, #op, #oc, #oe) ]]
    [[ JSObjGeneral(#l, #pr, "Object", true) * (ret == #l) ]]
    normal;
    
    [[ (l == #l) * (pr == #pr) * (cl == #cl) * (ext == #ext) *
	   types(#cl:Str, #ext:Bool) *
       JSObjGeneralWeak(#l, #op, #oc, #oe) ]]
    [[ JSObjGeneral(#l, #pr, #cl, #ext) * (ret == #l) ]]
    normal

proc create_default_object (l, pr, cl, ext) {

			goto [cl = undefined] scl text;
	scl:	cl := "Object";
	text:	goto [ext = undefined] sext setall;
	sext:	ext := true;

			(* Get the metadata, creating the object in the process *)
	setall:	m := metadata(l);
			
			(* Set the internal properties in the metadata *)
			[m, "@proto"] := pr;
			[m, "@class"] := cl;
			[m, "@extensible"] := ext;

	rlab:	xret := l
}
with
{
	ret:	xret, rlab;
};

(* ******************
 * OBJECT_CONSTRUCT *
 ********************)

spec Object_construct (xsc, vthis, l)
    
    [[ (l == #l) * types(#l:Undefined) ]]
    [[ JSObjGeneral(ret, $lobj_proto, "Object", true) * 
       empty_fields(ret : -{ }-) * MetaData(ret, #md) *
       empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal
    
    (* TODO: for Object, Boolean, Number, String *)

proc Object_construct (xsc, vthis, l) {

			goto [typeOf(l) = Obj] obj l1b;
	obj:	xret := l;
			goto rlab;

	l1b:	goto [(typeOf(l) = Bool) or (typeOf(l) = Num) or (typeOf(l) = Str)] to_obj norm;
	to_obj:	xret := "i__toObject" (l);
			goto rlab;

	norm:	xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lobj_proto, "Object", true);
	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* ***********************************
 * CREATE_OBJECT_WITH_CALL_CONSTRUCT *
 *************************************)

spec create_object_with_call_construct (l, call, construct, len)

    [[ (l == #l) * (call == #call) * (construct == empty) * (len == #len) *
	   types(#call:Str, #len:Num) *
       JSObjGeneralWeak(#l, #old_pr, #old_class, #old_ext) * 
       ((#l, "length") -> #old_len) * 
       MetaData(#l, #md) *
       ((#md, "@scope") -> #old_scope) * ((#md, "@call") -> #old_call) ]]
    [[ JSObjGeneral(#l, $lfun_proto, "Function", true) *
       ((#l, "length") -> {{ "d", #len, false, false, false }}) *  
       MetaData(#l, #md) *
	   ((#md, "@scope") -> empty) * ((#md, "@call") -> #call) *
	   (ret == #l) ]]
    normal;

    [[ (l == #l) * (call == #call) * (construct == #construct) * (len == #len) *
	   types(#call : Str, #construct: Str, #len : Num) *
       JSObjGeneralWeak(#l, #old_pr, #old_class, #old_ext) * 
       ((#l, "length") -> #old_len) *
       MetaData(#l, #md) *
       ((#md, "@scope") -> #old_scope) * ((#md, "@call") -> #old_call) * ((#md, "@construct") -> #old_construct) ]]
    [[ JSObjGeneral(#l, $lfun_proto, "Function", true, #md) *
       ((#l, "length") -> {{ "d", #len, false, false, false }}) *  
       MetaData(#l, #md) *
	   ((#md, "@scope") -> empty) * ((#md, "@call") -> #call) * ((#md, "@construct") -> #construct) *
	   (ret == #l) ]]
    normal
    
proc create_object_with_call_construct (l, call, construct, len) {

			xret := "create_default_object" (l, $lfun_proto, "Function", true);

			[xret, "length"] := {{ "d", len, false, false, false }};

			(* Get the metadata *)
			m := metadata(xret);
			
			(* Set the internal scope, call and construct properties *)
			[m, "@scope"] := empty;
			[m, "@call"] := call;
			
			goto [construct = empty] rlab cstr;

	cstr:	[m, "@construct"] := construct;

	rlab:	xret := l
}
with
{
	ret:	xret, rlab;
};

(* ************************
 * CREATE_FUNCTION_OBJECT *
 **************************)

spec create_function_object (xsc, call, construct, params)

    [[ (xsc == #xsc) * (call == #call) * (construct == #construct) * (params == #params) * (#call == #construct) *
       types(#xsc:List, #call:Str, #construct:Str, #params:List) ]]
    [[ FunctionObject(ret, #call, #xsc, #len, #prototype) * 
       empty_fields(ret : -{ "arguments", "caller", "length", "prototype" }-) *
       MetaData(ret, #mdf) * empty_fields(#mdf : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope" }-) *
       (#len == l-len #params) *
	   JSObjGeneral(#prototype, $lobj_proto, "Object", true) *
	   ((#prototype, "constructor") -> {{ "d", ret, true, false, true }}) *
	   empty_fields(#prototype : -{ "constructor" }-) *
	   MetaData(#prototype, #mdp) * empty_fields(#mdp : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc create_function_object (xsc, call, construct, params) {
			len := l-len (params);
			m := new (null);
			l := new (m);
			l := "create_object_with_call_construct" (l, call, construct, len);

			[m, "@scope"] := xsc;

			prototype := "Object_construct" ();
			[prototype, "constructor"] := {{ "d", l, true, false, true }};
			[l, "prototype"]           := {{ "d", prototype, true, false, false }};

			(* Strict mode only *)
			[l, "caller"]    := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};
			[l, "arguments"] := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};

			xret := l;

	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(************************
 ***** INITIAL HEAP *****
 ************************)
 
spec setupInitialHeap ()

	[[ initialHeapPre() ]]
	[[ initialHeapPost( -{ }- ) * (ret == empty) ]]
	normal

proc setupInitialHeap () {

			(* Global object *)

			xret := "create_default_object" ($lg, $lobj_proto, "Object", true);

			(* Object.prototype *)

			xret := "create_default_object" ($lobj_proto, null, "Object", true);
			
			[$lobj_proto, "hasOwnProperty"] := {{ "d", $lop_hasOwnProperty, true, false, true }};
  			
  			xret := "create_object_with_call_construct" ($lop_hasOwnProperty, "OP_hasOwnProperty", empty, 1);

			(* Function.prototype *)
			
			xret := "create_object_with_call_construct" ($lfun_proto, "FP_default", empty, 0);
			m := metadata($lfun_proto); 
   			[m, "@proto"] := $lobj_proto;
			
			(* Error object *)

			xret := "create_object_with_call_construct" ($lerr, "Error_call", "Error_construct", 1);
			[$lg, "Error"] := {{ "d", $lerr, true, false, true }};
			[$lerr, "prototype"] := {{ "d", $lerr_proto, false, false, false }};

			(* Error.prototype *)

			xret := "create_default_object" ($lerr_proto, $lobj_proto, "Error", true);
			[$lerr_proto, "message"]     := {{ "d", "", true, false, true }};

	rlab:	xret := empty
}
with
{
	ret:	xret, rlab;
};

(***********************
 ***********************
 ***** CONVERSIONS *****
 ***********************
 ***********************)  

(* *************
 * I__TOSTRING *
 ***************)

spec i__toString (v)

	[[ v == undefined ]]
	[[ ret == "undefined" ]]
	normal;

	[[ v == null ]]
	[[ ret == "null" ]]
	normal;
	
	[[ v == true ]]
	[[ ret == "true" ]]
	normal;
	
	[[ v == false ]]
	[[ ret == "false" ]]
	normal;

	[[ (v == #v) * types(#v:Num) ]]
	[[ types(ret:Str) * (ret == (num_to_string #v)) ]]
	normal;
	
	[[ (v == #v) * types(#v:Str) ]]
	[[ types(ret:Str) * (ret == #v) ]]
	normal
	
	(* TODO: for Object [HO] *)

proc i__toString (v) {
	iu:		goto [v = undefined] undef in;
	undef:	xret := "undefined";
			goto rlab;

	in:		goto [v = null] nul ib;
	nul:	xret := "null";
			goto rlab;

	ib:		goto [typeOf(v) = Bool] bool inum;
	bool:	goto [v = true] is_t is_f;
	is_t:	xret := "true";
			goto rlab;
	is_f:	xret := "false";
			goto rlab;

	inum:	goto [typeOf(v) = Num] num is;
	num:	xret := num_to_string v;
			goto rlab;

	is:		goto [typeOf(v) = Str] str io;
	str:	xret := v;
			goto rlab;

	io:		goto [typeOf(v) = Obj] obj oops;
	obj:	xret := "i__toPrimitive" (v, "String") with elab;
			xret := "i__toString" (xret) with elab;
			goto rlab;

	oops:	xret := "TypeError" ("ToString: This should not happen.");
            goto elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *************
 * I_TOBOOLEAN *
 ***************)

spec i__toBoolean (v)

	[[ v == undefined ]]
	[[ ret == false ]]
	normal;

	[[ v == null ]]
	[[ ret == false ]]
	normal;

	[[ (v == #v) * types(#v:Bool) ]]
	[[ ret == #v ]]
	normal; 

	[[ v == 0 ]]
	[[ ret == false ]]
	normal;
	
	[[ (v == #v) * types(#v:Num) * (! (#v == 0)) ]]
	[[ (ret == true) ]]
	normal;
	
	[[ v == "" ]]
	[[ ret == false ]]
	normal;
	
	[[ (v == #v) * types(#v:Str) * (! (#v == "")) ]]
	[[ ret == true ]]
	normal;
	
	[[ (v == #v) * types(#v:Obj) ]]
	[[ ret == true ]]
	normal

	(* TODO: for NaN *)

proc i__toBoolean (v) {
	iu:		goto [v = undefined] undef in;
	undef:	xret := false;
			goto rlab;

	in:		goto [v = null] nul ib;
	nul:	xret := false;
			goto rlab;

	ib:		goto [typeOf(v) = Bool] bool inum;
	bool:	xret := v;
			goto rlab;

	inum:	goto [typeOf(v) = Num] num is;
	num:	goto [(v = 0) or (not (v = v))] is_f is_t;

	is:		goto [typeOf(v) = Str] str io;
	str:	goto [v = ""] is_f is_t;
			goto rlab;

	io:		goto [typeOf(v) = Obj] obj oops;
	obj:	xret := true;
			goto rlab;

	is_t:	xret := true;
			goto rlab;
	is_f:	xret := false;
			goto rlab;

	oops:	xret := "ToBoolean: This should not happen.";

	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(******************
 ******************
 ***** ERRORS *****
 ******************
 ******************)  

(*******************
 * ERROR_CONSTRUCT *
 *******************)

spec Error_construct (xsc, vthis, v)

    (* Error constructor without message *)
    [[ (v == undefined) * (vthis == #vthis) *
       MetaData(#vthis, #mvt) * Extensible(#vthis, true) *
       ((#mvt, "@class") -> #oc) * ((#mvt, "@extensible") -> #oe) *
       MetaData(#mvt, null) * Extensible(#mvt, true) ]]
    [[ (ret == #vthis) * 
       MetaData(#vthis, #mvt) * Extensible(#vthis, true) *
       ((#mvt, "@class") -> "Error") * ((#mvt, "@extensible") -> true) *
       MetaData(#mvt, null) * Extensible(#mvt, true) ]]
    normal;
    
    (* Error constructor with message of type string *)
    [[ (v == #m) * (vthis == #vthis) *
	   types (#m:Str) * 
       ((#vthis, "message") -> #om) * 
       MetaData(#vthis, #mvt) *
       ((#mvt, "@class") -> #oc) * ((#mvt, "@extensible") -> #oe) ]]
    [[ (ret == #vthis) * 
       ((#vthis, "message") -> {{ "d", #m, true, false, true }}) *
       MetaData(#vthis, #mvt) *
       ((#mvt, "@class") -> "Error") * ((#mvt, "@extensible") -> true) ]]
    normal

proc Error_construct (xsc, vthis, v) {
			xret := vthis;

			m := metadata(vthis);
			[m, "@class"] := "Error";
			[m, "@extensible"] := true;

			goto [v = undefined] rlab mess;

	mess:	xerr := "i__toString" (v) with elab;
			[xret, "message"] := {{ "d", xerr, true, false, true }};

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xerr, elab;
};

(*********************************)
(* TYPEERROR_CALL and _CONSTRUCT *)
(*********************************)

spec TypeError_call (xsc, vthis, v)

    [[ v == undefined ]]
    [[ isTypeError(ret) * empty_fields(ret : -{ }-) *
       MetaData(ret, #md) * empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc TypeError_call (xsc, vthis, v) {
			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lterr_proto, "Error", true);

			xret := "Error_construct" (undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec TypeError (v)

    [[ v == undefined ]]
    [[ isTypeError(ret) * empty_fields(ret : -{ }-) *
       MetaData(ret, #md) * empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc TypeError (v) {
			xret := "TypeError_call" (undefined, undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(**************************************)
(* REFERENCEERROR_CALL and _CONSTRUCT *)
(**************************************)

spec ReferenceError_call (xsc, vthis, v)

    [[ v == undefined ]]
    [[ isReferenceError(ret) * empty_fields(ret : -{ }-) *
       MetaData(ret, #md) * empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc ReferenceError_call (xsc, vthis, v) {
			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lrferr_proto, "Error", true);

			xret := "Error_construct" (undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec ReferenceError (v)

    [[ v == undefined ]]
    [[ isReferenceError(ret) * empty_fields(ret : -{ }-) *
       MetaData(ret, #md) * empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc ReferenceError (v) {
			xret := "ReferenceError_call" (undefined, undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(***********************************)
(* SYNTAXERROR_CALL and _CONSTRUCT *)
(***********************************)

spec SyntaxError_call (xsc, vthis, v)

    [[ v == undefined ]]
    [[ isSyntaxError(ret) * empty_fields(ret : -{ }-) *
       MetaData(ret, #md) * empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc SyntaxError_call (xsc, vthis, v) {
			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lserr_proto, "Error", true);

			xret := "Error_construct" (undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec SyntaxError (v)

    [[ v == undefined ]]
    [[ isSyntaxError(ret) * empty_fields(ret : -{ }-) *
       MetaData(ret, #md) * empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc SyntaxError (v) {
			xret := "SyntaxError_call" (undefined, undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* **********************************************
   **********************************************
   ***********   INTERNAL FUNCTIONS   ***********
   **********************************************
   ********************************************** *)

(* *************************
   *** O__GETOWNPROPERTY ***
   ************************* *)

(*
 *    Name: o__getOwnProperty 
 * Purpose: Get own property of a non-String object
 *
 *   Specs:
 *
 * 01 - Property not defined, return undefined
 * 02 - Property defined, return property descriptor
 *
 *)

spec o__getOwnProperty (l, prop)

    [[ (l == #l) * (prop == #prop) * Cell_o (#l, #prop, none) ]]
    [[ Cell_o (#l, #prop, none) * (ret == undefined) ]]
    normal;

    [[ (l == #l) * (prop == #prop) * Cell_o (#l, #prop, #dx) * Descriptor(#dx) ]]
    [[ Cell_o (#l, #prop, #dx) * (ret == #dx) ]]
    normal

proc o__getOwnProperty (l, prop) {
            x := hasField(l, prop);
            goto [x] hp nhp; 			(* Does the field exist? *)

    nhp:    xret := undefined;			(* Field doesn't exist; return undefined *)
            goto rlab;

    hp:     xret := [l, prop];			(* Field exists; return the descriptor *)

    rlab:   skip
}
with
{
    ret: 	xret, rlab;
};

(*
 *    Name: s__getOwnProperty 
 * Purpose: Get own property of a String object
 *
 *   Specs:
 *
 * 01 - Property defined, return property descriptor
 *
 *)

spec s__getOwnProperty (l, prop) 

    [[ (l == #l) * (prop == #prop) * Cell_s (#l, #prop, #dx) * Descriptor(#dx) ]]
    [[ Cell_s (#l, #prop, #dx) * (ret == #dx) ]]
    normal

proc s__getOwnProperty (l, prop) {
			xret := "o__getOwnProperty" (l, prop);
			goto [xret = undefined] str rlab;

	str:	idx := "i__toInteger" (prop) with elab;
			goto [idx < 0] rlab next;

	next:	sidx := "i__toString" (idx);

			goto [sidx = prop] index rlab;

	index:	m := metadata(l);
			str := [m, "@primitiveValue"];
			len := s-len (str);
			goto [len <= idx] rlab return;

	return: rstr := s-nth (str, idx);
			xret := {{ "d", rstr, false, true, false }};

	rlab: 	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* **********************
   *** GETOWNPROPERTY ***
   ********************** *)

(*
 *    Name: getOwnProperty 
 * Purpose: Get own property of a (general) object
 *
 *   Specs:
 *
 * 01 - Non-string object, property not defined, return undefined
 * 02 - Any object, property defined, return property descriptor
 *
 *)

spec getOwnProperty (l, prop)

    [[ (l == #l) * (prop == #prop) * Cell_o (#l, #prop, none) *
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * isClass(#cls, "Non-String") ]]
    [[ Cell_o (#l, #prop, none) * 
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * (ret == undefined) ]]
    normal;

    [[ (l == #l) * (prop == #prop) * Cell_o (#l, #prop, #dx) * Descriptor(#dx) *
       MetaData(#l, #md) * ((#md, "@class") -> #cls) ]]
    [[ Cell_o (#l, #prop, #dx) * 
       MetaData(#l, #md) * ((#md, "@class") -> #cls) * (ret == #dx) ]]
    normal

proc getOwnProperty (l, prop) {

			m := metadata(l);
			class := [m, "@class"];

			goto [class = "String"] sgop ogop;

	sgop:	xret := "s__getOwnProperty" (l, prop) with elab;
			goto rlab;

	ogop:	xret := "o__getOwnProperty" (l, prop) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(*
 *    Name: getProperty 
 * Purpose: Get property of a (general) object, considering prototype inheritance
 *
 *   Specs:
 *
 * 01 - Get the heap value associated with the appropriate Pi
 *)

spec getProperty (l, prop)

	[[ (l == #l) * (prop == #prop) * Pi (#l, #prop, #d, #ls, #cls, #pv) ]]
	[[ Pi (#l, #prop, #d, #ls, #cls, #pv) * (ret == #d) ]]
	normal

proc getProperty (l, prop) {

			[* unfold Pi (#l, #prop, #d, #ls, #cls, #pv) *]
			xret := "getOwnProperty" (l, prop) with elab;
			goto [xret = undefined] next rlab;

	next:	m := metadata(l);
			proto := [m, "@proto"];
			goto [proto = null] rlab call;

	call:	xret := "getProperty" (proto, prop) with elab;

			[* fold Pi (#l, #prop, #d, #ls, #cls, #pv) *]
    rlab:   skip;
    elab:	skip
}
with
{
    ret: 	xret, rlab;
    err:	xret, elab;
};

(* *** *)
(* GET *)
(* *** *)

(*
 *    Name: get 
 * Purpose: Get the value of a property of a (general) object in the entire prototype chain
 *
 *   Specs:
 *
 * 01 - Property not defined in the prototype chain, return undefined ]
 * 02 - Property defined, data descriptor, get value of the descriptor 
 *)

spec get (l, prop)

    [[ (l == #l) * (prop == #prop) *
	   Pi (#l, #prop, #d, #ls, #cls, #pv) * (#d == undefined) ]]
    [[ Pi (#l, #prop, #d, #ls, #cls, #pv) * (ret == undefined) ]]
    normal;
    
    [[ (l == #l) * (prop == #prop) *
	   Pi (#l, #prop, #d, #ls, #cls, #pv) * DataDescriptor (#d) ]]
    [[ Pi (#l, #prop, #d, #ls, #cls, #pv) * desc_val (#d, #desc_val) * (ret == #desc_val) ]]
    normal

proc get (l, prop) {

			xret := "getProperty" (l, prop) with elab;
			goto [xret = undefined] rlab def;		(* Does the field exist?    *)

	def:	d := l-nth (xret, 0);					(* Get the descriptor type  *)
			xret := l-nth (xret, 1);				(* Get the value/getter     *)
			goto [d = "d"] rlab acc;				(* Is it a data descriptor? *)

	acc:	goto [xret = undefined] rlab get;		(* Is the getter defined?               *)
	get:	m := metadata(xret);
			xsc := [m, "@scope"];				    (* Get the scope of the getter          *)
			fun := [m, "@call"];					(* Get the name of the getter           *)
			xret := fun (xsc, l) with elab;			(* Call the getter, errors could happen *)
			goto [xret = empty] undef rlab;
	undef:	xret := undefined;

	rlab:	skip;
	elab:	skip
}
with
{
    ret: xret, rlab;
    err: xret, elab;
};