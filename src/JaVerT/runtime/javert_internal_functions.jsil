(* ******************
   *** PREDICATES ***
   ****************** *)

import javert_js_predicates.jsil;

(*
 * Predicate: isInternalProperty
 *
 * Resource: none
 *
 *)
pred isInternalProperty (prop : Str) :
	(! (prop == "")) * (s-nth (prop, 0) == "@");

(*
 * Predicate: isNamedProperty
 *
 * Resource: none
 *
 *)
pred isNamedProperty (prop : Str) :
	(! (prop == "")) * (! (s-nth (prop, 0) == "@"));

(*
 * Predicate: DataDescriptor
 *
 * Resource: none
 *
 *)
pred DataDescriptor (d : List) :
	(d == {{ "d", #dval, #dwrit, #denum, #dconf }}) *
	types (#dwrit : Bool, #denum : Bool, #dconf : Bool) * 
	(! (#dval == empty));
    
(*
 * Predicate: GenericDescriptor
 *
 * Resource: none
 *
 *)
pred GenericDescriptor (d : List) :
	(d == {{ "g", #genum, #gconf, #gval, #gwrit, #gget, #gset }});

(*
 * Predicate: Projection functions for descriptors
 *
 * Resource: none
 *
 *)
pred desc_val (d : List, v) :
    v == l-nth(d, 1);

pred desc_writ (d : List, v) :
    v == l-nth(d, 2);

pred desc_get (d : List, v) :
    v == l-nth(d, 1);

pred desc_set (d : List, v) :
    v == l-nth(d, 2);

pred desc_enum (d : List, v) :
    v == l-nth(d, 3);

pred desc_conf (d : List, v) :
    v == l-nth(d, 4);

(*
 * Predicate: Cell_o(l, prop, X)
 *
 * Resource:
 *      (l, prop)
 *
 * Note: We are not allowing accessor descriptors in the heap yet
 *)
pred Cell_o (l : Obj, prop : Str, d) :
    ((l, prop) -> d) * (d == none),
    ((l, prop) -> d) * DataDescriptor(d);

(*
 * Predicate: isClass(c, X)
 *
 * Resource:
 *      (l, "@class")
 *
 *)
pred isClass (c : Str, case : Str) :
	(case == "Array") * (c == "Array"),
	(case == "String") * (c == "String"),
	(case == "Non-Array") * (! (c == "Array")),
	(case == "Non-String") * (! (c == "String"));	

(*
 * The PI predicate
 *)

(*
 * Resource:
 *		(l, "@class")   via isClass
 *		(l, "@proto")	(l, "prop")
 *)
pred Pi (l, prop, lcls, undefined, ls, ltf, lpv) :
    types(l : Obj, prop : Str, #cls : Str, lcls : List, ls : List, ltf : List, lpv : List) *
	((l, "@proto") -> null) * ((l, "@class") -> #cls) *
	isClass (#cls, "Non-String") * Cell_o (l, prop, none) *
    (lcls == {{ #cls }}) * (ls == {{ l }}) * (ltf == {{ false }}) * (lpv == {{ "" }});

(*
 * Resource:
 *		(l, "@class")   via isClass
 *		(l, "@proto")	(l, "prop")
 *)
pred Pi (l, prop, lcls, d, ls, ltf, lpv) :
    types(l : Obj, prop : Str, #cls : Str, lcls : List, d : List, ls : List, ltf : List, lpv : List) *
	((l, "@class") -> #cls) *
	isClass (#cls, "Non-String") * Cell_o (l, prop, d) * (! (d == none)) *
    (lcls == {{ #cls }}) * (ls == {{ l }}) * (ltf == {{ false }}) * (lpv == {{ "" }});

(*
 * Resource:
 *		(l, "@class")   via isClass
 *		(l, "@proto")	(l, "prop")		(l, "@primitiveValue")
 *
 *		Those five fields captured throughout the chain
 *)

pred Pi (l, prop, lcls, d, ls, ltf, lpv) :
    types(l : Obj, prop : Str, lcls : List, ls : List, ltf : List, lpv : List) *
	((l, "@class") -> #cls) * ((l, "@proto") -> #lp) *
	isClass (#cls, "Non-String") * Cell_o (l, prop, none) *
	types(#lcls : List, #lls : List, #ltf  : List, #lpv : List) *
    Pi (#lp, prop, #lcls, d, #lls, #ltf, #lpv) *
	types(#pcls : Str,  #ocls : List,
	        #lp : Obj,  #ols  : List,
		   #ptf : Bool, #otf  : List,
		   #ppv : Str,  #otv  : List) *
	(#lcls == #pcls :: #ocls) * (#lls == #lp :: #ols) * (#ltf == #ptf :: #otf) * (#lpv == #ppv :: #otv) *
	(lcls == #cls :: #lcls) * (ls == l :: #lls) * (ltf == false :: #ltf) * (lpv == "" :: #lpv);

(*******************
 *******************
 ***** OBJECTS *****
 *******************
 *******************)    

(* ***********************
 * CREATE_DEFAULT_OBJECT *
 *************************)

spec create_default_object (l, pr, cl, ext)

    [[ (l == #l) * (pr == #pr) * (cl == #cl) * (ext == #ext) *
       (#cl == undefined) * (#ext == undefined) *
	   JSObjGeneralWeak(#l, #op, #oc, #oe, #md) ]]
    [[ JSObjGeneral(#l, #pr, "Object", true, #md) * (ret == #l) ]]
    normal;

    [[ (l == #l) * (pr == #pr) * (cl == #cl) * (ext == #ext) *
	   types(#cl:Str, #ext:Bool) *
       JSObjGeneralWeak(#l, #op, #oc, #oe, #md) ]]
    [[ JSObjGeneral(#l, #pr, #cl, #ext, #md) * (ret == #l) ]]
    normal

proc create_default_object (l, pr, cl, ext) {

			goto [cl = undefined] scl text;
	scl:	cl := "Object";
	text:	goto [ext = undefined] sext setall;
	sext:	ext := true;

			(* Get the metadata, creating the object in the process *)
	setall:	m := metadata(l);
			
			(* Set the internal properties in the metadata *)
			[m, "@proto"] := pr;
			[m, "@class"] := cl;
			[m, "@extensible"] := ext;

	rlab:	xret := l
}
with
{
	ret:	xret, rlab;
};

(* ******************
 * OBJECT_CONSTRUCT *
 ********************)

spec Object_construct (xsc, vthis, l)

    [[ (l == #l) * types(#l:Undefined) ]]
    [[ JSObjGeneral(ret, $lobj_proto, "Object", true, #md) * 
       empty_fields(ret : -{ }-) *
       empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal
    
    (* TODO: for Object, Boolean, Number, String *)

proc Object_construct (xsc, vthis, l) {
			l := l;

			goto [typeOf(l) = Obj] obj l1b;
	obj:	xret := l;
			goto rlab;

	l1b:	goto [(typeOf(l) = Bool) or (typeOf(l) = Num) or (typeOf(l) = Str)] to_obj norm;
	to_obj:	xret := "i__toObject" (l);
			goto rlab;

	norm:	xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lobj_proto, "Object", true);
	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* ***********************************
 * CREATE_OBJECT_WITH_CALL_CONSTRUCT *
 *************************************)

spec create_object_with_call_construct (l, call, construct, len)

    [[ (l == #l) * (call == #call) * (construct == empty) * (len == #len) *
	   types(#call:Str, #len:Num) *
       JSObjGeneralWeak(#l, #old_pr, #old_class, #old_ext, #md) * 
       ((#l, "length") -> #old_len) *  
       ((#md, "@scope") -> #old_scope) * ((#md, "@call") -> #old_call) ]]
    [[ JSObjGeneral(#l, $lfun_proto, "Function", true, #md) *
       ((#l, "length") -> {{ "d", #len, false, false, false }}) *  
	   ((#md, "@scope") -> empty) * ((#md, "@call") -> #call) *
	   (ret == #l) ]]
    normal;

    [[ (l == #l) * (call == #call) * (construct == #construct) * (len == #len) *
	   types(#call : Str, #construct: Str, #len : Num) *
       JSObjGeneralWeak(#l, #old_pr, #old_class, #old_ext, #md) * 
       ((#l, "length") -> #old_len) *
       ((#md, "@scope") -> #old_scope) * ((#md, "@call") -> #old_call) * ((#md, "@construct") -> #old_construct) ]]
    [[ JSObjGeneral(#l, $lfun_proto, "Function", true, #md) *
	   ((#md, "@scope") -> empty) * ((#md, "@call") -> #call) * ((#md, "@construct") -> #construct) *
	   ((#l, "length") -> {{ "d", #len, false, false, false }}) *  
	   (ret == #l) ]]
    normal
    
proc create_object_with_call_construct (l, call, construct, len) {

			xret := "create_default_object" (l, $lfun_proto, "Function", true);

			[xret, "length"] := {{ "d", len, false, false, false }};

			(* Get the metadata *)
			m := metadata(xret);
			
			(* Set the internal scope, call and construct properties *)
			[m, "@scope"] := empty;
			[m, "@call"] := call;
			
			goto [construct = empty] rlab cstr;

	cstr:	[m, "@construct"] := construct;

	rlab:	xret := l
}
with
{
	ret:	xret, rlab;
};

(* ************************
 * CREATE_FUNCTION_OBJECT *
 **************************)

spec create_function_object (xsc, call, construct, params)

    [[ (xsc == #xsc) * (call == #call) * (construct == #construct) * (params == #params) * (#call == #construct) *
       types(#xsc:List, #call:Str, #construct:Str, #params:List) ]]
    [[ FunctionObject(ret, #call, #xsc, #len, #prototype, #mdf) * 
       empty_fields(ret : -{ "arguments", "caller", "length", "prototype" }-) *
       empty_fields(#mdf : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope" }-) *
       (#len == l-len #params) *
	   JSObjGeneral(#prototype, $lobj_proto, "Object", true, #mdp) *
	   ((#prototype, "constructor") -> {{ "d", ret, true, false, true }}) *
	   empty_fields(#prototype : -{ "constructor" }-) *
	   empty_fields(#mdp : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc create_function_object (xsc, call, construct, params) {
			len := l-len (params);
			m := new (null);
			l := new (m);
			l := "create_object_with_call_construct" (l, call, construct, len);

			[m, "@scope"] := xsc;

			prototype := "Object_construct" ();
			[prototype, "constructor"] := {{ "d", l, true, false, true }};
			[l, "prototype"]           := {{ "d", prototype, true, false, false }};

			(* Strict mode only *)
			[l, "caller"]    := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};
			[l, "arguments"] := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};

			xret := l;

	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(***********************
 ***********************
 ***** CONVERSIONS *****
 ***********************
 ***********************)  

(* *************
 * I__TOSTRING *
 ***************)

spec i__toString (v)

	[[ v == undefined ]]
	[[ ret == "undefined" ]]
	normal;

	[[ v == null ]]
	[[ ret == "null" ]]
	normal;
	
	[[ v == true ]]
	[[ ret == "true" ]]
	normal;
	
	[[ v == false ]]
	[[ ret == "false" ]]
	normal;

	[[ (v == #v) * types(#v:Num) ]]
	[[ types(ret:Str) * (ret == (num_to_string #v)) ]]
	normal;
	
	[[ (v == #v) * types(#v:Str) ]]
	[[ types(ret:Str) * (ret == #v) ]]
	normal
	
	(* TODO: for Object [HO] *)

proc i__toString (v) {
	iu:		goto [v = undefined] undef in;
	undef:	xret := "undefined";
			goto rlab;

	in:		goto [v = null] nul ib;
	nul:	xret := "null";
			goto rlab;

	ib:		goto [typeOf(v) = Bool] bool inum;
	bool:	goto [v = true] is_t is_f;
	is_t:	xret := "true";
			goto rlab;
	is_f:	xret := "false";
			goto rlab;

	inum:	goto [typeOf(v) = Num] num is;
	num:	xret := num_to_string v;
			goto rlab;

	is:		goto [typeOf(v) = Str] str io;
	str:	xret := v;
			goto rlab;

	io:		goto [typeOf(v) = Obj] obj oops;
	obj:	xret := "i__toPrimitive" (v, "String") with elab;
			xret := "i__toString" (xret) with elab;
			goto rlab;

	oops:	xret := "TypeError" ("ToString: This should not happen.");
            goto elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *************
 * I_TOBOOLEAN *
 ***************)

spec i__toBoolean (v)

	[[ v == undefined ]]
	[[ ret == false ]]
	normal;

	[[ v == null ]]
	[[ ret == false ]]
	normal;

	[[ (v == #v) * types(#v:Bool) ]]
	[[ ret == #v ]]
	normal; 

	[[ v == 0 ]]
	[[ ret == false ]]
	normal;
	
	[[ (v == #v) * types(#v:Num) * (! (#v == 0)) ]]
	[[ (ret == true) ]]
	normal;
	
	[[ v == "" ]]
	[[ ret == false ]]
	normal;
	
	[[ (v == #v) * types(#v:Str) * (! (#v == "")) ]]
	[[ ret == true ]]
	normal;
	
	[[ (v == #v) * types(#v:Obj) ]]
	[[ ret == true ]]
	normal

	(* TODO: for NaN *)

proc i__toBoolean (v) {
	iu:		goto [v = undefined] undef in;
	undef:	xret := false;
			goto rlab;

	in:		goto [v = null] nul ib;
	nul:	xret := false;
			goto rlab;

	ib:		goto [typeOf(v) = Bool] bool inum;
	bool:	xret := v;
			goto rlab;

	inum:	goto [typeOf(v) = Num] num is;
	num:	goto [(v = 0) or (not (v = v))] is_f is_t;

	is:		goto [typeOf(v) = Str] str io;
	str:	goto [v = ""] is_f is_t;
			goto rlab;

	io:		goto [typeOf(v) = Obj] obj oops;
	obj:	xret := true;
			goto rlab;

	is_t:	xret := true;
			goto rlab;
	is_f:	xret := false;
			goto rlab;

	oops:	xret := "ToBoolean: This should not happen.";

	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(******************
 ******************
 ***** ERRORS *****
 ******************
 ******************)  

(*******************
 * ERROR_CONSTRUCT *
 *******************)

spec Error_construct (xsc, vthis, v)

    (* Error constructor without message *)
    [[ (v == undefined) * (vthis == #vthis) *
       MetaData(#vthis, #mvt) * Extensible(#vthis, true) *
       ((#mvt, "@class") -> #oc) * ((#mvt, "@extensible") -> #oe) *
       MetaData(#mvt, null) * Extensible(#mvt, true) ]]
    [[ (ret == #vthis) * 
       MetaData(#vthis, #mvt) * Extensible(#vthis, true) *
       ((#mvt, "@class") -> "Error") * ((#mvt, "@extensible") -> true) *
       MetaData(#mvt, null) * Extensible(#mvt, true) ]]
    normal;
    
    (* Error constructor with message of type string *)
    [[ (v == #m) * (vthis == #vthis) *
	   types (#m:Str) * 
       ((#vthis, "message") -> #om) * 
       MetaData(#vthis, #mvt) *
       ((#mvt, "@class") -> #oc) * ((#mvt, "@extensible") -> #oe) ]]
    [[ (ret == #vthis) * 
       ((#vthis, "message") -> {{ "d", #m, true, false, true }}) *
       MetaData(#vthis, #mvt) *
       ((#mvt, "@class") -> "Error") * ((#mvt, "@extensible") -> true) ]]
    normal

proc Error_construct (xsc, vthis, v) {
			xret := vthis;

			m := metadata(vthis);
			[m, "@class"] := "Error";
			[m, "@extensible"] := true;

			goto [v = undefined] rlab mess;

	mess:	xerr := "i__toString" (v) with elab;
			[xret, "message"] := {{ "d", xerr, true, false, true }};

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xerr, elab;
};

(*********************************)
(* TYPEERROR_CALL and _CONSTRUCT *)
(*********************************)

spec TypeError_call (xsc, vthis, v)

    [[ v == undefined ]]
    [[ isTypeError(ret, #md) *
       empty_fields(ret : -{ }-) *
       empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc TypeError_call (xsc, vthis, v) {
			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lterr_proto, "Error", true);

			xret := "Error_construct" (undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec TypeError (v)

    [[ v == undefined ]]
    [[ isTypeError(ret, #md) *
       empty_fields(ret : -{ }-) *
       empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc TypeError (v) {
			xret := "TypeError_call" (undefined, undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(**************************************)
(* REFERENCEERROR_CALL and _CONSTRUCT *)
(**************************************)

spec ReferenceError_call (xsc, vthis, v)

    [[ v == undefined ]]
    [[ isReferenceError(ret, #md) *
       empty_fields(ret : -{ }-) *
       empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc ReferenceError_call (xsc, vthis, v) {
			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lrferr_proto, "Error", true);

			xret := "Error_construct" (undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec ReferenceError (v)

    [[ v == undefined ]]
    [[ isReferenceError(ret, #md) *
       empty_fields(ret : -{ }-) *
       empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc ReferenceError (v) {
			xret := "ReferenceError_call" (undefined, undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(***********************************)
(* SYNTAXERROR_CALL and _CONSTRUCT *)
(***********************************)

spec SyntaxError_call (xsc, vthis, v)

    [[ v == undefined ]]
    [[ isSyntaxError(ret, #md) *
       empty_fields(ret : -{ }-) *
       empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc SyntaxError_call (xsc, vthis, v) {
			xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lserr_proto, "Error", true);

			xret := "Error_construct" (undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

spec SyntaxError (v)

    [[ v == undefined ]]
    [[ isSyntaxError(ret, #md) *
       empty_fields(ret : -{ }-) *
       empty_fields(#md : -{ "@class", "@extensible", "@proto" }-) ]]
    normal

proc SyntaxError (v) {
			xret := "SyntaxError_call" (undefined, undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};