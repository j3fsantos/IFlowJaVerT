pred isClass (c, case): 
types(c : Str, case : Str, _lvar_576 : Str) * (! (_lvar_576 == "String")) * (case == "Non-String") * (c == _lvar_576),
 types(c : Str, case : Str, _lvar_574 : Str) * (! (_lvar_574 == "Array")) * (case == "Non-Array") * (c == _lvar_574),
 types(c : Str, case : Str) * (case == "String") * (c == "String"),
 types(c : Str, case : Str) * (case == "Array") * (c == "Array");

pred ErrorObject (l, pr): 
types(l : Obj, _lvar_568 : Obj, pr : Obj) * (pr == _lvar_568) * (l == _$l_l) * ((_$l_l, "@proto") -> _lvar_568) * ((_$l_l, "@class") -> "Error") * ((_$l_l, "@extensible") -> true) * empty_fields(_$l_l : -{ "@class", "@extensible", "@proto" }-);

pred initialHeapPost (globals): 
types(globals : Set, _lvar_579 : Set) * (globals == _lvar_579) * (($lerr_proto, "@class") -> "Error") * (($lerr_proto, "@proto") -> $lobj_proto) * (($lerr_proto, "@extensible") -> true) * (($lerr_proto, "message") -> {{ "d", "", true, false, true }}) * empty_fields($lerr_proto : -{ "@class", "@extensible", "@proto", "message" }-) * (($lobj_proto, "@class") -> "Object") * (($lobj_proto, "@proto") -> null) * (($lobj_proto, "@extensible") -> true) * (($lobj_proto, "hasOwnProperty") -> {{ "d", $lop_hasOwnProperty, true, false, true }}) * empty_fields($lobj_proto : -{ "@class", "@extensible", "@proto", "hasOwnProperty" }-) * (($lop_hasOwnProperty, "@class") -> "Function") * (($lop_hasOwnProperty, "@proto") -> $lfun_proto) * (($lop_hasOwnProperty, "@extensible") -> true) * (($lop_hasOwnProperty, "@scope") -> empty) * (($lop_hasOwnProperty, "length") -> {{ "d", 1., false, false, false }}) * (($lop_hasOwnProperty, "@call") -> "OP_hasOwnProperty") * empty_fields($lop_hasOwnProperty : -{ "@call", "@class", "@extensible", "@proto", "@scope", "length" }-) * (($lg, "@class") -> "Object") * (($lg, "@proto") -> $lobj_proto) * (($lg, "@extensible") -> true) * (($lg, "Error") -> {{ "d", $lerr, true, false, true }}) * empty_fields($lg : -u- (_lvar_579, -{ "@class", "@extensible", "@proto", "Error" }-)) * (($lerr, "@class") -> "Function") * (($lerr, "@proto") -> $lfun_proto) * (($lerr, "@extensible") -> true) * (($lerr, "@scope") -> empty) * (($lerr, "length") -> {{ "d", 1., false, false, false }}) * (($lerr, "@call") -> "Error_call") * (($lerr, "@construct") -> "Error_construct") * (($lerr, "prototype") -> {{ "d", $lerr_proto, false, false, false }}) * empty_fields($lerr : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope", "length", "prototype" }-) * (($lfun_proto, "@class") -> "Function") * (($lfun_proto, "@proto") -> $lobj_proto) * (($lfun_proto, "@extensible") -> true) * (($lfun_proto, "@scope") -> empty) * (($lfun_proto, "length") -> {{ "d", 0., false, false, false }}) * (($lfun_proto, "@call") -> "FP_default") * empty_fields($lfun_proto : -{ "@call", "@class", "@extensible", "@proto", "@scope", "length" }-);

pred desc_enum (d, v): 
types(d : List, _lvar_578 : List) * (d == _lvar_578) * (v == l-nth(_lvar_578, 3.));

pred desc_set (d, v): 
types(d : List, _lvar_577 : List) * (d == _lvar_577) * (v == l-nth(_lvar_577, 2.));

pred desc_conf (d, v): 
types(d : List, _lvar_581 : List) * (d == _lvar_581) * (v == l-nth(_lvar_581, 4.));

pred desc_val (d, v): 
types(d : List, _lvar_580 : List) * (d == _lvar_580) * (v == l-nth(_lvar_580, 1.));

pred DataDescriptor (d): 
types(#denum : Bool, d : List, #dwrit : Bool, #dconf : Bool) * (! (#dval == empty)) * (d == {{ "d", #dval, #dwrit, #denum, #dconf }});

pred GenericDescriptor (d): 
types(d : List) * (d == {{ "g", #genum, #gconf, #gval, #gwrit, #gget, #gset }});

pred Pi (l, prop, lcls, d, ls, ltf, lpv): 
types(ls : List, lcls : List, d : Undefined, l : Obj, _lvar_601 : Str, #cls : Str, prop : Str, ltf : List, lpv : List) * (! (#cls == "String")) * (! (_lvar_601 == "")) * (! (s-nth(_lvar_601, 0.) == "@")) * (lpv == {{ "" }}) * (d == undefined) * (ls == {{ _$l_l }}) * (ltf == {{ false }}) * (prop == _lvar_601) * (l == _$l_l) * (lcls == {{ #cls }}) * ((_$l_l, "@proto") -> null) * ((_$l_l, "@class") -> #cls) * ((_$l_l, _lvar_601) -> none),
 types(lcls : List, ls : List, d : List, l : Obj, _lvar_6 : Bool, prop : Str, #cls : Str, ltf : List, _lvar_5 : Bool, _lvar_595 : Str, lpv : List, _lvar_7 : Bool) * (! (#cls == "String")) * (! (_lvar_595 == "")) * (! (s-nth(_lvar_595, 0.) == "@")) * (! (_lvar_4 == empty)) * (lpv == {{ "" }}) * (d == {{ "d", _lvar_4, _lvar_5, _lvar_6, _lvar_7 }}) * (ls == {{ _$l_l }}) * (ltf == {{ false }}) * (prop == _lvar_595) * (l == _$l_l) * (lcls == {{ #cls }}) * ((_$l_l, "@class") -> #cls) * ((_$l_l, _lvar_595) -> {{ "d", _lvar_4, _lvar_5, _lvar_6, _lvar_7 }}),
 Pi(#lp, _lvar_584, (#pcls :: #ocls), _lvar_d, (#lp :: #ols), (#ptf :: #otf), (#ppv :: #otv)) * types(#ocls : List, #otv : List, #otf : List, #lcls : List, lcls : List, ls : List, #lp : Obj, l : Obj, #ols : List, prop : Str, #cls : Str, _lvar_584 : Str, #ppv : Str, #ptf : Bool, ltf : List, #lls : List, lpv : List, #pcls : Str, #ltf : List, #lpv : List) * (#lcls == (#pcls :: #ocls)) * (#lls == (#lp :: #ols)) * (#ltf == (#ptf :: #otf)) * (#lpv == (#ppv :: #otv)) * (! (#cls == "String")) * (! (_lvar_584 == "")) * (! (s-nth(_lvar_584, 0.) == "@")) * (lpv == ("" :: (#ppv :: #otv))) * (d == _lvar_d) * (ls == (_$l_l :: (#lp :: #ols))) * (ltf == (false :: (#ptf :: #otf))) * (prop == _lvar_584) * (l == _$l_l) * (lcls == (#cls :: (#pcls :: #ocls))) * ((_$l_l, "@class") -> #cls) * ((_$l_l, "@proto") -> #lp) * ((_$l_l, _lvar_584) -> none);

pred isReferenceError (l): 
types(l : Obj) * (l == _$l_l) * ((_$l_l, "@proto") -> $lrferr_proto) * ((_$l_l, "@class") -> "Error") * ((_$l_l, "@extensible") -> true) * empty_fields(_$l_l : -{ "@class", "@extensible", "@proto" }-);

pred initialHeapPre (): 
types() * empty_fields($lerr_proto : -{  }-) * empty_fields($lobj_proto : -{  }-) * empty_fields($lop_hasOwnProperty : -{  }-) * empty_fields($lg : -{  }-) * empty_fields($lerr : -{  }-) * empty_fields($lfun_proto : -{  }-);

pred isTypeError (l): 
types(l : Obj) * (l == _$l_l) * ((_$l_l, "@proto") -> $lterr_proto) * ((_$l_l, "@class") -> "Error") * ((_$l_l, "@extensible") -> true) * empty_fields(_$l_l : -{ "@class", "@extensible", "@proto" }-);

pred isSyntaxError (l): 
types(l : Obj) * (l == _$l_l) * ((_$l_l, "@proto") -> $lserr_proto) * ((_$l_l, "@class") -> "Error") * ((_$l_l, "@extensible") -> true) * empty_fields(_$l_l : -{ "@class", "@extensible", "@proto" }-);

pred desc_writ (d, v): 
types(d : List, _lvar_606 : List) * (d == _lvar_606) * (v == l-nth(_lvar_606, 2.));

pred function_object (l, xsc, call, construct, len, prototype): 
types(_lvar_608 : Str, _lvar_610 : Num, construct : Str, prototype : Obj, xsc : List, l : Obj, _lvar_609 : Str, _lvar_611 : Obj, call : Str, _lvar_607 : List, len : Num) * (l == _$l_l) * (xsc == _lvar_607) * (prototype == _lvar_611) * (construct == _lvar_609) * (len == _lvar_610) * (call == _lvar_608) * ((_$l_l, "@proto") -> $lfun_proto) * ((_$l_l, "@class") -> "Function") * ((_$l_l, "@extensible") -> true) * ((_$l_l, "@scope") -> _lvar_607) * ((_$l_l, "length") -> {{ "d", _lvar_610, false, false, false }}) * ((_$l_l, "@call") -> _lvar_608) * ((_$l_l, "@construct") -> _lvar_609) * ((_$l_l, "caller") -> {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }}) * ((_$l_l, "arguments") -> {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }}) * ((_$l_l, "prototype") -> {{ "d", _lvar_611, true, false, false }}) * empty_fields(_$l_l : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope", "arguments", "caller", "length", "prototype" }-);

pred isNamedProperty (prop): 
types(prop : Str, _lvar_612 : Str) * (! (_lvar_612 == "")) * (! (s-nth(_lvar_612, 0.) == "@")) * (prop == _lvar_612);

pred desc_get (d, v): 
types(d : List, _lvar_613 : List) * (d == _lvar_613) * (v == l-nth(_lvar_613, 1.));

pred Cell_o (l, prop, d): 
types(_lvar_615 : Str, _lvar_13 : Bool, d : List, l : Obj, prop : Str, _lvar_14 : Bool, _lvar_15 : Bool) * (! (_lvar_615 == "")) * (! (s-nth(_lvar_615, 0.) == "@")) * (! (_lvar_12 == empty)) * (d == {{ "d", _lvar_12, _lvar_13, _lvar_14, _lvar_15 }}) * (prop == _lvar_615) * (l == _$l_l) * ((_$l_l, _lvar_615) -> {{ "d", _lvar_12, _lvar_13, _lvar_14, _lvar_15 }}),
 types(d : None, l : Obj, prop : Str, _lvar_614 : Str) * (! (_lvar_614 == "")) * (! (s-nth(_lvar_614, 0.) == "@")) * (d == none) * (prop == _lvar_614) * (l == _$l_l) * ((_$l_l, _lvar_614) -> none);

pred initialHeapPostWeak (): 
types() * (($lerr_proto, "@class") -> "Error") * (($lerr_proto, "@proto") -> $lobj_proto) * (($lerr_proto, "@extensible") -> true) * (($lerr_proto, "message") -> {{ "d", "", true, false, true }}) * empty_fields($lerr_proto : -{ "@class", "@extensible", "@proto", "message" }-) * (($lobj_proto, "@class") -> "Object") * (($lobj_proto, "@proto") -> null) * (($lobj_proto, "@extensible") -> true) * (($lobj_proto, "hasOwnProperty") -> {{ "d", $lop_hasOwnProperty, true, false, true }}) * empty_fields($lobj_proto : -{ "@class", "@extensible", "@proto", "hasOwnProperty" }-) * (($lop_hasOwnProperty, "@class") -> "Function") * (($lop_hasOwnProperty, "@proto") -> $lfun_proto) * (($lop_hasOwnProperty, "@extensible") -> true) * (($lop_hasOwnProperty, "@scope") -> empty) * (($lop_hasOwnProperty, "length") -> {{ "d", 1., false, false, false }}) * (($lop_hasOwnProperty, "@call") -> "OP_hasOwnProperty") * empty_fields($lop_hasOwnProperty : -{ "@call", "@class", "@extensible", "@proto", "@scope", "length" }-) * (($lg, "@class") -> "Object") * (($lg, "@proto") -> $lobj_proto) * (($lg, "@extensible") -> true) * (($lg, "Error") -> {{ "d", $lerr, true, false, true }}) * (($lerr, "@class") -> "Function") * (($lerr, "@proto") -> $lfun_proto) * (($lerr, "@extensible") -> true) * (($lerr, "@scope") -> empty) * (($lerr, "length") -> {{ "d", 1., false, false, false }}) * (($lerr, "@call") -> "Error_call") * (($lerr, "@construct") -> "Error_construct") * (($lerr, "prototype") -> {{ "d", $lerr_proto, false, false, false }}) * empty_fields($lerr : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope", "length", "prototype" }-) * (($lfun_proto, "@class") -> "Function") * (($lfun_proto, "@proto") -> $lobj_proto) * (($lfun_proto, "@extensible") -> true) * (($lfun_proto, "@scope") -> empty) * (($lfun_proto, "length") -> {{ "d", 0., false, false, false }}) * (($lfun_proto, "@call") -> "FP_default") * empty_fields($lfun_proto : -{ "@call", "@class", "@extensible", "@proto", "@scope", "length" }-);

pred isInternalProperty (prop): 
types(_lvar_617 : Str, prop : Str) * (! (_lvar_617 == "")) * (s-nth(_lvar_617, 0.) == "@") * (prop == _lvar_617);


spec TypeError_call(xsc, vthis, v)
[[ types(v : Undefined) * (v == undefined) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) ]]
[[ types(xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
normal

proc TypeError_call (xsc, vthis, v) {
			xret := new();
			xret := "create_default_object"(xret, $lterr_proto, "Error", true);
			xret := "Error_construct"(undefined, xret, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec TypeError(v)
[[ types(v : Undefined) * (v == undefined) ]]
[[ types(xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
normal

proc TypeError (v) {
			xret := "TypeError_call"(undefined, undefined, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__isCallable(l)
[[ types(l : Obj) * (l == _$l_l) * ((_$l_l, "@call") -> none) ]]
[[ types(l : Obj, xret : Bool) * (xret == false) * (l == _$l_l) * ((_$l_l, "@call") -> none) ]]
normal;

 [[ types(l : Obj) * (! (#y == none)) * (l == _$l_l) * ((_$l_l, "@call") -> #y) ]]
[[ types(l : Obj, xret : Bool) * (xret == true) * (l == _$l_l) * ((_$l_l, "@call") -> #y) ]]
normal

proc i__isCallable (l) {
			xret := false;
			goto [(typeOf(l) = Obj)] obj rlab;
	obj:		xret := hasField(l,"@call");
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec defineOwnProperty(l, prop, desc, throw)
[[ types(#desc : List, l : Obj, #cls : Str, throw : Bool, #prop : Str) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (throw == true) * (desc == #desc) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> none) * ((_$l_#l, "@extensible") -> false) ]]
[[ types(#desc : List, #cls : Str, xret : Obj, #prop : Str) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> none) * ((_$l_#l, "@extensible") -> false) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ types(#desc : List, l : Obj, #cls : Str, throw : Bool, #prop : Str) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (throw == false) * (desc == #desc) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> none) * ((_$l_#l, "@extensible") -> false) ]]
[[ types(#desc : List, #cls : Str, xret : Bool, #prop : Str) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> none) * ((_$l_#l, "@extensible") -> false) ]]
normal;

 [[ types(_lvar_393 : Bool, #desc : List, _lvar_394 : Bool, l : Obj, #cls : Str, #throw : Bool, _lvar_395 : Bool, #prop : Str) * (#desc == {{ "d", _lvar_392, _lvar_393, _lvar_394, _lvar_395 }}) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_392 == empty)) * (throw == #throw) * (desc == {{ "d", _lvar_392, _lvar_393, _lvar_394, _lvar_395 }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> none) * ((_$l_#l, "@extensible") -> true) ]]
[[ types(#desc : List, #cls : Str, #throw : Bool, xret : Bool, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (xret == true) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> #desc) * ((_$l_#l, "@extensible") -> true) ]]
normal;

 [[ types(_lvar_405 : Bool, #dcur : List, _lvar_407 : Bool, #desc : List, l : Obj, _lvar_402 : Bool, #cls : Str, #throw : Bool, _lvar_406 : Bool, #ext : Bool, #prop : Str, _lvar_401 : Bool) * (#dcur == {{ "d", _lvar_400, _lvar_401, _lvar_402, true }}) * (#desc == {{ "d", _lvar_404, _lvar_405, _lvar_406, _lvar_407 }}) * (! (_lvar_404 == empty)) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_400 == empty)) * (throw == #throw) * (desc == {{ "d", _lvar_404, _lvar_405, _lvar_406, _lvar_407 }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> {{ "d", _lvar_400, _lvar_401, _lvar_402, true }}) * ((_$l_#l, "@extensible") -> #ext) ]]
[[ types(#dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, xret : Bool, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (xret == true) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> #desc) * ((_$l_#l, "@extensible") -> #ext) ]]
normal;

 [[ types(#dcur : List, #desc : List, _lvar_410 : Bool, l : Obj, _lvar_413 : Bool, _lvar_409 : Bool, #cls : Str, #throw : Bool, _lvar_414 : Bool, #ext : Bool, throw : Bool, #prop : Str) * (#dcur == {{ "d", _lvar_408, _lvar_409, _lvar_410, false }}) * (#desc == {{ "d", _lvar_412, _lvar_413, _lvar_414, true }}) * (! (_lvar_412 == empty)) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_408 == empty)) * (throw == true) * (desc == {{ "d", _lvar_412, _lvar_413, _lvar_414, true }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_408, _lvar_409, _lvar_410, false }}) ]]
[[ types(#dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, xret : Obj, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #dcur) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ types(_lvar_421 : Bool, #dcur : List, #desc : List, l : Obj, #cls : Str, _lvar_418 : Bool, _lvar_422 : Bool, #throw : Bool, #ext : Bool, _lvar_417 : Bool, throw : Bool, #prop : Str) * (#dcur == {{ "d", _lvar_416, _lvar_417, _lvar_418, false }}) * (#desc == {{ "d", _lvar_420, _lvar_421, _lvar_422, true }}) * (! (_lvar_420 == empty)) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_416 == empty)) * (throw == false) * (desc == {{ "d", _lvar_420, _lvar_421, _lvar_422, true }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_416, _lvar_417, _lvar_418, false }}) ]]
[[ types(#dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, xret : Bool, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #dcur) ]]
normal;

 [[ types(#ec : Bool, #dcur : List, #ed : Bool, #desc : List, _lvar_429 : Bool, l : Obj, #cls : Str, #throw : Bool, #ext : Bool, throw : Bool, #prop : Str, _lvar_425 : Bool) * (#dcur == {{ "d", _lvar_424, _lvar_425, #ec, false }}) * (#desc == {{ "d", _lvar_428, _lvar_429, #ed, false }}) * (! (_lvar_428 == empty)) * (! (#ed == #ec)) * (! (#cls == "String")) * (! (#cls == "Array")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_424 == empty)) * (throw == true) * (desc == {{ "d", _lvar_428, _lvar_429, #ed, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_424, _lvar_425, #ec, false }}) ]]
[[ types(#ec : Bool, #ed : Bool, #dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, xret : Obj, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #dcur) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ types(#ec : Bool, #dcur : List, #ed : Bool, #desc : List, l : Obj, #cls : Str, #throw : Bool, _lvar_437 : Bool, #ext : Bool, throw : Bool, #prop : Str, _lvar_433 : Bool) * (#dcur == {{ "d", _lvar_432, _lvar_433, #ec, false }}) * (#desc == {{ "d", _lvar_436, _lvar_437, #ed, false }}) * (! (_lvar_436 == empty)) * (! (#ed == #ec)) * (! (#cls == "String")) * (! (#cls == "Array")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_432 == empty)) * (throw == false) * (desc == {{ "d", _lvar_436, _lvar_437, #ed, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_432, _lvar_433, #ec, false }}) ]]
[[ types(#ec : Bool, #ed : Bool, #dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, xret : Bool, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #dcur) ]]
normal;

 [[ types(#dcur : List, #desc : List, l : Obj, #cls : Str, #throw : Bool, #ext : Bool, #enum : Bool, throw : Bool, #prop : Str) * (#dcur == {{ "d", _lvar_440, false, #enum, false }}) * (#desc == {{ "d", _lvar_444, true, #enum, false }}) * (! (_lvar_444 == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_440 == empty)) * (throw == true) * (desc == {{ "d", _lvar_444, true, #enum, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_440, false, #enum, false }}) ]]
[[ types(#dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, #enum : Bool, xret : Obj, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #dcur) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ types(#dcur : List, #desc : List, l : Obj, #cls : Str, #throw : Bool, #ext : Bool, #enum : Bool, throw : Bool, #prop : Str) * (#dcur == {{ "d", _lvar_448, false, #enum, false }}) * (#desc == {{ "d", _lvar_452, true, #enum, false }}) * (! (_lvar_452 == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_448 == empty)) * (throw == false) * (desc == {{ "d", _lvar_452, true, #enum, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_448, false, #enum, false }}) ]]
[[ types(#dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, #enum : Bool, xret : Bool, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #dcur) ]]
normal;

 [[ types(#dcur : List, #desc : List, _lvar_461 : Bool, l : Obj, #cls : Str, #throw : Bool, #ext : Bool, #enum : Bool, throw : Bool, #prop : Str) * (#dcur == {{ "d", _lvar_456, true, #enum, false }}) * (#desc == {{ "d", _lvar_460, _lvar_461, #enum, false }}) * (! (_lvar_460 == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_456 == empty)) * (throw == false) * (desc == {{ "d", _lvar_460, _lvar_461, #enum, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_456, true, #enum, false }}) ]]
[[ types(#dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, #enum : Bool, xret : Bool, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (xret == true) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #desc) ]]
normal;

 [[ types(#dcur : List, #desc : List, l : Obj, #cls : Str, #throw : Bool, #ext : Bool, #dec : Bool, #dcc : Bool, #prop : Str) * (#dcur == {{ "d", _lvar_464, true, #dec, #dcc }}) * (#desc == {{ "g", empty, empty, #gval, empty, empty, empty }}) * (! (#gval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_464 == empty)) * (throw == #throw) * (desc == {{ "g", empty, empty, #gval, empty, empty, empty }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_464, true, #dec, #dcc }}) ]]
[[ types(#dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, #dec : Bool, xret : Bool, #dcc : Bool, #prop : Str) * (throw == _lvar_throw) * (xret == true) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", #gval, true, #dec, #dcc }}) ]]
normal

proc defineOwnProperty (l, prop, desc, throw) {
			class := [l, "@class"];
			goto [(class = "Array")] adop odop;
	adop:		xret := "a__defineOwnProperty"(l, prop, desc, throw) with elab;
			goto rlab;
	odop:		xret := "o__defineOwnProperty"(l, prop, desc, throw) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__strictEquality(v1, v2)
[[ types() * (#v1 == #v2) * (v2 == #v2) * (v1 == #v2) ]]
[[ types(xret : Bool) * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (! (#v1 == #v2)) * (v2 == #v2) * (v1 == #v1) ]]
[[ types(xret : Bool) * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal

proc i__strictEquality (v1, v2) {
			xret := (v1 = v2);
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__isDataDescriptor(desc)
[[ types(desc : Undefined) * (desc == undefined) ]]
[[ types(xret : Bool) * (xret == false) * (desc == _lvar_desc) ]]
normal;

 [[ types(_lvar_343 : Bool, _lvar_344 : Bool, desc : List, _lvar_342 : Bool) * (! (_lvar_341 == empty)) * (desc == {{ "d", _lvar_341, _lvar_342, _lvar_343, _lvar_344 }}) ]]
[[ types(xret : Bool) * (xret == true) * (desc == _lvar_desc) ]]
normal;

 [[ types(_lvar_348 : Empty, _lvar_349 : Empty, desc : List) * (desc == {{ "g", _lvar_346, _lvar_347, empty, empty, _lvar_350, _lvar_351 }}) ]]
[[ types(xret : Bool) * (xret == false) * (desc == _lvar_desc) ]]
normal;

 [[ types(desc : List) * (! (_lvar_355 == empty)) * (desc == {{ "g", _lvar_353, _lvar_354, _lvar_355, _lvar_356, _lvar_357, _lvar_358 }}) ]]
[[ types(xret : Bool) * (xret == true) * (desc == _lvar_desc) ]]
normal;

 [[ types(desc : List) * (! (_lvar_363 == empty)) * (desc == {{ "g", _lvar_360, _lvar_361, _lvar_362, _lvar_363, _lvar_364, _lvar_365 }}) ]]
[[ types(xret : Bool) * (xret == true) * (desc == _lvar_desc) ]]
normal

proc i__isDataDescriptor (desc) {
			goto [(desc = undefined)] rf cont;
	cont:		d := l-nth(desc, 0.);
			goto [(d = "d")] rt gen;
	gen:		goto [(d = "g")] test rf;
	test:		v := l-nth(desc, 3.);
			w := l-nth(desc, 4.);
			goto [((v = empty) and (w = empty))] rf rt;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec Error_construct(xsc, vthis, v)
[[ types(vthis : Obj, v : Undefined) * (v == undefined) * (xsc == _lvar_xsc) * (vthis == _$l_#vthis) * ((_$l_#vthis, "@class") -> #cls) * ((_$l_#vthis, "@extensible") -> #ext) ]]
[[ types(xret : Obj) * (xret == _$l_#vthis) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * ((_$l_#vthis, "@class") -> "Error") * ((_$l_#vthis, "@extensible") -> true) ]]
normal;

 [[ types(vthis : Obj, #m : Str) * (v == #m) * (xsc == _lvar_xsc) * (vthis == _$l_#vthis) * ((_$l_#vthis, "@class") -> #cls) * ((_$l_#vthis, "@extensible") -> #ext) * ((_$l_#vthis, "message") -> #ignore) ]]
[[ types(#m : Str, xret : Obj) * (xret == _$l_#vthis) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * ((_$l_#vthis, "@class") -> "Error") * ((_$l_#vthis, "@extensible") -> true) * ((_$l_#vthis, "message") -> {{ "d", #m, true, false, true }}) ]]
normal

proc Error_construct (xsc, vthis, v) {
			xret := vthis;
			[vthis, "@class"] := "Error";
			[vthis, "@extensible"] := true;
			goto [(v = undefined)] rlab mess;
	mess:		xerr := "i__toString"(v) with elab;
			[xret, "message"] := {{ "d", xerr, true, false, true }};
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xerr, elab;
};


spec canPut(l, prop)
[[ Pi(_$l_#l, #prop, #g_aux_0, undefined, #g_aux_2, #g_aux_3, #g_aux_4) * types(l : Obj, #ext : Bool) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@extensible") -> #ext) ]]
[[ Pi(_$l_#l, #prop, #g_aux_0, undefined, #g_aux_2, #g_aux_3, #g_aux_4) * types(#ext : Bool) * (xret == #ext) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@extensible") -> #ext) ]]
normal;

 [[ Pi(#l, #prop, #g_aux_0, {{ "d", _lvar_24, #writ, _lvar_26, _lvar_27 }}, {{ #l }}, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #writ : Bool, _lvar_27 : Bool, _lvar_26 : Bool) * (#g_aux_1 == {{ "d", _lvar_24, #writ, _lvar_26, _lvar_27 }}) * (! (_lvar_24 == empty)) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #g_aux_0, #g_aux_1, {{ #l }}, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #writ : Bool) * (xret == #writ) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal;

 [[ Pi(_$l_#l, #prop, #g_aux_0, {{ "d", _lvar_30, _lvar_31, _lvar_32, _lvar_33 }}, (_$l_#l :: (#lp :: #other)), #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, _lvar_31 : Bool, #lp : Obj, _lvar_32 : Bool, #g_aux_2 : List, l : Obj, #other : List, _lvar_33 : Bool) * (#g_aux_1 == {{ "d", _lvar_30, _lvar_31, _lvar_32, _lvar_33 }}) * (#g_aux_2 == (_$l_#l :: (#lp :: #other))) * (! (_lvar_30 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@extensible") -> false) ]]
[[ Pi(_$l_#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #lp : Obj, #g_aux_2 : List, #other : List, xret : Bool) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@extensible") -> false) ]]
normal;

 [[ Pi(_$l_#l, #prop, #g_aux_0, {{ "d", _lvar_34, #writ, _lvar_36, _lvar_37 }}, (_$l_#l :: (#lp :: #other)), #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #writ : Bool, _lvar_37 : Bool, #lp : Obj, #g_aux_2 : List, l : Obj, #other : List, _lvar_36 : Bool) * (#g_aux_1 == {{ "d", _lvar_34, #writ, _lvar_36, _lvar_37 }}) * (#g_aux_2 == (_$l_#l :: (#lp :: #other))) * (! (_lvar_34 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@extensible") -> true) ]]
[[ Pi(_$l_#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #writ : Bool, #lp : Obj, #g_aux_2 : List, #other : List) * (xret == #writ) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@extensible") -> true) ]]
normal

proc canPut (l, prop) {
			[* unfold Pi(#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) *]
			xret := "getOwnProperty"(l, prop) with elab;
			[* fold Pi(#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) *]
	op:		goto [(xret = undefined)] nop odesc;
	odesc:		d := l-nth(xret, 0.);
			goto [(d = "d")] odd nop;
	odd:		xret := l-nth(xret, 2.);
			goto rlab;
	nop:		e := [l, "@extensible"];
			xret := "getProperty"(l, prop) with elab;
			goto [(xret = undefined)] ext desc;
	desc:		d := l-nth(xret, 0.);
			v := l-nth(xret, 2.);
			goto [(d = "d")] dd ad;
	dd:		goto [e] wr ext;
	wr:		xret := v;
			goto rlab;
	ad:		xret := (not (v = undefined));
			goto rlab;
	ext:		xret := e;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec setupInitialHeap()
[[ types() * empty_fields($lerr_proto : -{  }-) * empty_fields($lobj_proto : -{  }-) * empty_fields($lop_hasOwnProperty : -{  }-) * empty_fields($lg : -{  }-) * empty_fields($lerr : -{  }-) * empty_fields($lfun_proto : -{  }-) ]]
[[ types(xret : Empty) * (xret == empty) * (($lerr_proto, "@class") -> "Error") * (($lerr_proto, "@proto") -> $lobj_proto) * (($lerr_proto, "@extensible") -> true) * (($lerr_proto, "message") -> {{ "d", "", true, false, true }}) * empty_fields($lerr_proto : -{ "@class", "@extensible", "@proto", "message" }-) * (($lobj_proto, "@class") -> "Object") * (($lobj_proto, "@proto") -> null) * (($lobj_proto, "@extensible") -> true) * (($lobj_proto, "hasOwnProperty") -> {{ "d", $lop_hasOwnProperty, true, false, true }}) * empty_fields($lobj_proto : -{ "@class", "@extensible", "@proto", "hasOwnProperty" }-) * (($lop_hasOwnProperty, "@class") -> "Function") * (($lop_hasOwnProperty, "@proto") -> $lfun_proto) * (($lop_hasOwnProperty, "@extensible") -> true) * (($lop_hasOwnProperty, "@scope") -> empty) * (($lop_hasOwnProperty, "length") -> {{ "d", 1., false, false, false }}) * (($lop_hasOwnProperty, "@call") -> "OP_hasOwnProperty") * empty_fields($lop_hasOwnProperty : -{ "@call", "@class", "@extensible", "@proto", "@scope", "length" }-) * (($lg, "@class") -> "Object") * (($lg, "@proto") -> $lobj_proto) * (($lg, "@extensible") -> true) * (($lg, "Error") -> {{ "d", $lerr, true, false, true }}) * empty_fields($lg : -u- (-{  }-, -{ "@class", "@extensible", "@proto", "Error" }-)) * (($lerr, "@class") -> "Function") * (($lerr, "@proto") -> $lfun_proto) * (($lerr, "@extensible") -> true) * (($lerr, "@scope") -> empty) * (($lerr, "length") -> {{ "d", 1., false, false, false }}) * (($lerr, "@call") -> "Error_call") * (($lerr, "@construct") -> "Error_construct") * (($lerr, "prototype") -> {{ "d", $lerr_proto, false, false, false }}) * empty_fields($lerr : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope", "length", "prototype" }-) * (($lfun_proto, "@class") -> "Function") * (($lfun_proto, "@proto") -> $lobj_proto) * (($lfun_proto, "@extensible") -> true) * (($lfun_proto, "@scope") -> empty) * (($lfun_proto, "length") -> {{ "d", 0., false, false, false }}) * (($lfun_proto, "@call") -> "FP_default") * empty_fields($lfun_proto : -{ "@call", "@class", "@extensible", "@proto", "@scope", "length" }-) ]]
normal

proc setupInitialHeap () {
			xret := "create_default_object"($lg, $lobj_proto, "Object", true);
			xret := "create_default_object"($lobj_proto, null, "Object", true);
			[$lobj_proto, "hasOwnProperty"] := {{ "d", $lop_hasOwnProperty, true, false, true }};
			xret := "create_object_with_call_construct"($lop_hasOwnProperty, "OP_hasOwnProperty", empty, 1.);
			xret := "create_object_with_call_construct"($lfun_proto, "FP_default", empty, 0.);
			[$lfun_proto, "@proto"] := $lobj_proto;
			xret := "create_object_with_call_construct"($lerr, "Error_call", "Error_construct", 1.);
			[$lg, "Error"] := {{ "d", $lerr, true, false, true }};
			[$lerr, "prototype"] := {{ "d", $lerr_proto, false, false, false }};
			xret := "create_default_object"($lerr_proto, $lobj_proto, "Error", true);
			[$lerr_proto, "message"] := {{ "d", "", true, false, true }};
	rlab:		xret := empty
} with {
	ret: xret, rlab;
};


spec copy_object(l, fields)
[[ types(#f : Str, l : Obj, #fields : List) * (#fields == {{ #f }}) * (! (#f == "")) * (! (s-nth(#f, 0.) == "@")) * (fields == {{ #f }}) * (l == _$l_#l) * ((_$l_#l, #f) -> #v) ]]
[[ types(#f : Str, #fields : List, xret : Obj) * (xret == _$l_xret) * (fields == _lvar_fields) * (l == _lvar_l) * ((_$l_#l, #f) -> #v) * ((_$l_xret, #f) -> #v) * ((_$l_xret, "@proto") -> null) * empty_fields(_$l_xret : -{ "@proto", #f }-) ]]
normal;

 [[ types(#f1 : Str, l : Obj, #fields : List) * (#fields == {{ #f1, "main" }}) * (! (#f1 == "")) * (! (s-nth(#f1, 0.) == "@")) * (! (#f1 == "main")) * (fields == {{ #f1, "main" }}) * (l == _$l_#l) * ((_$l_#l, #f1) -> #v1) * ((_$l_#l, "main") -> #v2) ]]
[[ types(#f1 : Str, #fields : List, xret : Obj) * (! (#f1 == "main")) * (xret == _$l_xret) * (fields == _lvar_fields) * (l == _lvar_l) * ((_$l_#l, #f1) -> #v1) * ((_$l_#l, "main") -> #v2) * ((_$l_xret, #f1) -> #v1) * ((_$l_xret, "main") -> #v2) * ((_$l_xret, "@proto") -> null) * empty_fields(_$l_xret : -{ "@proto", "main", #f1 }-) ]]
normal

proc copy_object (l, fields) {
			xret := new();
	rlab:		xret := "copy_object_rec"(l, fields, xret)
} with {
	ret: xret, rlab;
};


spec i__typeOf(v)
[[ types(#v : Undefined) * (#v == undefined) * (v == undefined) ]]
[[ types(#v : Undefined, xret : Str) * (#v == undefined) * (xret == "undefined") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Null) * (#v == null) * (v == null) ]]
[[ types(#v : Null, xret : Str) * (#v == null) * (xret == "object") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Bool) * (v == #v) ]]
[[ types(#v : Bool, xret : Str) * (xret == "boolean") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num, xret : Str) * (xret == "number") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str, xret : Str) * (xret == "string") * (v == _lvar_v) ]]
normal

proc i__typeOf (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := "undefined";
			goto rlab;
	in:		goto [(v = null)] nul ib;
	nul:		xret := "object";
			goto rlab;
	ib:		goto [(typeOf(v) = Bool)] bool inum;
	bool:		xret := "boolean";
			goto rlab;
	inum:		goto [(typeOf(v) = Num)] num is;
	num:		xret := "number";
			goto rlab;
	is:		goto [(typeOf(v) = Str)] str io;
	str:		xret := "string";
			goto rlab;
	io:		goto [(typeOf(v) = Obj)] obj oops;
	obj:		xret := hasField(v,"@call");
			goto [xret] isfun isobj;
	isobj:		xret := "object";
			goto rlab;
	isfun:		xret := "function";
			goto rlab;
	oops:		xret := "typeOf: This should not happen.";
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec create_function_object(xsc, call, construct, params)
[[ types(#construct : Str, #params : List, #xsc : List, #call : Str) * (xsc == #xsc) * (construct == #construct) * (params == #params) * (call == #call) ]]
[[ types(#construct : Str, #params : List, xret : Obj, #xsc : List, #call : Str) * (xret == _$l_xret) * (xsc == _lvar_xsc) * (construct == _lvar_construct) * (params == _lvar_params) * (call == _lvar_call) * ((_$l_#prototype, "@proto") -> $lobj_proto) * ((_$l_#prototype, "@class") -> "Object") * ((_$l_#prototype, "@extensible") -> true) * ((_$l_#prototype, "constructor") -> {{ "d", _$l_xret, true, false, true }}) * empty_fields(_$l_#prototype : -{ "@class", "@extensible", "@proto", "constructor" }-) * ((_$l_xret, "@proto") -> $lfun_proto) * ((_$l_xret, "@class") -> "Function") * ((_$l_xret, "@extensible") -> true) * ((_$l_xret, "@scope") -> #xsc) * ((_$l_xret, "length") -> {{ "d", (l-len #params), false, false, false }}) * ((_$l_xret, "@call") -> #call) * ((_$l_xret, "@construct") -> #construct) * ((_$l_xret, "caller") -> {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }}) * ((_$l_xret, "arguments") -> {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }}) * ((_$l_xret, "prototype") -> {{ "d", _$l_#prototype, true, false, false }}) * empty_fields(_$l_xret : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope", "arguments", "caller", "length", "prototype" }-) ]]
normal

proc create_function_object (xsc, call, construct, params) {
			len := (l-len params);
			l := new();
			l := "create_object_with_call_construct"(l, call, construct, len);
			[l, "@scope"] := xsc;
			prototype := new();
			prototype := "create_default_object"(prototype, $lobj_proto, "Object", true);
			[prototype, "constructor"] := {{ "d", l, true, false, true }};
			[l, "prototype"] := {{ "d", prototype, true, false, false }};
			[l, "caller"] := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};
			[l, "arguments"] := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};
			xret := l;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__abstractComparison(v1, v2, leftFirst)
[[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (#v1 <# #v2) * (leftFirst == #leftFirst) * (v2 == #v2) * (v1 == #v1) ]]
[[ types(#leftFirst : Bool, #v2 : Num, xret : Bool, #v1 : Num) * (#v1 <# #v2) * (xret == true) * (leftFirst == _lvar_leftFirst) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (#v1 == #v2) * (leftFirst == #leftFirst) * (v2 == #v2) * (v1 == #v2) ]]
[[ types(#leftFirst : Bool, #v2 : Num, xret : Bool, #v1 : Num) * (#v1 == #v2) * (xret == false) * (leftFirst == _lvar_leftFirst) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (#v2 <# #v1) * (leftFirst == #leftFirst) * (v2 == #v2) * (v1 == #v1) ]]
[[ types(#leftFirst : Bool, #v2 : Num, xret : Bool, #v1 : Num) * (#v2 <# #v1) * (xret == false) * (leftFirst == _lvar_leftFirst) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal

proc i__abstractComparison (v1, v2, leftFirst) {
			goto [((leftFirst = empty) or (leftFirst = true))] eleft eright;
	eleft:		xret := "i__toPrimitive"(v1, "Number") with elab;
			px := xret;
			xret := "i__toPrimitive"(v2, "Number") with elab;
			py := xret;
			goto is_str;
	eright:		xret := "i__toPrimitive"(v2, "Number") with elab;
			py := xret;
			xret := "i__toPrimitive"(v1, "Number") with elab;
			px := xret;
	is_str:		goto [((typeOf(px) = Str) and (typeOf(py) = Str))] str num;
	str:		xret := (px <s py);
			goto rlab;
	num:		xret := "i__toNumber"(px) with elab;
			nx := xret;
			xret := "i__toNumber"(py) with elab;
			ny := xret;
			goto [((not (nx = nx)) or (not (ny = ny)))] ru eq;
	eq:		goto [(nx = ny)] rf sl;
	sl:		xret := (nx < ny);
			goto rlab;
	ru:		xret := undefined;
			goto rlab;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__toNumber(v)
[[ types(v : Bool) * (v == true) ]]
[[ types(xret : Num) * (xret == 1.) * (v == _lvar_v) ]]
normal;

 [[ types(v : Bool) * (v == false) ]]
[[ types(xret : Num) * (xret == 0.) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str, xret : Num) * (xret == (string_to_num #v)) * (v == _lvar_v) ]]
normal

proc i__toNumber (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := nan;
			goto rlab;
	in:		goto [(v = null)] nul ib;
	nul:		xret := 0.;
			goto rlab;
	ib:		goto [(typeOf(v) = Bool)] bool inum;
	bool:		goto [(v = true)] is_t is_f;
	is_t:		xret := 1.;
			goto rlab;
	is_f:		xret := 0.;
			goto rlab;
	inum:		goto [(typeOf(v) = Num)] num is;
	num:		xret := v;
			goto rlab;
	is:		goto [(typeOf(v) = Str)] str io;
	str:		xret := (string_to_num v);
			goto rlab;
	io:		goto [(typeOf(v) = Obj)] obj oops;
	obj:		xret := "i__toPrimitive"(v, "Number") with elab;
			xret := "i__toNumber"(xret);
			goto rlab;
	oops:		xret := "TypeError"("ToNumber: This should not happen.");
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec ReferenceError(v)
[[ types(v : Undefined) * (v == undefined) ]]
[[ types(xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * ((_$l_xret, "@proto") -> $lrferr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
normal

proc ReferenceError (v) {
			xret := "ReferenceError_call"(undefined, undefined, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec create_default_object(l, pr, cl, ext)
[[ types(l : Obj, #cl : Undefined, #ext : Undefined) * (#cl == undefined) * (#ext == undefined) * (pr == #pr) * (ext == undefined) * (l == _$l_#l) * (cl == undefined) * ((_$l_#l, "@proto") -> #v1) * ((_$l_#l, "@class") -> #v2) * ((_$l_#l, "@extensible") -> #v3) ]]
[[ types(#cl : Undefined, #ext : Undefined, xret : Obj) * (#cl == undefined) * (#ext == undefined) * (xret == _$l_#l) * (pr == _lvar_pr) * (ext == _lvar_ext) * (l == _lvar_l) * (cl == _lvar_cl) * ((_$l_#l, "@proto") -> #pr) * ((_$l_#l, "@class") -> "Object") * ((_$l_#l, "@extensible") -> true) ]]
normal;

 [[ types(l : Obj, #cl : Str, #ext : Bool) * (pr == #pr) * (ext == #ext) * (l == _$l_#l) * (cl == #cl) * ((_$l_#l, "@proto") -> #v1) * ((_$l_#l, "@class") -> #v2) * ((_$l_#l, "@extensible") -> #v3) ]]
[[ types(#cl : Str, #ext : Bool, xret : Obj) * (xret == _$l_#l) * (pr == _lvar_pr) * (ext == _lvar_ext) * (l == _lvar_l) * (cl == _lvar_cl) * ((_$l_#l, "@proto") -> #pr) * ((_$l_#l, "@class") -> #cl) * ((_$l_#l, "@extensible") -> #ext) ]]
normal

proc create_default_object (l, pr, cl, ext) {
			goto [(cl = undefined)] scl text;
	scl:		cl := "Object";
	text:		goto [(ext = undefined)] sext setall;
	sext:		ext := true;
	setall:		[l, "@proto"] := pr;
			[l, "@class"] := cl;
			[l, "@extensible"] := ext;
	rlab:		xret := l
} with {
	ret: xret, rlab;
};


spec o__defineOwnProperty(l, prop, desc, throw)
[[ types(#desc : List, l : Obj, #cls : Str, throw : Bool, #prop : Str) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (throw == true) * (desc == #desc) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> none) * ((_$l_#l, "@extensible") -> false) ]]
[[ types(#desc : List, #cls : Str, xerr : Obj, #prop : Str) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (throw == _lvar_throw) * (desc == _lvar_desc) * (xerr == _$l_xerr) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_xerr, "@proto") -> $lterr_proto) * ((_$l_xerr, "@class") -> "Error") * ((_$l_xerr, "@extensible") -> true) * empty_fields(_$l_xerr : -{ "@class", "@extensible", "@proto" }-) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> none) * ((_$l_#l, "@extensible") -> false) ]]
error;

 [[ types(#desc : List, l : Obj, #cls : Str, throw : Bool, #prop : Str) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (throw == false) * (desc == #desc) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> none) * ((_$l_#l, "@extensible") -> false) ]]
[[ types(#desc : List, #cls : Str, xret : Bool, #prop : Str) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> none) * ((_$l_#l, "@extensible") -> false) ]]
normal;

 [[ types(#desc : List, _lvar_128 : Bool, _lvar_127 : Bool, l : Obj, #cls : Str, #throw : Bool, _lvar_126 : Bool, #prop : Str) * (#desc == {{ "d", _lvar_125, _lvar_126, _lvar_127, _lvar_128 }}) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_125 == empty)) * (throw == #throw) * (desc == {{ "d", _lvar_125, _lvar_126, _lvar_127, _lvar_128 }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> none) * ((_$l_#l, "@extensible") -> true) ]]
[[ types(#desc : List, #cls : Str, #throw : Bool, xret : Bool, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (xret == true) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> #desc) * ((_$l_#l, "@extensible") -> true) ]]
normal;

 [[ types(_lvar_135 : Bool, #dcur : List, #desc : List, _lvar_140 : Bool, l : Obj, _lvar_138 : Bool, #cls : Str, #throw : Bool, #ext : Bool, _lvar_134 : Bool, _lvar_139 : Bool, #prop : Str) * (#dcur == {{ "d", _lvar_133, _lvar_134, _lvar_135, true }}) * (#desc == {{ "d", _lvar_137, _lvar_138, _lvar_139, _lvar_140 }}) * (! (_lvar_137 == empty)) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_133 == empty)) * (throw == #throw) * (desc == {{ "d", _lvar_137, _lvar_138, _lvar_139, _lvar_140 }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> {{ "d", _lvar_133, _lvar_134, _lvar_135, true }}) * ((_$l_#l, "@extensible") -> #ext) ]]
[[ types(#dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, xret : Bool, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (xret == true) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> #desc) * ((_$l_#l, "@extensible") -> #ext) ]]
normal;

 [[ types(#dcur : List, #desc : List, _lvar_146 : Bool, l : Obj, #cls : Str, #throw : Bool, _lvar_143 : Bool, #ext : Bool, _lvar_147 : Bool, throw : Bool, #prop : Str, _lvar_142 : Bool) * (#dcur == {{ "d", _lvar_141, _lvar_142, _lvar_143, false }}) * (#desc == {{ "d", _lvar_145, _lvar_146, _lvar_147, true }}) * (! (_lvar_145 == empty)) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_141 == empty)) * (throw == true) * (desc == {{ "d", _lvar_145, _lvar_146, _lvar_147, true }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_141, _lvar_142, _lvar_143, false }}) ]]
[[ types(#dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, xerr : Obj, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (desc == _lvar_desc) * (xerr == _$l_xerr) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_xerr, "@proto") -> $lterr_proto) * ((_$l_xerr, "@class") -> "Error") * ((_$l_xerr, "@extensible") -> true) * empty_fields(_$l_xerr : -{ "@class", "@extensible", "@proto" }-) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #dcur) ]]
error;

 [[ types(#dcur : List, #desc : List, _lvar_150 : Bool, l : Obj, _lvar_155 : Bool, #cls : Str, #throw : Bool, _lvar_151 : Bool, #ext : Bool, throw : Bool, #prop : Str, _lvar_154 : Bool) * (#dcur == {{ "d", _lvar_149, _lvar_150, _lvar_151, false }}) * (#desc == {{ "d", _lvar_153, _lvar_154, _lvar_155, true }}) * (! (_lvar_153 == empty)) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_149 == empty)) * (throw == false) * (desc == {{ "d", _lvar_153, _lvar_154, _lvar_155, true }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_149, _lvar_150, _lvar_151, false }}) ]]
[[ types(#dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, xret : Bool, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #dcur) ]]
normal;

 [[ types(#ec : Bool, _lvar_162 : Bool, #dcur : List, #ed : Bool, #desc : List, l : Obj, _lvar_158 : Bool, #cls : Str, #throw : Bool, #ext : Bool, throw : Bool, #prop : Str) * (#dcur == {{ "d", _lvar_157, _lvar_158, #ec, false }}) * (#desc == {{ "d", _lvar_161, _lvar_162, #ed, false }}) * (! (_lvar_161 == empty)) * (! (#ed == #ec)) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_157 == empty)) * (throw == true) * (desc == {{ "d", _lvar_161, _lvar_162, #ed, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_157, _lvar_158, #ec, false }}) ]]
[[ types(#ec : Bool, #ed : Bool, #dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, xerr : Obj, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (desc == _lvar_desc) * (xerr == _$l_xerr) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_xerr, "@proto") -> $lterr_proto) * ((_$l_xerr, "@class") -> "Error") * ((_$l_xerr, "@extensible") -> true) * empty_fields(_$l_xerr : -{ "@class", "@extensible", "@proto" }-) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #dcur) ]]
error;

 [[ types(#ec : Bool, #dcur : List, #ed : Bool, #desc : List, _lvar_166 : Bool, l : Obj, _lvar_170 : Bool, #cls : Str, #throw : Bool, #ext : Bool, throw : Bool, #prop : Str) * (#dcur == {{ "d", _lvar_165, _lvar_166, #ec, false }}) * (#desc == {{ "d", _lvar_169, _lvar_170, #ed, false }}) * (! (_lvar_169 == empty)) * (! (#ed == #ec)) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_165 == empty)) * (throw == false) * (desc == {{ "d", _lvar_169, _lvar_170, #ed, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_165, _lvar_166, #ec, false }}) ]]
[[ types(#ec : Bool, #ed : Bool, #dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, xret : Bool, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #dcur) ]]
normal;

 [[ types(#dcur : List, #desc : List, l : Obj, #cls : Str, #throw : Bool, #ext : Bool, #enum : Bool, throw : Bool, #prop : Str) * (#dcur == {{ "d", _lvar_173, false, #enum, false }}) * (#desc == {{ "d", _lvar_177, true, #enum, false }}) * (! (_lvar_177 == empty)) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_173 == empty)) * (throw == true) * (desc == {{ "d", _lvar_177, true, #enum, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_173, false, #enum, false }}) ]]
[[ types(#dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, xerr : Obj, #enum : Bool, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (desc == _lvar_desc) * (xerr == _$l_xerr) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_xerr, "@proto") -> $lterr_proto) * ((_$l_xerr, "@class") -> "Error") * ((_$l_xerr, "@extensible") -> true) * empty_fields(_$l_xerr : -{ "@class", "@extensible", "@proto" }-) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #dcur) ]]
error;

 [[ types(#dcur : List, #desc : List, l : Obj, #cls : Str, #throw : Bool, #ext : Bool, #enum : Bool, throw : Bool, #prop : Str) * (#dcur == {{ "d", _lvar_181, false, #enum, false }}) * (#desc == {{ "d", _lvar_185, true, #enum, false }}) * (! (_lvar_185 == empty)) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_181 == empty)) * (throw == false) * (desc == {{ "d", _lvar_185, true, #enum, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_181, false, #enum, false }}) ]]
[[ types(#dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, #enum : Bool, xret : Bool, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #dcur) ]]
normal;

 [[ types(#dcur : List, #desc : List, l : Obj, #cls : Str, #throw : Bool, _lvar_194 : Bool, #ext : Bool, #enum : Bool, #prop : Str) * (#dcur == {{ "d", _lvar_189, true, #enum, false }}) * (#desc == {{ "d", _lvar_193, _lvar_194, #enum, false }}) * (! (_lvar_193 == empty)) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_189 == empty)) * (throw == #throw) * (desc == {{ "d", _lvar_193, _lvar_194, #enum, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_189, true, #enum, false }}) ]]
[[ types(#dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, #enum : Bool, xret : Bool, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (xret == true) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #desc) ]]
normal;

 [[ types(#dcur : List, #desc : List, l : Obj, #cls : Str, #throw : Bool, #ext : Bool, #dec : Bool, #dcc : Bool, #prop : Str) * (#dcur == {{ "d", _lvar_197, true, #dec, #dcc }}) * (#desc == {{ "g", empty, empty, #gval, empty, empty, empty }}) * (! (#gval == empty)) * (! (#cls == "String")) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_197 == empty)) * (throw == #throw) * (desc == {{ "g", empty, empty, #gval, empty, empty, empty }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_197, true, #dec, #dcc }}) ]]
[[ types(#dcur : List, #desc : List, #cls : Str, #throw : Bool, #ext : Bool, #dec : Bool, xret : Bool, #dcc : Bool, #prop : Str) * (throw == _lvar_throw) * (xret == true) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@class") -> #cls) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", #gval, true, #dec, #dcc }}) ]]
normal

proc o__defineOwnProperty (l, prop, desc, throw) {
			xret := true;
			current := "getOwnProperty"(l, prop) with celab;
			extensible := [l, "@extensible"];
			goto [(current = undefined)] cuf getall;
	cuf:		goto [(extensible = false)] reject l4;
	l4:		gd := "i__isGenericDescriptor"(desc);
			dd := "i__isDataDescriptor"(desc);
			goto [(gd or dd)] l4a1 l4b;
	l4a1:		ndesc := "i__toDataDescriptor"(desc);
			[l, prop] := ndesc;
			goto acc_t;
	l4b:		ndesc := "i__toAccessorDescriptor"(desc);
			[l, prop] := ndesc;
			goto acc_t;
	getall:		goto [(l-nth(desc, 0.) = "d")] ddd odd;
	ddd:		de := l-nth(desc, 3.);
			dc := l-nth(desc, 4.);
			dv := l-nth(desc, 1.);
			dw := l-nth(desc, 2.);
			dg := empty;
			ds := empty;
			goto l5;
	odd:		goto [(l-nth(desc, 0.) = "a")] add gdd;
	add:		de := l-nth(desc, 3.);
			dc := l-nth(desc, 4.);
			dv := empty;
			dw := empty;
			dg := l-nth(desc, 1.);
			ds := l-nth(desc, 2.);
			goto l5;
	gdd:		de := l-nth(desc, 1.);
			dc := l-nth(desc, 2.);
			dv := l-nth(desc, 3.);
			dw := l-nth(desc, 4.);
			dg := l-nth(desc, 5.);
			ds := l-nth(desc, 6.);
	l5:		goto [((((((de = empty) and (dc = empty)) and (dv = empty)) and (dw = empty)) and (dg = empty)) and (ds = empty))] acc_t l6;
	l6:		goto [(l-nth(current, 0.) = "d")] chd cha;
	chd:		goto [((dg = empty) and (ds = empty))] chd1 l7;
	chd1:		t1 := "i__sameValue"(dc, l-nth(current, 4.));
			goto [t1] chd2 l7;
	chd2:		t2 := "i__sameValue"(de, l-nth(current, 3.));
			goto [t2] chd3 l7;
	chd3:		t3 := "i__sameValue"(dw, l-nth(current, 2.));
			goto [t3] chd4 l7;
	chd4:		t4 := "i__sameValue"(dv, l-nth(current, 1.));
			goto [t4] acc_t l7;
	cha:		goto [((dv = empty) and (dw = empty))] cha1 l7;
	cha1:		t1 := "i__sameValue"(dc, l-nth(current, 4.));
			goto [t1] cha2 l7;
	cha2:		t2 := "i__sameValue"(de, l-nth(current, 3.));
			goto [t2] cha3 l7;
	cha3:		t3 := "i__sameValue"(ds, l-nth(current, 2.));
			goto [t3] cha4 l7;
	cha4:		t4 := "i__sameValue"(dg, l-nth(current, 1.));
			goto [t4] acc_t l7;
	l7:		cc := l-nth(current, 4.);
			ce := l-nth(current, 3.);
			goto [(cc = false)] l71 l8;
	l71:		goto [(dc = true)] reject l72;
	l72:		goto [(de = empty)] l8 l73;
	l73:		goto [(not (ce = de))] reject l8;
	l8:		ct := l-nth(current, 0.);
			cvg := l-nth(current, 1.);
			cws := l-nth(current, 2.);
			gd := "i__isGenericDescriptor"(desc);
			goto [gd] l12 l9;
	l9:		cdd := "i__isDataDescriptor"(current);
			ddd := "i__isDataDescriptor"(desc);
			goto [(not (cdd = ddd))] l9a l10;
	l9a:		goto [(cc = false)] reject change;
	change:		goto [(cdd = true)] toa tod;
	toa:		goto [(dg = empty)] sg gs;
	sg:		dg := undefined;
	gs:		goto [(ds = empty)] ss ge1;
	ss:		ds := undefined;
	ge1:		goto [(de = empty)] se1 gc1;
	se1:		de := ce;
	gc1:		goto [(dc = empty)] sc1 spa;
	sc1:		dc := cc;
	spa:		[l, prop] := {{ "a", dg, ds, de, dc }};
			goto acc_t;
	tod:		goto [(dv = empty)] sv gw;
	sv:		dv := undefined;
	gw:		goto [(dw = empty)] sw ge2;
	sw:		dw := false;
	ge2:		goto [(de = empty)] se2 gc2;
	se2:		de := ce;
	gc2:		goto [(dc = empty)] sc2 spd;
	sc2:		dc := cc;
	spd:		[l, prop] := {{ "d", dv, dw, de, dc }};
			goto acc_t;
	l10:		goto [(cdd = true)] l10a l11;
	l10a:		goto [(cc = false)] l10ai l12;
	l10ai:		goto [((cws = false) and (dw = true))] reject l10aii;
	l10aii:		goto [((cws = false) and (not (dv = empty)))] sv l12;
	sv:		t1 := "i__sameValue"(cvg, dv);
			goto [(not t1)] reject l12;
	l11:		t1 := "i__sameValue"(dg, l-nth(current, 1.));
			t2 := "i__sameValue"(ds, l-nth(current, 2.));
			goto [((cc = false) and (((not (dg = empty)) and (not t1)) or ((not (ds = empty)) and (not t2))))] reject l12;
	l12:		re := de;
			rc := dc;
			goto [(de = empty)] rec red;
	rec:		re := l-nth(current, 3.);
	red:		goto [(dc = empty)] rcd rd;
	rcd:		rc := l-nth(current, 4.);
	rd:		goto [(ct = "d")] l12d l12a;
	l12d:		rv := dv;
			rw := dw;
			goto [(dv = empty)] rvc rvd;
	rvc:		rv := l-nth(current, 1.);
	rvd:		goto [(dw = empty)] rwd setd;
	rwd:		rw := l-nth(current, 2.);
	setd:		[l, prop] := {{ "d", rv, rw, re, rc }};
			goto acc_t;
	l12a:		rg := dg;
			rs := ds;
			goto [(dg = empty)] rgc rgd;
	rgc:		rg := l-nth(current, 1.);
	rgd:		goto [(ds = empty)] rsd seta;
	rsd:		rs := l-nth(current, 2.);
	seta:		[l, prop] := {{ "a", rg, rs, re, rc }};
			goto acc_t;
	acc_t:		xret := true;
			goto rlab;
	acc_f:		xret := false;
	rlab:		skip;
	celab:		xerr := current;
			goto elab;
	reject:		goto [throw] tt acc_f;
	tt:		xerr := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xerr, elab;
};


spec i__toPrimitive(v, hint)
[[ types(v : Undefined) * (v == undefined) * (hint == _lvar_hint) ]]
[[ types(xret : Undefined) * (xret == undefined) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types(v : Null) * (v == null) * (hint == _lvar_hint) ]]
[[ types(xret : Null) * (xret == null) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types(#v : Num) * (v == #v) * (hint == _lvar_hint) ]]
[[ types(#v : Num) * (xret == #v) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types(#v : Bool) * (v == #v) * (hint == _lvar_hint) ]]
[[ types(#v : Bool) * (xret == #v) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types(#v : Str) * (v == #v) * (hint == _lvar_hint) ]]
[[ types(#v : Str) * (xret == #v) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal

proc i__toPrimitive (v, hint) {
			xret := v;
			tv := typeOf(v);
	iu:		goto [(((((v = undefined) or (v = null)) or (typeOf(v) = Bool)) or (typeOf(v) = Num)) or (typeOf(v) = Str))] rlab is_obj;
	is_obj:		print := "object";
			goto [(typeOf(v) = Obj)] obj oops;
	obj:		xret := "defaultValue"(v, hint) with elab;
			goto rlab;
	oops:		xret := "ToPrimitive: This should not happen.";
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__isAccessorDescriptor(desc)
[[ types(desc : Undefined) * (desc == undefined) ]]
[[ types(xret : Bool) * (xret == false) * (desc == _lvar_desc) ]]
normal;

 [[ types(_lvar_64 : Bool, _lvar_65 : Bool, desc : List, _lvar_66 : Bool) * (! (_lvar_63 == empty)) * (desc == {{ "d", _lvar_63, _lvar_64, _lvar_65, _lvar_66 }}) ]]
[[ types(xret : Bool) * (xret == false) * (desc == _lvar_desc) ]]
normal;

 [[ types(_lvar_72 : Empty, _lvar_73 : Empty, desc : List) * (desc == {{ "g", _lvar_68, _lvar_69, _lvar_70, _lvar_71, empty, empty }}) ]]
[[ types(xret : Bool) * (xret == false) * (desc == _lvar_desc) ]]
normal;

 [[ types(desc : List) * (! (_lvar_79 == empty)) * (desc == {{ "g", _lvar_75, _lvar_76, _lvar_77, _lvar_78, _lvar_79, _lvar_80 }}) ]]
[[ types(xret : Bool) * (xret == true) * (desc == _lvar_desc) ]]
normal;

 [[ types(desc : List) * (! (_lvar_87 == empty)) * (desc == {{ "g", _lvar_82, _lvar_83, _lvar_84, _lvar_85, _lvar_86, _lvar_87 }}) ]]
[[ types(xret : Bool) * (xret == true) * (desc == _lvar_desc) ]]
normal

proc i__isAccessorDescriptor (desc) {
			goto [(desc = undefined)] rf cont;
	cont:		d := l-nth(desc, 0.);
			goto [(d = "a")] rt gen;
	gen:		goto [(d = "g")] test rf;
	test:		g := l-nth(desc, 5.);
			s := l-nth(desc, 6.);
			goto [((g = empty) and (s = empty))] rf rt;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec o__getOwnProperty(l, prop)
[[ types(l : Obj, #prop : Str) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) -> none) ]]
[[ types(xret : Undefined, #prop : Str) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (xret == undefined) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) -> none) ]]
normal;

 [[ types(_lvar_50 : Bool, _lvar_48 : Bool, l : Obj, _lvar_49 : Bool, #prop : Str, #dx : List) * (#dx == {{ "d", _lvar_47, _lvar_48, _lvar_49, _lvar_50 }}) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_47 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) -> {{ "d", _lvar_47, _lvar_48, _lvar_49, _lvar_50 }}) ]]
[[ types(_lvar_53 : Bool, _lvar_54 : Bool, _lvar_52 : Bool, #prop : Str, #dx : List) * (#dx == {{ "d", _lvar_51, _lvar_52, _lvar_53, _lvar_54 }}) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_51 == empty)) * (xret == {{ "d", _lvar_51, _lvar_52, _lvar_53, _lvar_54 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) -> {{ "d", _lvar_51, _lvar_52, _lvar_53, _lvar_54 }}) ]]
normal

proc o__getOwnProperty (l, prop) {
			x := hasField(l,prop);
			goto [x] hp nhp;
	nhp:		xret := undefined;
			goto rlab;
	hp:		xret := [l, prop];
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__toInteger(v)
[[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str, xret : Num) * (xret == (num_to_int (string_to_num #v))) * (v == _lvar_v) ]]
normal

proc i__toInteger (v) {
			xret := "i__toNumber"(v) with elab;
			xret := (num_to_int xret);
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec deleteProperty(l, prop, throw)
[[ types(l : Obj, #cls : Str, #prop : Str) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (#cls == "String")) * (throw == _lvar_throw) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) -> none) * ((_$l_#l, "@class") -> #cls) ]]
[[ types(#cls : Str, xret : Bool, #prop : Str) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (throw == _lvar_throw) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) -> none) * ((_$l_#l, "@class") -> #cls) ]]
normal;

 [[ types(_lvar_509 : Bool, #desc : List, _lvar_510 : Bool, l : Obj, #cls : Str, #prop : Str) * (#desc == {{ "d", _lvar_508, _lvar_509, _lvar_510, true }}) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_508 == empty)) * (! (#cls == "String")) * (throw == _lvar_throw) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) -> {{ "d", _lvar_508, _lvar_509, _lvar_510, true }}) * ((_$l_#l, "@class") -> #cls) ]]
[[ types(#desc : List, #cls : Str, xret : Bool, #prop : Str) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (throw == _lvar_throw) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) -> none) * ((_$l_#l, "@class") -> #cls) ]]
normal;

 [[ types(_lvar_522 : Bool, #desc : List, l : Obj, #cls : Str, _lvar_521 : Bool, throw : Bool, #prop : Str) * (#desc == {{ "d", _lvar_520, _lvar_521, _lvar_522, false }}) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_520 == empty)) * (! (#cls == "String")) * (throw == true) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) -> {{ "d", _lvar_520, _lvar_521, _lvar_522, false }}) * ((_$l_#l, "@class") -> #cls) ]]
[[ types(_lvar_525 : Bool, _lvar_527 : Bool, #desc : List, #cls : Str, xret : Obj, _lvar_526 : Bool, #prop : Str) * (#desc == {{ "d", _lvar_524, _lvar_525, _lvar_526, _lvar_527 }}) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_524 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) -> {{ "d", _lvar_524, _lvar_525, _lvar_526, _lvar_527 }}) * ((_$l_#l, "@class") -> #cls) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error

proc deleteProperty (l, prop, throw) {
			xret := "getOwnProperty"(l, prop) with elab;
			goto [(xret = undefined)] dt cont;
	cont:		c := l-nth(xret, 4.);
			goto [c] del reject;
	del:		delete(l,prop);
	dt:		xret := true;
			goto rlab;
	df:		xret := false;
	rlab:		skip;
	reject:		goto [throw] tt df;
	tt:		xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec getOwnProperty(l, prop)
[[ types(l : Obj, #cls : Str, #prop : Str) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (#cls == "String")) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) -> none) * ((_$l_#l, "@class") -> #cls) ]]
[[ types(#cls : Str, xret : Undefined, #prop : Str) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (#cls == "String")) * (xret == undefined) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) -> none) * ((_$l_#l, "@class") -> #cls) ]]
normal;

 [[ types(_lvar_485 : Bool, _lvar_487 : Bool, l : Obj, #cls : Str, #prop : Str, #dx : List, _lvar_486 : Bool) * (#dx == {{ "d", _lvar_484, _lvar_485, _lvar_486, _lvar_487 }}) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_484 == empty)) * (! (#cls == "String")) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) -> {{ "d", _lvar_484, _lvar_485, _lvar_486, _lvar_487 }}) * ((_$l_#l, "@class") -> #cls) ]]
[[ types(_lvar_491 : Bool, _lvar_489 : Bool, _lvar_490 : Bool, #cls : Str, #prop : Str, #dx : List) * (#dx == {{ "d", _lvar_488, _lvar_489, _lvar_490, _lvar_491 }}) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_488 == empty)) * (! (#cls == "String")) * (xret == {{ "d", _lvar_488, _lvar_489, _lvar_490, _lvar_491 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) -> {{ "d", _lvar_488, _lvar_489, _lvar_490, _lvar_491 }}) * ((_$l_#l, "@class") -> #cls) ]]
normal

proc getOwnProperty (l, prop) {
			class := [l, "@class"];
			goto [(class = "String")] sgop ogop;
	sgop:		xret := "s__getOwnProperty"(l, prop) with elab;
			goto rlab;
	ogop:		xret := "o__getOwnProperty"(l, prop) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__toString(v)
[[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num, xret : Str) * (xret == (num_to_string #v)) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str, xret : Str) * (xret == #v) * (v == _lvar_v) ]]
normal

proc i__toString (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := "undefined";
			goto rlab;
	in:		goto [(v = null)] nul ib;
	nul:		xret := "null";
			goto rlab;
	ib:		goto [(typeOf(v) = Bool)] bool inum;
	bool:		goto [(v = true)] is_t is_f;
	is_t:		xret := "true";
			goto rlab;
	is_f:		xret := "false";
			goto rlab;
	inum:		goto [(typeOf(v) = Num)] num is;
	num:		xret := (num_to_string v);
			goto rlab;
	is:		goto [(typeOf(v) = Str)] str io;
	str:		xret := v;
			goto rlab;
	io:		goto [(typeOf(v) = Obj)] obj oops;
	obj:		xret := "i__toPrimitive"(v, "String") with elab;
			xret := "i__toString"(xret) with elab;
			goto rlab;
	oops:		xret := "TypeError"("ToString: This should not happen.");
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__checkAssignmentErrors(v)
[[ types(v : Undefined) * (v == undefined) ]]
[[ types(xret : Bool) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(v : Null) * (v == null) ]]
[[ types(xret : Bool) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_370 : Num, v : Num) * (v == _lvar_370) ]]
[[ types(xret : Bool) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(v : Bool, _lvar_371 : Bool) * (v == _lvar_371) ]]
[[ types(xret : Bool) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(v : Str, _lvar_372 : Str) * (v == _lvar_372) ]]
[[ types(xret : Bool) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(v : Obj, _lvar_373 : Obj) * (v == _lvar_373) ]]
[[ types(xret : Bool) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(#v : List, #l : Obj, #prop : Str) * (#v == {{ "v", #l, #prop }}) * (! (#prop == "eval")) * (! (#prop == "arguments")) * (v == {{ "v", #l, #prop }}) ]]
[[ types(#v : List, #l : Obj, xret : Bool, #prop : Str) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(#v : List, #l : Obj) * (#v == {{ "v", #l, "eval" }}) * (v == {{ "v", #l, "eval" }}) ]]
[[ types(#v : List, #l : Obj, xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * ((_$l_xret, "@proto") -> $lserr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ types(#v : List, #l : Obj) * (#v == {{ "v", #l, "arguments" }}) * (v == {{ "v", #l, "arguments" }}) ]]
[[ types(#v : List, #l : Obj, xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * ((_$l_xret, "@proto") -> $lserr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ types(#field : Str, #v : List, #base : Obj) * (#v == {{ "o", #base, #field }}) * (v == {{ "o", #base, #field }}) ]]
[[ types(#field : Str, #v : List, #base : Obj, xret : Bool) * (xret == true) * (v == _lvar_v) ]]
normal

proc i__checkAssignmentErrors (v) {
			tv := typeOf(v);
			goto [(tv = List)] isref rlab;
	isref:		goto [((l-nth(v, 0.) = "v") or (l-nth(v, 0.) = "o"))] prep rlab;
	prep:		fv := l-nth(v, 2.);
	csyn:		goto [((l-nth(v, 0.) = "v") and ((fv = "eval") or (fv = "arguments")))] se rlab;
	rlab:		xret := true;
	se:		xret := "SyntaxError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec put(l, prop, value, throw)
[[ Pi(_$l_#l, #prop, #g_aux_0, undefined, #g_aux_2, #g_aux_3, #g_aux_4) * types(l : Obj, #throw : Bool, throw : Bool, #prop : Str) * (! (#value == empty)) * (throw == true) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@extensible") -> false) ]]
[[ Pi(_$l_#l, #prop, #g_aux_0, undefined, #g_aux_2, #g_aux_3, #g_aux_4) * types(#throw : Bool, xret : Obj, #prop : Str) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@extensible") -> false) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ Pi(_$l_#l, #prop, #g_aux_0, {{ "d", _lvar_292, false, _lvar_294, _lvar_295 }}, {{ _$l_#l }}, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, _lvar_295 : Bool, l : Obj, #throw : Bool, _lvar_294 : Bool, throw : Bool, #prop : Str) * (#g_aux_1 == {{ "d", _lvar_292, false, _lvar_294, _lvar_295 }}) * (! (#value == empty)) * (! (_lvar_292 == empty)) * (throw == true) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@extensible") -> #ignore) ]]
[[ Pi(_$l_#l, #prop, #g_aux_0, #g_aux_1, {{ _$l_#l }}, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #throw : Bool, xret : Obj, #prop : Str) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@extensible") -> #ignore) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ Pi(_$l_#l, #prop, #g_aux_0, {{ "d", _lvar_298, _lvar_299, _lvar_300, _lvar_301 }}, (_$l_#l :: (#lp :: #other)), #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, _lvar_300 : Bool, _lvar_301 : Bool, #lp : Obj, #g_aux_2 : List, l : Obj, #other : List, #throw : Bool, _lvar_299 : Bool, throw : Bool, #prop : Str) * (#g_aux_1 == {{ "d", _lvar_298, _lvar_299, _lvar_300, _lvar_301 }}) * (#g_aux_2 == (_$l_#l :: (#lp :: #other))) * (! (#value == empty)) * (! (_lvar_298 == empty)) * (throw == true) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@extensible") -> false) ]]
[[ Pi(_$l_#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #lp : Obj, #g_aux_2 : List, #other : List, #throw : Bool, xret : Obj, #prop : Str) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@extensible") -> false) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ Pi(_$l_#l, #prop, #g_aux_0, {{ "d", _lvar_302, false, _lvar_304, _lvar_305 }}, (_$l_#l :: (#lp :: #other)), #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #lp : Obj, #g_aux_2 : List, l : Obj, #other : List, _lvar_304 : Bool, #throw : Bool, _lvar_305 : Bool, throw : Bool, #prop : Str) * (#g_aux_1 == {{ "d", _lvar_302, false, _lvar_304, _lvar_305 }}) * (#g_aux_2 == (_$l_#l :: (#lp :: #other))) * (! (#value == empty)) * (! (_lvar_302 == empty)) * (throw == true) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@extensible") -> true) ]]
[[ Pi(_$l_#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #lp : Obj, #g_aux_2 : List, #other : List, #throw : Bool, xret : Obj, #prop : Str) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@extensible") -> true) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ #cls }}, undefined, {{ _$l_#l }}, {{ false }}, {{ "" }}) * types(l : Obj, #cls : Str, #throw : Bool, #prop : Str) * (! (#value == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@extensible") -> true) ]]
[[ Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #value, true, true, true }}, {{ _$l_#l }}, {{ false }}, {{ "" }}) * types(#cls : Str, #throw : Bool, xret : Empty, #prop : Str) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == empty) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@proto") -> null) * ((_$l_#l, "@extensible") -> true) ]]
normal;

 [[ Pi(_$l_#l, #prop, (#cls :: (#ccls :: #llcls)), undefined, (_$l_#l :: (#lp :: #lllp)), (false :: (#tf :: #lltf)), ("" :: (#pv :: #llpv))) * types(#lllp : List, #lp : Obj, #pv : Str, l : Obj, #cls : Str, #throw : Bool, #lltf : List, #ccls : Str, #llcls : List, #tf : Bool, #prop : Str, #llpv : List) * (! (#value == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@extensible") -> true) ]]
[[ Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #value, true, true, true }}, {{ _$l_#l }}, {{ false }}, {{ "" }}) * Pi(#lp, #prop, (#ccls :: #llcls), undefined, (#lp :: #lllp), (#tf :: #lltf), (#pv :: #llpv)) * types(#lllp : List, #lp : Obj, #pv : Str, #cls : Str, #throw : Bool, #lltf : List, #ccls : Str, xret : Empty, #llcls : List, #tf : Bool, #prop : Str, #llpv : List) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == empty) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@proto") -> #lp) * ((_$l_#l, "@extensible") -> true) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #dval, true, #denum, #dconf }}, {{ _$l_#l }}, #g_aux_3, #g_aux_4) * types(#denum : Bool, l : Obj, #cls : Str, #throw : Bool, #ext : Bool, #dconf : Bool, #prop : Str) * (! (#value == empty)) * (! (#dval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@extensible") -> #ext) ]]
[[ Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #value, true, #denum, #dconf }}, {{ _$l_#l }}, #g_aux_3, #g_aux_4) * types(#denum : Bool, #cls : Str, #throw : Bool, #ext : Bool, xret : Empty, #dconf : Bool, #prop : Str) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == empty) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@extensible") -> #ext) ]]
normal;

 [[ Pi(_$l_#l, #prop, (#cls :: (#pcls :: #ocls)), {{ "d", #dcval, true, #dcenum, #dcconf }}, (_$l_#l :: (#lp :: #lllp)), (false :: (#tf :: #lltf)), ("" :: (#pv :: #llpv))) * types(#ocls : List, #lllp : List, #dcenum : Bool, #lp : Obj, #pv : Str, l : Obj, #cls : Str, #throw : Bool, #lltf : List, #dcconf : Bool, #tf : Bool, #prop : Str, #pcls : Str, #llpv : List) * (! (#value == empty)) * (! (#dcval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, "@extensible") -> true) ]]
[[ Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #value, true, true, true }}, {{ _$l_#l }}, {{ false }}, {{ "" }}) * Pi(#lp, #prop, (#pcls :: #ocls), {{ "d", #dcval, true, #dcenum, #dcconf }}, (#lp :: #lllp), (#tf :: #lltf), (#pv :: #llpv)) * types(#ocls : List, #lllp : List, #dcenum : Bool, #lp : Obj, #pv : Str, #cls : Str, #throw : Bool, #lltf : List, xret : Empty, #dcconf : Bool, #tf : Bool, #prop : Str, #pcls : Str, #llpv : List) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == empty) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, "@proto") -> #lp) * ((_$l_#l, "@extensible") -> true) ]]
normal

proc put (l, prop, value, throw) {
			xret := "canPut"(l, prop) with elab;
			goto [xret] cp reject;
			[* unfold Pi(#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) *]
	cp:		xret := "getOwnProperty"(l, prop) with elab;
			dd := "i__isDataDescriptor"(xret);
			goto [dd] dd gp;
	dd:		desc := {{ "g", empty, empty, value, empty, empty, empty }};
			xret := "defineOwnProperty"(l, prop, desc, throw) with elab;
			[* fold Pi(#l, #prop, #g_aux_new_1, {{ "d", #value, true, #denum, #dconf }}, {{ #l }}, #g_aux_new_3, #g_aux_new_4) *]
			goto remp;
			[* fold Pi(#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) *]
	gp:		xret := "getProperty"(l, prop) with elab;
			ad := "i__isAccessorDescriptor"(xret);
			goto [ad] ad def;
	ad:		s := l-nth(xret, 2.);
			xsc := [s, "@scope"];
			fun := [s, "@call"];
			xret := fun(xsc, l, value) with elab;
			goto remp;
	def:		desc := {{ "d", value, true, true, true }};
			[* unfold Pi(#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) *]
			xret := "defineOwnProperty"(l, prop, desc, throw) with elab;
			[* fold Pi(#l, #prop, #g_aux_new_1, {{ "d", #value, true, true, true }}, {{ #l }}, #g_aux_new_3, #g_aux_new_4) *]
			skip;
	remp:		xret := empty;
	rlab:		skip;
	reject:		xret := empty;
			goto [throw] tt rlab;
	tt:		xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__putValue(v, w)
[[ types(v : Undefined) * (v == undefined) * (w == _lvar_w) ]]
[[ types(xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_xret, "@proto") -> $lrferr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ types(v : Null) * (v == null) * (w == _lvar_w) ]]
[[ types(xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_xret, "@proto") -> $lrferr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ types(v : Num, _lvar_205 : Num) * (v == _lvar_205) * (w == _lvar_w) ]]
[[ types(xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_xret, "@proto") -> $lrferr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ types(_lvar_206 : Bool, v : Bool) * (v == _lvar_206) * (w == _lvar_w) ]]
[[ types(xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_xret, "@proto") -> $lrferr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ types(v : Str, _lvar_207 : Str) * (v == _lvar_207) * (w == _lvar_w) ]]
[[ types(xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_xret, "@proto") -> $lrferr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ types(v : Obj, _lvar_208 : Obj) * (v == _lvar_208) * (w == _lvar_w) ]]
[[ types(xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_xret, "@proto") -> $lrferr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ types(#field : Str, v : List) * (! (#w == empty)) * (! (#field == "")) * (! (s-nth(#field, 0.) == "@")) * (v == {{ "v", _$l_#obj, #field }}) * (w == #w) * ((_$l_#obj, #field) -> #oldvalue) ]]
[[ types(#field : Str, xret : Empty) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#obj, #field) -> #w) ]]
normal;

 [[ Pi(_$l_#l, #prop, #cls, undefined, #g_aux_4, #g_aux_5, #g_aux_6) * types(v : List, #cls : List, #prop : Str) * (! (#w == empty)) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#l, "@extensible") -> false) ]]
[[ Pi(_$l_#l, #prop, #cls, undefined, #g_aux_4, #g_aux_5, #g_aux_6) * types(#cls : List, xret : Obj, #prop : Str) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#l, "@extensible") -> false) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ Pi(_$l_#l, #prop, #cls, {{ "d", _lvar_209, false, _lvar_211, _lvar_212 }}, {{ _$l_#l }}, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, _lvar_212 : Bool, v : List, #cls : List, #prop : Str, _lvar_211 : Bool) * (#g_aux_1 == {{ "d", _lvar_209, false, _lvar_211, _lvar_212 }}) * (! (#w == empty)) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_209 == empty)) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#l, "@extensible") -> #ignore) ]]
[[ Pi(_$l_#l, #prop, #cls, #g_aux_1, {{ _$l_#l }}, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #cls : List, xret : Obj, #prop : Str) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#l, "@extensible") -> #ignore) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ Pi(_$l_#l, #prop, #cls, {{ "d", _lvar_215, _lvar_216, _lvar_217, _lvar_218 }}, (_$l_#l :: (#lp :: #other)), #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, _lvar_218 : Bool, v : List, #lp : Obj, #g_aux_2 : List, #other : List, _lvar_217 : Bool, #cls : List, _lvar_216 : Bool, #prop : Str) * (#g_aux_1 == {{ "d", _lvar_215, _lvar_216, _lvar_217, _lvar_218 }}) * (#g_aux_2 == (_$l_#l :: (#lp :: #other))) * (! (#w == empty)) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_215 == empty)) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#l, "@extensible") -> false) ]]
[[ Pi(_$l_#l, #prop, #cls, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #lp : Obj, #g_aux_2 : List, #other : List, #cls : List, xret : Obj, #prop : Str) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#l, "@extensible") -> false) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ Pi(_$l_#l, #prop, #cls, {{ "d", _lvar_219, false, _lvar_221, _lvar_222 }}, (_$l_#l :: (#lp :: #other)), #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, v : List, #lp : Obj, #g_aux_2 : List, #other : List, #cls : List, _lvar_221 : Bool, _lvar_222 : Bool, #prop : Str) * (#g_aux_1 == {{ "d", _lvar_219, false, _lvar_221, _lvar_222 }}) * (#g_aux_2 == (_$l_#l :: (#lp :: #other))) * (! (#w == empty)) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_219 == empty)) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#l, "@extensible") -> true) ]]
[[ Pi(_$l_#l, #prop, #cls, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #lp : Obj, #g_aux_2 : List, #other : List, #cls : List, xret : Obj, #prop : Str) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#l, "@extensible") -> true) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ Pi($lg, #prop, {{ "Object" }}, undefined, #g_aux_4, #g_aux_5, #g_aux_6) * types(v : List, #prop : Str) * (! (#w == empty)) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (v == {{ "v", $lg, #prop }}) * (w == #w) * (($lg, "@extensible") -> false) ]]
[[ Pi($lg, #prop, {{ "Object" }}, undefined, #g_aux_4, #g_aux_5, #g_aux_6) * types(xret : Obj, #prop : Str) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * (($lg, "@extensible") -> false) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ Pi($lg, #prop, {{ "Object" }}, {{ "d", _lvar_223, false, _lvar_225, _lvar_226 }}, {{ $lg }}, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, _lvar_225 : Bool, v : List, _lvar_226 : Bool, #prop : Str) * (#g_aux_1 == {{ "d", _lvar_223, false, _lvar_225, _lvar_226 }}) * (! (#w == empty)) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_223 == empty)) * (v == {{ "v", $lg, #prop }}) * (w == #w) * (($lg, "@extensible") -> false) ]]
[[ Pi($lg, #prop, {{ "Object" }}, #g_aux_1, {{ $lg }}, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, xret : Obj, #prop : Str) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * (($lg, "@extensible") -> false) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ Pi($lg, #prop, {{ "Object" }}, {{ "d", _lvar_227, _lvar_228, _lvar_229, _lvar_230 }}, ($lg :: (#lp :: #other)), #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, _lvar_229 : Bool, v : List, #lp : Obj, #g_aux_2 : List, #other : List, _lvar_228 : Bool, _lvar_230 : Bool, #prop : Str) * (#g_aux_1 == {{ "d", _lvar_227, _lvar_228, _lvar_229, _lvar_230 }}) * (#g_aux_2 == ($lg :: (#lp :: #other))) * (! (#w == empty)) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_227 == empty)) * (v == {{ "v", $lg, #prop }}) * (w == #w) * (($lg, "@extensible") -> false) ]]
[[ Pi($lg, #prop, {{ "Object" }}, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #lp : Obj, #g_aux_2 : List, #other : List, xret : Obj, #prop : Str) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * (($lg, "@extensible") -> false) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ Pi($lg, #prop, {{ "Object" }}, {{ "d", _lvar_231, false, _lvar_233, _lvar_234 }}, ($lg :: (#lp :: #other)), #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, _lvar_234 : Bool, v : List, #lp : Obj, #g_aux_2 : List, #other : List, _lvar_233 : Bool, #prop : Str) * (#g_aux_1 == {{ "d", _lvar_231, false, _lvar_233, _lvar_234 }}) * (#g_aux_2 == ($lg :: (#lp :: #other))) * (! (#w == empty)) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (_lvar_231 == empty)) * (v == {{ "v", $lg, #prop }}) * (w == #w) * (($lg, "@extensible") -> true) ]]
[[ Pi($lg, #prop, {{ "Object" }}, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #lp : Obj, #g_aux_2 : List, #other : List, xret : Obj, #prop : Str) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * (($lg, "@extensible") -> true) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ #cls }}, undefined, {{ _$l_#l }}, {{ false }}, {{ "" }}) * types(v : List, #cls : Str, #prop : Str) * (! (#w == empty)) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#l, "@extensible") -> true) ]]
[[ Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #w, true, true, true }}, {{ _$l_#l }}, {{ false }}, {{ "" }}) * types(#cls : Str, xret : Empty, #prop : Str) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#l, "@proto") -> null) * ((_$l_#l, "@extensible") -> true) ]]
normal;

 [[ Pi(_$l_#l, #prop, (#cls :: (#pcls :: #ocls)), undefined, (_$l_#l :: (#lp :: #lllp)), (false :: (#tf :: #lltf)), ("" :: (#pv :: #llpv))) * types(#ocls : List, v : List, #lllp : List, #lp : Obj, #pv : Str, #cls : Str, #lltf : List, #tf : Bool, #prop : Str, #pcls : Str, #llpv : List) * (! (#w == empty)) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#l, "@extensible") -> true) ]]
[[ Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #w, true, true, true }}, {{ _$l_#l }}, {{ false }}, {{ "" }}) * Pi(#lp, #prop, (#pcls :: #ocls), undefined, (#lp :: #lllp), (#tf :: #lltf), (#pv :: #llpv)) * types(#ocls : List, #lllp : List, #lp : Obj, #pv : Str, #cls : Str, #lltf : List, xret : Empty, #tf : Bool, #prop : Str, #pcls : Str, #llpv : List) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#l, "@proto") -> #lp) * ((_$l_#l, "@extensible") -> true) ]]
normal;

 [[ Pi($lg, #prop, ("Object" :: (#pcls :: #ocls)), undefined, ($lg :: (#lp :: #lllp)), (false :: (#tf :: #lltf)), ("" :: (#pv :: #llpv))) * types(#ocls : List, v : List, #lllp : List, #lp : Obj, #pv : Str, #lltf : List, #tf : Bool, #prop : Str, #pcls : Str, #llpv : List) * (! (#w == empty)) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (v == {{ "v", $lg, #prop }}) * (w == #w) * (($lg, "@extensible") -> true) ]]
[[ Pi($lg, #prop, {{ "Object" }}, {{ "d", #w, true, true, true }}, {{ $lg }}, {{ false }}, {{ "" }}) * Pi(#lp, #prop, (#pcls :: #ocls), undefined, (#lp :: #lllp), (#tf :: #lltf), (#pv :: #llpv)) * types(#ocls : List, #lllp : List, #lp : Obj, #pv : Str, #lltf : List, xret : Empty, #tf : Bool, #prop : Str, #pcls : Str, #llpv : List) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * (($lg, "@proto") -> #lp) * (($lg, "@extensible") -> true) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #dval, true, #denum, #dconf }}, {{ _$l_#l }}, #g_aux_3, #g_aux_4) * types(#denum : Bool, v : List, #cls : Str, #ext : Bool, #dconf : Bool, #prop : Str) * (! (#w == empty)) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (#dval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#l, "@extensible") -> #ext) ]]
[[ Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #w, true, #denum, #dconf }}, {{ _$l_#l }}, #g_aux_3, #g_aux_4) * types(#denum : Bool, #cls : Str, #ext : Bool, xret : Empty, #dconf : Bool, #prop : Str) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#l, "@extensible") -> #ext) ]]
normal;

 [[ Pi($lg, #prop, {{ "Object" }}, {{ "d", #dval, true, #denum, #dconf }}, {{ $lg }}, #g_aux_3, #g_aux_4) * types(#denum : Bool, v : List, #ext : Bool, #dconf : Bool, #prop : Str) * (! (#w == empty)) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (#dval == empty)) * (v == {{ "v", $lg, #prop }}) * (w == #w) * (($lg, "@extensible") -> #ext) ]]
[[ Pi($lg, #prop, {{ "Object" }}, {{ "d", #w, true, #denum, #dconf }}, {{ $lg }}, #g_aux_3, #g_aux_4) * types(#denum : Bool, #ext : Bool, xret : Empty, #dconf : Bool, #prop : Str) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * (($lg, "@extensible") -> #ext) ]]
normal;

 [[ Pi(_$l_#l, #prop, (#cls :: (#pcls :: #ocls)), {{ "d", #dcval, true, #dcenum, #dcconf }}, (_$l_#l :: (#lp :: #lllp)), (false :: (#tf :: #lltf)), ("" :: (#pv :: #llpv))) * types(#ocls : List, v : List, #lllp : List, #dcenum : Bool, #lp : Obj, #pv : Str, #cls : Str, #throw : Bool, #lltf : List, #dcconf : Bool, #tf : Bool, #prop : Str, #pcls : Str, #llpv : List) * (! (#w == empty)) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (#dcval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#l, "@extensible") -> true) ]]
[[ Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #w, true, true, true }}, {{ _$l_#l }}, {{ false }}, {{ "" }}) * Pi(#lp, #prop, (#pcls :: #ocls), {{ "d", #dcval, true, #dcenum, #dcconf }}, (#lp :: #lllp), (#tf :: #lltf), (#pv :: #llpv)) * types(#ocls : List, #lllp : List, #dcenum : Bool, #lp : Obj, #pv : Str, #cls : Str, #throw : Bool, #lltf : List, xret : Empty, #dcconf : Bool, #tf : Bool, #prop : Str, #pcls : Str, #llpv : List) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#l, "@proto") -> #lp) * ((_$l_#l, "@extensible") -> true) ]]
normal;

 [[ Pi($lg, #prop, ("Object" :: (#pcls :: #ocls)), {{ "d", #dcval, true, #dcenum, #dcconf }}, ($lg :: (#lp :: #lllp)), (false :: (#tf :: #lltf)), ("" :: (#pv :: #llpv))) * types(#ocls : List, v : List, #lllp : List, #dcenum : Bool, #lp : Obj, #pv : Str, #throw : Bool, #lltf : List, #dcconf : Bool, #tf : Bool, #prop : Str, #pcls : Str, #llpv : List) * (! (#w == empty)) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (#dcval == empty)) * (v == {{ "v", $lg, #prop }}) * (w == #w) * (($lg, "@extensible") -> true) ]]
[[ Pi($lg, #prop, {{ "Object" }}, {{ "d", #w, true, true, true }}, {{ $lg }}, {{ false }}, {{ "" }}) * Pi(#lp, #prop, (#pcls :: #ocls), {{ "d", #dcval, true, #dcenum, #dcconf }}, (#lp :: #lllp), (#tf :: #lltf), (#pv :: #llpv)) * types(#ocls : List, #lllp : List, #dcenum : Bool, #lp : Obj, #pv : Str, #throw : Bool, #lltf : List, xret : Empty, #dcconf : Bool, #tf : Bool, #prop : Str, #pcls : Str, #llpv : List) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * (($lg, "@proto") -> #lp) * (($lg, "@extensible") -> true) ]]
normal

proc i__putValue (v, w) {
			goto [(typeOf(v) = List)] isref throw;
	isref:		goto [((l-nth(v, 0.) = "v") or (l-nth(v, 0.) = "o"))] init throw;
	init:		rbase := l-nth(v, 1.);
			rfield := l-nth(v, 2.);
			goto [(rbase = undefined)] throw prim;
	prim:		prim := "i__isPrimitive"(rbase);
			goto [prim] is_pr refr;
	refr:		goto [(l-nth(v, 0.) = "o")] oref vref;
	oref:		xret := "put"(rbase, rfield, w, true) with elab;
			goto dflt;
	vref:		goto [(rbase = $lg)] lg er;
	lg:		xret := "put"(rbase, rfield, w, true) with elab;
			goto dflt;
	er:		[rbase, rfield] := w;
	dflt:		xret := empty;
	rlab:		skip;
	throw:		xret := "ReferenceError"();
	elab:		skip;
	is_pr:		xret := "i__toObject"(rbase) with elab;
			l := xret;
			xret := "canPut"(l, rfield) with elab;
			goto [xret] cp reject;
	cp:		xret := "getProperty"(l, rfield) with elab;
			dd := "i__isDataDescriptor"(xret);
			goto [dd] reject is_ad;
	is_ad:		ad := "i__isAccessorDescriptor"(xret);
			goto [ad] ad reject;
	ad:		s := l-nth(xret, 2.);
			xsc := [s, "@scope"];
			fun := [s, "@call"];
			xret := fun(xsc, rbase, w) with elab;
			goto dflt;
	reject:		xret := "TypeError"();
			goto elab
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec OP_hasOwnProperty(xsc, vthis, v)
[[ types(vthis : Obj, #en : Bool, #wr : Bool, #prop : Str, #co : Bool) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (#v == empty)) * (v == #prop) * (xsc == _lvar_xsc) * (vthis == _$l_#l) * ((_$l_#l, "@class") -> "Object") * ((_$l_#l, #prop) -> {{ "d", #v, #wr, #en, #co }}) ]]
[[ types(#en : Bool, #wr : Bool, xret : Bool, #co : Bool, #prop : Str) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (! (#v == empty)) * (xret == true) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * ((_$l_#l, "@class") -> "Object") * ((_$l_#l, #prop) -> {{ "d", #v, #wr, #en, #co }}) ]]
normal;

 [[ types(vthis : Obj, #prop : Str) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (v == #prop) * (xsc == _lvar_xsc) * (vthis == _$l_#l) * ((_$l_#l, "@class") -> "Object") * ((_$l_#l, #prop) -> none) ]]
[[ types(xret : Bool, #prop : Str) * (! (#prop == "")) * (! (s-nth(#prop, 0.) == "@")) * (xret == false) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * ((_$l_#l, "@class") -> "Object") * ((_$l_#l, #prop) -> none) ]]
normal

proc OP_hasOwnProperty (xsc, vthis, v) {
			xret := "i__toString"(v) with elab;
			p := xret;
			xret := "i__toObject"(vthis) with elab;
			xret := "getOwnProperty"(xret, p) with elab;
			xret := (not (xret = undefined));
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec hasProperty(l, prop)
[[ Pi(#l, #prop, #gp_aux_0, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4) * types(#l : Obj, #prop : Str) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #gp_aux_0, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4) * types(#l : Obj, xret : Bool, #prop : Str) * (xret == (not (#gp_aux_1 = undefined))) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal

proc hasProperty (l, prop) {
			xret := "getProperty"(l, prop) with elab;
	rlab:		xret := (not (xret = undefined));
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec create_object_with_call_construct(l, call, construct, len)
[[ types(#construct : Str, #len : Num, l : Obj, #call : Str) * (l == _$l_#l) * (construct == #construct) * (len == #len) * (call == #call) * ((_$l_#l, "@proto") -> null) * empty_fields(_$l_#l : -{ "@proto" }-) ]]
[[ types(#construct : Str, #len : Num, xret : Obj, #call : Str) * (xret == _$l_#l) * (l == _lvar_l) * (construct == _lvar_construct) * (len == _lvar_len) * (call == _lvar_call) * ((_$l_#l, "@proto") -> $lfun_proto) * ((_$l_#l, "@class") -> "Function") * ((_$l_#l, "@extensible") -> true) * ((_$l_#l, "@scope") -> empty) * ((_$l_#l, "length") -> {{ "d", #len, false, false, false }}) * ((_$l_#l, "@call") -> #call) * ((_$l_#l, "@construct") -> #construct) * empty_fields(_$l_#l : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope", "length" }-) ]]
normal;

 [[ types(construct : Empty, #len : Num, l : Obj, #call : Str) * (l == _$l_#l) * (construct == empty) * (len == #len) * (call == #call) * empty_fields(_$l_#l : -{  }-) ]]
[[ types(#len : Num, xret : Obj, #call : Str) * (xret == _$l_#l) * (l == _lvar_l) * (construct == _lvar_construct) * (len == _lvar_len) * (call == _lvar_call) * ((_$l_#l, "@proto") -> $lfun_proto) * ((_$l_#l, "@class") -> "Function") * ((_$l_#l, "@extensible") -> true) * ((_$l_#l, "@scope") -> empty) * ((_$l_#l, "length") -> {{ "d", #len, false, false, false }}) * ((_$l_#l, "@call") -> #call) * empty_fields(_$l_#l : -{ "@call", "@class", "@extensible", "@proto", "@scope", "length" }-) ]]
normal;

 [[ types(#construct : Str, #len : Num, l : Obj, #call : Str) * (l == _$l_#l) * (construct == #construct) * (len == #len) * (call == #call) * empty_fields(_$l_#l : -{  }-) ]]
[[ types(#construct : Str, #len : Num, xret : Obj, #call : Str) * (xret == _$l_#l) * (l == _lvar_l) * (construct == _lvar_construct) * (len == _lvar_len) * (call == _lvar_call) * ((_$l_#l, "@proto") -> $lfun_proto) * ((_$l_#l, "@class") -> "Function") * ((_$l_#l, "@extensible") -> true) * ((_$l_#l, "@scope") -> empty) * ((_$l_#l, "length") -> {{ "d", #len, false, false, false }}) * ((_$l_#l, "@call") -> #call) * ((_$l_#l, "@construct") -> #construct) * empty_fields(_$l_#l : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope", "length" }-) ]]
normal

proc create_object_with_call_construct (l, call, construct, len) {
			xret := "create_default_object"(l, $lfun_proto, "Function", true);
			[xret, "@scope"] := empty;
			[xret, "length"] := {{ "d", len, false, false, false }};
			[xret, "@call"] := call;
			goto [(construct = empty)] rlab cstr;
	cstr:		[xret, "@construct"] := construct;
	rlab:		xret := l
} with {
	ret: xret, rlab;
};


spec i__isPrimitive(v)
[[ types(v : Undefined) * (v == undefined) ]]
[[ types(xret : Bool) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(v : Null) * (v == null) ]]
[[ types(xret : Bool) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(v : Num, _lvar_20 : Num) * (v == _lvar_20) ]]
[[ types(xret : Bool) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(v : Bool, _lvar_21 : Bool) * (v == _lvar_21) ]]
[[ types(xret : Bool) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_22 : Str, v : Str) * (v == _lvar_22) ]]
[[ types(xret : Bool) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(v : Obj, _lvar_23 : Obj) * (v == _lvar_23) ]]
[[ types(xret : Bool) * (xret == false) * (v == _lvar_v) ]]
normal

proc i__isPrimitive (v) {
			tv := typeOf(v);
	iu:		goto [(((((v = undefined) or (v = null)) or (typeOf(v) = Bool)) or (typeOf(v) = Num)) or (typeOf(v) = Str))] rt rf;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec copy_object_rec(lf, fields, lt)
[[ types(fields : List) * (lf == _lvar_lf) * (fields == nil) * (lt == _lvar_lt) ]]
[[ types() * (xret == #lt) * (lf == _lvar_lf) * (fields == _lvar_fields) * (lt == _lvar_lt) ]]
normal;

 [[ types(#f : Str, lt : Obj, lf : Obj, #fields : List) * (#fields == {{ #f }}) * (! (#f == "")) * (! (s-nth(#f, 0.) == "@")) * (lf == _$l_#lf) * (fields == {{ #f }}) * (lt == _$l_#lt) * ((_$l_#lt, #f) -> none) * ((_$l_#lt, "@proto") -> null) * ((_$l_#lf, #f) -> #v) ]]
[[ types(#f : Str, #fields : List, xret : Obj) * (xret == _$l_#lt) * (lf == _lvar_lf) * (fields == _lvar_fields) * (lt == _lvar_lt) * ((_$l_#lt, #f) -> #v) * ((_$l_#lt, "@proto") -> null) * ((_$l_#lf, #f) -> #v) ]]
normal;

 [[ types(#f1 : Str, lt : Obj, lf : Obj, #fields : List) * (#fields == {{ #f1, "main" }}) * (! (#f1 == "")) * (! (s-nth(#f1, 0.) == "@")) * (lf == _$l_#lf) * (fields == {{ #f1, "main" }}) * (lt == _$l_#lt) * ((_$l_#lt, #f1) -> none) * ((_$l_#lt, "main") -> none) * ((_$l_#lt, "@proto") -> null) * ((_$l_#lf, #f1) -> #v1) * ((_$l_#lf, "main") -> #v2) ]]
[[ types(#f1 : Str, #fields : List, xret : Obj) * (xret == _$l_#lt) * (lf == _lvar_lf) * (fields == _lvar_fields) * (lt == _lvar_lt) * ((_$l_#lt, #f1) -> #v1) * ((_$l_#lt, "main") -> #v2) * ((_$l_#lt, "@proto") -> null) * ((_$l_#lf, #f1) -> #v1) * ((_$l_#lf, "main") -> #v2) ]]
normal

proc copy_object_rec (lf, fields, lt) {
			goto [(fields = nil)] rlab next;
	next:		head := l-nth(fields, 0.);
			tail := (cdr fields);
			val := [lf, head];
			[lt, head] := val;
			xret := "copy_object_rec"(lf, tail, lt);
	rlab:		xret := lt
} with {
	ret: xret, rlab;
};


spec i__isGenericDescriptor(desc)
[[ types(desc : Undefined) * (desc == undefined) ]]
[[ types(xret : Bool) * (xret == false) * (desc == _lvar_desc) ]]
normal;

 [[ types(_lvar_530 : Bool, _lvar_531 : Bool, desc : List, _lvar_529 : Bool) * (! (_lvar_528 == empty)) * (desc == {{ "d", _lvar_528, _lvar_529, _lvar_530, _lvar_531 }}) ]]
[[ types(xret : Bool) * (xret == false) * (desc == _lvar_desc) ]]
normal;

 [[ types(_lvar_535 : Empty, _lvar_536 : Empty, desc : List, _lvar_537 : Empty, _lvar_538 : Empty) * (desc == {{ "g", _lvar_533, _lvar_534, empty, empty, empty, empty }}) ]]
[[ types(xret : Bool) * (xret == true) * (desc == _lvar_desc) ]]
normal;

 [[ types(desc : List) * (! (_lvar_542 == empty)) * (desc == {{ "g", _lvar_540, _lvar_541, _lvar_542, _lvar_543, _lvar_544, _lvar_545 }}) ]]
[[ types(xret : Bool) * (xret == false) * (desc == _lvar_desc) ]]
normal;

 [[ types(desc : List) * (! (_lvar_550 == empty)) * (desc == {{ "g", _lvar_547, _lvar_548, _lvar_549, _lvar_550, _lvar_551, _lvar_552 }}) ]]
[[ types(xret : Bool) * (xret == false) * (desc == _lvar_desc) ]]
normal;

 [[ types(desc : List) * (! (_lvar_558 == empty)) * (desc == {{ "g", _lvar_554, _lvar_555, _lvar_556, _lvar_557, _lvar_558, _lvar_559 }}) ]]
[[ types(xret : Bool) * (xret == false) * (desc == _lvar_desc) ]]
normal;

 [[ types(desc : List) * (! (_lvar_566 == empty)) * (desc == {{ "g", _lvar_561, _lvar_562, _lvar_563, _lvar_564, _lvar_565, _lvar_566 }}) ]]
[[ types(xret : Bool) * (xret == false) * (desc == _lvar_desc) ]]
normal

proc i__isGenericDescriptor (desc) {
			goto [(desc = undefined)] rf cont;
	cont:		dd := "i__isDataDescriptor"(desc);
			ad := "i__isAccessorDescriptor"(desc);
			xret := (not (dd or ad));
			goto rlab;
	rf:		xret := false;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__toDataDescriptor(desc)
[[ types(_lvar_493 : Bool, #desc : List, _lvar_495 : Bool, _lvar_494 : Bool) * (#desc == {{ "d", _lvar_492, _lvar_493, _lvar_494, _lvar_495 }}) * (! (_lvar_492 == empty)) * (desc == {{ "d", _lvar_492, _lvar_493, _lvar_494, _lvar_495 }}) ]]
[[ types(#desc : List) * (xret == #desc) * (desc == _lvar_desc) ]]
normal

proc i__toDataDescriptor (desc) {
			d := l-nth(desc, 0.);
			goto [(d = "d")] rd cstr;
	cstr:		goto [(d = "a")] ra gen;
	ra:		xret := {{ "d", undefined, false, l-nth(desc, 3.), l-nth(desc, 4.) }};
			goto rlab;
	gen:		e := l-nth(desc, 1.);
			c := l-nth(desc, 2.);
			v := l-nth(desc, 3.);
			w := l-nth(desc, 4.);
			goto [(e = empty)] fixe c;
	fixe:		e := false;
	c:		goto [(c = empty)] fixc v;
	fixc:		c := false;
	v:		goto [(v = empty)] fixv w;
	fixv:		v := undefined;
	w:		goto [(w = empty)] fixw fixed;
	fixw:		w := false;
	fixed:		xret := {{ "d", v, w, e, c }};
			goto rlab;
	rd:		xret := desc;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__sameValue(v1, v2)
[[ types(v2 : Num, #v2 : Num, v1 : Num, #v1 : Num) * (#v1 == 0.) * (#v2 == 0.) * (v2 == 0.) * (v1 == 0.) ]]
[[ types(#v2 : Num, xret : Bool, #v1 : Num) * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types(v2 : Num, #v2 : Num, v1 : Num, #v1 : Num) * (#v1 == -0.) * (#v2 == -0.) * (v2 == -0.) * (v1 == -0.) ]]
[[ types(#v2 : Num, xret : Bool, #v1 : Num) * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types(v2 : Num, #v2 : Num, v1 : Num, #v1 : Num) * (#v1 == -0.) * (#v2 == 0.) * (v2 == 0.) * (v1 == -0.) ]]
[[ types(#v2 : Num, xret : Bool, #v1 : Num) * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types(v2 : Num, #v2 : Num, v1 : Num, #v1 : Num) * (#v1 == 0.) * (#v2 == -0.) * (v2 == -0.) * (v1 == 0.) ]]
[[ types(#v2 : Num, xret : Bool, #v1 : Num) * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (#v1 == #v2) * (v2 == #v2) * (v1 == #v2) ]]
[[ types(xret : Bool) * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (! (#v1 == #v2)) * (v2 == #v2) * (v1 == #v1) ]]
[[ types(xret : Bool) * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal

proc i__sameValue (v1, v2) {
			xret := (v1 = v2);
			goto [(typeOf(v1) = Num)] test2 rlab;
	test2:		goto [(typeOf(v2) = Num)] inan1 rlab;
	inan1:		goto [(not (v1 = v1))] inan2 zero1;
	inan2:		goto [(not (v2 = v2))] rt zero1;
	zero1:		goto [(v1 = 0.)] zero2 rlab;
	zero2:		goto [(v2 = 0.)] fix rlab;
	fix:		sv1 := (m_sgn v1);
			sv2 := (m_sgn v2);
			xret := (sv1 = sv2);
			goto rlab;
	rt:		xret := true;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__toObject(v)
[[ types(#v : Obj) * (v == #v) ]]
[[ types(#v : Obj) * (xret == #v) * (v == _lvar_v) ]]
normal

proc i__toObject (v) {
	iu:		goto [(v = undefined)] throw in;
	in:		goto [(v = null)] throw ib;
	ib:		goto [(typeOf(v) = Bool)] bool inum;
	bool:		xret := "Boolean_construct"(undefined, undefined, v);
			goto rlab;
	inum:		goto [(typeOf(v) = Num)] num is;
	num:		xret := "Number_construct"(undefined, undefined, v);
			goto rlab;
	is:		goto [(typeOf(v) = Str)] str io;
	str:		xret := "String_construct"(undefined, undefined, v);
			goto rlab;
	io:		goto [(typeOf(v) = Obj)] obj oops;
	obj:		xret := v;
			goto rlab;
	oops:		xret := "ToObject: This should not happen.";
	rlab:		skip;
	throw:		xret := "Here!";
			xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__toBoolean(v)
[[ types(#v : Bool) * (v == #v) ]]
[[ types(#v : Bool) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(v : Num) * (v == 0.) ]]
[[ types(xret : Bool) * (xret == false) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (! (#v == 0.)) * (v == #v) ]]
[[ types(#v : Num, xret : Bool) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Obj) * (v == #v) ]]
[[ types(#v : Obj, xret : Bool) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(v : Null) * (v == null) ]]
[[ types(xret : Bool) * (xret == false) * (v == _lvar_v) ]]
normal

proc i__toBoolean (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := false;
			goto rlab;
	in:		goto [(v = null)] nul ib;
	nul:		xret := false;
			goto rlab;
	ib:		goto [(typeOf(v) = Bool)] bool inum;
	bool:		xret := v;
			goto rlab;
	inum:		goto [(typeOf(v) = Num)] num is;
	num:		goto [((v = 0.) or (not (v = v)))] is_f is_t;
	is:		goto [(typeOf(v) = Str)] str io;
	str:		goto [(v = "")] is_f is_t;
			goto rlab;
	io:		goto [(typeOf(v) = Obj)] obj oops;
	obj:		xret := true;
			goto rlab;
	is_t:		xret := true;
			goto rlab;
	is_f:		xret := false;
			goto rlab;
	oops:		xret := "ToBoolean: This should not happen.";
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec getProperty(l, prop)
[[ Pi(#l, #prop, #gp_aux_0, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4) * types(#l : Obj, #prop : Str) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #gp_aux_0, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4) * types(#l : Obj, #prop : Str) * (xret == #gp_aux_1) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal

proc getProperty (l, prop) {
			[* unfold Pi(#l, #prop, #gp_aux_0, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4) *]
	start:		xret := "getOwnProperty"(l, prop) with elab;
			goto [(xret = undefined)] next rlab;
	next:		proto := [l, "@proto"];
			goto [(proto = null)] rlab call;
	call:		xret := "getProperty"(proto, prop) with elab;
			[* fold Pi(#l, #prop, #gp_aux_0, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4) *]
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec get(l, prop)
[[ Pi(#l, #prop, #g_aux_0, {{ "d", _lvar_201, _lvar_202, _lvar_203, _lvar_204 }}, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, _lvar_202 : Bool, _lvar_203 : Bool, #l : Obj, _lvar_204 : Bool, #prop : Str) * (#g_aux_1 == {{ "d", _lvar_201, _lvar_202, _lvar_203, _lvar_204 }}) * (! (_lvar_201 == empty)) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #l : Obj, #prop : Str) * (xret == l-nth(#g_aux_1, 1.)) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal;

 [[ Pi(#l, #prop, #g_aux_0, undefined, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : Undefined, #l : Obj, #prop : Str) * (#g_aux_1 == undefined) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #g_aux_0, undefined, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : Undefined, #l : Obj, xret : Undefined, #prop : Str) * (#g_aux_1 == undefined) * (xret == undefined) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal

proc get (l, prop) {
			xret := "getProperty"(l, prop) with elab;
			goto [(xret = undefined)] rlab def;
	def:		d := l-nth(xret, 0.);
			xret := l-nth(xret, 1.);
			goto [(d = "d")] rlab acc;
	acc:		goto [(xret = undefined)] rlab get;
	get:		xsc := [xret, "@scope"];
			fun := [xret, "@call"];
			xret := fun(xsc, l) with elab;
			goto [(xret = empty)] undef rlab;
	undef:		xret := undefined;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__checkObjectCoercible(v)
[[ types(v : Undefined) * (v == undefined) ]]
[[ types(xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
normal;

 [[ types(v : Null) * (v == null) ]]
[[ types(xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
normal;

 [[ types(_lvar_89 : Num, v : Num) * (v == _lvar_89) ]]
[[ types(xret : Empty) * (xret == empty) * (v == _lvar_v) ]]
normal;

 [[ types(v : Bool, _lvar_90 : Bool) * (v == _lvar_90) ]]
[[ types(xret : Empty) * (xret == empty) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_91 : Str, v : Str) * (v == _lvar_91) ]]
[[ types(xret : Empty) * (xret == empty) * (v == _lvar_v) ]]
normal;

 [[ types(v : Obj, _lvar_92 : Obj) * (v == _lvar_92) ]]
[[ types(xret : Empty) * (xret == empty) * (v == _lvar_v) ]]
normal

proc i__checkObjectCoercible (v) {
			xret := empty;
	iu:		goto [(v = undefined)] throw in;
	in:		goto [(v = null)] throw other;
	other:		goto [((((typeOf(v) = Bool) or (typeOf(v) = Num)) or (typeOf(v) = Str)) or (typeOf(v) = Obj))] rlab oops;
	oops:		xret := "CheckObjectCoercible: This should not happen.";
	rlab:		skip;
	throw:		xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec SyntaxError_call(xsc, vthis, v)
[[ types(v : Undefined) * (v == undefined) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) ]]
[[ types(xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * ((_$l_xret, "@proto") -> $lserr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
normal

proc SyntaxError_call (xsc, vthis, v) {
			xret := new();
			xret := "create_default_object"(xret, $lserr_proto, "Error", true);
			xret := "Error_construct"(undefined, xret, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__getValue(v)
[[ Pi(#obj, #field, #g_aux_0, {{ "d", _lvar_55, _lvar_56, _lvar_57, _lvar_58 }}, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #field : Str, v : List, #obj : Obj, _lvar_57 : Bool, _lvar_56 : Bool, _lvar_58 : Bool) * (#g_aux_1 == {{ "d", _lvar_55, _lvar_56, _lvar_57, _lvar_58 }}) * (! (#field == "")) * (! (s-nth(#field, 0.) == "@")) * (! (_lvar_55 == empty)) * (v == {{ "o", #obj, #field }}) ]]
[[ Pi(#obj, #field, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #field : Str, #obj : Obj) * (xret == l-nth(#g_aux_1, 1.)) * (v == _lvar_v) ]]
normal;

 [[ types(#field : Str, v : List) * (! (#field == "")) * (! (s-nth(#field, 0.) == "@")) * (v == {{ "v", _$l_#obj, #field }}) * ((_$l_#obj, #field) -> #value) ]]
[[ types(#field : Str) * (xret == #value) * (v == _lvar_v) * ((_$l_#obj, #field) -> #value) ]]
normal;

 [[ Pi($lg, #field, #g_aux_0, {{ "d", _lvar_59, _lvar_60, _lvar_61, _lvar_62 }}, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #field : Str, v : List, _lvar_62 : Bool, _lvar_61 : Bool, _lvar_60 : Bool) * (#g_aux_1 == {{ "d", _lvar_59, _lvar_60, _lvar_61, _lvar_62 }}) * (! (#field == "")) * (! (s-nth(#field, 0.) == "@")) * (! (_lvar_59 == empty)) * (v == {{ "v", $lg, #field }}) ]]
[[ Pi($lg, #field, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : List, #field : Str) * (xret == l-nth(#g_aux_1, 1.)) * (v == _lvar_v) ]]
normal;

 [[ Pi(#obj, #field, #g_aux_0, undefined, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : Undefined, #field : Str, v : List, #obj : Obj) * (#g_aux_1 == undefined) * (! (#field == "")) * (! (s-nth(#field, 0.) == "@")) * (v == {{ "o", #obj, #field }}) ]]
[[ Pi(#obj, #field, #g_aux_0, undefined, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : Undefined, #field : Str, #obj : Obj, xret : Undefined) * (#g_aux_1 == undefined) * (xret == undefined) * (v == _lvar_v) ]]
normal;

 [[ Pi($lg, #field, #g_aux_0, undefined, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : Undefined, #field : Str, v : List) * (#g_aux_1 == undefined) * (! (#field == "")) * (! (s-nth(#field, 0.) == "@")) * (v == {{ "v", $lg, #field }}) ]]
[[ Pi($lg, #field, #g_aux_0, undefined, #g_aux_2, #g_aux_3, #g_aux_4) * types(#g_aux_1 : Undefined, #field : Str, xret : Undefined) * (#g_aux_1 == undefined) * (xret == undefined) * (v == _lvar_v) ]]
normal;

 [[ types(v : Null) * (v == null) ]]
[[ types(xret : Null) * (xret == null) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Obj) * (v == #v) ]]
[[ types(#v : Obj) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Bool) * (v == #v) ]]
[[ types(#v : Bool) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(v : Undefined) * (v == undefined) ]]
[[ types(xret : Undefined) * (xret == undefined) * (v == _lvar_v) ]]
normal;

 [[ types(#field : Str, v : List) * (! (#field == "")) * (! (s-nth(#field, 0.) == "@")) * (v == {{ "o", undefined, #field }}) ]]
[[ types(#field : Str, xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * ((_$l_xret, "@proto") -> $lrferr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error;

 [[ types(#field : Str, v : List) * (! (#field == "")) * (! (s-nth(#field, 0.) == "@")) * (v == {{ "v", undefined, #field }}) ]]
[[ types(#field : Str, xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * ((_$l_xret, "@proto") -> $lrferr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
error

proc i__getValue (v) {
			goto [(typeOf(v) = List)] rcand dflt;
	rcand:		rtype := l-nth(v, 0.);
			goto [((rtype = "v") or (rtype = "o"))] init dflt;
	init:		rbase := l-nth(v, 1.);
			rfield := l-nth(v, 2.);
			goto [(rbase = undefined)] throw prim;
	prim:		prim := "i__isPrimitive"(rbase);
			goto [prim] is_pr ref;
	is_pr:		xret := "i__toObject"(rbase) with elab;
			xret := "getProperty"(xret, rfield) with elab;
			goto [(xret = undefined)] rlab def;
	def:		d := l-nth(xret, 0.);
			xret := l-nth(xret, 1.);
			goto [(d = "d")] rlab acc;
	acc:		goto [(xret = undefined)] rlab get;
	get:		xsc := [xret, "@scope"];
			fun := [xret, "@call"];
			xret := fun(xsc, rbase) with elab;
			goto [(xret = empty)] undef rlab;
	undef:		xret := undefined;
	ref:		goto [(l-nth(v, 0.) = "o")] oref vref;
	oref:		xret := "get"(rbase, rfield) with elab;
			goto rlab;
	vref:		goto [(rbase = $lg)] lg er;
	lg:		xret := "get"(rbase, rfield) with elab;
			goto rlab;
	er:		xret := [rbase, rfield];
			goto rlab;
	dflt:		xret := v;
	rlab:		skip;
	throw:		xret := "ReferenceError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec ReferenceError_call(xsc, vthis, v)
[[ types(v : Undefined) * (v == undefined) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) ]]
[[ types(xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * ((_$l_xret, "@proto") -> $lrferr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
normal

proc ReferenceError_call (xsc, vthis, v) {
			xret := new();
			xret := "create_default_object"(xret, $lrferr_proto, "Error", true);
			xret := "Error_construct"(undefined, xret, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec SyntaxError(v)
[[ types(v : Undefined) * (v == undefined) ]]
[[ types(xret : Obj) * (xret == _$l_xret) * (v == _lvar_v) * ((_$l_xret, "@proto") -> $lserr_proto) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@extensible") -> true) * empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) ]]
normal

proc SyntaxError (v) {
			xret := "SyntaxError_call"(undefined, undefined, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__abstractEquality(v1, v2)
[[ types(v2 : Null, v1 : Null) * (v2 == null) * (v1 == null) ]]
[[ types(xret : Bool) * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types(_lvar_17 : Null, v2 : Null, _lvar_16 : Obj, v1 : Obj) * (v2 == null) * (v1 == _lvar_16) ]]
[[ types(xret : Bool) * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types(v2 : Num, _lvar_18 : Num, _lvar_19 : Num, v1 : Num) * (! (_lvar_18 == _lvar_19)) * (v2 == _lvar_19) * (v1 == _lvar_18) ]]
[[ types(xret : Bool) * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal

proc i__abstractEquality (v1, v2) {
			tv1 := typeOf(v1);
			tv2 := typeOf(v2);
			goto [(tv1 = tv2)] same diff;
	same:		goto [((((((tv1 = Undefined) or (tv1 = Null)) or (tv1 = Bool)) or (tv1 = Num)) or (tv1 = Str)) or (tv1 = Obj))] ieq oops;
	ieq:		xret := (v1 = v2);
			goto rlab;
	diff:		goto [(((tv1 = Undefined) and (tv2 = Null)) or ((tv1 = Null) and (tv2 = Undefined)))] rt dns;
	dns:		goto [((tv1 = Num) and (tv2 = Str))] tn2 dsn;
	tn2:		xret := "i__toNumber"(v2) with elab;
			xret := "i__abstractEquality"(v1, xret) with elab;
			goto rlab;
	dsn:		goto [((tv1 = Str) and (tv2 = Num))] tn1 s1b;
	tn1:		xret := "i__toNumber"(v1) with elab;
			xret := "i__abstractEquality"(xret, v2) with elab;
			goto rlab;
	s1b:		goto [(tv1 = Bool)] tn1 s2b;
	s2b:		goto [(tv2 = Bool)] tn2 s2o;
	s2o:		goto [(((tv1 = Num) or (tv1 = Str)) and (tv2 = Obj))] tp2 s1o;
	tp2:		xret := "i__toPrimitive"(v2) with elab;
			xret := "i__abstractEquality"(v1, xret) with elab;
			goto rlab;
	s1o:		goto [((tv1 = Obj) and ((tv2 = Num) or (tv2 = Str)))] tp1 rf;
	tp1:		xret := "i__toPrimitive"(v1) with elab;
			xret := "i__abstractEquality"(xret, v2) with elab;
			goto rlab;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
			goto rlab;
	oops:		xret := "AbstractEquality: This should not happen.";
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};



