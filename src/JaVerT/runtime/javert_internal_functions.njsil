import javert_js_predicates.jsil;

spec TypeError_call(xsc, vthis, v)
[[ types() * (xsc == _lvar_xsc) * (v == undefined) * (vthis == _lvar_vthis) ]]
[[ types() * (xret == _$l_xret) * (xsc == _lvar_xsc) * (v == _lvar_v) * (vthis == _lvar_vthis) * Extensible (_$l__lvar_594, true) * MetaData (_$l__lvar_594, null) * empty_fields(_$l__lvar_594 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_594, "@proto") ->@d $lterr_proto) * ((_$l__lvar_594, "@extensible") ->@d true) * ((_$l__lvar_594, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_594) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc TypeError_call (xsc, vthis, v) {
			xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lterr_proto, "Error", true);
			xret := "Error_construct"(undefined, xret, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec TypeError(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_548, true) * MetaData (_$l__lvar_548, null) * empty_fields(_$l__lvar_548 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_548, "@proto") ->@d $lterr_proto) * ((_$l__lvar_548, "@extensible") ->@d true) * ((_$l__lvar_548, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_548) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc TypeError (v) {
			xret := "TypeError_call"(undefined, undefined, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__isCallable(l)
[[ types() * (l == _$l_l) * ((_$l_#md, "@call") ->@d none) * MetaData (_$l_l, _$l_#md) ]]
[[ types() * (xret == false) * (l == _$l_l) * ((_$l_#md, "@call") ->@d none) * MetaData (_$l_l, _$l_#md) ]]
normal;

 [[ types() * (! (#y == none)) * (l == _$l_l) * ((_$l_#md, "@call") ->@d #y) * MetaData (_$l_l, _$l_#md) ]]
[[ types() * (xret == true) * (l == _$l_l) * ((_$l_#md, "@call") ->@d #y) * MetaData (_$l_l, _$l_#md) ]]
normal

proc i__isCallable (l) {
			xret := false;
			goto [((typeOf l) = Obj)] obj rlab;
	obj:		m := metadata (l);
			xret := hasField(m,"@call");
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec defineOwnProperty(l, prop, desc, throw)
[[ types(_lvar_337 : Bool, #throw : Bool, #prop : Str, _lvar_338 : Bool, #desc : List, #cls : Str, _lvar_336 : Bool) * (#desc == {{ "d", _lvar_335, _lvar_336, _lvar_337, _lvar_338 }}) * (! (_lvar_335 == empty)) * (! (#cls == "Array")) * (! (#cls == "String")) * (desc == {{ "d", _lvar_335, _lvar_336, _lvar_337, _lvar_338 }}) * (throw == #throw) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#throw : Bool, #prop : Str, #desc : List, _lvar_341 : Bool, #cls : Str, _lvar_340 : Bool, _lvar_342 : Bool) * (#desc == {{ "d", _lvar_339, _lvar_340, _lvar_341, _lvar_342 }}) * (! (_lvar_339 == empty)) * (desc == _lvar_desc) * (throw == _lvar_throw) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d true) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_339, _lvar_340, _lvar_341, _lvar_342 }}) ]]
normal;

 [[ types(#dcc : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, #cls : Str, #dec : Bool) * (#dcur == {{ "d", _lvar_347, true, #dec, #dcc }}) * (#desc == {{ "g", empty, empty, #gval, empty, empty, empty }}) * (! (_lvar_347 == empty)) * (! (#gval == empty)) * (! (#cls == "Array")) * (desc == {{ "g", empty, empty, #gval, empty, empty, empty }}) * (throw == #throw) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_347, true, #dec, #dcc }}) ]]
[[ types(#dcc : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, #cls : Str, #dec : Bool) * (! (#gval == empty)) * (desc == _lvar_desc) * (throw == _lvar_throw) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", #gval, true, #dec, #dcc }}) ]]
normal;

 [[ types(_lvar_364 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, #cls : Str, _lvar_361 : Bool, _lvar_365 : Bool, _lvar_360 : Bool, _lvar_366 : Bool) * (#dcur == {{ "d", _lvar_359, _lvar_360, _lvar_361, true }}) * (#desc == {{ "d", _lvar_363, _lvar_364, _lvar_365, _lvar_366 }}) * (! (_lvar_363 == empty)) * (! (_lvar_359 == empty)) * (! (#cls == "Array")) * (desc == {{ "d", _lvar_363, _lvar_364, _lvar_365, _lvar_366 }}) * (throw == #throw) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_359, _lvar_360, _lvar_361, true }}) ]]
[[ types(_lvar_369 : Bool, _lvar_368 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, #cls : Str, _lvar_370 : Bool) * (#desc == {{ "d", _lvar_367, _lvar_368, _lvar_369, _lvar_370 }}) * (! (_lvar_367 == empty)) * (! (#cls == "Array")) * (desc == _lvar_desc) * (throw == _lvar_throw) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_367, _lvar_368, _lvar_369, _lvar_370 }}) ]]
normal;

 [[ types(#prop : Str, #dcur : List, #desc : List, _lvar_372 : Bool, #ext : Bool, #cls : Str, #enum : Bool) * (#dcur == {{ "d", _lvar_379, true, #enum, false }}) * (#desc == {{ "d", _lvar_371, _lvar_372, #enum, false }}) * (! (_lvar_379 == empty)) * (! (_lvar_371 == empty)) * (! (#cls == "Array")) * (desc == {{ "d", _lvar_371, _lvar_372, #enum, false }}) * (throw == #throw) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_379, true, #enum, false }}) ]]
[[ types(_lvar_386 : Bool, #prop : Str, #dcur : List, #desc : List, _lvar_384 : Bool, #ext : Bool, #cls : Str, #enum : Bool, _lvar_385 : Bool) * (#desc == {{ "d", _lvar_383, _lvar_384, _lvar_385, _lvar_386 }}) * (! (_lvar_383 == empty)) * (desc == _lvar_desc) * (throw == _lvar_throw) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_383, _lvar_384, _lvar_385, _lvar_386 }}) ]]
normal;

 [[ types(#prop : Str, #cls : Str) * (! (#cls == "Array")) * (desc == #desc) * (throw == true) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d false) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#prop : Str, #cls : Str) * (desc == _lvar_desc) * (throw == _lvar_throw) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d false) * ((_$l_#md, "@class") ->@d #cls) * Extensible (_$l__lvar_391, true) * MetaData (_$l__lvar_391, null) * empty_fields(_$l__lvar_391 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_391, "@proto") ->@d $lterr_proto) * ((_$l__lvar_391, "@extensible") ->@d true) * ((_$l__lvar_391, "@class") ->@d "Error") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_391) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#prop : Str, #cls : Str) * (! (#cls == "Array")) * (desc == #desc) * (throw == false) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d false) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#prop : Str, #cls : Str) * (desc == _lvar_desc) * (throw == _lvar_throw) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d false) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(#prop : Str, #dcur : List, #desc : List, #ext : Bool, _lvar_413 : Bool, #cls : Str, _lvar_414 : Bool, _lvar_405 : Bool, _lvar_406 : Bool) * (#dcur == {{ "d", _lvar_412, _lvar_413, _lvar_414, false }}) * (#desc == {{ "d", _lvar_404, _lvar_405, _lvar_406, true }}) * (! (_lvar_412 == empty)) * (! (_lvar_404 == empty)) * (! (#cls == "Array")) * (desc == {{ "d", _lvar_404, _lvar_405, _lvar_406, true }}) * (throw == true) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_412, _lvar_413, _lvar_414, false }}) ]]
[[ types(_lvar_419 : Bool, #prop : Str, #dcur : List, #desc : List, _lvar_418 : Bool, #ext : Bool, _lvar_420 : Bool, #cls : Str) * (#dcur == {{ "d", _lvar_417, _lvar_418, _lvar_419, _lvar_420 }}) * (! (_lvar_417 == empty)) * (desc == _lvar_desc) * (throw == _lvar_throw) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * Extensible (_$l__lvar_416, true) * MetaData (_$l__lvar_416, null) * empty_fields(_$l__lvar_416 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_416, "@proto") ->@d $lterr_proto) * ((_$l__lvar_416, "@extensible") ->@d true) * ((_$l__lvar_416, "@class") ->@d "Error") * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_417, _lvar_418, _lvar_419, _lvar_420 }}) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_416) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(_lvar_423 : Bool, _lvar_431 : Bool, _lvar_430 : Bool, _lvar_422 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, #cls : Str) * (#dcur == {{ "d", _lvar_429, _lvar_430, _lvar_431, false }}) * (#desc == {{ "d", _lvar_421, _lvar_422, _lvar_423, true }}) * (! (_lvar_429 == empty)) * (! (_lvar_421 == empty)) * (! (#cls == "Array")) * (desc == {{ "d", _lvar_421, _lvar_422, _lvar_423, true }}) * (throw == false) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_429, _lvar_430, _lvar_431, false }}) ]]
[[ types(#prop : Str, #dcur : List, #desc : List, #ext : Bool, _lvar_436 : Bool, #cls : Str, _lvar_435 : Bool, _lvar_434 : Bool) * (#dcur == {{ "d", _lvar_433, _lvar_434, _lvar_435, _lvar_436 }}) * (! (_lvar_433 == empty)) * (desc == _lvar_desc) * (throw == _lvar_throw) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_433, _lvar_434, _lvar_435, _lvar_436 }}) ]]
normal;

 [[ types(_lvar_438 : Bool, #ed : Bool, _lvar_446 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, #cls : Str, #ec : Bool) * (#dcur == {{ "d", _lvar_445, _lvar_446, #ec, false }}) * (#desc == {{ "d", _lvar_437, _lvar_438, #ed, false }}) * (! (_lvar_445 == empty)) * (! (_lvar_437 == empty)) * (! (#ed == #ec)) * (! (#cls == "Array")) * (desc == {{ "d", _lvar_437, _lvar_438, #ed, false }}) * (throw == true) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_445, _lvar_446, #ec, false }}) ]]
[[ types(#ed : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, _lvar_451 : Bool, _lvar_453 : Bool, #cls : Str, _lvar_452 : Bool, #ec : Bool) * (#dcur == {{ "d", _lvar_450, _lvar_451, _lvar_452, _lvar_453 }}) * (! (_lvar_450 == empty)) * (desc == _lvar_desc) * (throw == _lvar_throw) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_450, _lvar_451, _lvar_452, _lvar_453 }}) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_449) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_449, true) * MetaData (_$l__lvar_449, null) * empty_fields(_$l__lvar_449 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_449, "@proto") ->@d $lterr_proto) * ((_$l__lvar_449, "@extensible") ->@d true) * ((_$l__lvar_449, "@class") ->@d "Error") ]]
error;

 [[ types(#ed : Bool, _lvar_455 : Bool, #prop : Str, #dcur : List, #desc : List, _lvar_463 : Bool, #ext : Bool, #cls : Str, #ec : Bool) * (#dcur == {{ "d", _lvar_462, _lvar_463, #ec, false }}) * (#desc == {{ "d", _lvar_454, _lvar_455, #ed, false }}) * (! (_lvar_462 == empty)) * (! (_lvar_454 == empty)) * (! (#ed == #ec)) * (! (#cls == "Array")) * (desc == {{ "d", _lvar_454, _lvar_455, #ed, false }}) * (throw == false) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_462, _lvar_463, #ec, false }}) ]]
[[ types(_lvar_467 : Bool, #ed : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, _lvar_469 : Bool, #cls : Str, _lvar_468 : Bool, #ec : Bool) * (#dcur == {{ "d", _lvar_466, _lvar_467, _lvar_468, _lvar_469 }}) * (! (_lvar_466 == empty)) * (desc == _lvar_desc) * (throw == _lvar_throw) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_466, _lvar_467, _lvar_468, _lvar_469 }}) ]]
normal;

 [[ types(#prop : Str, #dcur : List, #desc : List, #ext : Bool, #en : Bool, #cls : Str) * (#dcur == {{ "d", _lvar_478, false, #en, false }}) * (#desc == {{ "d", _lvar_470, true, #en, false }}) * (! (_lvar_478 == empty)) * (! (_lvar_470 == empty)) * (! (#cls == "Array")) * (desc == {{ "d", _lvar_470, true, #en, false }}) * (throw == true) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_478, false, #en, false }}) ]]
[[ types(_lvar_484 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, #en : Bool, #cls : Str, _lvar_485 : Bool, _lvar_486 : Bool) * (#dcur == {{ "d", _lvar_483, _lvar_484, _lvar_485, _lvar_486 }}) * (! (_lvar_483 == empty)) * (desc == _lvar_desc) * (throw == _lvar_throw) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_483, _lvar_484, _lvar_485, _lvar_486 }}) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_482) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_482, true) * MetaData (_$l__lvar_482, null) * empty_fields(_$l__lvar_482 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_482, "@proto") ->@d $lterr_proto) * ((_$l__lvar_482, "@extensible") ->@d true) * ((_$l__lvar_482, "@class") ->@d "Error") ]]
error;

 [[ types(#prop : Str, #dcur : List, #desc : List, #ext : Bool, #en : Bool, #cls : Str) * (#dcur == {{ "d", _lvar_495, false, #en, false }}) * (#desc == {{ "d", _lvar_487, true, #en, false }}) * (! (_lvar_495 == empty)) * (! (_lvar_487 == empty)) * (! (#cls == "Array")) * (desc == {{ "d", _lvar_487, true, #en, false }}) * (throw == false) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_495, false, #en, false }}) ]]
[[ types(_lvar_501 : Bool, #prop : Str, _lvar_500 : Bool, #dcur : List, #desc : List, #ext : Bool, _lvar_502 : Bool, #en : Bool, #cls : Str) * (#dcur == {{ "d", _lvar_499, _lvar_500, _lvar_501, _lvar_502 }}) * (! (_lvar_499 == empty)) * (desc == _lvar_desc) * (throw == _lvar_throw) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_499, _lvar_500, _lvar_501, _lvar_502 }}) ]]
normal

proc defineOwnProperty (l, prop, desc, throw) {
			m := metadata (l);
			class := [m, "@class"];
			goto [(class = "Array")] adop odop;
	adop:		xret := "a__defineOwnProperty"(l, prop, desc, throw) with elab;
			goto rlab;
	odop:		xret := "o__defineOwnProperty"(l, prop, desc, throw) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__strictEquality(v1, v2)
[[ types() * (#v1 == #v2) * (v2 == #v2) * (v1 == #v1) ]]
[[ types() * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (! (#v1 == #v2)) * (v2 == #v2) * (v1 == #v1) ]]
[[ types() * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal

proc i__strictEquality (v1, v2) {
			xret := (v1 = v2);
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec Error_construct(xsc, vthis, v)
[[ types() * (xsc == _lvar_xsc) * (v == undefined) * (vthis == _$l_#vthis) * Extensible (_$l_#mvt, true) * MetaData (_$l_#mvt, null) * ((_$l_#mvt, "@extensible") ->@d #oe) * ((_$l_#mvt, "@class") ->@d #oc) * Extensible (_$l_#vthis, true) * MetaData (_$l_#vthis, _$l_#mvt) ]]
[[ types() * (xret == _$l_#vthis) * (xsc == _lvar_xsc) * (v == _lvar_v) * (vthis == _lvar_vthis) * Extensible (_$l_#mvt, true) * MetaData (_$l_#mvt, null) * ((_$l_#mvt, "@extensible") ->@d true) * ((_$l_#mvt, "@class") ->@d "Error") * Extensible (_$l_#vthis, true) * MetaData (_$l_#vthis, _$l_#mvt) ]]
normal;

 [[ types(#m : Str) * (xsc == _lvar_xsc) * (v == #m) * (vthis == _$l_#vthis) * ((_$l_#mvt, "@extensible") ->@d #oe) * ((_$l_#mvt, "@class") ->@d #oc) * MetaData (_$l_#vthis, _$l_#mvt) * ((_$l_#vthis, "message") ->@d #om) ]]
[[ types(#m : Str) * (xret == _$l_#vthis) * (xsc == _lvar_xsc) * (v == _lvar_v) * (vthis == _lvar_vthis) * ((_$l_#mvt, "@extensible") ->@d true) * ((_$l_#mvt, "@class") ->@d "Error") * MetaData (_$l_#vthis, _$l_#mvt) * ((_$l_#vthis, "message") ->@d {{ "d", #m, true, false, true }}) ]]
normal

proc Error_construct (xsc, vthis, v) {
			xret := vthis;
			m := metadata (vthis);
			[m, "@class"] := "Error";
			[m, "@extensible"] := true;
			goto [(v = undefined)] rlab mess;
	mess:		xerr := "i__toString"(v) with elab;
			[xret, "message"] := {{ "d", xerr, true, false, true }};
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xerr, elab;
};


spec canPut(l, prop)
[[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, #ext : Bool, #lcls : List) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, #ext : Bool, #lcls : List) * (xret == #ext) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(#l, #prop, {{ "d", _lvar_74, #writ, _lvar_76, _lvar_77 }}, {{ #l }}, #lcls, #lpv) * types(#l : Obj, _lvar_76 : Bool, #lpv : List, #prop : Str, #d : List, _lvar_77 : Bool, #lcls : List, #writ : Bool) * (#d == {{ "d", _lvar_74, #writ, _lvar_76, _lvar_77 }}) * (! (_lvar_74 == empty)) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #d, {{ #l }}, #lcls, #lpv) * types(#l : Obj, #lpv : List, #prop : Str, #d : List, #lcls : List, #writ : Bool) * (xret == #writ) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_80, _lvar_81, _lvar_82, _lvar_83 }}, ({{ _$l_#l, #lp }} @ #other), #lcls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, _lvar_82 : Bool, #d : List, #lcls : List, _lvar_83 : Bool, _lvar_81 : Bool, #other : List) * (#ls == ({{ _$l_#l, #lp }} @ #other)) * (#d == {{ "d", _lvar_80, _lvar_81, _lvar_82, _lvar_83 }}) * (! (_lvar_80 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, #d : List, #lcls : List, #other : List) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_84, #writ, _lvar_86, _lvar_87 }}, ({{ _$l_#l, #lp }} @ #other), #lcls, #lpv) * types(_lvar_86 : Bool, #lpv : List, #ls : List, #prop : Str, #d : List, _lvar_87 : Bool, #lcls : List, #writ : Bool, #other : List) * (#ls == ({{ _$l_#l, #lp }} @ #other)) * (#d == {{ "d", _lvar_84, #writ, _lvar_86, _lvar_87 }}) * (! (_lvar_84 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, #d : List, #lcls : List, #writ : Bool, #other : List) * (xret == #writ) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal

proc canPut (l, prop) {
			[* unfold Pi(#l, #prop, #d, #ls, #lcls, #lpv) *]
			xret := "getOwnProperty"(l, prop) with elab;
			[* fold Pi(#l, #prop, #d, #ls, #lcls, #lpv) *]
	op:		goto [(xret = undefined)] nop odesc;
	odesc:		d := l-nth(xret, 0.);
			goto [(d = "d")] odd nop;
	odd:		xret := l-nth(xret, 2.);
			goto rlab;
	nop:		m := metadata (l);
			e := [m, "@extensible"];
			xret := "getProperty"(l, prop) with elab;
			goto [(xret = undefined)] ext desc;
	desc:		d := l-nth(xret, 0.);
			v := l-nth(xret, 2.);
			goto [(d = "d")] dd ad;
	dd:		goto [e] wr ext;
	wr:		xret := v;
			goto rlab;
	ad:		xret := (not (v = undefined));
			goto rlab;
	ext:		xret := e;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec setupInitialHeap()
[[ types() * Extensible ($lbool_proto, true) * MetaData ($lbool_proto, _$l__lvar_599) * empty_fields($lbool_proto : -{  }-) * Extensible (_$l__lvar_595, true) * MetaData (_$l__lvar_595, null) * empty_fields(_$l__lvar_595 : -{  }-) * Extensible (_$l__lvar_597, true) * MetaData (_$l__lvar_597, null) * empty_fields(_$l__lvar_597 : -{  }-) * Extensible ($lnum_proto, true) * MetaData ($lnum_proto, _$l__lvar_598) * empty_fields($lnum_proto : -{  }-) * Extensible (_$l__lvar_596, true) * MetaData (_$l__lvar_596, null) * empty_fields(_$l__lvar_596 : -{  }-) * Extensible ($lerr_proto, true) * MetaData ($lerr_proto, _$l__lvar_596) * empty_fields($lerr_proto : -{  }-) * Extensible ($lobj_proto, true) * MetaData ($lobj_proto, _$l__lvar_601) * empty_fields($lobj_proto : -{  }-) * Extensible ($lop_hasOwnProperty, true) * MetaData ($lop_hasOwnProperty, _$l__lvar_595) * empty_fields($lop_hasOwnProperty : -{  }-) * Extensible (_$l__lvar_598, true) * MetaData (_$l__lvar_598, null) * empty_fields(_$l__lvar_598 : -{  }-) * Extensible ($lg, true) * MetaData ($lg, _$l__lvar_602) * empty_fields($lg : -{  }-) * Extensible ($lerr, true) * MetaData ($lerr, _$l__lvar_597) * empty_fields($lerr : -{  }-) * Extensible (_$l__lvar_602, true) * MetaData (_$l__lvar_602, null) * empty_fields(_$l__lvar_602 : -{  }-) * Extensible (_$l__lvar_601, true) * MetaData (_$l__lvar_601, null) * empty_fields(_$l__lvar_601 : -{  }-) * Extensible (_$l__lvar_599, true) * MetaData (_$l__lvar_599, null) * empty_fields(_$l__lvar_599 : -{  }-) * Extensible ($lfun_proto, true) * MetaData ($lfun_proto, _$l__lvar_600) * empty_fields($lfun_proto : -{  }-) * Extensible (_$l__lvar_600, true) * MetaData (_$l__lvar_600, null) * empty_fields(_$l__lvar_600 : -{  }-) ]]
[[ types() * (xret == empty) * Extensible ($lbool_proto, true) * MetaData ($lbool_proto, _$l__lvar_607) * empty_fields($lbool_proto : -{ "constructor" }-) * (($lbool_proto, "constructor") ->@d {{ "d", $lbool, true, false, true }}) * Extensible (_$l__lvar_603, true) * MetaData (_$l__lvar_603, null) * empty_fields(_$l__lvar_603 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_603, "@proto") ->@d $lobj_proto) * ((_$l__lvar_603, "@extensible") ->@d true) * ((_$l__lvar_603, "@class") ->@d "Error") * Extensible ($lnum_proto, true) * MetaData ($lnum_proto, _$l__lvar_606) * empty_fields($lnum_proto : -{ "constructor" }-) * (($lnum_proto, "constructor") ->@d {{ "d", $lnum, true, false, true }}) * Extensible (_$l__lvar_607, true) * MetaData (_$l__lvar_607, null) * empty_fields(_$l__lvar_607 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_607, "@proto") ->@d $lobj_proto) * ((_$l__lvar_607, "@primitiveValue") ->@d false) * ((_$l__lvar_607, "@extensible") ->@d true) * ((_$l__lvar_607, "@class") ->@d "Boolean") * Extensible (_$l__lvar_609, true) * MetaData (_$l__lvar_609, null) * empty_fields(_$l__lvar_609 : -{ "@call", "@class", "@extensible", "@proto", "@scope" }-) * ((_$l__lvar_609, "@scope") ->@d empty) * ((_$l__lvar_609, "@proto") ->@d $lobj_proto) * ((_$l__lvar_609, "@extensible") ->@d true) * ((_$l__lvar_609, "@class") ->@d "Function") * ((_$l__lvar_609, "@call") ->@d "FP_default") * Extensible ($lerr_proto, true) * MetaData ($lerr_proto, _$l__lvar_603) * empty_fields($lerr_proto : -{ "message" }-) * (($lerr_proto, "message") ->@d {{ "d", "", true, false, true }}) * Extensible ($lobj_proto, true) * MetaData ($lobj_proto, _$l__lvar_611) * empty_fields($lobj_proto : -{ "hasOwnProperty" }-) * (($lobj_proto, "hasOwnProperty") ->@d {{ "d", $lop_hasOwnProperty, true, false, true }}) * Extensible ($lop_hasOwnProperty, true) * MetaData ($lop_hasOwnProperty, _$l__lvar_610) * empty_fields($lop_hasOwnProperty : -{ "length" }-) * (($lop_hasOwnProperty, "length") ->@d {{ "d", 1., false, false, false }}) * Extensible (_$l__lvar_611, true) * MetaData (_$l__lvar_611, null) * empty_fields(_$l__lvar_611 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_611, "@proto") ->@d null) * ((_$l__lvar_611, "@extensible") ->@d true) * ((_$l__lvar_611, "@class") ->@d "Object") * Extensible ($lg, true) * MetaData ($lg, _$l__lvar_612) * empty_fields($lg : -u- (-{  }-, -{ "Error" }-)) * (($lg, "Error") ->@d {{ "d", $lerr, true, false, true }}) * Extensible ($lerr, true) * MetaData ($lerr, _$l__lvar_605) * empty_fields($lerr : -{ "length", "prototype" }-) * (($lerr, "prototype") ->@d {{ "d", $lerr_proto, false, false, false }}) * (($lerr, "length") ->@d {{ "d", 1., false, false, false }}) * Extensible (_$l__lvar_612, true) * MetaData (_$l__lvar_612, null) * empty_fields(_$l__lvar_612 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_612, "@proto") ->@d $lobj_proto) * ((_$l__lvar_612, "@extensible") ->@d true) * ((_$l__lvar_612, "@class") ->@d "Object") * Extensible (_$l__lvar_610, true) * MetaData (_$l__lvar_610, null) * empty_fields(_$l__lvar_610 : -{ "@call", "@class", "@extensible", "@proto", "@scope" }-) * ((_$l__lvar_610, "@scope") ->@d empty) * ((_$l__lvar_610, "@proto") ->@d $lfun_proto) * ((_$l__lvar_610, "@extensible") ->@d true) * ((_$l__lvar_610, "@class") ->@d "Function") * ((_$l__lvar_610, "@call") ->@d "OP_hasOwnProperty") * Extensible (_$l__lvar_605, true) * MetaData (_$l__lvar_605, null) * empty_fields(_$l__lvar_605 : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope" }-) * ((_$l__lvar_605, "@scope") ->@d empty) * ((_$l__lvar_605, "@proto") ->@d $lfun_proto) * ((_$l__lvar_605, "@extensible") ->@d true) * ((_$l__lvar_605, "@construct") ->@d "Error_construct") * ((_$l__lvar_605, "@class") ->@d "Function") * ((_$l__lvar_605, "@call") ->@d "Error_call") * Extensible ($lfun_proto, true) * MetaData ($lfun_proto, _$l__lvar_609) * empty_fields($lfun_proto : -{ "length" }-) * (($lfun_proto, "length") ->@d {{ "d", 0., false, false, false }}) * Extensible (_$l__lvar_606, true) * MetaData (_$l__lvar_606, null) * empty_fields(_$l__lvar_606 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_606, "@proto") ->@d $lobj_proto) * ((_$l__lvar_606, "@primitiveValue") ->@d 0.) * ((_$l__lvar_606, "@extensible") ->@d true) * ((_$l__lvar_606, "@class") ->@d "Number") ]]
normal

proc setupInitialHeap () {
			xret := "create_default_object"($lg, $lobj_proto, "Object", true);
			xret := "create_default_object"($lobj_proto, null, "Object", true);
			[$lobj_proto, "hasOwnProperty"] := {{ "d", $lop_hasOwnProperty, true, false, true }};
			xret := "create_object_with_call_construct"($lop_hasOwnProperty, "OP_hasOwnProperty", empty, 1.);
			xret := "create_object_with_call_construct"($lfun_proto, "FP_default", empty, 0.);
			m := metadata ($lfun_proto);
			[m, "@proto"] := $lobj_proto;
			xret := "create_default_object"($lbool_proto, $lobj_proto, "Boolean", true);
			m := metadata ($lbool_proto);
			[m, "@primitiveValue"] := false;
			[$lbool_proto, "constructor"] := {{ "d", $lbool, true, false, true }};
			xret := "create_default_object"($lnum_proto, $lobj_proto, "Number", true);
			m := metadata ($lnum_proto);
			[m, "@primitiveValue"] := 0.;
			[$lnum_proto, "constructor"] := {{ "d", $lnum, true, false, true }};
			xret := "create_object_with_call_construct"($lerr, "Error_call", "Error_construct", 1.);
			[$lg, "Error"] := {{ "d", $lerr, true, false, true }};
			[$lerr, "prototype"] := {{ "d", $lerr_proto, false, false, false }};
			xret := "create_default_object"($lerr_proto, $lobj_proto, "Error", true);
			[$lerr_proto, "message"] := {{ "d", "", true, false, true }};
	rlab:		xret := empty
} with {
	ret: xret, rlab;
};


spec i__typeOf(v)
[[ types(#v : Undefined) * (#v == undefined) * (v == undefined) ]]
[[ types(#v : Undefined) * (#v == undefined) * (xret == "undefined") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Null) * (#v == null) * (v == null) ]]
[[ types(#v : Null) * (#v == null) * (xret == "object") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Bool) * (v == #v) ]]
[[ types(#v : Bool) * (xret == "boolean") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == "number") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str) * (xret == "string") * (v == _lvar_v) ]]
normal

proc i__typeOf (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := "undefined";
			goto rlab;
	in:		goto [(v = null)] nll ib;
	nll:		xret := "object";
			goto rlab;
	ib:		goto [((typeOf v) = Bool)] bool inum;
	bool:		xret := "boolean";
			goto rlab;
	inum:		goto [((typeOf v) = Num)] num is;
	num:		xret := "number";
			goto rlab;
	is:		goto [((typeOf v) = Str)] str io;
	str:		xret := "string";
			goto rlab;
	io:		goto [((typeOf v) = Obj)] obj oops;
	obj:		m := metadata (v);
			xret := hasField(m,"@call");
			goto [xret] isfun isobj;
	isobj:		xret := "object";
			goto rlab;
	isfun:		xret := "function";
			goto rlab;
	oops:		xret := "typeOf: This should not happen.";
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec s__getOwnProperty(l, prop)
[[ types(#dx : List, _lvar_513 : Bool, _lvar_515 : Bool, #prop : Str, _lvar_514 : Bool) * (#dx == {{ "d", _lvar_512, _lvar_513, _lvar_514, _lvar_515 }}) * (! (_lvar_512 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_512, _lvar_513, _lvar_514, _lvar_515 }}) ]]
[[ types(#dx : List, #prop : Str, _lvar_522 : Bool, _lvar_523 : Bool, _lvar_521 : Bool) * (#dx == {{ "d", _lvar_520, _lvar_521, _lvar_522, _lvar_523 }}) * (! (_lvar_520 == empty)) * (xret == {{ "d", _lvar_520, _lvar_521, _lvar_522, _lvar_523 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_520, _lvar_521, _lvar_522, _lvar_523 }}) ]]
normal

proc s__getOwnProperty (l, prop) {
			xret := "o__getOwnProperty"(l, prop);
			goto [(xret = undefined)] str rlab;
	str:		idx := "i__toInteger"(prop) with elab;
			goto [(idx < 0.)] rlab next;
	next:		sidx := "i__toString"(idx);
			goto [(sidx = prop)] index rlab;
	index:		m := metadata (l);
			str := [m, "@primitiveValue"];
			len := (s-len str);
			goto [(len <= idx)] rlab return;
	return:		rstr := s-nth(str, idx);
			xret := {{ "d", rstr, false, true, false }};
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec create_function_object(xsc, call, construct, params)
[[ types(#xsc : List, #construct : Str, #params : List, #call : Str) * (#call == #construct) * (call == #call) * (xsc == #xsc) * (params == #params) * (construct == #construct) ]]
[[ types(#xsc : List, #construct : Str, #params : List, #call : Str) * (xret == _$l_xret) * (call == _lvar_call) * (xsc == _lvar_xsc) * (params == _lvar_params) * (construct == _lvar_construct) * Extensible (_$l_#prototype, true) * MetaData (_$l_#prototype, _$l__lvar_503) * empty_fields(_$l_#prototype : -{ "constructor" }-) * ((_$l_#prototype, "constructor") ->@d {{ "d", _$l_xret, true, false, true }}) * Extensible (_$l__lvar_503, true) * MetaData (_$l__lvar_503, null) * empty_fields(_$l__lvar_503 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_503, "@proto") ->@d $lobj_proto) * ((_$l__lvar_503, "@extensible") ->@d true) * ((_$l__lvar_503, "@class") ->@d "Object") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_504) * empty_fields(_$l_xret : -{ "arguments", "caller", "length", "prototype" }-) * ((_$l_xret, "prototype") ->@d {{ "d", _$l_#prototype, true, false, false }}) * ((_$l_xret, "length") ->@d {{ "d", (l-len #params), false, false, false }}) * ((_$l_xret, "caller") ->@d {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }}) * ((_$l_xret, "arguments") ->@d {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }}) * Extensible (_$l__lvar_504, true) * MetaData (_$l__lvar_504, null) * empty_fields(_$l__lvar_504 : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope" }-) * ((_$l__lvar_504, "@scope") ->@d #xsc) * ((_$l__lvar_504, "@proto") ->@d $lfun_proto) * ((_$l__lvar_504, "@extensible") ->@d true) * ((_$l__lvar_504, "@construct") ->@d #call) * ((_$l__lvar_504, "@class") ->@d "Function") * ((_$l__lvar_504, "@call") ->@d #call) ]]
normal

proc create_function_object (xsc, call, construct, params) {
			len := (l-len params);
			m := new(null);
			l := new(m);
			l := "create_object_with_call_construct"(l, call, construct, len);
			[m, "@scope"] := xsc;
			prototype := "Object_construct"();
			[prototype, "constructor"] := {{ "d", l, true, false, true }};
			[l, "prototype"] := {{ "d", prototype, true, false, false }};
			[l, "caller"] := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};
			[l, "arguments"] := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};
			xret := l;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__abstractComparison(v1, v2, leftFirst)
[[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (#v1 <# #v2) * (leftFirst == #leftFirst) * (v2 == #v2) * (v1 == #v1) ]]
[[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (leftFirst == _lvar_leftFirst) * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (#v1 == #v2) * (leftFirst == #leftFirst) * (v2 == #v2) * (v1 == #v1) ]]
[[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (leftFirst == _lvar_leftFirst) * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (#v2 <# #v1) * (leftFirst == #leftFirst) * (v2 == #v2) * (v1 == #v1) ]]
[[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (leftFirst == _lvar_leftFirst) * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal

proc i__abstractComparison (v1, v2, leftFirst) {
			goto [((leftFirst = empty) or (leftFirst = true))] eleft eright;
	eleft:		xret := "i__toPrimitive"(v1, "Number") with elab;
			px := xret;
			xret := "i__toPrimitive"(v2, "Number") with elab;
			py := xret;
			goto is_str;
	eright:		xret := "i__toPrimitive"(v2, "Number") with elab;
			py := xret;
			xret := "i__toPrimitive"(v1, "Number") with elab;
			px := xret;
	is_str:		goto [(((typeOf px) = Str) and ((typeOf py) = Str))] str num;
	str:		xret := (px <s py);
			goto rlab;
	num:		xret := "i__toNumber"(px) with elab;
			nx := xret;
			xret := "i__toNumber"(py) with elab;
			ny := xret;
			goto [((not (nx = nx)) or (not (ny = ny)))] ru eq;
	eq:		goto [(nx = ny)] rf sl;
	sl:		xret := (nx < ny);
			goto rlab;
	ru:		xret := undefined;
			goto rlab;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec Boolean_construct(xsc, vthis, v)
[[ types(#v : Bool) * (xsc == _lvar_xsc) * (v == #v) * (vthis == _lvar_vthis) ]]
[[ types(#v : Bool) * (xret == _$l_xret) * (xsc == _lvar_xsc) * (v == _lvar_v) * (vthis == _lvar_vthis) * Extensible (_$l__lvar_327, true) * MetaData (_$l__lvar_327, null) * empty_fields(_$l__lvar_327 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_327, "@proto") ->@d $lbool_proto) * ((_$l__lvar_327, "@primitiveValue") ->@d #v) * ((_$l__lvar_327, "@extensible") ->@d true) * ((_$l__lvar_327, "@class") ->@d "Boolean") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_327) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc Boolean_construct (xsc, vthis, v) {
			pv := "i__toBoolean"(v);
			xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lbool_proto, "Boolean", true);
			m := metadata (xret);
			[m, "@primitiveValue"] := pv;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__toNumber(v)
[[ types() * (v == null) ]]
[[ types() * (xret == 0.) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == true) ]]
[[ types() * (xret == 1.) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == false) ]]
[[ types() * (xret == 0.) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str) * (xret == (string_to_num #v)) * (v == _lvar_v) ]]
normal

proc i__toNumber (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := nan;
			goto rlab;
	in:		goto [(v = null)] nul ib;
	nul:		xret := 0.;
			goto rlab;
	ib:		goto [((typeOf v) = Bool)] bool inum;
	bool:		goto [(v = true)] is_t is_f;
	is_t:		xret := 1.;
			goto rlab;
	is_f:		xret := 0.;
			goto rlab;
	inum:		goto [((typeOf v) = Num)] num is;
	num:		xret := v;
			goto rlab;
	is:		goto [((typeOf v) = Str)] str io;
	str:		xret := (string_to_num v);
			goto rlab;
	io:		goto [((typeOf v) = Obj)] obj oops;
	obj:		xret := "i__toPrimitive"(v, "Number") with elab;
			xret := "i__toNumber"(xret);
			goto rlab;
	oops:		xret := "TypeError"("ToNumber: This should not happen.");
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec ReferenceError(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_318, true) * MetaData (_$l__lvar_318, null) * empty_fields(_$l__lvar_318 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_318, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_318, "@extensible") ->@d true) * ((_$l__lvar_318, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_318) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc ReferenceError (v) {
			xret := "ReferenceError_call"(undefined, undefined, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec create_default_object(l, pr, cl, ext)
[[ types(#l : Obj) * (#l == _$l_l) * (ext == undefined) * (pr == #pr) * (cl == undefined) * (l == _$l_l) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@proto") ->@d #lvar_0) * ((_$l_#md, "@extensible") ->@d #lvar_2) * ((_$l_#md, "@class") ->@d #lvar_1) * Extensible (_$l_l, true) * MetaData (_$l_l, _$l_#md) ]]
[[ types(#l : Obj) * (ext == _lvar_ext) * (xret == #l) * (pr == _lvar_pr) * (cl == _lvar_cl) * (l == _$l_l) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@proto") ->@d #pr) * ((_$l_#md, "@extensible") ->@d true) * ((_$l_#md, "@class") ->@d "Object") * Extensible (_$l_l, true) * MetaData (_$l_l, _$l_#md) ]]
normal;

 [[ types(#l : Obj, #cl : Str, #ext : Bool) * (#l == _$l_l) * (ext == #ext) * (pr == #pr) * (cl == #cl) * (l == _$l_l) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@proto") ->@d #lvar_3) * ((_$l_#md, "@extensible") ->@d #lvar_5) * ((_$l_#md, "@class") ->@d #lvar_4) * Extensible (_$l_l, true) * MetaData (_$l_l, _$l_#md) ]]
[[ types(#l : Obj, #cl : Str, #ext : Bool) * (ext == _lvar_ext) * (xret == #l) * (pr == _lvar_pr) * (cl == _lvar_cl) * (l == _$l_l) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@proto") ->@d #pr) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cl) * Extensible (_$l_l, true) * MetaData (_$l_l, _$l_#md) ]]
normal

proc create_default_object (l, pr, cl, ext) {
			goto [(cl = undefined)] scl text;
	scl:		cl := "Object";
	text:		goto [(ext = undefined)] sext setall;
	sext:		ext := true;
	setall:		m := metadata (l);
			[m, "@proto"] := pr;
			[m, "@class"] := cl;
			[m, "@extensible"] := ext;
	rlab:		xret := l
} with {
	ret: xret, rlab;
};


spec i__toPrimitive(v, hint)
[[ types() * (v == undefined) * (hint == _lvar_hint) ]]
[[ types() * (xret == undefined) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types() * (v == null) * (hint == _lvar_hint) ]]
[[ types() * (xret == null) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types(#v : Num) * (v == #v) * (hint == _lvar_hint) ]]
[[ types(#v : Num) * (xret == #v) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types(#v : Bool) * (v == #v) * (hint == _lvar_hint) ]]
[[ types(#v : Bool) * (xret == #v) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types(#v : Str) * (v == #v) * (hint == _lvar_hint) ]]
[[ types(#v : Str) * (xret == #v) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal

proc i__toPrimitive (v, hint) {
			xret := v;
			tv := (typeOf v);
	iu:		goto [(((((v = undefined) or (v = null)) or ((typeOf v) = Bool)) or ((typeOf v) = Num)) or ((typeOf v) = Str))] rlab is_obj;
	is_obj:		goto [((typeOf v) = Obj)] obj oops;
	obj:		xret := "defaultValue"(v, hint) with elab;
			goto rlab;
	oops:		xret := "ToPrimitive: This should not happen.";
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec o__getOwnProperty(l, prop)
[[ types(#prop : Str) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#prop : Str) * (xret == undefined) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(#dx : List, #prop : Str, _lvar_103 : Bool, _lvar_102 : Bool, _lvar_104 : Bool) * (#dx == {{ "d", _lvar_101, _lvar_102, _lvar_103, _lvar_104 }}) * (! (_lvar_101 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_101, _lvar_102, _lvar_103, _lvar_104 }}) ]]
[[ types(#dx : List, _lvar_107 : Bool, #prop : Str, _lvar_108 : Bool, _lvar_106 : Bool) * (#dx == {{ "d", _lvar_105, _lvar_106, _lvar_107, _lvar_108 }}) * (! (_lvar_105 == empty)) * (xret == {{ "d", _lvar_105, _lvar_106, _lvar_107, _lvar_108 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_105, _lvar_106, _lvar_107, _lvar_108 }}) ]]
normal

proc o__getOwnProperty (l, prop) {
			x := hasField(l,prop);
			goto [x] hp nhp;
	nhp:		xret := undefined;
			goto rlab;
	hp:		xret := [l, prop];
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec deleteProperty(l, prop, throw)
[[ types(#prop : Str, #cls : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#prop : Str, #cls : Str) * (throw == _lvar_throw) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(_lvar_562 : Bool, #prop : Str, _lvar_563 : Bool, #d : List, #cls : Str) * (#d == {{ "d", _lvar_561, _lvar_562, _lvar_563, true }}) * (! (_lvar_561 == empty)) * (! (#cls == "String")) * (throw == _lvar_throw) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_561, _lvar_562, _lvar_563, true }}) ]]
[[ types(#prop : Str, #d : List, #cls : Str) * (throw == _lvar_throw) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(#prop : Str, #d : List, _lvar_574 : Bool, #cls : Str, _lvar_575 : Bool) * (#d == {{ "d", _lvar_573, _lvar_574, _lvar_575, false }}) * (! (_lvar_573 == empty)) * (! (#cls == "String")) * (throw == false) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_573, _lvar_574, _lvar_575, false }}) ]]
[[ types(#prop : Str, _lvar_579 : Bool, #d : List, #cls : Str, _lvar_580 : Bool, _lvar_578 : Bool) * (#d == {{ "d", _lvar_577, _lvar_578, _lvar_579, _lvar_580 }}) * (! (_lvar_577 == empty)) * (throw == _lvar_throw) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_577, _lvar_578, _lvar_579, _lvar_580 }}) ]]
normal;

 [[ types(_lvar_587 : Bool, #prop : Str, #d : List, #cls : Str, _lvar_586 : Bool) * (#d == {{ "d", _lvar_585, _lvar_586, _lvar_587, false }}) * (! (_lvar_585 == empty)) * (! (#cls == "String")) * (throw == true) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_585, _lvar_586, _lvar_587, false }}) ]]
[[ types(#prop : Str, #d : List, #cls : Str, _lvar_593 : Bool, _lvar_591 : Bool, _lvar_592 : Bool) * (#d == {{ "d", _lvar_590, _lvar_591, _lvar_592, _lvar_593 }}) * (! (_lvar_590 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * Extensible (_$l__lvar_589, true) * MetaData (_$l__lvar_589, null) * empty_fields(_$l__lvar_589 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_589, "@proto") ->@d $lterr_proto) * ((_$l__lvar_589, "@extensible") ->@d true) * ((_$l__lvar_589, "@class") ->@d "Error") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_590, _lvar_591, _lvar_592, _lvar_593 }}) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_589) * empty_fields(_$l_xret : -{  }-) ]]
error

proc deleteProperty (l, prop, throw) {
			xret := "getOwnProperty"(l, prop) with elab;
			goto [(xret = undefined)] dt cont;
	cont:		c := l-nth(xret, 4.);
			goto [c] del reject;
	del:		delete (l,prop);
	dt:		xret := true;
			goto rlab;
	df:		xret := false;
	rlab:		skip;
	reject:		goto [throw] tt df;
	tt:		xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec getOwnProperty(l, prop)
[[ types(#prop : Str, #cls : Str) * (! (#cls == "String")) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#prop : Str, #cls : Str) * (xret == undefined) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(_lvar_542 : Bool, #dx : List, _lvar_543 : Bool, #prop : Str, #cls : Str, _lvar_541 : Bool) * (#dx == {{ "d", _lvar_540, _lvar_541, _lvar_542, _lvar_543 }}) * (! (_lvar_540 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_540, _lvar_541, _lvar_542, _lvar_543 }}) ]]
[[ types(#dx : List, _lvar_546 : Bool, #prop : Str, _lvar_547 : Bool, #cls : Str, _lvar_545 : Bool) * (#dx == {{ "d", _lvar_544, _lvar_545, _lvar_546, _lvar_547 }}) * (! (_lvar_544 == empty)) * (xret == {{ "d", _lvar_544, _lvar_545, _lvar_546, _lvar_547 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_544, _lvar_545, _lvar_546, _lvar_547 }}) ]]
normal

proc getOwnProperty (l, prop) {
			m := metadata (l);
			class := [m, "@class"];
			goto [(class = "String")] sgop ogop;
	sgop:		xret := "s__getOwnProperty"(l, prop) with elab;
			goto rlab;
	ogop:		xret := "o__getOwnProperty"(l, prop) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__toString(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == "undefined") * (v == _lvar_v) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == "null") * (v == _lvar_v) ]]
normal;

 [[ types() * (v == true) ]]
[[ types() * (xret == "true") * (v == _lvar_v) ]]
normal;

 [[ types() * (v == false) ]]
[[ types() * (xret == "false") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == (num_to_string #v)) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str) * (xret == #v) * (v == _lvar_v) ]]
normal

proc i__toString (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := "undefined";
			goto rlab;
	in:		goto [(v = null)] nul ib;
	nul:		xret := "null";
			goto rlab;
	ib:		goto [((typeOf v) = Bool)] bool inum;
	bool:		goto [(v = true)] is_t is_f;
	is_t:		xret := "true";
			goto rlab;
	is_f:		xret := "false";
			goto rlab;
	inum:		goto [((typeOf v) = Num)] num is;
	num:		xret := (num_to_string v);
			goto rlab;
	is:		goto [((typeOf v) = Str)] str io;
	str:		xret := v;
			goto rlab;
	io:		goto [((typeOf v) = Obj)] obj oops;
	obj:		xret := "i__toPrimitive"(v, "String") with elab;
			xret := "i__toString"(xret) with elab;
			goto rlab;
	oops:		xret := "TypeError"("ToString: This should not happen.");
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__checkAssignmentErrors(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_319 : Num) * (v == _lvar_319) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_320 : Bool) * (v == _lvar_320) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_321 : Str) * (v == _lvar_321) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_322 : Obj) * (v == _lvar_322) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(#l : Obj, #prop : Str, #v : List) * (#v == {{ "v", #l, #prop }}) * (! (#prop == "eval")) * (! (#prop == "arguments")) * (v == {{ "v", #l, #prop }}) ]]
[[ types(#l : Obj, #prop : Str, #v : List) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(#l : Obj, #v : List) * (#v == {{ "v", #l, "eval" }}) * (v == {{ "v", #l, "eval" }}) ]]
[[ types(#l : Obj, #v : List) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_323) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_323, true) * MetaData (_$l__lvar_323, null) * empty_fields(_$l__lvar_323 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_323, "@proto") ->@d $lserr_proto) * ((_$l__lvar_323, "@extensible") ->@d true) * ((_$l__lvar_323, "@class") ->@d "Error") ]]
error;

 [[ types(#l : Obj, #v : List) * (#v == {{ "v", #l, "arguments" }}) * (v == {{ "v", #l, "arguments" }}) ]]
[[ types(#l : Obj, #v : List) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_324, true) * MetaData (_$l__lvar_324, null) * empty_fields(_$l__lvar_324 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_324, "@proto") ->@d $lserr_proto) * ((_$l__lvar_324, "@extensible") ->@d true) * ((_$l__lvar_324, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_324) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#v : List, #base : Obj, #field : Str) * (#v == {{ "o", #base, #field }}) * (v == {{ "o", #base, #field }}) ]]
[[ types(#v : List, #base : Obj, #field : Str) * (xret == true) * (v == _lvar_v) ]]
normal

proc i__checkAssignmentErrors (v) {
			tv := (typeOf v);
			goto [(tv = List)] list rlab;
	list:		goto [((l-nth(v, 0.) = "v") or (l-nth(v, 0.) = "o"))] prep rlab;
	prep:		fv := l-nth(v, 2.);
	csyn:		goto [((l-nth(v, 0.) = "v") and ((fv = "eval") or (fv = "arguments")))] se rlab;
	rlab:		xret := true;
	se:		xret := "SyntaxError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec put(l, prop, value, throw)
[[ Pi(_$l_#l, #prop, undefined, ({{ _$l_#l, #lp }} @ #lllp), ({{ #cls, #ccls }} @ #llcls), ({{ "", #pv }} @ #llpv)) * types(#throw : Bool, #ccls : Str, #prop : Str, #pv : Str, #cls : Str, #llpv : List, #lllp : List, #lp : Obj, #llcls : List) * (! (#value == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (prop == #prop) * (value == #value) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #value, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, undefined, ({{ #lp }} @ #lllp), ({{ #ccls }} @ #llcls), ({{ #pv }} @ #llpv)) * types(#throw : Bool, #ccls : Str, #prop : Str, #pv : Str, #cls : Str, #llpv : List, #lllp : List, #lp : Obj, #llcls : List) * (throw == _lvar_throw) * (xret == empty) * (prop == _lvar_prop) * (value == _lvar_value) * (l == _lvar_l) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", #dval, true, #denum, #dconf }}, {{ _$l_#l }}, {{ #cls }}, #lpv) * types(#throw : Bool, #dconf : Bool, #lpv : List, #denum : Bool, #prop : Str, #ext : Bool, #cls : Str) * (! (#value == empty)) * (! (#dval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (prop == #prop) * (value == #value) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #value, true, #denum, #dconf }}, {{ _$l_#l }}, {{ #cls }}, #lpv) * types(#throw : Bool, #dconf : Bool, #lpv : List, #denum : Bool, #prop : Str, #ext : Bool, #cls : Str) * (throw == _lvar_throw) * (xret == empty) * (prop == _lvar_prop) * (value == _lvar_value) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, ({{ _$l_#l, #lp }} @ #lllp), ({{ #cls, #pcls }} @ #ocls), ({{ "", #pv }} @ #llpv)) * types(#throw : Bool, #dcconf : Bool, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #pv : Str, #cls : Str, #llpv : List, #lllp : List, #lp : Obj) * (! (#value == empty)) * (! (#dcval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (prop == #prop) * (value == #value) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #value, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, ({{ #lp }} @ #lllp), ({{ #pcls }} @ #ocls), ({{ #pv }} @ #llpv)) * types(#throw : Bool, #dcconf : Bool, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #pv : Str, #cls : Str, #llpv : List, #lllp : List, #lp : Obj) * (throw == _lvar_throw) * (xret == empty) * (prop == _lvar_prop) * (value == _lvar_value) * (l == _lvar_l) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, undefined, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#throw : Bool, #prop : Str, #cls : Str) * (! (#value == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (prop == #prop) * (value == #value) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #value, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#throw : Bool, #prop : Str, #cls : Str) * (throw == _lvar_throw) * (xret == empty) * (prop == _lvar_prop) * (value == _lvar_value) * (l == _lvar_l) * ((_$l_#md, "@proto") ->@d null) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, #lcls : List) * (throw == true) * (prop == #prop) * (value == #value) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, #lcls : List) * (throw == _lvar_throw) * (xret == _$l_xret) * (prop == _lvar_prop) * (value == _lvar_value) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l__lvar_300, true) * MetaData (_$l__lvar_300, null) * empty_fields(_$l__lvar_300 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_300, "@proto") ->@d $lterr_proto) * ((_$l__lvar_300, "@extensible") ->@d true) * ((_$l__lvar_300, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_300) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_301, false, _lvar_303, _lvar_304 }}, {{ _$l_#l }}, #lcls, #lpv) * types(#lpv : List, #prop : Str, #ext : Bool, #d : List, _lvar_304 : Bool, #lcls : List, _lvar_303 : Bool) * (#d == {{ "d", _lvar_301, false, _lvar_303, _lvar_304 }}) * (! (_lvar_301 == empty)) * (throw == true) * (prop == #prop) * (value == #value) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, {{ _$l_#l }}, #lcls, #lpv) * types(#lpv : List, #prop : Str, #ext : Bool, #d : List, #lcls : List) * (throw == _lvar_throw) * (xret == _$l_xret) * (prop == _lvar_prop) * (value == _lvar_value) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l__lvar_305, true) * MetaData (_$l__lvar_305, null) * empty_fields(_$l__lvar_305 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_305, "@proto") ->@d $lterr_proto) * ((_$l__lvar_305, "@extensible") ->@d true) * ((_$l__lvar_305, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_305) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_308, _lvar_309, _lvar_310, _lvar_311 }}, ({{ _$l_#l, #lp }} @ #other), #lcls, #lpv) * types(_lvar_309 : Bool, _lvar_310 : Bool, #lpv : List, #ls : List, #prop : Str, _lvar_311 : Bool, #d : List, #lcls : List, #lp : Obj, #other : List) * (#ls == ({{ _$l_#l, #lp }} @ #other)) * (#d == {{ "d", _lvar_308, _lvar_309, _lvar_310, _lvar_311 }}) * (! (_lvar_308 == empty)) * (throw == true) * (prop == #prop) * (value == #value) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, #d : List, #lcls : List, #lp : Obj, #other : List) * (throw == _lvar_throw) * (xret == _$l_xret) * (prop == _lvar_prop) * (value == _lvar_value) * (l == _lvar_l) * Extensible (_$l__lvar_312, true) * MetaData (_$l__lvar_312, null) * empty_fields(_$l__lvar_312 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_312, "@proto") ->@d $lterr_proto) * ((_$l__lvar_312, "@extensible") ->@d true) * ((_$l__lvar_312, "@class") ->@d "Error") * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_312) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_313, false, _lvar_315, _lvar_316 }}, ({{ _$l_#l, #lp }} @ #other), #lcls, #lpv) * types(_lvar_316 : Bool, _lvar_315 : Bool, #lpv : List, #ls : List, #prop : Str, #d : List, #lcls : List, #lp : Obj, #other : List) * (#ls == ({{ _$l_#l, #lp }} @ #other)) * (#d == {{ "d", _lvar_313, false, _lvar_315, _lvar_316 }}) * (! (_lvar_313 == empty)) * (throw == true) * (prop == #prop) * (value == #value) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, #d : List, #lcls : List, #lp : Obj, #other : List) * (throw == _lvar_throw) * (xret == _$l_xret) * (prop == _lvar_prop) * (value == _lvar_value) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d true) * Extensible (_$l__lvar_317, true) * MetaData (_$l__lvar_317, null) * empty_fields(_$l__lvar_317 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_317, "@proto") ->@d $lterr_proto) * ((_$l__lvar_317, "@extensible") ->@d true) * ((_$l__lvar_317, "@class") ->@d "Error") * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_317) * empty_fields(_$l_xret : -{  }-) ]]
error

proc put (l, prop, value, throw) {
			xret := "canPut"(l, prop) with elab;
			goto [xret] cp reject;
			[* unfold Pi(#l, #prop, #d, #ls, #lcls, #lpv) *]
	cp:		xret := "getOwnProperty"(l, prop) with elab;
			dd := "i__isDataDescriptor"(xret);
			goto [dd] dd gp;
	dd:		desc := {{ "g", empty, empty, value, empty, empty, empty }};
			xret := "defineOwnProperty"(l, prop, desc, throw) with elab;
			[* fold Pi(#l, #prop, {{ "d", #value, true, #denum, #dconf }}, {{ #l }}, #lvar_19, #lvar_20) *]
			goto remp;
			[* fold Pi(#l, #prop, #d, #ls, #lcls, #lpv) *]
	gp:		xret := "getProperty"(l, prop) with elab;
			ad := "i__isAccessorDescriptor"(xret);
			goto [ad] ad def;
	ad:		s := l-nth(xret, 2.);
			xsc := [s, "@scope"];
			fun := [s, "@call"];
			xret := fun(xsc, l, value) with elab;
			goto remp;
	def:		desc := {{ "d", value, true, true, true }};
			[* unfold Pi(#l, #prop, #d, #ls, #lcls, #lpv) *]
			xret := "defineOwnProperty"(l, prop, desc, throw) with elab;
			[* fold Pi(#l, #prop, {{ "d", #value, true, true, true }}, {{ #l }}, #lvar_21, #lvar_22) *]
			skip;
	remp:		xret := empty;
	rlab:		skip;
	reject:		xret := empty;
			goto [throw] tt rlab;
	tt:		xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__putValue(v, w)
[[ types() * (w == _lvar_w) * (v == undefined) ]]
[[ types() * (w == _lvar_w) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_187) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_187, true) * MetaData (_$l__lvar_187, null) * empty_fields(_$l__lvar_187 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_187, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_187, "@extensible") ->@d true) * ((_$l__lvar_187, "@class") ->@d "Error") ]]
error;

 [[ types() * (w == _lvar_w) * (v == null) ]]
[[ types() * (w == _lvar_w) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_188, true) * MetaData (_$l__lvar_188, null) * empty_fields(_$l__lvar_188 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_188, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_188, "@extensible") ->@d true) * ((_$l__lvar_188, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_188) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(_lvar_190 : Num) * (w == _lvar_w) * (v == _lvar_190) ]]
[[ types() * (w == _lvar_w) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_189, true) * MetaData (_$l__lvar_189, null) * empty_fields(_$l__lvar_189 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_189, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_189, "@extensible") ->@d true) * ((_$l__lvar_189, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_189) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(_lvar_192 : Bool) * (w == _lvar_w) * (v == _lvar_192) ]]
[[ types() * (w == _lvar_w) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_191) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_191, true) * MetaData (_$l__lvar_191, null) * empty_fields(_$l__lvar_191 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_191, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_191, "@extensible") ->@d true) * ((_$l__lvar_191, "@class") ->@d "Error") ]]
error;

 [[ types(_lvar_194 : Str) * (w == _lvar_w) * (v == _lvar_194) ]]
[[ types() * (w == _lvar_w) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_193, true) * MetaData (_$l__lvar_193, null) * empty_fields(_$l__lvar_193 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_193, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_193, "@extensible") ->@d true) * ((_$l__lvar_193, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_193) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(_lvar_196 : Obj) * (w == _lvar_w) * (v == _lvar_196) ]]
[[ types() * (w == _lvar_w) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_195, true) * MetaData (_$l__lvar_195, null) * empty_fields(_$l__lvar_195 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_195, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_195, "@extensible") ->@d true) * ((_$l__lvar_195, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_195) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types() * (! (#w == empty)) * (w == #w) * (v == {{ "v", _$l_#obj, #field }}) * ((_$l_#obj, #field) ->@d #lvar_23) ]]
[[ types() * (w == _lvar_w) * (xret == empty) * (v == _lvar_v) * ((_$l_#obj, #field) ->@d #w) ]]
normal;

 [[ Pi(_$l_#l, #prop, undefined, ({{ _$l_#l, #lp }} @ #lllp), ({{ #cls, #pcls }} @ #ocls), ({{ "", #pv }} @ #llpv)) * types(#pcls : Str, #ocls : List, #prop : Str, #pv : Str, #cls : Str, #llpv : List, #lllp : List, #lp : Obj) * (! (#w == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (w == #w) * (v == {{ "o", _$l_#l, #prop }}) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #w, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, undefined, ({{ #lp }} @ #lllp), ({{ #pcls }} @ #ocls), ({{ #pv }} @ #llpv)) * types(#pcls : Str, #ocls : List, #prop : Str, #pv : Str, #cls : Str, #llpv : List, #lllp : List, #lp : Obj) * (w == _lvar_w) * (xret == empty) * (v == _lvar_v) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi($lg, #prop, undefined, ({{ $lg, #lp }} @ #lllp), ({{ #cls, #pcls }} @ #ocls), ({{ "", #pv }} @ #llpv)) * types(#pcls : Str, #ocls : List, #prop : Str, #pv : Str, #cls : Str, #llpv : List, #lllp : List, #lp : Obj) * (! (#w == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (w == #w) * (v == {{ "v", $lg, #prop }}) * ((_$l_#md, "@extensible") ->@d true) * MetaData ($lg, _$l_#md) ]]
[[ Pi($lg, #prop, {{ "d", #w, true, true, true }}, {{ $lg }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, undefined, ({{ #lp }} @ #lllp), ({{ #pcls }} @ #ocls), ({{ #pv }} @ #llpv)) * types(#pcls : Str, #ocls : List, #prop : Str, #pv : Str, #cls : Str, #llpv : List, #lllp : List, #lp : Obj) * (w == _lvar_w) * (xret == empty) * (v == _lvar_v) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData ($lg, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", #dval, true, #denum, #dconf }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#dconf : Bool, #denum : Bool, #prop : Str, #ext : Bool, #cls : Str) * (! (#w == empty)) * (! (#dval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (w == #w) * (v == {{ "o", _$l_#l, #prop }}) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #w, true, #denum, #dconf }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#dconf : Bool, #denum : Bool, #prop : Str, #ext : Bool, #cls : Str) * (w == _lvar_w) * (xret == empty) * (v == _lvar_v) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi($lg, #prop, {{ "d", #dval, true, #denum, #dconf }}, {{ $lg }}, {{ #cls }}, {{ "" }}) * types(#dconf : Bool, #denum : Bool, #prop : Str, #ext : Bool, #cls : Str) * (! (#w == empty)) * (! (#dval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (w == #w) * (v == {{ "v", $lg, #prop }}) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData ($lg, _$l_#md) ]]
[[ Pi($lg, #prop, {{ "d", #w, true, #denum, #dconf }}, {{ $lg }}, {{ #cls }}, {{ "" }}) * types(#dconf : Bool, #denum : Bool, #prop : Str, #ext : Bool, #cls : Str) * (w == _lvar_w) * (xret == empty) * (v == _lvar_v) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData ($lg, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, ({{ _$l_#l, #lp }} @ #lllp), ({{ #cls, #pcls }} @ #ocls), ({{ "", #pv }} @ #llpv)) * types(#dcconf : Bool, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #pv : Str, #cls : Str, #llpv : List, #lllp : List, #lp : Obj) * (! (#w == empty)) * (! (#dcval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (w == #w) * (v == {{ "o", _$l_#l, #prop }}) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #w, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, ({{ #lp }} @ #lllp), ({{ #pcls }} @ #ocls), ({{ #pv }} @ #llpv)) * types(#dcconf : Bool, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #pv : Str, #cls : Str, #llpv : List, #lllp : List, #lp : Obj) * (w == _lvar_w) * (xret == empty) * (v == _lvar_v) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi($lg, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, ({{ $lg, #lp }} @ #lllp), ({{ #cls, #pcls }} @ #ocls), ({{ "", #pv }} @ #llpv)) * types(#dcconf : Bool, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #pv : Str, #cls : Str, #llpv : List, #lllp : List, #lp : Obj) * (! (#w == empty)) * (! (#dcval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (w == #w) * (v == {{ "v", $lg, #prop }}) * ((_$l_#md, "@extensible") ->@d true) * MetaData ($lg, _$l_#md) ]]
[[ Pi($lg, #prop, {{ "d", #w, true, true, true }}, {{ $lg }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, ({{ #lp }} @ #lllp), ({{ #pcls }} @ #ocls), ({{ #pv }} @ #llpv)) * types(#dcconf : Bool, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #pv : Str, #cls : Str, #llpv : List, #lllp : List, #lp : Obj) * (w == _lvar_w) * (xret == empty) * (v == _lvar_v) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData ($lg, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, undefined, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#prop : Str, #cls : Str) * (! (#w == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (w == #w) * (v == {{ "o", _$l_#l, #prop }}) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #w, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#prop : Str, #cls : Str) * (w == _lvar_w) * (xret == empty) * (v == _lvar_v) * ((_$l_#md, "@proto") ->@d null) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, #lcls : List) * (w == #w) * (v == {{ "o", _$l_#l, #prop }}) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, #lcls : List) * (w == _lvar_w) * (xret == _$l_xret) * (v == _lvar_v) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l__lvar_250, true) * MetaData (_$l__lvar_250, null) * empty_fields(_$l__lvar_250 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_250, "@proto") ->@d $lterr_proto) * ((_$l__lvar_250, "@extensible") ->@d true) * ((_$l__lvar_250, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_250) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_251, false, _lvar_253, _lvar_254 }}, {{ _$l_#l }}, #lcls, #lpv) * types(#lpv : List, #prop : Str, #ext : Bool, #d : List, _lvar_253 : Bool, #lcls : List, _lvar_254 : Bool) * (#d == {{ "d", _lvar_251, false, _lvar_253, _lvar_254 }}) * (! (_lvar_251 == empty)) * (w == #w) * (v == {{ "o", _$l_#l, #prop }}) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, {{ _$l_#l }}, #lcls, #lpv) * types(#lpv : List, #prop : Str, #ext : Bool, #d : List, #lcls : List) * (w == _lvar_w) * (xret == _$l_xret) * (v == _lvar_v) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_255) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_255, true) * MetaData (_$l__lvar_255, null) * empty_fields(_$l__lvar_255 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_255, "@proto") ->@d $lterr_proto) * ((_$l__lvar_255, "@extensible") ->@d true) * ((_$l__lvar_255, "@class") ->@d "Error") ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_258, _lvar_259, _lvar_260, _lvar_261 }}, ({{ _$l_#l, #lp }} @ #other), #cls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, _lvar_260 : Bool, #d : List, #cls : List, _lvar_261 : Bool, _lvar_259 : Bool, #lp : Obj, #other : List) * (#ls == ({{ _$l_#l, #lp }} @ #other)) * (#d == {{ "d", _lvar_258, _lvar_259, _lvar_260, _lvar_261 }}) * (! (_lvar_258 == empty)) * (w == #w) * (v == {{ "o", _$l_#l, #prop }}) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #cls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, #d : List, #cls : List, #lp : Obj, #other : List) * (w == _lvar_w) * (xret == _$l_xret) * (v == _lvar_v) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_262) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_262, true) * MetaData (_$l__lvar_262, null) * empty_fields(_$l__lvar_262 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_262, "@proto") ->@d $lterr_proto) * ((_$l__lvar_262, "@extensible") ->@d true) * ((_$l__lvar_262, "@class") ->@d "Error") ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_263, false, _lvar_265, _lvar_266 }}, ({{ _$l_#l, #lp }} @ #other), #lcls, #lpv) * types(_lvar_266 : Bool, #lpv : List, #ls : List, #prop : Str, #d : List, _lvar_265 : Bool, #lcls : List, #lp : Obj, #other : List) * (#ls == ({{ _$l_#l, #lp }} @ #other)) * (#d == {{ "d", _lvar_263, false, _lvar_265, _lvar_266 }}) * (! (_lvar_263 == empty)) * (w == #w) * (v == {{ "o", _$l_#l, #prop }}) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, #d : List, #lcls : List, #lp : Obj, #other : List) * (w == _lvar_w) * (xret == _$l_xret) * (v == _lvar_v) * ((_$l_#md, "@extensible") ->@d false) * Extensible (_$l__lvar_267, true) * MetaData (_$l__lvar_267, null) * empty_fields(_$l__lvar_267 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_267, "@proto") ->@d $lterr_proto) * ((_$l__lvar_267, "@extensible") ->@d true) * ((_$l__lvar_267, "@class") ->@d "Error") * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_267) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi($lg, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, #lcls : List) * (w == #w) * (v == {{ "v", $lg, #prop }}) * ((_$l_#md, "@extensible") ->@d false) * MetaData ($lg, _$l_#md) ]]
[[ Pi($lg, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #prop : Str, #lcls : List) * (w == _lvar_w) * (xret == _$l_xret) * (v == _lvar_v) * ((_$l_#md, "@extensible") ->@d false) * MetaData ($lg, _$l_#md) * Extensible (_$l__lvar_268, true) * MetaData (_$l__lvar_268, null) * empty_fields(_$l__lvar_268 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_268, "@proto") ->@d $lterr_proto) * ((_$l__lvar_268, "@extensible") ->@d true) * ((_$l__lvar_268, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_268) * empty_fields(_$l_xret : -{  }-) ]]
error

proc i__putValue (v, w) {
			goto [((typeOf v) = List)] list throw;
	list:		goto [((l-nth(v, 0.) = "v") or (l-nth(v, 0.) = "o"))] init throw;
	init:		rbase := l-nth(v, 1.);
			rfield := l-nth(v, 2.);
			goto [(rbase = undefined)] throw prim;
	prim:		prim := "i__isPrimitive"(rbase);
			goto [prim] is_pr refr;
	refr:		goto [(((typeOf v) = List) and (l-nth(v, 0.) = "o"))] oref vref;
	oref:		xret := "put"(rbase, rfield, w, true) with elab;
			goto dflt;
	vref:		goto [(rbase = $lg)] lg er;
	lg:		xret := "put"(rbase, rfield, w, true) with elab;
			goto dflt;
	er:		[rbase, rfield] := w;
	dflt:		xret := empty;
	rlab:		skip;
	throw:		xret := "ReferenceError"();
	elab:		skip;
	is_pr:		xret := "i__toObject"(rbase) with elab;
			l := xret;
			xret := "canPut"(l, rfield) with elab;
			goto [xret] cp reject;
	cp:		xret := "getProperty"(l, rfield) with elab;
			dd := "i__isDataDescriptor"(xret);
			goto [dd] reject is_ad;
	is_ad:		ad := "i__isAccessorDescriptor"(xret);
			goto [ad] ad reject;
	ad:		s := l-nth(xret, 2.);
			m := metadata (s);
			xsc := [m, "@scope"];
			fun := [m, "@call"];
			xret := fun(xsc, rbase, w) with elab;
			goto dflt;
	reject:		xret := "TypeError"();
			goto elab
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec OP_hasOwnProperty(xsc, vthis, v)
[[ types(#co : Bool, #prop : Str, #en : Bool, #wr : Bool) * (! (#v == empty)) * (xsc == _lvar_xsc) * (v == #prop) * (vthis == _$l_#l) * ((_$l_#md, "@class") ->@d "Object") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", #v, #wr, #en, #co }}) ]]
[[ types(#co : Bool, #prop : Str, #en : Bool, #wr : Bool) * (! (#v == empty)) * (xret == true) * (xsc == _lvar_xsc) * (v == _lvar_v) * (vthis == _lvar_vthis) * ((_$l_#md, "@class") ->@d "Object") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", #v, #wr, #en, #co }}) ]]
normal;

 [[ types(#prop : Str) * (xsc == _lvar_xsc) * (v == #prop) * (vthis == _$l_#l) * ((_$l_#md, "@class") ->@d "Object") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#prop : Str) * (xret == false) * (xsc == _lvar_xsc) * (v == _lvar_v) * (vthis == _lvar_vthis) * ((_$l_#md, "@class") ->@d "Object") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal

proc OP_hasOwnProperty (xsc, vthis, v) {
			xret := "i__toString"(v) with elab;
			p := xret;
			xret := "i__toObject"(vthis) with elab;
			xret := "getOwnProperty"(xret, p) with elab;
			xret := (not (xret = undefined));
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec hasProperty(l, prop)
[[ Pi(#l, #prop, undefined, #ls, #cls, #pv) * types(#l : Obj, #ls : List, #prop : Str, #pv : List, #cls : List) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, undefined, #ls, #cls, #pv) * types(#l : Obj, #ls : List, #prop : Str, #pv : List, #cls : List) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal;

 [[ Pi(#l, #prop, {{ "d", _lvar_157, _lvar_158, _lvar_159, _lvar_160 }}, #ls, #cls, #pv) * types(_lvar_158 : Bool, #l : Obj, #ls : List, #prop : Str, #pv : List, #d : List, #cls : List, _lvar_159 : Bool, _lvar_160 : Bool) * (#d == {{ "d", _lvar_157, _lvar_158, _lvar_159, _lvar_160 }}) * (! (_lvar_157 == empty)) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #d, #ls, #cls, #pv) * types(#l : Obj, #ls : List, #prop : Str, #pv : List, #d : List, #cls : List) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal

proc hasProperty (l, prop) {
			xret := "getProperty"(l, prop) with elab;
	rlab:		xret := (not (xret = undefined));
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec create_object_with_call_construct(l, call, construct, len)
[[ types(#len : Num, #call : Str) * (call == #call) * (l == _$l_#l) * (construct == empty) * (len == #len) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@scope") ->@d #lvar_10) * ((_$l_#md, "@proto") ->@d #lvar_7) * ((_$l_#md, "@extensible") ->@d #lvar_9) * ((_$l_#md, "@class") ->@d #lvar_8) * ((_$l_#md, "@call") ->@d #lvar_11) * Extensible (_$l_#l, true) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, "length") ->@d #lvar_6) ]]
[[ types(#len : Num, #call : Str) * (xret == _$l_#l) * (call == _lvar_call) * (l == _lvar_l) * (construct == _lvar_construct) * (len == _lvar_len) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@scope") ->@d empty) * ((_$l_#md, "@proto") ->@d $lfun_proto) * ((_$l_#md, "@extensible") ->@d true) * ((_$l_#md, "@class") ->@d "Function") * ((_$l_#md, "@call") ->@d #call) * Extensible (_$l_#l, true) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, "length") ->@d {{ "d", #len, false, false, false }}) ]]
normal;

 [[ types(#construct : Str, #len : Num, #call : Str) * (call == #call) * (l == _$l_#l) * (construct == #construct) * (len == #len) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@scope") ->@d #lvar_16) * ((_$l_#md, "@proto") ->@d #lvar_13) * ((_$l_#md, "@extensible") ->@d #lvar_15) * ((_$l_#md, "@construct") ->@d #lvar_18) * ((_$l_#md, "@class") ->@d #lvar_14) * ((_$l_#md, "@call") ->@d #lvar_17) * Extensible (_$l_#l, true) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, "length") ->@d #lvar_12) ]]
[[ types(#construct : Str, #len : Num, #call : Str) * (xret == _$l_#l) * (call == _lvar_call) * (l == _lvar_l) * (construct == _lvar_construct) * (len == _lvar_len) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@scope") ->@d empty) * ((_$l_#md, "@proto") ->@d $lfun_proto) * ((_$l_#md, "@extensible") ->@d true) * ((_$l_#md, "@construct") ->@d #construct) * ((_$l_#md, "@class") ->@d "Function") * ((_$l_#md, "@call") ->@d #call) * Extensible (_$l_#l, true) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, "length") ->@d {{ "d", #len, false, false, false }}) ]]
normal

proc create_object_with_call_construct (l, call, construct, len) {
			xret := "create_default_object"(l, $lfun_proto, "Function", true);
			[xret, "length"] := {{ "d", len, false, false, false }};
			m := metadata (xret);
			[m, "@scope"] := empty;
			[m, "@call"] := call;
			goto [(construct = empty)] rlab cstr;
	cstr:		[m, "@construct"] := construct;
	rlab:		xret := l
} with {
	ret: xret, rlab;
};


spec i__isPrimitive(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_70 : Num) * (v == _lvar_70) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_71 : Bool) * (v == _lvar_71) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_72 : Str) * (v == _lvar_72) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_73 : Obj) * (v == _lvar_73) ]]
[[ types() * (xret == false) * (v == _lvar_v) ]]
normal

proc i__isPrimitive (v) {
			tv := (typeOf v);
	iu:		goto [(((((v = undefined) or (v = null)) or ((typeOf v) = Bool)) or ((typeOf v) = Num)) or ((typeOf v) = Str))] rt rf;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec Object_construct(xsc, vthis, l)
[[ types(#l : Undefined) * (#l == undefined) * (xsc == _lvar_xsc) * (l == undefined) * (vthis == _lvar_vthis) ]]
[[ types(#l : Undefined) * (#l == undefined) * (xret == _$l_xret) * (xsc == _lvar_xsc) * (l == _lvar_l) * (vthis == _lvar_vthis) * Extensible (_$l__lvar_69, true) * MetaData (_$l__lvar_69, null) * empty_fields(_$l__lvar_69 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_69, "@proto") ->@d $lobj_proto) * ((_$l__lvar_69, "@extensible") ->@d true) * ((_$l__lvar_69, "@class") ->@d "Object") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_69) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc Object_construct (xsc, vthis, l) {
			goto [((typeOf l) = Obj)] obj l1b;
	obj:		xret := l;
			goto rlab;
	l1b:		goto [((((typeOf l) = Bool) or ((typeOf l) = Num)) or ((typeOf l) = Str))] to_obj norm;
	to_obj:		xret := "i__toObject"(l);
			goto rlab;
	norm:		xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lobj_proto, "Object", true);
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__sameValue(v1, v2)
[[ types() * (v2 == 0.) * (v1 == 0.) ]]
[[ types() * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (v2 == -0.) * (v1 == -0.) ]]
[[ types() * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (v2 == 0.) * (v1 == -0.) ]]
[[ types() * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (v2 == -0.) * (v1 == 0.) ]]
[[ types() * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (v2 == _lvar_507) * (v1 == _lvar_507) ]]
[[ types() * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (! (_lvar_v1 == _lvar_v2)) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
[[ types() * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal

proc i__sameValue (v1, v2) {
			goto [((typeOf v1) = Num)] test2 nonum;
	test2:		goto [((typeOf v2) = Num)] inan1 nonum;
	inan1:		goto [(not (v1 = v1))] inan2 zero1;
	inan2:		goto [(not (v2 = v2))] rt zero1;
	zero1:		goto [(v1 = 0.)] zero2 nonum;
	zero2:		goto [(v2 = 0.)] fix nonum;
	fix:		sv1 := (m_sgn v1);
			sv2 := (m_sgn v2);
			goto [(sv1 = sv2)] rt rf;
			goto rlab;
	nonum:		goto [(v1 = v2)] rt rf;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__toObject(v)
[[ types(#v : Obj) * (v == #v) ]]
[[ types(#v : Obj) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Bool) * (v == #v) ]]
[[ types(#v : Bool) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_505, true) * MetaData (_$l__lvar_505, null) * empty_fields(_$l__lvar_505 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_505, "@proto") ->@d $lbool_proto) * ((_$l__lvar_505, "@primitiveValue") ->@d #v) * ((_$l__lvar_505, "@extensible") ->@d true) * ((_$l__lvar_505, "@class") ->@d "Boolean") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_505) * empty_fields(_$l_xret : -{  }-) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_506, true) * MetaData (_$l__lvar_506, null) * empty_fields(_$l__lvar_506 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_506, "@proto") ->@d $lnum_proto) * ((_$l__lvar_506, "@primitiveValue") ->@d #v) * ((_$l__lvar_506, "@extensible") ->@d true) * ((_$l__lvar_506, "@class") ->@d "Number") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_506) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc i__toObject (v) {
	iu:		goto [(v = undefined)] throw in;
	in:		goto [(v = null)] throw ib;
	ib:		goto [((typeOf v) = Bool)] bool inum;
	bool:		xret := "Boolean_construct"(undefined, undefined, v);
			goto rlab;
	inum:		goto [((typeOf v) = Num)] num is;
	num:		xret := "Number_construct"(undefined, undefined, v);
			goto rlab;
	is:		goto [((typeOf v) = Str)] str io;
	str:		xret := "String_construct"(undefined, undefined, v);
			goto rlab;
	io:		goto [((typeOf v) = Obj)] obj oops;
	obj:		xret := v;
			goto rlab;
	oops:		xret := "ToObject: This should not happen.";
	rlab:		skip;
	throw:		xret := "Here!";
			xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__toBoolean(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == false) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == false) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Bool) * (v == #v) ]]
[[ types(#v : Bool) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == 0.) ]]
[[ types() * (xret == false) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (! (#v == 0.)) * (v == #v) ]]
[[ types(#v : Num) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == "") ]]
[[ types() * (xret == false) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (! (#v == "")) * (v == #v) ]]
[[ types(#v : Str) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Obj) * (v == #v) ]]
[[ types(#v : Obj) * (xret == true) * (v == _lvar_v) ]]
normal

proc i__toBoolean (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := false;
			goto rlab;
	in:		goto [(v = null)] nul ib;
	nul:		xret := false;
			goto rlab;
	ib:		goto [((typeOf v) = Bool)] bool inum;
	bool:		xret := v;
			goto rlab;
	inum:		goto [((typeOf v) = Num)] num is;
	num:		goto [((v = 0.) or (not (v = v)))] is_f is_t;
	is:		goto [((typeOf v) = Str)] str io;
	str:		goto [(v = "")] is_f is_t;
			goto rlab;
	io:		goto [((typeOf v) = Obj)] obj oops;
	obj:		xret := true;
			goto rlab;
	is_t:		xret := true;
			goto rlab;
	is_f:		xret := false;
			goto rlab;
	oops:		xret := "ToBoolean: This should not happen.";
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec getProperty(l, prop)
[[ Pi(#l, #prop, #d, #ls, #cls, #pv) * types(#l : Obj, #ls : List, #prop : Str, #pv : List, #cls : List) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #d, #ls, #cls, #pv) * types(#l : Obj, #ls : List, #prop : Str, #pv : List, #cls : List) * (xret == #d) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal

proc getProperty (l, prop) {
			[* unfold Pi(#l, #prop, #d, #ls, #cls, #pv) *]
			xret := "getOwnProperty"(l, prop) with elab;
			goto [(xret = undefined)] next rlab;
	next:		m := metadata (l);
			proto := [m, "@proto"];
			goto [(proto = null)] rlab call;
	call:		xret := "getProperty"(proto, prop) with elab;
			[* fold Pi(#l, #prop, #d, #ls, #cls, #pv) *]
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec Number_construct(xsc, vthis, v)
[[ types(#v : Num) * (xsc == _lvar_xsc) * (v == #v) * (vthis == _lvar_vthis) ]]
[[ types(#v : Num) * (xret == _$l_xret) * (xsc == _lvar_xsc) * (v == _lvar_v) * (vthis == _lvar_vthis) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_325) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_325, true) * MetaData (_$l__lvar_325, null) * empty_fields(_$l__lvar_325 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_325, "@proto") ->@d $lnum_proto) * ((_$l__lvar_325, "@primitiveValue") ->@d #v) * ((_$l__lvar_325, "@extensible") ->@d true) * ((_$l__lvar_325, "@class") ->@d "Number") ]]
normal

proc Number_construct (xsc, vthis, v) {
	init:		pv := "i__toNumber"(v) with elab;
			xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lnum_proto, "Number", true);
			m := metadata (xret);
			[m, "@primitiveValue"] := pv;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: pv, elab;
};


spec get(l, prop)
[[ Pi(#l, #prop, undefined, #ls, #cls, #pv) * types(#l : Obj, #ls : List, #prop : Str, #pv : List, #d : Undefined, #cls : List) * (#d == undefined) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, undefined, #ls, #cls, #pv) * types(#l : Obj, #ls : List, #prop : Str, #pv : List, #d : Undefined, #cls : List) * (#d == undefined) * (xret == undefined) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal;

 [[ Pi(#l, #prop, {{ "d", _lvar_183, _lvar_184, _lvar_185, _lvar_186 }}, #ls, #cls, #pv) * types(_lvar_184 : Bool, #l : Obj, _lvar_186 : Bool, #ls : List, #prop : Str, #pv : List, #d : List, #cls : List, _lvar_185 : Bool) * (#d == {{ "d", _lvar_183, _lvar_184, _lvar_185, _lvar_186 }}) * (! (_lvar_183 == empty)) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #d, #ls, #cls, #pv) * types(#l : Obj, #ls : List, #prop : Str, #pv : List, #d : List, #cls : List) * (xret == l-nth(#d, 1.)) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal

proc get (l, prop) {
			xret := "getProperty"(l, prop) with elab;
			goto [(xret = undefined)] rlab def;
	def:		d := l-nth(xret, 0.);
			xret := l-nth(xret, 1.);
			goto [(d = "d")] rlab acc;
	acc:		goto [(xret = undefined)] rlab get;
	get:		m := metadata (xret);
			xsc := [m, "@scope"];
			fun := [m, "@call"];
			xret := fun(xsc, l) with elab;
			goto [(xret = empty)] undef rlab;
	undef:		xret := undefined;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__checkObjectCoercible(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_161, true) * MetaData (_$l__lvar_161, null) * empty_fields(_$l__lvar_161 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_161, "@proto") ->@d $lterr_proto) * ((_$l__lvar_161, "@extensible") ->@d true) * ((_$l__lvar_161, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_161) * empty_fields(_$l_xret : -{  }-) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_162, true) * MetaData (_$l__lvar_162, null) * empty_fields(_$l__lvar_162 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_162, "@proto") ->@d $lterr_proto) * ((_$l__lvar_162, "@extensible") ->@d true) * ((_$l__lvar_162, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_162) * empty_fields(_$l_xret : -{  }-) ]]
normal;

 [[ types(_lvar_163 : Num) * (v == _lvar_163) ]]
[[ types() * (xret == empty) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_164 : Bool) * (v == _lvar_164) ]]
[[ types() * (xret == empty) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_165 : Str) * (v == _lvar_165) ]]
[[ types() * (xret == empty) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_166 : Obj) * (v == _lvar_166) ]]
[[ types() * (xret == empty) * (v == _lvar_v) ]]
normal

proc i__checkObjectCoercible (v) {
			xret := empty;
	iu:		goto [(v = undefined)] throw in;
	in:		goto [(v = null)] throw other;
	other:		goto [(((((typeOf v) = Bool) or ((typeOf v) = Num)) or ((typeOf v) = Str)) or ((typeOf v) = Obj))] rlab oops;
	oops:		xret := "CheckObjectCoercible: This should not happen.";
	rlab:		skip;
	throw:		xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec SyntaxError_call(xsc, vthis, v)
[[ types() * (xsc == _lvar_xsc) * (v == undefined) * (vthis == _lvar_vthis) ]]
[[ types() * (xret == _$l_xret) * (xsc == _lvar_xsc) * (v == _lvar_v) * (vthis == _lvar_vthis) * Extensible (_$l__lvar_156, true) * MetaData (_$l__lvar_156, null) * empty_fields(_$l__lvar_156 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_156, "@proto") ->@d $lserr_proto) * ((_$l__lvar_156, "@extensible") ->@d true) * ((_$l__lvar_156, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_156) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc SyntaxError_call (xsc, vthis, v) {
			xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lserr_proto, "Error", true);
			xret := "Error_construct"(undefined, xret, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__getValue(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == undefined) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == null) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Obj) * (v == #v) ]]
[[ types(#v : Obj) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Bool) * (v == #v) ]]
[[ types(#v : Bool) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ Pi(#obj, #field, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #obj : Obj, #ls : List, #d : Undefined, #field : Str, #lcls : List) * (#d == undefined) * (v == {{ "o", #obj, #field }}) ]]
[[ Pi(#obj, #field, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #obj : Obj, #ls : List, #d : Undefined, #field : Str, #lcls : List) * (#d == undefined) * (xret == undefined) * (v == _lvar_v) ]]
normal;

 [[ Pi(#obj, #field, {{ "d", _lvar_110, _lvar_111, _lvar_112, _lvar_113 }}, #ls, #lcls, #lpv) * types(#lpv : List, #obj : Obj, #ls : List, #d : List, #field : Str, _lvar_112 : Bool, _lvar_111 : Bool, #lcls : List, _lvar_113 : Bool) * (#d == {{ "d", _lvar_110, _lvar_111, _lvar_112, _lvar_113 }}) * (! (_lvar_110 == empty)) * (v == {{ "o", #obj, #field }}) ]]
[[ Pi(#obj, #field, #d, #ls, #lcls, #lpv) * types(#lpv : List, #obj : Obj, #ls : List, #d : List, #field : Str, #lcls : List) * (xret == l-nth(#d, 1.)) * (v == _lvar_v) ]]
normal;

 [[ Pi($lg, #field, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #d : Undefined, #field : Str, #lcls : List) * (#d == undefined) * (v == {{ "v", $lg, #field }}) ]]
[[ Pi($lg, #field, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #d : Undefined, #field : Str, #lcls : List) * (#d == undefined) * (xret == undefined) * (v == _lvar_v) ]]
normal;

 [[ Pi($lg, #field, {{ "d", _lvar_114, _lvar_115, _lvar_116, _lvar_117 }}, #ls, #lcls, #lpv) * types(_lvar_115 : Bool, #lpv : List, _lvar_117 : Bool, #ls : List, #d : List, #field : Str, #lcls : List, _lvar_116 : Bool) * (#d == {{ "d", _lvar_114, _lvar_115, _lvar_116, _lvar_117 }}) * (! (_lvar_114 == empty)) * (v == {{ "v", $lg, #field }}) ]]
[[ Pi($lg, #field, #d, #ls, #lcls, #lpv) * types(#lpv : List, #ls : List, #d : List, #field : Str, #lcls : List) * (xret == l-nth(#d, 1.)) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == {{ "v", _$l_#obj, #field }}) * ((_$l_#obj, #field) ->@d #value) ]]
[[ types() * (xret == #value) * (v == _lvar_v) * ((_$l_#obj, #field) ->@d #value) ]]
normal;

 [[ types(#field : Str) * (v == {{ "v", undefined, #field }}) ]]
[[ types(#field : Str) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_118, true) * MetaData (_$l__lvar_118, null) * empty_fields(_$l__lvar_118 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_118, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_118, "@extensible") ->@d true) * ((_$l__lvar_118, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_118) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#field : Str) * (v == {{ "o", undefined, #field }}) ]]
[[ types(#field : Str) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_119, true) * MetaData (_$l__lvar_119, null) * empty_fields(_$l__lvar_119 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_119, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_119, "@extensible") ->@d true) * ((_$l__lvar_119, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_119) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi($lbool_proto, #field, undefined, ({{ $lbool_proto }} @ #ols), ({{ "Boolean" }} @ #ocls), ({{ "" }} @ #opv)) * types(#opv : List, #ocls : List, #ols : List, #d : Undefined, #field : Str, #b : Bool) * (#d == undefined) * (v == {{ "o", #b, #field }}) ]]
[[ Pi($lbool_proto, #field, undefined, ({{ $lbool_proto }} @ #ols), ({{ "Boolean" }} @ #ocls), ({{ "" }} @ #opv)) * types(#opv : List, #ocls : List, #ols : List, #d : Undefined, #field : Str, #b : Bool) * (#d == undefined) * (xobj == _$l_#o) * (xret == undefined) * (v == _lvar_v) * Extensible (_$l_#o, true) * MetaData (_$l_#o, _$l__lvar_120) * empty_fields(_$l_#o : -{  }-) * Extensible (_$l__lvar_120, true) * MetaData (_$l__lvar_120, null) * empty_fields(_$l__lvar_120 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_120, "@proto") ->@d $lbool_proto) * ((_$l__lvar_120, "@primitiveValue") ->@d #b) * ((_$l__lvar_120, "@extensible") ->@d true) * ((_$l__lvar_120, "@class") ->@d "Boolean") ]]
normal;

 [[ Pi($lbool_proto, #field, {{ "d", _lvar_127, _lvar_128, _lvar_129, _lvar_130 }}, ({{ $lbool_proto }} @ #ols), ({{ "Boolean" }} @ #ocls), ({{ "" }} @ #opv)) * types(#opv : List, #ocls : List, _lvar_129 : Bool, #ols : List, _lvar_130 : Bool, #d : List, #field : Str, #b : Bool, _lvar_128 : Bool) * (#d == {{ "d", _lvar_127, _lvar_128, _lvar_129, _lvar_130 }}) * (! (_lvar_127 == empty)) * (v == {{ "o", #b, #field }}) ]]
[[ Pi($lbool_proto, #field, #d, ({{ $lbool_proto }} @ #ols), ({{ "Boolean" }} @ #ocls), ({{ "" }} @ #opv)) * types(#opv : List, #ocls : List, #ols : List, #d : List, #field : Str, #b : Bool) * (xobj == _$l_#o) * (xret == l-nth(#d, 1.)) * (v == _lvar_v) * Extensible (_$l__lvar_131, true) * MetaData (_$l__lvar_131, null) * empty_fields(_$l__lvar_131 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_131, "@proto") ->@d $lbool_proto) * ((_$l__lvar_131, "@primitiveValue") ->@d #b) * ((_$l__lvar_131, "@extensible") ->@d true) * ((_$l__lvar_131, "@class") ->@d "Boolean") * Extensible (_$l_#o, true) * MetaData (_$l_#o, _$l__lvar_131) * empty_fields(_$l_#o : -{  }-) ]]
normal;

 [[ Pi($lnum_proto, #field, undefined, ({{ $lnum_proto }} @ #ols), ({{ "Number" }} @ #ocls), ({{ "" }} @ #opv)) * types(#opv : List, #ocls : List, #ols : List, #d : Undefined, #field : Str, #n : Num) * (#d == undefined) * (v == {{ "o", #n, #field }}) ]]
[[ Pi($lnum_proto, #field, undefined, ({{ $lnum_proto }} @ #ols), ({{ "Number" }} @ #ocls), ({{ "" }} @ #opv)) * types(#opv : List, #ocls : List, #ols : List, #d : Undefined, #field : Str, #n : Num) * (#d == undefined) * (xobj == _$l_#o) * (xret == undefined) * (v == _lvar_v) * Extensible (_$l__lvar_138, true) * MetaData (_$l__lvar_138, null) * empty_fields(_$l__lvar_138 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_138, "@proto") ->@d $lnum_proto) * ((_$l__lvar_138, "@primitiveValue") ->@d #n) * ((_$l__lvar_138, "@extensible") ->@d true) * ((_$l__lvar_138, "@class") ->@d "Number") * Extensible (_$l_#o, true) * MetaData (_$l_#o, _$l__lvar_138) * empty_fields(_$l_#o : -{  }-) ]]
normal;

 [[ Pi($lnum_proto, #field, {{ "d", _lvar_145, _lvar_146, _lvar_147, _lvar_148 }}, ({{ $lnum_proto }} @ #ols), ({{ "Number" }} @ #ocls), ({{ "" }} @ #opv)) * types(_lvar_147 : Bool, #opv : List, #ocls : List, #ols : List, #d : List, _lvar_146 : Bool, #field : Str, #n : Num, _lvar_148 : Bool) * (#d == {{ "d", _lvar_145, _lvar_146, _lvar_147, _lvar_148 }}) * (! (_lvar_145 == empty)) * (v == {{ "o", #n, #field }}) ]]
[[ Pi($lnum_proto, #field, #d, ({{ $lnum_proto }} @ #ols), ({{ "Number" }} @ #ocls), ({{ "" }} @ #opv)) * types(#opv : List, #ocls : List, #ols : List, #d : List, #field : Str, #n : Num) * (xobj == _$l_#o) * (xret == l-nth(#d, 1.)) * (v == _lvar_v) * Extensible (_$l_#o, true) * MetaData (_$l_#o, _$l__lvar_149) * empty_fields(_$l_#o : -{  }-) * Extensible (_$l__lvar_149, true) * MetaData (_$l__lvar_149, null) * empty_fields(_$l__lvar_149 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_149, "@proto") ->@d $lnum_proto) * ((_$l__lvar_149, "@primitiveValue") ->@d #n) * ((_$l__lvar_149, "@extensible") ->@d true) * ((_$l__lvar_149, "@class") ->@d "Number") ]]
normal

proc i__getValue (v) {
			goto [((typeOf v) = List)] rcand dflt;
	rcand:		rtype := l-nth(v, 0.);
			goto [((rtype = "v") or (rtype = "o"))] init dflt;
	init:		rbase := l-nth(v, 1.);
			rfield := l-nth(v, 2.);
			goto [(rbase = undefined)] throw prim;
	prim:		prim := "i__isPrimitive"(rbase);
			goto [prim] is_pr ref;
	is_pr:		xobj := "i__toObject"(rbase) with pelab;
			[* fold Pi(xobj, #field, #d, #ls, #lcls, #lpv) *]
			xret := "getProperty"(xobj, rfield) with pelab;
			[* unfold Pi(xobj, #field, #d, #ls, #lcls, #lpv) *]
			goto [(xret = undefined)] rlab def;
	def:		d := l-nth(xret, 0.);
			xret := l-nth(xret, 1.);
			goto [(d = "d")] rlab acc;
	acc:		goto [(xret = undefined)] rlab get;
	get:		m := metadata (xret);
			xsc := [m, "@scope"];
			fun := [m, "@call"];
			xret := fun(xsc, rbase) with pelab;
			goto [(xret = empty)] undef rlab;
	undef:		xret := undefined;
	ref:		goto [(((typeOf v) = List) and (l-nth(v, 0.) = "o"))] oref vref;
	oref:		xret := "get"(rbase, rfield) with pelab;
			goto rlab;
	vref:		goto [(rbase = $lg)] lg er;
	lg:		xret := "get"(rbase, rfield) with pelab;
			goto rlab;
	er:		xret := [rbase, rfield];
			goto rlab;
	dflt:		xret := v;
	rlab:		skip;
	throw:		xret := "ReferenceError"();
	pelab:		xret := PHI(xobj, xret, xret, xret, xret, xret);
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec ReferenceError_call(xsc, vthis, v)
[[ types() * (xsc == _lvar_xsc) * (v == undefined) * (vthis == _lvar_vthis) ]]
[[ types() * (xret == _$l_xret) * (xsc == _lvar_xsc) * (v == _lvar_v) * (vthis == _lvar_vthis) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_109) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_109, true) * MetaData (_$l__lvar_109, null) * empty_fields(_$l__lvar_109 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_109, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_109, "@extensible") ->@d true) * ((_$l__lvar_109, "@class") ->@d "Error") ]]
normal

proc ReferenceError_call (xsc, vthis, v) {
			xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lrferr_proto, "Error", true);
			xret := "Error_construct"(undefined, xret, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec SyntaxError(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_88, true) * MetaData (_$l__lvar_88, null) * empty_fields(_$l__lvar_88 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_88, "@proto") ->@d $lserr_proto) * ((_$l__lvar_88, "@extensible") ->@d true) * ((_$l__lvar_88, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_88) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc SyntaxError (v) {
			xret := "SyntaxError_call"(undefined, undefined, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};