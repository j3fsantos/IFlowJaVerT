import javert_js_predicates.jsil;

spec TypeError_call(xsc, vthis, v)
[[ types() * (v == undefined) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * Extensible (_$l__lvar_829, true) * MetaData (_$l__lvar_829, null) * empty_fields(_$l__lvar_829 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_829, "@proto") ->@d $lterr_proto) * ((_$l__lvar_829, "@extensible") ->@d true) * ((_$l__lvar_829, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_829) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc TypeError_call (xsc, vthis, v) {
			xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lterr_proto, "Error", true);
			xret := "Error_construct"(undefined, xret, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec TypeError(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_739, true) * MetaData (_$l__lvar_739, null) * empty_fields(_$l__lvar_739 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_739, "@proto") ->@d $lterr_proto) * ((_$l__lvar_739, "@extensible") ->@d true) * ((_$l__lvar_739, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_739) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc TypeError (v) {
			xret := "TypeError_call"(undefined, undefined, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__isCallable(l)
[[ types() * (l == _$l_l) * ((_$l_#md, "@call") ->@d none) * MetaData (_$l_l, _$l_#md) ]]
[[ types() * (xret == false) * (l == _$l_l) * ((_$l_#md, "@call") ->@d none) * MetaData (_$l_l, _$l_#md) ]]
normal;

 [[ types() * (! (#y == none)) * (l == _$l_l) * ((_$l_#md, "@call") ->@d #y) * MetaData (_$l_l, _$l_#md) ]]
[[ types() * (xret == true) * (l == _$l_l) * ((_$l_#md, "@call") ->@d #y) * MetaData (_$l_l, _$l_#md) ]]
normal

proc i__isCallable (l) {
			xret := false;
			goto [((typeOf l) = Obj)] obj rlab;
	obj:		m := metadata (l);
			xret := hasField(m,"@call");
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec defineOwnProperty(l, prop, desc, throw)
[[ types(#cls : Str, #throw : Bool, _lvar_397 : Bool, #prop : Str, #desc : List, _lvar_395 : Bool, _lvar_396 : Bool) * (#desc == {{ "d", _lvar_394, _lvar_395, _lvar_396, _lvar_397 }}) * (! (_lvar_394 == empty)) * (! (#cls == "Array")) * (! (#cls == "String")) * (throw == #throw) * (desc == {{ "d", _lvar_394, _lvar_395, _lvar_396, _lvar_397 }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(_lvar_399 : Bool, #cls : Str, #throw : Bool, _lvar_401 : Bool, _lvar_400 : Bool, #prop : Str, #desc : List) * (#desc == {{ "d", _lvar_398, _lvar_399, _lvar_400, _lvar_401 }}) * (! (_lvar_398 == empty)) * (throw == _lvar_throw) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d true) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_398, _lvar_399, _lvar_400, _lvar_401 }}) ]]
normal;

 [[ types(#cls : Str, #dec : Bool, #dcc : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_410, true, #dec, #dcc }}) * (#desc == {{ "g", empty, empty, #gval, empty, empty, empty }}) * (! (_lvar_410 == empty)) * (! (#gval == empty)) * (! (#cls == "Array")) * (throw == #throw) * (desc == {{ "g", empty, empty, #gval, empty, empty, empty }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_410, true, #dec, #dcc }}) ]]
[[ types(#cls : Str, #dec : Bool, #dcc : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (! (#gval == empty)) * (throw == _lvar_throw) * (xret == true) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", #gval, true, #dec, #dcc }}) ]]
normal;

 [[ types(_lvar_432 : Bool, _lvar_439 : Bool, _lvar_440 : Bool, #cls : Str, _lvar_431 : Bool, #prop : Str, #dcur : List, #desc : List, _lvar_441 : Bool, #ext : Bool) * (#dcur == {{ "d", _lvar_430, _lvar_431, _lvar_432, true }}) * (#desc == {{ "d", _lvar_438, _lvar_439, _lvar_440, _lvar_441 }}) * (! (_lvar_438 == empty)) * (! (_lvar_430 == empty)) * (! (#cls == "Array")) * (throw == #throw) * (desc == {{ "d", _lvar_438, _lvar_439, _lvar_440, _lvar_441 }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_430, _lvar_431, _lvar_432, true }}) ]]
[[ types(#cls : Str, _lvar_444 : Bool, _lvar_445 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, _lvar_443 : Bool) * (#desc == {{ "d", _lvar_442, _lvar_443, _lvar_444, _lvar_445 }}) * (! (_lvar_442 == empty)) * (! (#cls == "Array")) * (throw == _lvar_throw) * (xret == true) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_442, _lvar_443, _lvar_444, _lvar_445 }}) ]]
normal;

 [[ types(#cls : Str, #enum : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, _lvar_451 : Bool) * (#dcur == {{ "d", _lvar_458, true, #enum, false }}) * (#desc == {{ "d", _lvar_450, _lvar_451, #enum, false }}) * (! (_lvar_458 == empty)) * (! (_lvar_450 == empty)) * (! (#cls == "Array")) * (throw == #throw) * (desc == {{ "d", _lvar_450, _lvar_451, #enum, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_458, true, #enum, false }}) ]]
[[ types(_lvar_467 : Bool, #cls : Str, #enum : Bool, _lvar_468 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, _lvar_469 : Bool) * (#desc == {{ "d", _lvar_466, _lvar_467, _lvar_468, _lvar_469 }}) * (! (_lvar_466 == empty)) * (throw == _lvar_throw) * (xret == true) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_466, _lvar_467, _lvar_468, _lvar_469 }}) ]]
normal;

 [[ types(#cls : Str, #prop : Str) * (! (#cls == "Array")) * (throw == true) * (desc == #desc) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d false) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#cls : Str, #prop : Str) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d false) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_482) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_482, true) * MetaData (_$l__lvar_482, null) * empty_fields(_$l__lvar_482 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_482, "@proto") ->@d $lterr_proto) * ((_$l__lvar_482, "@extensible") ->@d true) * ((_$l__lvar_482, "@class") ->@d "Error") ]]
error;

 [[ types(#cls : Str, #prop : Str) * (! (#cls == "Array")) * (throw == false) * (desc == #desc) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d false) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#cls : Str, #prop : Str) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d false) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(#cls : Str, _lvar_509 : Bool, _lvar_508 : Bool, #prop : Str, _lvar_520 : Bool, #dcur : List, #desc : List, _lvar_521 : Bool, #ext : Bool) * (#dcur == {{ "d", _lvar_519, _lvar_520, _lvar_521, false }}) * (#desc == {{ "d", _lvar_507, _lvar_508, _lvar_509, true }}) * (! (_lvar_519 == empty)) * (! (_lvar_507 == empty)) * (! (#cls == "Array")) * (throw == true) * (desc == {{ "d", _lvar_507, _lvar_508, _lvar_509, true }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_519, _lvar_520, _lvar_521, false }}) ]]
[[ types(#cls : Str, _lvar_530 : Bool, _lvar_531 : Bool, #prop : Str, _lvar_529 : Bool, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_528, _lvar_529, _lvar_530, _lvar_531 }}) * (! (_lvar_528 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_528, _lvar_529, _lvar_530, _lvar_531 }}) * Extensible (_$l__lvar_527, true) * MetaData (_$l__lvar_527, null) * empty_fields(_$l__lvar_527 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_527, "@proto") ->@d $lterr_proto) * ((_$l__lvar_527, "@extensible") ->@d true) * ((_$l__lvar_527, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_527) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#cls : Str, _lvar_525 : Bool, _lvar_509 : Bool, _lvar_508 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "a", _lvar_524, _lvar_523, _lvar_525, false }}) * (#desc == {{ "d", _lvar_507, _lvar_508, _lvar_509, true }}) * (! (_lvar_524 == empty)) * (! (_lvar_523 == empty)) * (! (_lvar_507 == empty)) * (! (#cls == "Array")) * (throw == true) * (desc == {{ "d", _lvar_507, _lvar_508, _lvar_509, true }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_524, _lvar_523, _lvar_525, false }}) ]]
[[ types(_lvar_535 : Bool, #cls : Str, _lvar_534 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "a", _lvar_533, _lvar_532, _lvar_534, _lvar_535 }}) * (! (_lvar_533 == empty)) * (! (_lvar_532 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_533, _lvar_532, _lvar_534, _lvar_535 }}) * Extensible (_$l__lvar_527, true) * MetaData (_$l__lvar_527, null) * empty_fields(_$l__lvar_527 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_527, "@proto") ->@d $lterr_proto) * ((_$l__lvar_527, "@extensible") ->@d true) * ((_$l__lvar_527, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_527) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#cls : Str, _lvar_549 : Bool, _lvar_538 : Bool, _lvar_550 : Bool, #prop : Str, _lvar_537 : Bool, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_548, _lvar_549, _lvar_550, false }}) * (#desc == {{ "d", _lvar_536, _lvar_537, _lvar_538, true }}) * (! (_lvar_548 == empty)) * (! (_lvar_536 == empty)) * (! (#cls == "Array")) * (throw == false) * (desc == {{ "d", _lvar_536, _lvar_537, _lvar_538, true }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_548, _lvar_549, _lvar_550, false }}) ]]
[[ types(#cls : Str, _lvar_558 : Bool, _lvar_559 : Bool, _lvar_557 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_556, _lvar_557, _lvar_558, _lvar_559 }}) * (! (_lvar_556 == empty)) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_556, _lvar_557, _lvar_558, _lvar_559 }}) ]]
normal;

 [[ types(#cls : Str, _lvar_554 : Bool, _lvar_538 : Bool, #prop : Str, _lvar_537 : Bool, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "a", _lvar_553, _lvar_552, _lvar_554, false }}) * (#desc == {{ "d", _lvar_536, _lvar_537, _lvar_538, true }}) * (! (_lvar_553 == empty)) * (! (_lvar_552 == empty)) * (! (_lvar_536 == empty)) * (! (#cls == "Array")) * (throw == false) * (desc == {{ "d", _lvar_536, _lvar_537, _lvar_538, true }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_553, _lvar_552, _lvar_554, false }}) ]]
[[ types(#cls : Str, _lvar_562 : Bool, #prop : Str, #dcur : List, #desc : List, _lvar_563 : Bool, #ext : Bool) * (#dcur == {{ "a", _lvar_561, _lvar_560, _lvar_562, _lvar_563 }}) * (! (_lvar_561 == empty)) * (! (_lvar_560 == empty)) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_561, _lvar_560, _lvar_562, _lvar_563 }}) ]]
normal;

 [[ types(#ed : Bool, #cls : Str, _lvar_577 : Bool, #ec : Bool, #prop : Str, _lvar_565 : Bool, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_576, _lvar_577, #ec, false }}) * (#desc == {{ "d", _lvar_564, _lvar_565, #ed, false }}) * (! (_lvar_576 == empty)) * (! (_lvar_564 == empty)) * (! (#ed == #ec)) * (! (#cls == "Array")) * (throw == true) * (desc == {{ "d", _lvar_564, _lvar_565, #ed, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_576, _lvar_577, #ec, false }}) ]]
[[ types(#ed : Bool, #cls : Str, _lvar_587 : Bool, _lvar_586 : Bool, #ec : Bool, #prop : Str, #dcur : List, #desc : List, _lvar_588 : Bool, #ext : Bool) * (#dcur == {{ "d", _lvar_585, _lvar_586, _lvar_587, _lvar_588 }}) * (! (_lvar_585 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_585, _lvar_586, _lvar_587, _lvar_588 }}) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_584) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_584, true) * MetaData (_$l__lvar_584, null) * empty_fields(_$l__lvar_584 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_584, "@proto") ->@d $lterr_proto) * ((_$l__lvar_584, "@extensible") ->@d true) * ((_$l__lvar_584, "@class") ->@d "Error") ]]
error;

 [[ types(#ed : Bool, #cls : Str, #ec : Bool, #prop : Str, _lvar_565 : Bool, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "a", _lvar_581, _lvar_580, #ec, false }}) * (#desc == {{ "d", _lvar_564, _lvar_565, #ed, false }}) * (! (_lvar_581 == empty)) * (! (_lvar_580 == empty)) * (! (_lvar_564 == empty)) * (! (#ed == #ec)) * (! (#cls == "Array")) * (throw == true) * (desc == {{ "d", _lvar_564, _lvar_565, #ed, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_581, _lvar_580, #ec, false }}) ]]
[[ types(#ed : Bool, #cls : Str, _lvar_591 : Bool, #ec : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, _lvar_592 : Bool) * (#dcur == {{ "a", _lvar_590, _lvar_589, _lvar_591, _lvar_592 }}) * (! (_lvar_590 == empty)) * (! (_lvar_589 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_590, _lvar_589, _lvar_591, _lvar_592 }}) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_584) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_584, true) * MetaData (_$l__lvar_584, null) * empty_fields(_$l__lvar_584 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_584, "@proto") ->@d $lterr_proto) * ((_$l__lvar_584, "@extensible") ->@d true) * ((_$l__lvar_584, "@class") ->@d "Error") ]]
error;

 [[ types(#ed : Bool, #cls : Str, _lvar_594 : Bool, _lvar_606 : Bool, #ec : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_605, _lvar_606, #ec, false }}) * (#desc == {{ "d", _lvar_593, _lvar_594, #ed, false }}) * (! (_lvar_605 == empty)) * (! (_lvar_593 == empty)) * (! (#ed == #ec)) * (! (#cls == "Array")) * (throw == false) * (desc == {{ "d", _lvar_593, _lvar_594, #ed, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_605, _lvar_606, #ec, false }}) ]]
[[ types(#ed : Bool, #cls : Str, _lvar_616 : Bool, _lvar_614 : Bool, #ec : Bool, #prop : Str, #dcur : List, #desc : List, _lvar_615 : Bool, #ext : Bool) * (#dcur == {{ "d", _lvar_613, _lvar_614, _lvar_615, _lvar_616 }}) * (! (_lvar_613 == empty)) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_613, _lvar_614, _lvar_615, _lvar_616 }}) ]]
normal;

 [[ types(#ed : Bool, #cls : Str, _lvar_594 : Bool, #ec : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "a", _lvar_610, _lvar_609, #ec, false }}) * (#desc == {{ "d", _lvar_593, _lvar_594, #ed, false }}) * (! (_lvar_610 == empty)) * (! (_lvar_609 == empty)) * (! (_lvar_593 == empty)) * (! (#ed == #ec)) * (! (#cls == "Array")) * (throw == false) * (desc == {{ "d", _lvar_593, _lvar_594, #ed, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_610, _lvar_609, #ec, false }}) ]]
[[ types(#ed : Bool, #cls : Str, #ec : Bool, #prop : Str, #dcur : List, #desc : List, _lvar_619 : Bool, #ext : Bool, _lvar_620 : Bool) * (#dcur == {{ "a", _lvar_618, _lvar_617, _lvar_619, _lvar_620 }}) * (! (_lvar_618 == empty)) * (! (_lvar_617 == empty)) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_618, _lvar_617, _lvar_619, _lvar_620 }}) ]]
normal;

 [[ types(#en : Bool, #cls : Str, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_629, false, #en, false }}) * (#desc == {{ "d", _lvar_621, true, #en, false }}) * (! (_lvar_629 == empty)) * (! (_lvar_621 == empty)) * (! (#cls == "Array")) * (throw == true) * (desc == {{ "d", _lvar_621, true, #en, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_629, false, #en, false }}) ]]
[[ types(#en : Bool, #cls : Str, _lvar_639 : Bool, _lvar_641 : Bool, _lvar_640 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_638, _lvar_639, _lvar_640, _lvar_641 }}) * (! (_lvar_638 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * Extensible (_$l__lvar_637, true) * MetaData (_$l__lvar_637, null) * empty_fields(_$l__lvar_637 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_637, "@proto") ->@d $lterr_proto) * ((_$l__lvar_637, "@extensible") ->@d true) * ((_$l__lvar_637, "@class") ->@d "Error") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_638, _lvar_639, _lvar_640, _lvar_641 }}) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_637) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#en : Bool, #cls : Str, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_654, false, #en, false }}) * (#desc == {{ "d", _lvar_646, true, #en, false }}) * (! (_lvar_654 == empty)) * (! (_lvar_646 == empty)) * (! (#cls == "Array")) * (throw == false) * (desc == {{ "d", _lvar_646, true, #en, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_654, false, #en, false }}) ]]
[[ types(_lvar_663 : Bool, #en : Bool, #cls : Str, #prop : Str, #dcur : List, #desc : List, _lvar_664 : Bool, #ext : Bool, _lvar_665 : Bool) * (#dcur == {{ "d", _lvar_662, _lvar_663, _lvar_664, _lvar_665 }}) * (! (_lvar_662 == empty)) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_662, _lvar_663, _lvar_664, _lvar_665 }}) ]]
normal

proc defineOwnProperty (l, prop, desc, throw) {
			m := metadata (l);
			class := [m, "@class"];
			goto [(class = "Array")] adop odop;
	adop:		xret := "a__defineOwnProperty"(l, prop, desc, throw) with elab;
			goto rlab;
	odop:		xret := "o__defineOwnProperty"(l, prop, desc, throw) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__strictEquality(v1, v2)
[[ types() * (#v1 == #v2) * (v2 == #v2) * (v1 == #v2) ]]
[[ types() * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (! (#v1 == #v2)) * (v2 == #v2) * (v1 == #v1) ]]
[[ types() * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal

proc i__strictEquality (v1, v2) {
			xret := (v1 = v2);
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec Error_construct(xsc, vthis, v)
[[ types() * (v == undefined) * (xsc == _lvar_xsc) * (vthis == _$l_#vthis) * Extensible (_$l_#mvt, true) * MetaData (_$l_#mvt, null) * ((_$l_#mvt, "@extensible") ->@d #oe) * ((_$l_#mvt, "@class") ->@d #oc) * Extensible (_$l_#vthis, true) * MetaData (_$l_#vthis, _$l_#mvt) ]]
[[ types() * (xret == _$l_#vthis) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * Extensible (_$l_#mvt, true) * MetaData (_$l_#mvt, null) * ((_$l_#mvt, "@extensible") ->@d true) * ((_$l_#mvt, "@class") ->@d "Error") * Extensible (_$l_#vthis, true) * MetaData (_$l_#vthis, _$l_#mvt) ]]
normal;

 [[ types(#m : Str) * (v == #m) * (xsc == _lvar_xsc) * (vthis == _$l_#vthis) * ((_$l_#mvt, "@extensible") ->@d #oe) * ((_$l_#mvt, "@class") ->@d #oc) * MetaData (_$l_#vthis, _$l_#mvt) * ((_$l_#vthis, "message") ->@d #om) ]]
[[ types(#m : Str) * (xret == _$l_#vthis) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * ((_$l_#mvt, "@extensible") ->@d true) * ((_$l_#mvt, "@class") ->@d "Error") * MetaData (_$l_#vthis, _$l_#mvt) * ((_$l_#vthis, "message") ->@d {{ "d", #m, true, false, true }}) ]]
normal

proc Error_construct (xsc, vthis, v) {
			xret := vthis;
			m := metadata (vthis);
			[m, "@class"] := "Error";
			[m, "@extensible"] := true;
			goto [(v = undefined)] rlab mess;
	mess:		xerr := "i__toString"(v) with elab;
			[xret, "message"] := {{ "d", xerr, true, false, true }};
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xerr, elab;
};


spec canPut(l, prop)
[[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str, #ext : Bool) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str, #ext : Bool) * (xret == #ext) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(#l, #prop, {{ "d", _lvar_89, #writ, _lvar_91, _lvar_92 }}, {{ #l }}, #lcls, #lpv) * types(_lvar_92 : Bool, #l : Obj, #lpv : List, _lvar_91 : Bool, #lcls : List, #prop : Str, #writ : Bool, #d : List) * (#d == {{ "d", _lvar_89, #writ, _lvar_91, _lvar_92 }}) * (! (_lvar_89 == empty)) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #d, {{ #l }}, #lcls, #lpv) * types(#l : Obj, #lpv : List, #lcls : List, #prop : Str, #writ : Bool, #d : List) * (xret == #writ) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_95, _lvar_96, _lvar_97, _lvar_98 }}, (_$l_#l :: (#lp :: #other)), #lcls, #lpv) * types(_lvar_97 : Bool, _lvar_96 : Bool, _lvar_98 : Bool, #lpv : List, #lcls : List, #ls : List, #prop : Str, #other : List, #d : List) * (#ls == (_$l_#l :: (#lp :: #other))) * (#d == {{ "d", _lvar_95, _lvar_96, _lvar_97, _lvar_98 }}) * (! (_lvar_95 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str, #other : List, #d : List) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_99, #writ, _lvar_101, _lvar_102 }}, (_$l_#l :: (#lp :: #other)), #lcls, #lpv) * types(_lvar_102 : Bool, #lpv : List, #lcls : List, _lvar_101 : Bool, #ls : List, #prop : Str, #writ : Bool, #other : List, #d : List) * (#ls == (_$l_#l :: (#lp :: #other))) * (#d == {{ "d", _lvar_99, #writ, _lvar_101, _lvar_102 }}) * (! (_lvar_99 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str, #writ : Bool, #other : List, #d : List) * (xret == #writ) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal

proc canPut (l, prop) {
			[* unfold Pi(#l, #prop, #d, #ls, #lcls, #lpv) *]
			xret := "getOwnProperty"(l, prop) with elab;
			[* fold Pi(#l, #prop, #d, #ls, #lcls, #lpv) *]
	op:		goto [(xret = undefined)] nop odesc;
	odesc:		d := l-nth(xret, 0.);
			goto [(d = "d")] odd nop;
	odd:		xret := l-nth(xret, 2.);
			goto rlab;
	nop:		m := metadata (l);
			e := [m, "@extensible"];
			xret := "getProperty"(l, prop) with elab;
			goto [(xret = undefined)] ext desc;
	desc:		d := l-nth(xret, 0.);
			v := l-nth(xret, 2.);
			goto [(d = "d")] dd ad;
	dd:		goto [e] wr ext;
	wr:		xret := v;
			goto rlab;
	ad:		xret := (not (v = undefined));
			goto rlab;
	ext:		xret := e;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec setupInitialHeap()
[[ types() * Extensible ($lbool_proto, true) * MetaData ($lbool_proto, _$l__lvar_834) * empty_fields($lbool_proto : -{  }-) * Extensible ($lnum_proto, true) * MetaData ($lnum_proto, _$l__lvar_833) * empty_fields($lnum_proto : -{  }-) * Extensible (_$l__lvar_834, true) * MetaData (_$l__lvar_834, null) * empty_fields(_$l__lvar_834 : -{  }-) * Extensible (_$l__lvar_837, true) * MetaData (_$l__lvar_837, null) * empty_fields(_$l__lvar_837 : -{  }-) * Extensible ($lerr_proto, true) * MetaData ($lerr_proto, _$l__lvar_831) * empty_fields($lerr_proto : -{  }-) * Extensible ($lobj_proto, true) * MetaData ($lobj_proto, _$l__lvar_836) * empty_fields($lobj_proto : -{  }-) * Extensible ($lop_hasOwnProperty, true) * MetaData ($lop_hasOwnProperty, _$l__lvar_830) * empty_fields($lop_hasOwnProperty : -{  }-) * Extensible ($lg, true) * MetaData ($lg, _$l__lvar_837) * empty_fields($lg : -{  }-) * Extensible ($lerr, true) * MetaData ($lerr, _$l__lvar_832) * empty_fields($lerr : -{  }-) * Extensible (_$l__lvar_832, true) * MetaData (_$l__lvar_832, null) * empty_fields(_$l__lvar_832 : -{  }-) * Extensible (_$l__lvar_830, true) * MetaData (_$l__lvar_830, null) * empty_fields(_$l__lvar_830 : -{  }-) * Extensible (_$l__lvar_831, true) * MetaData (_$l__lvar_831, null) * empty_fields(_$l__lvar_831 : -{  }-) * Extensible (_$l__lvar_833, true) * MetaData (_$l__lvar_833, null) * empty_fields(_$l__lvar_833 : -{  }-) * Extensible (_$l__lvar_835, true) * MetaData (_$l__lvar_835, null) * empty_fields(_$l__lvar_835 : -{  }-) * Extensible ($lfun_proto, true) * MetaData ($lfun_proto, _$l__lvar_835) * empty_fields($lfun_proto : -{  }-) * Extensible (_$l__lvar_836, true) * MetaData (_$l__lvar_836, null) * empty_fields(_$l__lvar_836 : -{  }-) ]]
[[ types() * (xret == empty) * Extensible (_$l__lvar_840, true) * MetaData (_$l__lvar_840, null) * empty_fields(_$l__lvar_840 : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope" }-) * ((_$l__lvar_840, "@scope") ->@d empty) * ((_$l__lvar_840, "@proto") ->@d $lfun_proto) * ((_$l__lvar_840, "@extensible") ->@d true) * ((_$l__lvar_840, "@construct") ->@d "Error_construct") * ((_$l__lvar_840, "@class") ->@d "Function") * ((_$l__lvar_840, "@call") ->@d "Error_call") * Extensible ($lbool_proto, true) * MetaData ($lbool_proto, _$l__lvar_842) * empty_fields($lbool_proto : -{ "constructor" }-) * (($lbool_proto, "constructor") ->@d {{ "d", $lbool, true, false, true }}) * Extensible (_$l__lvar_845, true) * MetaData (_$l__lvar_845, null) * empty_fields(_$l__lvar_845 : -{ "@call", "@class", "@extensible", "@proto", "@scope" }-) * ((_$l__lvar_845, "@scope") ->@d empty) * ((_$l__lvar_845, "@proto") ->@d $lfun_proto) * ((_$l__lvar_845, "@extensible") ->@d true) * ((_$l__lvar_845, "@class") ->@d "Function") * ((_$l__lvar_845, "@call") ->@d "OP_hasOwnProperty") * Extensible (_$l__lvar_844, true) * MetaData (_$l__lvar_844, null) * empty_fields(_$l__lvar_844 : -{ "@call", "@class", "@extensible", "@proto", "@scope" }-) * ((_$l__lvar_844, "@scope") ->@d empty) * ((_$l__lvar_844, "@proto") ->@d $lobj_proto) * ((_$l__lvar_844, "@extensible") ->@d true) * ((_$l__lvar_844, "@class") ->@d "Function") * ((_$l__lvar_844, "@call") ->@d "FP_default") * Extensible ($lnum_proto, true) * MetaData ($lnum_proto, _$l__lvar_841) * empty_fields($lnum_proto : -{ "constructor" }-) * (($lnum_proto, "constructor") ->@d {{ "d", $lnum, true, false, true }}) * Extensible (_$l__lvar_847, true) * MetaData (_$l__lvar_847, null) * empty_fields(_$l__lvar_847 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_847, "@proto") ->@d $lobj_proto) * ((_$l__lvar_847, "@extensible") ->@d true) * ((_$l__lvar_847, "@class") ->@d "Object") * Extensible (_$l__lvar_846, true) * MetaData (_$l__lvar_846, null) * empty_fields(_$l__lvar_846 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_846, "@proto") ->@d null) * ((_$l__lvar_846, "@extensible") ->@d true) * ((_$l__lvar_846, "@class") ->@d "Object") * Extensible ($lerr_proto, true) * MetaData ($lerr_proto, _$l__lvar_838) * empty_fields($lerr_proto : -{ "message" }-) * (($lerr_proto, "message") ->@d {{ "d", "", true, false, true }}) * Extensible ($lobj_proto, true) * MetaData ($lobj_proto, _$l__lvar_846) * empty_fields($lobj_proto : -{ "hasOwnProperty" }-) * (($lobj_proto, "hasOwnProperty") ->@d {{ "d", $lop_hasOwnProperty, true, false, true }}) * Extensible ($lop_hasOwnProperty, true) * MetaData ($lop_hasOwnProperty, _$l__lvar_845) * empty_fields($lop_hasOwnProperty : -{ "length" }-) * (($lop_hasOwnProperty, "length") ->@d {{ "d", 1., false, false, false }}) * Extensible ($lg, true) * MetaData ($lg, _$l__lvar_847) * empty_fields($lg : -u- (-{  }-, -{ "Error" }-)) * (($lg, "Error") ->@d {{ "d", $lerr, true, false, true }}) * Extensible ($lerr, true) * MetaData ($lerr, _$l__lvar_840) * empty_fields($lerr : -{ "length", "prototype" }-) * (($lerr, "prototype") ->@d {{ "d", $lerr_proto, false, false, false }}) * (($lerr, "length") ->@d {{ "d", 1., false, false, false }}) * Extensible (_$l__lvar_838, true) * MetaData (_$l__lvar_838, null) * empty_fields(_$l__lvar_838 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_838, "@proto") ->@d $lobj_proto) * ((_$l__lvar_838, "@extensible") ->@d true) * ((_$l__lvar_838, "@class") ->@d "Error") * Extensible (_$l__lvar_841, true) * MetaData (_$l__lvar_841, null) * empty_fields(_$l__lvar_841 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_841, "@proto") ->@d $lobj_proto) * ((_$l__lvar_841, "@primitiveValue") ->@d 0.) * ((_$l__lvar_841, "@extensible") ->@d true) * ((_$l__lvar_841, "@class") ->@d "Number") * Extensible ($lfun_proto, true) * MetaData ($lfun_proto, _$l__lvar_844) * empty_fields($lfun_proto : -{ "length" }-) * (($lfun_proto, "length") ->@d {{ "d", 0., false, false, false }}) * Extensible (_$l__lvar_842, true) * MetaData (_$l__lvar_842, null) * empty_fields(_$l__lvar_842 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_842, "@proto") ->@d $lobj_proto) * ((_$l__lvar_842, "@primitiveValue") ->@d false) * ((_$l__lvar_842, "@extensible") ->@d true) * ((_$l__lvar_842, "@class") ->@d "Boolean") ]]
normal

proc setupInitialHeap () {
			xret := "create_default_object"($lg, $lobj_proto, "Object", true);
			xret := "create_default_object"($lobj_proto, null, "Object", true);
			[$lobj_proto, "hasOwnProperty"] := {{ "d", $lop_hasOwnProperty, true, false, true }};
			xret := "create_object_with_call_construct"($lop_hasOwnProperty, "OP_hasOwnProperty", empty, 1.);
			xret := "create_object_with_call_construct"($lfun_proto, "FP_default", empty, 0.);
			m := metadata ($lfun_proto);
			[m, "@proto"] := $lobj_proto;
			xret := "create_default_object"($lbool_proto, $lobj_proto, "Boolean", true);
			m := metadata ($lbool_proto);
			[m, "@primitiveValue"] := false;
			[$lbool_proto, "constructor"] := {{ "d", $lbool, true, false, true }};
			xret := "create_default_object"($lnum_proto, $lobj_proto, "Number", true);
			m := metadata ($lnum_proto);
			[m, "@primitiveValue"] := 0.;
			[$lnum_proto, "constructor"] := {{ "d", $lnum, true, false, true }};
			xret := "create_object_with_call_construct"($lerr, "Error_call", "Error_construct", 1.);
			[$lg, "Error"] := {{ "d", $lerr, true, false, true }};
			[$lerr, "prototype"] := {{ "d", $lerr_proto, false, false, false }};
			xret := "create_default_object"($lerr_proto, $lobj_proto, "Error", true);
			[$lerr_proto, "message"] := {{ "d", "", true, false, true }};
	rlab:		xret := empty
} with {
	ret: xret, rlab;
};


spec i__typeOf(v)
[[ types(#v : Undefined) * (#v == undefined) * (v == undefined) ]]
[[ types(#v : Undefined) * (#v == undefined) * (xret == "undefined") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Null) * (#v == null) * (v == null) ]]
[[ types(#v : Null) * (#v == null) * (xret == "object") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Bool) * (v == #v) ]]
[[ types(#v : Bool) * (xret == "boolean") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == "number") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str) * (xret == "string") * (v == _lvar_v) ]]
normal

proc i__typeOf (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := "undefined";
			goto rlab;
	in:		goto [(v = null)] nll ib;
	nll:		xret := "object";
			goto rlab;
	ib:		goto [((typeOf v) = Bool)] bool inum;
	bool:		xret := "boolean";
			goto rlab;
	inum:		goto [((typeOf v) = Num)] num is;
	num:		xret := "number";
			goto rlab;
	is:		goto [((typeOf v) = Str)] str io;
	str:		xret := "string";
			goto rlab;
	io:		goto [((typeOf v) = Obj)] obj oops;
	obj:		m := metadata (v);
			xret := hasField(m,"@call");
			goto [xret] isfun isobj;
	isobj:		xret := "object";
			goto rlab;
	isfun:		xret := "function";
			goto rlab;
	oops:		xret := "typeOf: This should not happen.";
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec s__getOwnProperty(l, prop)
[[ types(#dx : List, _lvar_684 : Bool, #prop : Str, _lvar_685 : Bool, _lvar_686 : Bool) * (#dx == {{ "d", _lvar_683, _lvar_684, _lvar_685, _lvar_686 }}) * (! (_lvar_683 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_683, _lvar_684, _lvar_685, _lvar_686 }}) ]]
[[ types(#dx : List, _lvar_692 : Bool, _lvar_693 : Bool, _lvar_694 : Bool, #prop : Str) * (#dx == {{ "d", _lvar_691, _lvar_692, _lvar_693, _lvar_694 }}) * (! (_lvar_691 == empty)) * (xret == {{ "d", _lvar_691, _lvar_692, _lvar_693, _lvar_694 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_691, _lvar_692, _lvar_693, _lvar_694 }}) ]]
normal;

 [[ types(#dx : List, #prop : Str, _lvar_689 : Bool, _lvar_690 : Bool) * (#dx == {{ "a", _lvar_688, _lvar_687, _lvar_689, _lvar_690 }}) * (! (_lvar_688 == empty)) * (! (_lvar_687 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_688, _lvar_687, _lvar_689, _lvar_690 }}) ]]
[[ types(#dx : List, _lvar_697 : Bool, #prop : Str, _lvar_698 : Bool) * (#dx == {{ "a", _lvar_696, _lvar_695, _lvar_697, _lvar_698 }}) * (! (_lvar_696 == empty)) * (! (_lvar_695 == empty)) * (xret == {{ "a", _lvar_696, _lvar_695, _lvar_697, _lvar_698 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_696, _lvar_695, _lvar_697, _lvar_698 }}) ]]
normal

proc s__getOwnProperty (l, prop) {
			xret := "o__getOwnProperty"(l, prop);
			goto [(xret = undefined)] str rlab;
	str:		idx := "i__toInteger"(prop) with elab;
			goto [(idx < 0.)] rlab next;
	next:		sidx := "i__toString"(idx);
			goto [(sidx = prop)] index rlab;
	index:		m := metadata (l);
			str := [m, "@primitiveValue"];
			len := (s-len str);
			goto [(len <= idx)] rlab return;
	return:		rstr := s-nth(str, idx);
			xret := {{ "d", rstr, false, true, false }};
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec create_function_object(xsc, call, construct, params)
[[ types(#xsc : List, #construct : Str, #params : List, #call : Str) * (#call == #construct) * (xsc == #xsc) * (construct == #construct) * (params == #params) * (call == #construct) ]]
[[ types(#xsc : List, #construct : Str, #params : List, #call : Str) * (xret == _$l_xret) * (xsc == _lvar_xsc) * (construct == _lvar_construct) * (params == _lvar_params) * (call == _lvar_call) * Extensible (_$l__lvar_671, true) * MetaData (_$l__lvar_671, null) * empty_fields(_$l__lvar_671 : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope" }-) * ((_$l__lvar_671, "@scope") ->@d #xsc) * ((_$l__lvar_671, "@proto") ->@d $lfun_proto) * ((_$l__lvar_671, "@extensible") ->@d true) * ((_$l__lvar_671, "@construct") ->@d #call) * ((_$l__lvar_671, "@class") ->@d "Function") * ((_$l__lvar_671, "@call") ->@d #call) * Extensible (_$l_#prototype, true) * MetaData (_$l_#prototype, _$l__lvar_670) * empty_fields(_$l_#prototype : -{ "constructor" }-) * ((_$l_#prototype, "constructor") ->@d {{ "d", _$l_xret, true, false, true }}) * Extensible (_$l__lvar_670, true) * MetaData (_$l__lvar_670, null) * empty_fields(_$l__lvar_670 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_670, "@proto") ->@d $lobj_proto) * ((_$l__lvar_670, "@extensible") ->@d true) * ((_$l__lvar_670, "@class") ->@d "Object") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_671) * empty_fields(_$l_xret : -{ "arguments", "caller", "length", "prototype" }-) * ((_$l_xret, "prototype") ->@d {{ "d", _$l_#prototype, true, false, false }}) * ((_$l_xret, "length") ->@d {{ "d", (l-len #params), false, false, false }}) * ((_$l_xret, "caller") ->@d {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }}) * ((_$l_xret, "arguments") ->@d {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }}) ]]
normal

proc create_function_object (xsc, call, construct, params) {
			len := (l-len params);
			m := new(null);
			l := new(m);
			l := "create_object_with_call_construct"(l, call, construct, len);
			[m, "@scope"] := xsc;
			prototype := "Object_construct"();
			[prototype, "constructor"] := {{ "d", l, true, false, true }};
			[l, "prototype"] := {{ "d", prototype, true, false, false }};
			[l, "caller"] := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};
			[l, "arguments"] := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};
			xret := l;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__abstractComparison(v1, v2, leftFirst)
[[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (#v1 <# #v2) * (leftFirst == #leftFirst) * (v2 == #v2) * (v1 == #v1) ]]
[[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (xret == true) * (leftFirst == _lvar_leftFirst) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (#v1 == #v2) * (leftFirst == #leftFirst) * (v2 == #v2) * (v1 == #v2) ]]
[[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (xret == false) * (leftFirst == _lvar_leftFirst) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (#v2 <# #v1) * (leftFirst == #leftFirst) * (v2 == #v2) * (v1 == #v1) ]]
[[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (xret == false) * (leftFirst == _lvar_leftFirst) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal

proc i__abstractComparison (v1, v2, leftFirst) {
			goto [((leftFirst = empty) or (leftFirst = true))] eleft eright;
	eleft:		xret := "i__toPrimitive"(v1, "Number") with elab;
			px := xret;
			xret := "i__toPrimitive"(v2, "Number") with elab;
			py := xret;
			goto is_str;
	eright:		xret := "i__toPrimitive"(v2, "Number") with elab;
			py := xret;
			xret := "i__toPrimitive"(v1, "Number") with elab;
			px := xret;
	is_str:		goto [(((typeOf px) = Str) and ((typeOf py) = Str))] str num;
	str:		xret := (px <s py);
			goto rlab;
	num:		xret := "i__toNumber"(px) with elab;
			nx := xret;
			xret := "i__toNumber"(py) with elab;
			ny := xret;
			goto [((not (nx = nx)) or (not (ny = ny)))] ru eq;
	eq:		goto [(nx = ny)] rf sl;
	sl:		xret := (nx < ny);
			goto rlab;
	ru:		xret := undefined;
			goto rlab;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec Boolean_construct(xsc, vthis, v)
[[ types(#v : Bool) * (v == #v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) ]]
[[ types(#v : Bool) * (xret == _$l_xret) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * Extensible (_$l__lvar_382, true) * MetaData (_$l__lvar_382, null) * empty_fields(_$l__lvar_382 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_382, "@proto") ->@d $lbool_proto) * ((_$l__lvar_382, "@primitiveValue") ->@d #v) * ((_$l__lvar_382, "@extensible") ->@d true) * ((_$l__lvar_382, "@class") ->@d "Boolean") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_382) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc Boolean_construct (xsc, vthis, v) {
			pv := "i__toBoolean"(v);
			xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lbool_proto, "Boolean", true);
			m := metadata (xret);
			[m, "@primitiveValue"] := pv;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__toNumber(v)
[[ types() * (v == null) ]]
[[ types() * (xret == 0.) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == true) ]]
[[ types() * (xret == 1.) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == false) ]]
[[ types() * (xret == 0.) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str) * (xret == (string_to_num #v)) * (v == _lvar_v) ]]
normal

proc i__toNumber (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := nan;
			goto rlab;
	in:		goto [(v = null)] nul ib;
	nul:		xret := 0.;
			goto rlab;
	ib:		goto [((typeOf v) = Bool)] bool inum;
	bool:		goto [(v = true)] is_t is_f;
	is_t:		xret := 1.;
			goto rlab;
	is_f:		xret := 0.;
			goto rlab;
	inum:		goto [((typeOf v) = Num)] num is;
	num:		xret := v;
			goto rlab;
	is:		goto [((typeOf v) = Str)] str io;
	str:		xret := (string_to_num v);
			goto rlab;
	io:		goto [((typeOf v) = Obj)] obj oops;
	obj:		xret := "i__toPrimitive"(v, "Number") with elab;
			xret := "i__toNumber"(xret);
			goto rlab;
	oops:		xret := "TypeError"("ToNumber: This should not happen.");
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec ReferenceError(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_373) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_373, true) * MetaData (_$l__lvar_373, null) * empty_fields(_$l__lvar_373 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_373, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_373, "@extensible") ->@d true) * ((_$l__lvar_373, "@class") ->@d "Error") ]]
normal

proc ReferenceError (v) {
			xret := "ReferenceError_call"(undefined, undefined, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec create_default_object(l, pr, cl, ext)
[[ types(#l : Obj) * (#l == _$l_l) * (pr == #pr) * (ext == undefined) * (l == _$l_l) * (cl == undefined) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@proto") ->@d #lvar_0) * ((_$l_#md, "@extensible") ->@d #lvar_2) * ((_$l_#md, "@class") ->@d #lvar_1) * Extensible (_$l_l, true) * MetaData (_$l_l, _$l_#md) ]]
[[ types(#l : Obj) * (xret == #l) * (pr == _lvar_pr) * (ext == _lvar_ext) * (l == _$l_l) * (cl == _lvar_cl) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@proto") ->@d #pr) * ((_$l_#md, "@extensible") ->@d true) * ((_$l_#md, "@class") ->@d "Object") * Extensible (_$l_l, true) * MetaData (_$l_l, _$l_#md) ]]
normal;

 [[ types(#l : Obj, #cl : Str, #ext : Bool) * (#l == _$l_l) * (pr == #pr) * (ext == #ext) * (l == _$l_l) * (cl == #cl) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@proto") ->@d #lvar_3) * ((_$l_#md, "@extensible") ->@d #lvar_5) * ((_$l_#md, "@class") ->@d #lvar_4) * Extensible (_$l_l, true) * MetaData (_$l_l, _$l_#md) ]]
[[ types(#l : Obj, #cl : Str, #ext : Bool) * (xret == #l) * (pr == _lvar_pr) * (ext == _lvar_ext) * (l == _$l_l) * (cl == _lvar_cl) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@proto") ->@d #pr) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cl) * Extensible (_$l_l, true) * MetaData (_$l_l, _$l_#md) ]]
normal

proc create_default_object (l, pr, cl, ext) {
			goto [(cl = undefined)] scl text;
	scl:		cl := "Object";
	text:		goto [(ext = undefined)] sext setall;
	sext:		ext := true;
	setall:		m := metadata (l);
			[m, "@proto"] := pr;
			[m, "@class"] := cl;
			[m, "@extensible"] := ext;
	rlab:		xret := l
} with {
	ret: xret, rlab;
};


spec i__toPrimitive(v, hint)
[[ types() * (v == undefined) * (hint == _lvar_hint) ]]
[[ types() * (xret == undefined) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types() * (v == null) * (hint == _lvar_hint) ]]
[[ types() * (xret == null) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types(#v : Num) * (v == #v) * (hint == _lvar_hint) ]]
[[ types(#v : Num) * (xret == #v) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types(#v : Bool) * (v == #v) * (hint == _lvar_hint) ]]
[[ types(#v : Bool) * (xret == #v) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types(#v : Str) * (v == #v) * (hint == _lvar_hint) ]]
[[ types(#v : Str) * (xret == #v) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal

proc i__toPrimitive (v, hint) {
			xret := v;
			tv := (typeOf v);
	iu:		goto [(((((v = undefined) or (v = null)) or ((typeOf v) = Bool)) or ((typeOf v) = Num)) or ((typeOf v) = Str))] rlab is_obj;
	is_obj:		goto [((typeOf v) = Obj)] obj oops;
	obj:		xret := "defaultValue"(v, hint) with elab;
			goto rlab;
	oops:		xret := "ToPrimitive: This should not happen.";
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec o__getOwnProperty(l, prop)
[[ types(#prop : Str) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#prop : Str) * (xret == undefined) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(#dx : List, _lvar_131 : Bool, _lvar_129 : Bool, #prop : Str, _lvar_130 : Bool) * (#dx == {{ "d", _lvar_128, _lvar_129, _lvar_130, _lvar_131 }}) * (! (_lvar_128 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_128, _lvar_129, _lvar_130, _lvar_131 }}) ]]
[[ types(#dx : List, _lvar_138 : Bool, #prop : Str, _lvar_137 : Bool, _lvar_139 : Bool) * (#dx == {{ "d", _lvar_136, _lvar_137, _lvar_138, _lvar_139 }}) * (! (_lvar_136 == empty)) * (xret == {{ "d", _lvar_136, _lvar_137, _lvar_138, _lvar_139 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_136, _lvar_137, _lvar_138, _lvar_139 }}) ]]
normal;

 [[ types(#dx : List, _lvar_134 : Bool, #prop : Str, _lvar_135 : Bool) * (#dx == {{ "a", _lvar_133, _lvar_132, _lvar_134, _lvar_135 }}) * (! (_lvar_133 == empty)) * (! (_lvar_132 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_133, _lvar_132, _lvar_134, _lvar_135 }}) ]]
[[ types(#dx : List, _lvar_143 : Bool, #prop : Str, _lvar_142 : Bool) * (#dx == {{ "a", _lvar_141, _lvar_140, _lvar_142, _lvar_143 }}) * (! (_lvar_141 == empty)) * (! (_lvar_140 == empty)) * (xret == {{ "a", _lvar_141, _lvar_140, _lvar_142, _lvar_143 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_141, _lvar_140, _lvar_142, _lvar_143 }}) ]]
normal

proc o__getOwnProperty (l, prop) {
			x := hasField(l,prop);
			goto [x] hp nhp;
	nhp:		xret := undefined;
			goto rlab;
	hp:		xret := [l, prop];
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec deleteProperty(l, prop, throw)
[[ types(#cls : Str, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#cls : Str, #prop : Str) * (throw == _lvar_throw) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(_lvar_766 : Bool, #cls : Str, #prop : Str, _lvar_765 : Bool, #d : List) * (#d == {{ "d", _lvar_764, _lvar_765, _lvar_766, true }}) * (! (_lvar_764 == empty)) * (! (#cls == "String")) * (throw == _lvar_throw) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_764, _lvar_765, _lvar_766, true }}) ]]
[[ types(#cls : Str, #prop : Str, #d : List) * (throw == _lvar_throw) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(_lvar_770 : Bool, #cls : Str, #prop : Str, #d : List) * (#d == {{ "a", _lvar_769, _lvar_768, _lvar_770, true }}) * (! (_lvar_769 == empty)) * (! (_lvar_768 == empty)) * (! (#cls == "String")) * (throw == _lvar_throw) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_769, _lvar_768, _lvar_770, true }}) ]]
[[ types(#cls : Str, #prop : Str, #d : List) * (throw == _lvar_throw) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(#cls : Str, _lvar_789 : Bool, #prop : Str, #d : List, _lvar_790 : Bool) * (#d == {{ "d", _lvar_788, _lvar_789, _lvar_790, false }}) * (! (_lvar_788 == empty)) * (! (#cls == "String")) * (throw == false) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_788, _lvar_789, _lvar_790, false }}) ]]
[[ types(#cls : Str, _lvar_797 : Bool, #prop : Str, _lvar_798 : Bool, #d : List, _lvar_799 : Bool) * (#d == {{ "d", _lvar_796, _lvar_797, _lvar_798, _lvar_799 }}) * (! (_lvar_796 == empty)) * (throw == _lvar_throw) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_796, _lvar_797, _lvar_798, _lvar_799 }}) ]]
normal;

 [[ types(#cls : Str, #prop : Str, _lvar_794 : Bool, #d : List) * (#d == {{ "a", _lvar_793, _lvar_792, _lvar_794, false }}) * (! (_lvar_793 == empty)) * (! (_lvar_792 == empty)) * (! (#cls == "String")) * (throw == false) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_793, _lvar_792, _lvar_794, false }}) ]]
[[ types(#cls : Str, _lvar_802 : Bool, _lvar_803 : Bool, #prop : Str, #d : List) * (#d == {{ "a", _lvar_801, _lvar_800, _lvar_802, _lvar_803 }}) * (! (_lvar_801 == empty)) * (! (_lvar_800 == empty)) * (throw == _lvar_throw) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_801, _lvar_800, _lvar_802, _lvar_803 }}) ]]
normal;

 [[ types(#cls : Str, _lvar_813 : Bool, #prop : Str, _lvar_814 : Bool, #d : List) * (#d == {{ "d", _lvar_812, _lvar_813, _lvar_814, false }}) * (! (_lvar_812 == empty)) * (! (#cls == "String")) * (throw == true) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_812, _lvar_813, _lvar_814, false }}) ]]
[[ types(_lvar_822 : Bool, _lvar_824 : Bool, #cls : Str, #prop : Str, _lvar_823 : Bool, #d : List) * (#d == {{ "d", _lvar_821, _lvar_822, _lvar_823, _lvar_824 }}) * (! (_lvar_821 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_821, _lvar_822, _lvar_823, _lvar_824 }}) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_820) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_820, true) * MetaData (_$l__lvar_820, null) * empty_fields(_$l__lvar_820 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_820, "@proto") ->@d $lterr_proto) * ((_$l__lvar_820, "@extensible") ->@d true) * ((_$l__lvar_820, "@class") ->@d "Error") ]]
error;

 [[ types(#cls : Str, _lvar_818 : Bool, #prop : Str, #d : List) * (#d == {{ "a", _lvar_817, _lvar_816, _lvar_818, false }}) * (! (_lvar_817 == empty)) * (! (_lvar_816 == empty)) * (! (#cls == "String")) * (throw == true) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_817, _lvar_816, _lvar_818, false }}) ]]
[[ types(#cls : Str, _lvar_828 : Bool, _lvar_827 : Bool, #prop : Str, #d : List) * (#d == {{ "a", _lvar_826, _lvar_825, _lvar_827, _lvar_828 }}) * (! (_lvar_826 == empty)) * (! (_lvar_825 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_826, _lvar_825, _lvar_827, _lvar_828 }}) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_820) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_820, true) * MetaData (_$l__lvar_820, null) * empty_fields(_$l__lvar_820 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_820, "@proto") ->@d $lterr_proto) * ((_$l__lvar_820, "@extensible") ->@d true) * ((_$l__lvar_820, "@class") ->@d "Error") ]]
error

proc deleteProperty (l, prop, throw) {
			xret := "getOwnProperty"(l, prop) with elab;
			goto [(xret = undefined)] dt cont;
	cont:		c := l-nth(xret, 4.);
			goto [c] del reject;
	del:		delete (l,prop);
	dt:		xret := true;
			goto rlab;
	df:		xret := false;
	rlab:		skip;
	reject:		goto [throw] tt df;
	tt:		xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec getOwnProperty(l, prop)
[[ types(#cls : Str, #prop : Str) * (! (#cls == "String")) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#cls : Str, #prop : Str) * (xret == undefined) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(_lvar_724 : Bool, _lvar_725 : Bool, #dx : List, _lvar_726 : Bool, #prop : Str) * (#dx == {{ "d", _lvar_723, _lvar_724, _lvar_725, _lvar_726 }}) * (! (_lvar_723 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_723, _lvar_724, _lvar_725, _lvar_726 }}) ]]
[[ types(#dx : List, _lvar_734 : Bool, _lvar_733 : Bool, _lvar_732 : Bool, #prop : Str) * (#dx == {{ "d", _lvar_731, _lvar_732, _lvar_733, _lvar_734 }}) * (! (_lvar_731 == empty)) * (xret == {{ "d", _lvar_731, _lvar_732, _lvar_733, _lvar_734 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_731, _lvar_732, _lvar_733, _lvar_734 }}) ]]
normal;

 [[ types(_lvar_729 : Bool, #dx : List, #prop : Str, _lvar_730 : Bool) * (#dx == {{ "a", _lvar_728, _lvar_727, _lvar_729, _lvar_730 }}) * (! (_lvar_728 == empty)) * (! (_lvar_727 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_728, _lvar_727, _lvar_729, _lvar_730 }}) ]]
[[ types(_lvar_737 : Bool, #dx : List, #prop : Str, _lvar_738 : Bool) * (#dx == {{ "a", _lvar_736, _lvar_735, _lvar_737, _lvar_738 }}) * (! (_lvar_736 == empty)) * (! (_lvar_735 == empty)) * (xret == {{ "a", _lvar_736, _lvar_735, _lvar_737, _lvar_738 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_736, _lvar_735, _lvar_737, _lvar_738 }}) ]]
normal

proc getOwnProperty (l, prop) {
			m := metadata (l);
			class := [m, "@class"];
			goto [(class = "String")] sgop ogop;
	sgop:		xret := "s__getOwnProperty"(l, prop) with elab;
			goto rlab;
	ogop:		xret := "o__getOwnProperty"(l, prop) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__toString(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == "undefined") * (v == _lvar_v) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == "null") * (v == _lvar_v) ]]
normal;

 [[ types() * (v == true) ]]
[[ types() * (xret == "true") * (v == _lvar_v) ]]
normal;

 [[ types() * (v == false) ]]
[[ types() * (xret == "false") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == (num_to_string #v)) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str) * (xret == #v) * (v == _lvar_v) ]]
normal

proc i__toString (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := "undefined";
			goto rlab;
	in:		goto [(v = null)] nul ib;
	nul:		xret := "null";
			goto rlab;
	ib:		goto [((typeOf v) = Bool)] bool inum;
	bool:		goto [(v = true)] is_t is_f;
	is_t:		xret := "true";
			goto rlab;
	is_f:		xret := "false";
			goto rlab;
	inum:		goto [((typeOf v) = Num)] num is;
	num:		xret := (num_to_string v);
			goto rlab;
	is:		goto [((typeOf v) = Str)] str io;
	str:		xret := v;
			goto rlab;
	io:		goto [((typeOf v) = Obj)] obj oops;
	obj:		xret := "i__toPrimitive"(v, "String") with elab;
			xret := "i__toString"(xret) with elab;
			goto rlab;
	oops:		xret := "TypeError"("ToString: This should not happen.");
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__checkAssignmentErrors(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_374 : Num) * (v == _lvar_374) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_375 : Bool) * (v == _lvar_375) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_376 : Str) * (v == _lvar_376) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_377 : Obj) * (v == _lvar_377) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(#l : Obj, #prop : Str, #v : List) * (#v == {{ "v", #l, #prop }}) * (! (#prop == "eval")) * (! (#prop == "arguments")) * (v == {{ "v", #l, #prop }}) ]]
[[ types(#l : Obj, #prop : Str, #v : List) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(#l : Obj, #v : List) * (#v == {{ "v", #l, "eval" }}) * (v == {{ "v", #l, "eval" }}) ]]
[[ types(#l : Obj, #v : List) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_378, true) * MetaData (_$l__lvar_378, null) * empty_fields(_$l__lvar_378 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_378, "@proto") ->@d $lserr_proto) * ((_$l__lvar_378, "@extensible") ->@d true) * ((_$l__lvar_378, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_378) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#l : Obj, #v : List) * (#v == {{ "v", #l, "arguments" }}) * (v == {{ "v", #l, "arguments" }}) ]]
[[ types(#l : Obj, #v : List) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_379) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_379, true) * MetaData (_$l__lvar_379, null) * empty_fields(_$l__lvar_379 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_379, "@proto") ->@d $lserr_proto) * ((_$l__lvar_379, "@extensible") ->@d true) * ((_$l__lvar_379, "@class") ->@d "Error") ]]
error;

 [[ types(#field : Str, #v : List, #base : Obj) * (#v == {{ "o", #base, #field }}) * (v == {{ "o", #base, #field }}) ]]
[[ types(#field : Str, #v : List, #base : Obj) * (xret == true) * (v == _lvar_v) ]]
normal

proc i__checkAssignmentErrors (v) {
			tv := (typeOf v);
			goto [(tv = List)] list rlab;
	list:		goto [((l-nth(v, 0.) = "v") or (l-nth(v, 0.) = "o"))] prep rlab;
	prep:		fv := l-nth(v, 2.);
	csyn:		goto [((l-nth(v, 0.) = "v") and ((fv = "eval") or (fv = "arguments")))] se rlab;
	rlab:		xret := true;
	se:		xret := "SyntaxError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec put(l, prop, value, throw)
[[ Pi(_$l_#l, #prop, undefined, (_$l_#l :: (#lp :: #lllp)), (#cls :: (#ccls :: #llcls)), ("" :: (#pv :: #llpv))) * types(#cls : Str, #throw : Bool, #ccls : Str, #llpv : List, #prop : Str, #lllp : List, #lp : Obj, #pv : Str, #llcls : List) * (! (#value == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #value, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, undefined, (#lp :: #lllp), (#ccls :: #llcls), (#pv :: #llpv)) * types(#cls : Str, #throw : Bool, #ccls : Str, #llpv : List, #prop : Str, #lllp : List, #lp : Obj, #pv : Str, #llcls : List) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == empty) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", #dval, true, #denum, #dconf }}, {{ _$l_#l }}, {{ #cls }}, #lpv) * types(#cls : Str, #throw : Bool, #dconf : Bool, #lpv : List, #denum : Bool, #prop : Str, #ext : Bool) * (! (#value == empty)) * (! (#dval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #value, true, #denum, #dconf }}, {{ _$l_#l }}, {{ #cls }}, #lpv) * types(#cls : Str, #throw : Bool, #dconf : Bool, #lpv : List, #denum : Bool, #prop : Str, #ext : Bool) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == empty) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, (_$l_#l :: (#lp :: #lllp)), (#cls :: (#pcls :: #ocls)), ("" :: (#pv :: #llpv))) * types(#cls : Str, #throw : Bool, #dcconf : Bool, #llpv : List, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (! (#value == empty)) * (! (#dcval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #value, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, (#lp :: #lllp), (#pcls :: #ocls), (#pv :: #llpv)) * types(#cls : Str, #throw : Bool, #dcconf : Bool, #llpv : List, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == empty) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, undefined, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #throw : Bool, #prop : Str) * (! (#value == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #value, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #throw : Bool, #prop : Str) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == empty) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@proto") ->@d null) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str) * (throw == true) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * Extensible (_$l__lvar_355, true) * MetaData (_$l__lvar_355, null) * empty_fields(_$l__lvar_355 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_355, "@proto") ->@d $lterr_proto) * ((_$l__lvar_355, "@extensible") ->@d true) * ((_$l__lvar_355, "@class") ->@d "Error") * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_355) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_356, false, _lvar_358, _lvar_359 }}, {{ _$l_#l }}, #lcls, #lpv) * types(_lvar_358 : Bool, #lpv : List, #lcls : List, #prop : Str, _lvar_359 : Bool, #ext : Bool, #d : List) * (#d == {{ "d", _lvar_356, false, _lvar_358, _lvar_359 }}) * (! (_lvar_356 == empty)) * (throw == true) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, {{ _$l_#l }}, #lcls, #lpv) * types(#lpv : List, #lcls : List, #prop : Str, #ext : Bool, #d : List) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l__lvar_360, true) * MetaData (_$l__lvar_360, null) * empty_fields(_$l__lvar_360 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_360, "@proto") ->@d $lterr_proto) * ((_$l__lvar_360, "@extensible") ->@d true) * ((_$l__lvar_360, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_360) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_363, _lvar_364, _lvar_365, _lvar_366 }}, (_$l_#l :: (#lp :: #other)), #lcls, #lpv) * types(#lpv : List, _lvar_364 : Bool, #lcls : List, #ls : List, #prop : Str, _lvar_365 : Bool, #lp : Obj, #other : List, _lvar_366 : Bool, #d : List) * (#ls == (_$l_#l :: (#lp :: #other))) * (#d == {{ "d", _lvar_363, _lvar_364, _lvar_365, _lvar_366 }}) * (! (_lvar_363 == empty)) * (throw == true) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str, #lp : Obj, #other : List, #d : List) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d false) * Extensible (_$l__lvar_367, true) * MetaData (_$l__lvar_367, null) * empty_fields(_$l__lvar_367 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_367, "@proto") ->@d $lterr_proto) * ((_$l__lvar_367, "@extensible") ->@d true) * ((_$l__lvar_367, "@class") ->@d "Error") * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_367) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_368, false, _lvar_370, _lvar_371 }}, (_$l_#l :: (#lp :: #other)), #lcls, #lpv) * types(#lpv : List, _lvar_370 : Bool, #lcls : List, #ls : List, #prop : Str, #lp : Obj, _lvar_371 : Bool, #other : List, #d : List) * (#ls == (_$l_#l :: (#lp :: #other))) * (#d == {{ "d", _lvar_368, false, _lvar_370, _lvar_371 }}) * (! (_lvar_368 == empty)) * (throw == true) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str, #lp : Obj, #other : List, #d : List) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * Extensible (_$l__lvar_372, true) * MetaData (_$l__lvar_372, null) * empty_fields(_$l__lvar_372 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_372, "@proto") ->@d $lterr_proto) * ((_$l__lvar_372, "@extensible") ->@d true) * ((_$l__lvar_372, "@class") ->@d "Error") * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_372) * empty_fields(_$l_xret : -{  }-) ]]
error

proc put (l, prop, value, throw) {
			xret := "canPut"(l, prop) with elab;
			goto [xret] cp reject;
			[* unfold Pi(#l, #prop, #d, #ls, #lcls, #lpv) *]
	cp:		xret := "getOwnProperty"(l, prop) with elab;
			dd := "i__isDataDescriptor"(xret);
			goto [dd] dd gp;
	dd:		desc := {{ "g", empty, empty, value, empty, empty, empty }};
			xret := "defineOwnProperty"(l, prop, desc, throw) with elab;
			[* fold Pi(#l, #prop, {{ "d", #value, true, #denum, #dconf }}, {{ #l }}, #lvar_19, #lvar_20) *]
			goto remp;
			[* fold Pi(#l, #prop, #d, #ls, #lcls, #lpv) *]
	gp:		xret := "getProperty"(l, prop) with elab;
			ad := "i__isAccessorDescriptor"(xret);
			goto [ad] ad def;
	ad:		s := l-nth(xret, 2.);
			xsc := [s, "@scope"];
			fun := [s, "@call"];
			xret := fun(xsc, l, value) with elab;
			goto remp;
	def:		desc := {{ "d", value, true, true, true }};
			[* unfold Pi(#l, #prop, #d, #ls, #lcls, #lpv) *]
			xret := "defineOwnProperty"(l, prop, desc, throw) with elab;
			[* fold Pi(#l, #prop, {{ "d", #value, true, true, true }}, {{ #l }}, #lvar_21, #lvar_22) *]
			skip;
	remp:		xret := empty;
	rlab:		skip;
	reject:		xret := empty;
			goto [throw] tt rlab;
	tt:		xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__putValue(v, w)
[[ types() * (v == undefined) * (w == _lvar_w) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * Extensible (_$l__lvar_242, true) * MetaData (_$l__lvar_242, null) * empty_fields(_$l__lvar_242 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_242, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_242, "@extensible") ->@d true) * ((_$l__lvar_242, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_242) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types() * (v == null) * (w == _lvar_w) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * Extensible (_$l__lvar_243, true) * MetaData (_$l__lvar_243, null) * empty_fields(_$l__lvar_243 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_243, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_243, "@extensible") ->@d true) * ((_$l__lvar_243, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_243) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(_lvar_245 : Num) * (v == _lvar_245) * (w == _lvar_w) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * Extensible (_$l__lvar_244, true) * MetaData (_$l__lvar_244, null) * empty_fields(_$l__lvar_244 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_244, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_244, "@extensible") ->@d true) * ((_$l__lvar_244, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_244) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(_lvar_247 : Bool) * (v == _lvar_247) * (w == _lvar_w) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * Extensible (_$l__lvar_246, true) * MetaData (_$l__lvar_246, null) * empty_fields(_$l__lvar_246 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_246, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_246, "@extensible") ->@d true) * ((_$l__lvar_246, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_246) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(_lvar_249 : Str) * (v == _lvar_249) * (w == _lvar_w) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * Extensible (_$l__lvar_248, true) * MetaData (_$l__lvar_248, null) * empty_fields(_$l__lvar_248 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_248, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_248, "@extensible") ->@d true) * ((_$l__lvar_248, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_248) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(_lvar_251 : Obj) * (v == _lvar_251) * (w == _lvar_w) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * Extensible (_$l__lvar_250, true) * MetaData (_$l__lvar_250, null) * empty_fields(_$l__lvar_250 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_250, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_250, "@extensible") ->@d true) * ((_$l__lvar_250, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_250) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types() * (! (#w == empty)) * (v == {{ "v", _$l_#obj, #field }}) * (w == #w) * ((_$l_#obj, #field) ->@d #lvar_23) ]]
[[ types() * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#obj, #field) ->@d #w) ]]
normal;

 [[ Pi(_$l_#l, #prop, undefined, (_$l_#l :: (#lp :: #lllp)), (#cls :: (#pcls :: #ocls)), ("" :: (#pv :: #llpv))) * types(#cls : Str, #llpv : List, #pcls : Str, #ocls : List, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (! (#w == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #w, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, undefined, (#lp :: #lllp), (#pcls :: #ocls), (#pv :: #llpv)) * types(#cls : Str, #llpv : List, #pcls : Str, #ocls : List, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi($lg, #prop, undefined, ($lg :: (#lp :: #lllp)), (#cls :: (#pcls :: #ocls)), ("" :: (#pv :: #llpv))) * types(#cls : Str, #llpv : List, #pcls : Str, #ocls : List, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (! (#w == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "v", $lg, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d true) * MetaData ($lg, _$l_#md) ]]
[[ Pi($lg, #prop, {{ "d", #w, true, true, true }}, {{ $lg }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, undefined, (#lp :: #lllp), (#pcls :: #ocls), (#pv :: #llpv)) * types(#cls : Str, #llpv : List, #pcls : Str, #ocls : List, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData ($lg, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", #dval, true, #denum, #dconf }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #dconf : Bool, #denum : Bool, #prop : Str, #ext : Bool) * (! (#w == empty)) * (! (#dval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #w, true, #denum, #dconf }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #dconf : Bool, #denum : Bool, #prop : Str, #ext : Bool) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi($lg, #prop, {{ "d", #dval, true, #denum, #dconf }}, {{ $lg }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #dconf : Bool, #denum : Bool, #prop : Str, #ext : Bool) * (! (#w == empty)) * (! (#dval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "v", $lg, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData ($lg, _$l_#md) ]]
[[ Pi($lg, #prop, {{ "d", #w, true, #denum, #dconf }}, {{ $lg }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #dconf : Bool, #denum : Bool, #prop : Str, #ext : Bool) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData ($lg, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, (_$l_#l :: (#lp :: #lllp)), (#cls :: (#pcls :: #ocls)), ("" :: (#pv :: #llpv))) * types(#cls : Str, #dcconf : Bool, #llpv : List, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (! (#w == empty)) * (! (#dcval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #w, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, (#lp :: #lllp), (#pcls :: #ocls), (#pv :: #llpv)) * types(#cls : Str, #dcconf : Bool, #llpv : List, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi($lg, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, ($lg :: (#lp :: #lllp)), (#cls :: (#pcls :: #ocls)), ("" :: (#pv :: #llpv))) * types(#cls : Str, #dcconf : Bool, #llpv : List, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (! (#w == empty)) * (! (#dcval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "v", $lg, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d true) * MetaData ($lg, _$l_#md) ]]
[[ Pi($lg, #prop, {{ "d", #w, true, true, true }}, {{ $lg }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, (#lp :: #lllp), (#pcls :: #ocls), (#pv :: #llpv)) * types(#cls : Str, #dcconf : Bool, #llpv : List, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData ($lg, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, undefined, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #prop : Str) * (! (#w == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #w, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #prop : Str) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@proto") ->@d null) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l__lvar_305, true) * MetaData (_$l__lvar_305, null) * empty_fields(_$l__lvar_305 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_305, "@proto") ->@d $lterr_proto) * ((_$l__lvar_305, "@extensible") ->@d true) * ((_$l__lvar_305, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_305) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_306, false, _lvar_308, _lvar_309 }}, {{ _$l_#l }}, #lcls, #lpv) * types(_lvar_309 : Bool, _lvar_308 : Bool, #lpv : List, #lcls : List, #prop : Str, #ext : Bool, #d : List) * (#d == {{ "d", _lvar_306, false, _lvar_308, _lvar_309 }}) * (! (_lvar_306 == empty)) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, {{ _$l_#l }}, #lcls, #lpv) * types(#lpv : List, #lcls : List, #prop : Str, #ext : Bool, #d : List) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l__lvar_310, true) * MetaData (_$l__lvar_310, null) * empty_fields(_$l__lvar_310 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_310, "@proto") ->@d $lterr_proto) * ((_$l__lvar_310, "@extensible") ->@d true) * ((_$l__lvar_310, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_310) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_313, _lvar_314, _lvar_315, _lvar_316 }}, (_$l_#l :: (#lp :: #other)), #cls, #lpv) * types(_lvar_316 : Bool, #cls : List, _lvar_315 : Bool, #lpv : List, #ls : List, #prop : Str, #lp : Obj, #other : List, _lvar_314 : Bool, #d : List) * (#ls == (_$l_#l :: (#lp :: #other))) * (#d == {{ "d", _lvar_313, _lvar_314, _lvar_315, _lvar_316 }}) * (! (_lvar_313 == empty)) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #cls, #lpv) * types(#cls : List, #lpv : List, #ls : List, #prop : Str, #lp : Obj, #other : List, #d : List) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@extensible") ->@d false) * Extensible (_$l__lvar_317, true) * MetaData (_$l__lvar_317, null) * empty_fields(_$l__lvar_317 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_317, "@proto") ->@d $lterr_proto) * ((_$l__lvar_317, "@extensible") ->@d true) * ((_$l__lvar_317, "@class") ->@d "Error") * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_317) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_318, false, _lvar_320, _lvar_321 }}, (_$l_#l :: (#lp :: #other)), #lcls, #lpv) * types(#lpv : List, #lcls : List, _lvar_321 : Bool, _lvar_320 : Bool, #ls : List, #prop : Str, #lp : Obj, #other : List, #d : List) * (#ls == (_$l_#l :: (#lp :: #other))) * (#d == {{ "d", _lvar_318, false, _lvar_320, _lvar_321 }}) * (! (_lvar_318 == empty)) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str, #lp : Obj, #other : List, #d : List) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@extensible") ->@d false) * Extensible (_$l__lvar_322, true) * MetaData (_$l__lvar_322, null) * empty_fields(_$l__lvar_322 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_322, "@proto") ->@d $lterr_proto) * ((_$l__lvar_322, "@extensible") ->@d true) * ((_$l__lvar_322, "@class") ->@d "Error") * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_322) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi($lg, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str) * (v == {{ "v", $lg, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d false) * MetaData ($lg, _$l_#md) ]]
[[ Pi($lg, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@extensible") ->@d false) * MetaData ($lg, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_323) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_323, true) * MetaData (_$l__lvar_323, null) * empty_fields(_$l__lvar_323 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_323, "@proto") ->@d $lterr_proto) * ((_$l__lvar_323, "@extensible") ->@d true) * ((_$l__lvar_323, "@class") ->@d "Error") ]]
error

proc i__putValue (v, w) {
			goto [((typeOf v) = List)] list throw;
	list:		goto [((l-nth(v, 0.) = "v") or (l-nth(v, 0.) = "o"))] init throw;
	init:		rbase := l-nth(v, 1.);
			rfield := l-nth(v, 2.);
			goto [(rbase = undefined)] throw prim;
	prim:		prim := "i__isPrimitive"(rbase);
			goto [prim] is_pr refr;
	refr:		goto [(((typeOf v) = List) and (l-nth(v, 0.) = "o"))] oref vref;
	oref:		xret := "put"(rbase, rfield, w, true) with elab;
			goto dflt;
	vref:		goto [(rbase = $lg)] lg er;
	lg:		xret := "put"(rbase, rfield, w, true) with elab;
			goto dflt;
	er:		[rbase, rfield] := w;
	dflt:		xret := empty;
	rlab:		skip;
	throw:		xret := "ReferenceError"();
	elab:		skip;
	is_pr:		xret := "i__toObject"(rbase) with elab;
			l := xret;
			xret := "canPut"(l, rfield) with elab;
			goto [xret] cp reject;
	cp:		xret := "getProperty"(l, rfield) with elab;
			dd := "i__isDataDescriptor"(xret);
			goto [dd] reject is_ad;
	is_ad:		ad := "i__isAccessorDescriptor"(xret);
			goto [ad] ad reject;
	ad:		s := l-nth(xret, 2.);
			m := metadata (s);
			xsc := [m, "@scope"];
			fun := [m, "@call"];
			xret := fun(xsc, rbase, w) with elab;
			goto dflt;
	reject:		xret := "TypeError"();
			goto elab
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec OP_hasOwnProperty(xsc, vthis, v)
[[ types(#en : Bool, #wr : Bool, #co : Bool, #prop : Str) * (! (#v == empty)) * (v == #prop) * (xsc == _lvar_xsc) * (vthis == _$l_#l) * ((_$l_#md, "@class") ->@d "Object") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", #v, #wr, #en, #co }}) ]]
[[ types(#en : Bool, #wr : Bool, #co : Bool, #prop : Str) * (! (#v == empty)) * (xret == true) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * ((_$l_#md, "@class") ->@d "Object") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", #v, #wr, #en, #co }}) ]]
normal;

 [[ types(#prop : Str) * (v == #prop) * (xsc == _lvar_xsc) * (vthis == _$l_#l) * ((_$l_#md, "@class") ->@d "Object") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#prop : Str) * (xret == false) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * ((_$l_#md, "@class") ->@d "Object") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal

proc OP_hasOwnProperty (xsc, vthis, v) {
			xret := "i__toString"(v) with elab;
			p := xret;
			xret := "i__toObject"(vthis) with elab;
			xret := "getOwnProperty"(xret, p) with elab;
			xret := (not (xret = undefined));
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec hasProperty(l, prop)
[[ Pi(#l, #prop, undefined, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, undefined, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal;

 [[ Pi(#l, #prop, {{ "d", _lvar_192, _lvar_193, _lvar_194, _lvar_195 }}, #ls, #cls, #pv) * types(#cls : List, #l : Obj, _lvar_195 : Bool, _lvar_193 : Bool, _lvar_194 : Bool, #ls : List, #prop : Str, #pv : List, #d : List) * (#d == {{ "d", _lvar_192, _lvar_193, _lvar_194, _lvar_195 }}) * (! (_lvar_192 == empty)) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #d, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List, #d : List) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal;

 [[ Pi(#l, #prop, {{ "a", _lvar_197, _lvar_196, _lvar_198, _lvar_199 }}, #ls, #cls, #pv) * types(#cls : List, #l : Obj, _lvar_199 : Bool, #ls : List, #prop : Str, _lvar_198 : Bool, #pv : List, #d : List) * (#d == {{ "a", _lvar_197, _lvar_196, _lvar_198, _lvar_199 }}) * (! (_lvar_197 == empty)) * (! (_lvar_196 == empty)) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #d, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List, #d : List) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal

proc hasProperty (l, prop) {
			xret := "getProperty"(l, prop) with elab;
	rlab:		xret := (not (xret = undefined));
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec create_object_with_call_construct(l, call, construct, len)
[[ types(#len : Num, #call : Str) * (l == _$l_#l) * (construct == empty) * (len == #len) * (call == #call) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@scope") ->@d #lvar_10) * ((_$l_#md, "@proto") ->@d #lvar_7) * ((_$l_#md, "@extensible") ->@d #lvar_9) * ((_$l_#md, "@class") ->@d #lvar_8) * ((_$l_#md, "@call") ->@d #lvar_11) * Extensible (_$l_#l, true) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, "length") ->@d #lvar_6) ]]
[[ types(#len : Num, #call : Str) * (xret == _$l_#l) * (l == _lvar_l) * (construct == _lvar_construct) * (len == _lvar_len) * (call == _lvar_call) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@scope") ->@d empty) * ((_$l_#md, "@proto") ->@d $lfun_proto) * ((_$l_#md, "@extensible") ->@d true) * ((_$l_#md, "@class") ->@d "Function") * ((_$l_#md, "@call") ->@d #call) * Extensible (_$l_#l, true) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, "length") ->@d {{ "d", #len, false, false, false }}) ]]
normal;

 [[ types(#construct : Str, #len : Num, #call : Str) * (l == _$l_#l) * (construct == #construct) * (len == #len) * (call == #call) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@scope") ->@d #lvar_16) * ((_$l_#md, "@proto") ->@d #lvar_13) * ((_$l_#md, "@extensible") ->@d #lvar_15) * ((_$l_#md, "@construct") ->@d #lvar_18) * ((_$l_#md, "@class") ->@d #lvar_14) * ((_$l_#md, "@call") ->@d #lvar_17) * Extensible (_$l_#l, true) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, "length") ->@d #lvar_12) ]]
[[ types(#construct : Str, #len : Num, #call : Str) * (xret == _$l_#l) * (l == _lvar_l) * (construct == _lvar_construct) * (len == _lvar_len) * (call == _lvar_call) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@scope") ->@d empty) * ((_$l_#md, "@proto") ->@d $lfun_proto) * ((_$l_#md, "@extensible") ->@d true) * ((_$l_#md, "@construct") ->@d #construct) * ((_$l_#md, "@class") ->@d "Function") * ((_$l_#md, "@call") ->@d #call) * Extensible (_$l_#l, true) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, "length") ->@d {{ "d", #len, false, false, false }}) ]]
normal

proc create_object_with_call_construct (l, call, construct, len) {
			xret := "create_default_object"(l, $lfun_proto, "Function", true);
			[xret, "length"] := {{ "d", len, false, false, false }};
			m := metadata (xret);
			[m, "@scope"] := empty;
			[m, "@call"] := call;
			goto [(construct = empty)] rlab cstr;
	cstr:		[m, "@construct"] := construct;
	rlab:		xret := l
} with {
	ret: xret, rlab;
};


spec i__isPrimitive(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_85 : Num) * (v == _lvar_85) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_86 : Bool) * (v == _lvar_86) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_87 : Str) * (v == _lvar_87) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_88 : Obj) * (v == _lvar_88) ]]
[[ types() * (xret == false) * (v == _lvar_v) ]]
normal

proc i__isPrimitive (v) {
			tv := (typeOf v);
	iu:		goto [(((((v = undefined) or (v = null)) or ((typeOf v) = Bool)) or ((typeOf v) = Num)) or ((typeOf v) = Str))] rt rf;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec Object_construct(xsc, vthis, l)
[[ types(#l : Undefined) * (#l == undefined) * (l == undefined) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) ]]
[[ types(#l : Undefined) * (#l == undefined) * (xret == _$l_xret) * (l == _lvar_l) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * Extensible (_$l__lvar_84, true) * MetaData (_$l__lvar_84, null) * empty_fields(_$l__lvar_84 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_84, "@proto") ->@d $lobj_proto) * ((_$l__lvar_84, "@extensible") ->@d true) * ((_$l__lvar_84, "@class") ->@d "Object") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_84) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc Object_construct (xsc, vthis, l) {
			goto [((typeOf l) = Obj)] obj l1b;
	obj:		xret := l;
			goto rlab;
	l1b:		goto [((((typeOf l) = Bool) or ((typeOf l) = Num)) or ((typeOf l) = Str))] to_obj norm;
	to_obj:		xret := "i__toObject"(l);
			goto rlab;
	norm:		xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lobj_proto, "Object", true);
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__sameValue(v1, v2)
[[ types() * (v2 == 0.) * (v1 == 0.) ]]
[[ types() * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (v2 == -0.) * (v1 == -0.) ]]
[[ types() * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (v2 == 0.) * (v1 == -0.) ]]
[[ types() * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (v2 == -0.) * (v1 == 0.) ]]
[[ types() * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (v2 == _lvar_674) * (v1 == _lvar_674) ]]
[[ types() * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (! (_lvar_v1 == _lvar_v2)) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
[[ types() * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal

proc i__sameValue (v1, v2) {
			goto [((typeOf v1) = Num)] test2 nonum;
	test2:		goto [((typeOf v2) = Num)] inan1 nonum;
	inan1:		goto [(not (v1 = v1))] inan2 zero1;
	inan2:		goto [(not (v2 = v2))] rt zero1;
	zero1:		goto [(v1 = 0.)] zero2 nonum;
	zero2:		goto [(v2 = 0.)] fix nonum;
	fix:		sv1 := (m_sgn v1);
			sv2 := (m_sgn v2);
			goto [(sv1 = sv2)] rt rf;
			goto rlab;
	nonum:		goto [(v1 = v2)] rt rf;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__toObject(v)
[[ types(#v : Obj) * (v == #v) ]]
[[ types(#v : Obj) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Bool) * (v == #v) ]]
[[ types(#v : Bool) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_672, true) * MetaData (_$l__lvar_672, null) * empty_fields(_$l__lvar_672 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_672, "@proto") ->@d $lbool_proto) * ((_$l__lvar_672, "@primitiveValue") ->@d #v) * ((_$l__lvar_672, "@extensible") ->@d true) * ((_$l__lvar_672, "@class") ->@d "Boolean") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_672) * empty_fields(_$l_xret : -{  }-) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_673, true) * MetaData (_$l__lvar_673, null) * empty_fields(_$l__lvar_673 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_673, "@proto") ->@d $lnum_proto) * ((_$l__lvar_673, "@primitiveValue") ->@d #v) * ((_$l__lvar_673, "@extensible") ->@d true) * ((_$l__lvar_673, "@class") ->@d "Number") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_673) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc i__toObject (v) {
	iu:		goto [(v = undefined)] throw in;
	in:		goto [(v = null)] throw ib;
	ib:		goto [((typeOf v) = Bool)] bool inum;
	bool:		xret := "Boolean_construct"(undefined, undefined, v);
			goto rlab;
	inum:		goto [((typeOf v) = Num)] num is;
	num:		xret := "Number_construct"(undefined, undefined, v);
			goto rlab;
	is:		goto [((typeOf v) = Str)] str io;
	str:		xret := "String_construct"(undefined, undefined, v);
			goto rlab;
	io:		goto [((typeOf v) = Obj)] obj oops;
	obj:		xret := v;
			goto rlab;
	oops:		xret := "ToObject: This should not happen.";
	rlab:		skip;
	throw:		xret := "Here!";
			xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__toBoolean(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == false) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == false) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Bool) * (v == #v) ]]
[[ types(#v : Bool) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == 0.) ]]
[[ types() * (xret == false) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (! (#v == 0.)) * (v == #v) ]]
[[ types(#v : Num) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == "") ]]
[[ types() * (xret == false) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (! (#v == "")) * (v == #v) ]]
[[ types(#v : Str) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Obj) * (v == #v) ]]
[[ types(#v : Obj) * (xret == true) * (v == _lvar_v) ]]
normal

proc i__toBoolean (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := false;
			goto rlab;
	in:		goto [(v = null)] nul ib;
	nul:		xret := false;
			goto rlab;
	ib:		goto [((typeOf v) = Bool)] bool inum;
	bool:		xret := v;
			goto rlab;
	inum:		goto [((typeOf v) = Num)] num is;
	num:		goto [((v = 0.) or (not (v = v)))] is_f is_t;
	is:		goto [((typeOf v) = Str)] str io;
	str:		goto [(v = "")] is_f is_t;
			goto rlab;
	io:		goto [((typeOf v) = Obj)] obj oops;
	obj:		xret := true;
			goto rlab;
	is_t:		xret := true;
			goto rlab;
	is_f:		xret := false;
			goto rlab;
	oops:		xret := "ToBoolean: This should not happen.";
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec getProperty(l, prop)
[[ Pi(#l, #prop, #d, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #d, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List) * (xret == #d) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal

proc getProperty (l, prop) {
			[* unfold Pi(#l, #prop, #d, #ls, #cls, #pv) *]
			xret := "getOwnProperty"(l, prop) with elab;
			goto [(xret = undefined)] next rlab;
	next:		m := metadata (l);
			proto := [m, "@proto"];
			goto [(proto = null)] rlab call;
	call:		xret := "getProperty"(proto, prop) with elab;
			[* fold Pi(#l, #prop, #d, #ls, #cls, #pv) *]
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec Number_construct(xsc, vthis, v)
[[ types(#v : Num) * (v == #v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) ]]
[[ types(#v : Num) * (xret == _$l_xret) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * Extensible (_$l__lvar_380, true) * MetaData (_$l__lvar_380, null) * empty_fields(_$l__lvar_380 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_380, "@proto") ->@d $lnum_proto) * ((_$l__lvar_380, "@primitiveValue") ->@d #v) * ((_$l__lvar_380, "@extensible") ->@d true) * ((_$l__lvar_380, "@class") ->@d "Number") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_380) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc Number_construct (xsc, vthis, v) {
	init:		pv := "i__toNumber"(v) with elab;
			xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lnum_proto, "Number", true);
			m := metadata (xret);
			[m, "@primitiveValue"] := pv;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: pv, elab;
};


spec get(l, prop)
[[ Pi(#l, #prop, undefined, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List, #d : Undefined) * (#d == undefined) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, undefined, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List, #d : Undefined) * (#d == undefined) * (xret == undefined) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal;

 [[ Pi(#l, #prop, {{ "d", _lvar_238, _lvar_239, _lvar_240, _lvar_241 }}, #ls, #cls, #pv) * types(#cls : List, _lvar_240 : Bool, #l : Obj, _lvar_241 : Bool, _lvar_239 : Bool, #ls : List, #prop : Str, #pv : List, #d : List) * (#d == {{ "d", _lvar_238, _lvar_239, _lvar_240, _lvar_241 }}) * (! (_lvar_238 == empty)) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #d, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List, #d : List) * (xret == l-nth(#d, 1.)) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal

proc get (l, prop) {
			xret := "getProperty"(l, prop) with elab;
			goto [(xret = undefined)] rlab def;
	def:		d := l-nth(xret, 0.);
			xret := l-nth(xret, 1.);
			goto [(d = "d")] rlab acc;
	acc:		goto [(xret = undefined)] rlab get;
	get:		m := metadata (xret);
			xsc := [m, "@scope"];
			fun := [m, "@call"];
			xret := fun(xsc, l) with elab;
			goto [(xret = empty)] undef rlab;
	undef:		xret := undefined;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__checkObjectCoercible(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_200) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_200, true) * MetaData (_$l__lvar_200, null) * empty_fields(_$l__lvar_200 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_200, "@proto") ->@d $lterr_proto) * ((_$l__lvar_200, "@extensible") ->@d true) * ((_$l__lvar_200, "@class") ->@d "Error") ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_201, true) * MetaData (_$l__lvar_201, null) * empty_fields(_$l__lvar_201 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_201, "@proto") ->@d $lterr_proto) * ((_$l__lvar_201, "@extensible") ->@d true) * ((_$l__lvar_201, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_201) * empty_fields(_$l_xret : -{  }-) ]]
normal;

 [[ types(_lvar_202 : Num) * (v == _lvar_202) ]]
[[ types() * (xret == empty) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_203 : Bool) * (v == _lvar_203) ]]
[[ types() * (xret == empty) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_204 : Str) * (v == _lvar_204) ]]
[[ types() * (xret == empty) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_205 : Obj) * (v == _lvar_205) ]]
[[ types() * (xret == empty) * (v == _lvar_v) ]]
normal

proc i__checkObjectCoercible (v) {
			xret := empty;
	iu:		goto [(v = undefined)] throw in;
	in:		goto [(v = null)] throw other;
	other:		goto [(((((typeOf v) = Bool) or ((typeOf v) = Num)) or ((typeOf v) = Str)) or ((typeOf v) = Obj))] rlab oops;
	oops:		xret := "CheckObjectCoercible: This should not happen.";
	rlab:		skip;
	throw:		xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec SyntaxError_call(xsc, vthis, v)
[[ types() * (v == undefined) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_191) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_191, true) * MetaData (_$l__lvar_191, null) * empty_fields(_$l__lvar_191 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_191, "@proto") ->@d $lserr_proto) * ((_$l__lvar_191, "@extensible") ->@d true) * ((_$l__lvar_191, "@class") ->@d "Error") ]]
normal

proc SyntaxError_call (xsc, vthis, v) {
			xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lserr_proto, "Error", true);
			xret := "Error_construct"(undefined, xret, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__getValue(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == undefined) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == null) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Obj) * (v == #v) ]]
[[ types(#v : Obj) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Bool) * (v == #v) ]]
[[ types(#v : Bool) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ Pi(#obj, #field, undefined, #ls, #lcls, #lpv) * types(#field : Str, #lpv : List, #lcls : List, #obj : Obj, #ls : List, #d : Undefined) * (#d == undefined) * (v == {{ "o", #obj, #field }}) ]]
[[ Pi(#obj, #field, undefined, #ls, #lcls, #lpv) * types(#field : Str, #lpv : List, #lcls : List, #obj : Obj, #ls : List, #d : Undefined) * (#d == undefined) * (xret == undefined) * (v == _lvar_v) ]]
normal;

 [[ Pi(#obj, #field, {{ "d", _lvar_145, _lvar_146, _lvar_147, _lvar_148 }}, #ls, #lcls, #lpv) * types(_lvar_146 : Bool, _lvar_147 : Bool, #field : Str, #lpv : List, #lcls : List, #obj : Obj, #ls : List, _lvar_148 : Bool, #d : List) * (#d == {{ "d", _lvar_145, _lvar_146, _lvar_147, _lvar_148 }}) * (! (_lvar_145 == empty)) * (v == {{ "o", #obj, #field }}) ]]
[[ Pi(#obj, #field, #d, #ls, #lcls, #lpv) * types(#field : Str, #lpv : List, #lcls : List, #obj : Obj, #ls : List, #d : List) * (xret == l-nth(#d, 1.)) * (v == _lvar_v) ]]
normal;

 [[ Pi($lg, #field, undefined, #ls, #lcls, #lpv) * types(#field : Str, #lpv : List, #lcls : List, #ls : List, #d : Undefined) * (#d == undefined) * (v == {{ "v", $lg, #field }}) ]]
[[ Pi($lg, #field, undefined, #ls, #lcls, #lpv) * types(#field : Str, #lpv : List, #lcls : List, #ls : List, #d : Undefined) * (#d == undefined) * (xret == undefined) * (v == _lvar_v) ]]
normal;

 [[ Pi($lg, #field, {{ "d", _lvar_149, _lvar_150, _lvar_151, _lvar_152 }}, #ls, #lcls, #lpv) * types(_lvar_150 : Bool, _lvar_152 : Bool, #field : Str, _lvar_151 : Bool, #lpv : List, #lcls : List, #ls : List, #d : List) * (#d == {{ "d", _lvar_149, _lvar_150, _lvar_151, _lvar_152 }}) * (! (_lvar_149 == empty)) * (v == {{ "v", $lg, #field }}) ]]
[[ Pi($lg, #field, #d, #ls, #lcls, #lpv) * types(#field : Str, #lpv : List, #lcls : List, #ls : List, #d : List) * (xret == l-nth(#d, 1.)) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == {{ "v", _$l_#obj, #field }}) * ((_$l_#obj, #field) ->@d #value) ]]
[[ types() * (xret == #value) * (v == _lvar_v) * ((_$l_#obj, #field) ->@d #value) ]]
normal;

 [[ types(#field : Str) * (v == {{ "v", undefined, #field }}) ]]
[[ types(#field : Str) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_153, true) * MetaData (_$l__lvar_153, null) * empty_fields(_$l__lvar_153 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_153, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_153, "@extensible") ->@d true) * ((_$l__lvar_153, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_153) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#field : Str) * (v == {{ "o", undefined, #field }}) ]]
[[ types(#field : Str) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_154, true) * MetaData (_$l__lvar_154, null) * empty_fields(_$l__lvar_154 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_154, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_154, "@extensible") ->@d true) * ((_$l__lvar_154, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_154) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi($lbool_proto, #field, undefined, ($lbool_proto :: #ols), ("Boolean" :: #ocls), ("" :: #opv)) * types(#field : Str, #b : Bool, #opv : List, #ocls : List, #ols : List, #d : Undefined) * (#d == undefined) * (v == {{ "o", #b, #field }}) ]]
[[ Pi($lbool_proto, #field, undefined, ($lbool_proto :: #ols), ("Boolean" :: #ocls), ("" :: #opv)) * types(#field : Str, #b : Bool, #opv : List, #ocls : List, #ols : List, #d : Undefined) * (#d == undefined) * (xret == undefined) * (v == _lvar_v) * (xobj == _$l_#o) * Extensible (_$l_#o, true) * MetaData (_$l_#o, _$l__lvar_155) * empty_fields(_$l_#o : -{  }-) * Extensible (_$l__lvar_155, true) * MetaData (_$l__lvar_155, null) * empty_fields(_$l__lvar_155 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_155, "@proto") ->@d $lbool_proto) * ((_$l__lvar_155, "@primitiveValue") ->@d #b) * ((_$l__lvar_155, "@extensible") ->@d true) * ((_$l__lvar_155, "@class") ->@d "Boolean") ]]
normal;

 [[ Pi($lbool_proto, #field, {{ "d", _lvar_162, _lvar_163, _lvar_164, _lvar_165 }}, ($lbool_proto :: #ols), ("Boolean" :: #ocls), ("" :: #opv)) * types(#field : Str, #b : Bool, _lvar_163 : Bool, #opv : List, _lvar_164 : Bool, #ocls : List, _lvar_165 : Bool, #ols : List, #d : List) * (#d == {{ "d", _lvar_162, _lvar_163, _lvar_164, _lvar_165 }}) * (! (_lvar_162 == empty)) * (v == {{ "o", #b, #field }}) ]]
[[ Pi($lbool_proto, #field, #d, ($lbool_proto :: #ols), ("Boolean" :: #ocls), ("" :: #opv)) * types(#field : Str, #b : Bool, #opv : List, #ocls : List, #ols : List, #d : List) * (xret == l-nth(#d, 1.)) * (v == _lvar_v) * (xobj == _$l_#o) * Extensible (_$l_#o, true) * MetaData (_$l_#o, _$l__lvar_166) * empty_fields(_$l_#o : -{  }-) * Extensible (_$l__lvar_166, true) * MetaData (_$l__lvar_166, null) * empty_fields(_$l__lvar_166 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_166, "@proto") ->@d $lbool_proto) * ((_$l__lvar_166, "@primitiveValue") ->@d #b) * ((_$l__lvar_166, "@extensible") ->@d true) * ((_$l__lvar_166, "@class") ->@d "Boolean") ]]
normal;

 [[ Pi($lnum_proto, #field, undefined, ($lnum_proto :: #ols), ("Number" :: #ocls), ("" :: #opv)) * types(#field : Str, #opv : List, #ocls : List, #n : Num, #ols : List, #d : Undefined) * (#d == undefined) * (v == {{ "o", #n, #field }}) ]]
[[ Pi($lnum_proto, #field, undefined, ($lnum_proto :: #ols), ("Number" :: #ocls), ("" :: #opv)) * types(#field : Str, #opv : List, #ocls : List, #n : Num, #ols : List, #d : Undefined) * (#d == undefined) * (xret == undefined) * (v == _lvar_v) * (xobj == _$l_#o) * Extensible (_$l__lvar_173, true) * MetaData (_$l__lvar_173, null) * empty_fields(_$l__lvar_173 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_173, "@proto") ->@d $lnum_proto) * ((_$l__lvar_173, "@primitiveValue") ->@d #n) * ((_$l__lvar_173, "@extensible") ->@d true) * ((_$l__lvar_173, "@class") ->@d "Number") * Extensible (_$l_#o, true) * MetaData (_$l_#o, _$l__lvar_173) * empty_fields(_$l_#o : -{  }-) ]]
normal;

 [[ Pi($lnum_proto, #field, {{ "d", _lvar_180, _lvar_181, _lvar_182, _lvar_183 }}, ($lnum_proto :: #ols), ("Number" :: #ocls), ("" :: #opv)) * types(#field : Str, #opv : List, #ocls : List, _lvar_182 : Bool, #n : Num, #ols : List, _lvar_183 : Bool, #d : List, _lvar_181 : Bool) * (#d == {{ "d", _lvar_180, _lvar_181, _lvar_182, _lvar_183 }}) * (! (_lvar_180 == empty)) * (v == {{ "o", #n, #field }}) ]]
[[ Pi($lnum_proto, #field, #d, ($lnum_proto :: #ols), ("Number" :: #ocls), ("" :: #opv)) * types(#field : Str, #opv : List, #ocls : List, #n : Num, #ols : List, #d : List) * (xret == l-nth(#d, 1.)) * (v == _lvar_v) * (xobj == _$l_#o) * Extensible (_$l__lvar_184, true) * MetaData (_$l__lvar_184, null) * empty_fields(_$l__lvar_184 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_184, "@proto") ->@d $lnum_proto) * ((_$l__lvar_184, "@primitiveValue") ->@d #n) * ((_$l__lvar_184, "@extensible") ->@d true) * ((_$l__lvar_184, "@class") ->@d "Number") * Extensible (_$l_#o, true) * MetaData (_$l_#o, _$l__lvar_184) * empty_fields(_$l_#o : -{  }-) ]]
normal

proc i__getValue (v) {
			goto [((typeOf v) = List)] rcand dflt;
	rcand:		rtype := l-nth(v, 0.);
			goto [((rtype = "v") or (rtype = "o"))] init dflt;
	init:		rbase := l-nth(v, 1.);
			rfield := l-nth(v, 2.);
			goto [(rbase = undefined)] throw prim;
	prim:		prim := "i__isPrimitive"(rbase);
			goto [prim] is_pr ref;
	is_pr:		xobj := "i__toObject"(rbase) with pelab;
			[* fold Pi(xobj, #field, #d, #ls, #lcls, #lpv) *]
			xret := "getProperty"(xobj, rfield) with pelab;
			[* unfold Pi(xobj, #field, #d, #ls, #lcls, #lpv) *]
			goto [(xret = undefined)] rlab def;
	def:		d := l-nth(xret, 0.);
			xret := l-nth(xret, 1.);
			goto [(d = "d")] rlab acc;
	acc:		goto [(xret = undefined)] rlab get;
	get:		m := metadata (xret);
			xsc := [m, "@scope"];
			fun := [m, "@call"];
			xret := fun(xsc, rbase) with pelab;
			goto [(xret = empty)] undef rlab;
	undef:		xret := undefined;
	ref:		goto [(((typeOf v) = List) and (l-nth(v, 0.) = "o"))] oref vref;
	oref:		xret := "get"(rbase, rfield) with pelab;
			goto rlab;
	vref:		goto [(rbase = $lg)] lg er;
	lg:		xret := "get"(rbase, rfield) with pelab;
			goto rlab;
	er:		xret := [rbase, rfield];
			goto rlab;
	dflt:		xret := v;
	rlab:		skip;
	throw:		xret := "ReferenceError"();
	pelab:		xret := PHI(xobj, xret, xret, xret, xret, xret);
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec ReferenceError_call(xsc, vthis, v)
[[ types() * (v == undefined) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_144) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_144, true) * MetaData (_$l__lvar_144, null) * empty_fields(_$l__lvar_144 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_144, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_144, "@extensible") ->@d true) * ((_$l__lvar_144, "@class") ->@d "Error") ]]
normal

proc ReferenceError_call (xsc, vthis, v) {
			xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lrferr_proto, "Error", true);
			xret := "Error_construct"(undefined, xret, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec SyntaxError(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_103, true) * MetaData (_$l__lvar_103, null) * empty_fields(_$l__lvar_103 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_103, "@proto") ->@d $lserr_proto) * ((_$l__lvar_103, "@extensible") ->@d true) * ((_$l__lvar_103, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_103) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc SyntaxError (v) {
			xret := "SyntaxError_call"(undefined, undefined, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};



