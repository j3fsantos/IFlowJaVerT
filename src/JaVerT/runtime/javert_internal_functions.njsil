pred isClass (c, pvar_0): 
(c == "Array") * (pvar_0 == "Array") * types(c : $$string_type, pvar_0 : $$string_type),
 (c == "String") * (pvar_0 == "String") * types(c : $$string_type, pvar_0 : $$string_type),
 (c == _lvar_c) * (pvar_0 == "Non-String") * (! (_lvar_c == "String")) * types(c : $$string_type, pvar_0 : $$string_type, _lvar_c : $$string_type),
 (c == _lvar_c) * (pvar_0 == "Non-Array") * (! (_lvar_c == "Array")) * types(c : $$string_type, pvar_0 : $$string_type, _lvar_c : $$string_type);

pred ErrorObject (l, pr): 
empty_fields(_$l_l : -{ "@class", "@extensible", "@proto" }-) * ((_$l_l, "@extensible") -> $$t) * ((_$l_l, "@class") -> "Error") * ((_$l_l, "@proto") -> _lvar_pr) * (l == _$l_l) * (pr == _lvar_pr) * types(l : $$object_type, _lvar_pr : $$object_type, pr : $$object_type);

pred initialHeapPost (): 
empty_fields($lfun_proto : -{ "@call", "@class", "@extensible", "@proto", "@scope", "length" }-) * (($lfun_proto, "@call") -> "FP_default") * (($lfun_proto, "length") -> {{ "d", 0., $$f, $$f, $$f }}) * (($lfun_proto, "@scope") -> $$empty) * (($lfun_proto, "@extensible") -> $$t) * (($lfun_proto, "@proto") -> $lobj_proto) * (($lfun_proto, "@class") -> "Function") * empty_fields($lerr : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope", "length", "prototype" }-) * (($lerr, "prototype") -> {{ "d", $lerr_proto, $$f, $$f, $$f }}) * (($lerr, "@construct") -> "Error_construct") * (($lerr, "@call") -> "Error_call") * (($lerr, "length") -> {{ "d", 1., $$f, $$f, $$f }}) * (($lerr, "@scope") -> $$empty) * (($lerr, "@extensible") -> $$t) * (($lerr, "@proto") -> $lfun_proto) * (($lerr, "@class") -> "Function") * (($lg, "Error") -> {{ "d", $lerr, $$t, $$f, $$t }}) * (($lg, "@extensible") -> $$t) * (($lg, "@proto") -> $lobj_proto) * (($lg, "@class") -> "Object") * empty_fields($lop_hasOwnProperty : -{ "@call", "@class", "@extensible", "@proto", "@scope", "length" }-) * (($lop_hasOwnProperty, "@call") -> "OP_hasOwnProperty") * (($lop_hasOwnProperty, "length") -> {{ "d", 1., $$f, $$f, $$f }}) * (($lop_hasOwnProperty, "@scope") -> $$empty) * (($lop_hasOwnProperty, "@extensible") -> $$t) * (($lop_hasOwnProperty, "@proto") -> $lfun_proto) * (($lop_hasOwnProperty, "@class") -> "Function") * empty_fields($lobj_proto : -{ "@class", "@extensible", "@proto", "hasOwnProperty" }-) * (($lobj_proto, "hasOwnProperty") -> {{ "d", $lop_hasOwnProperty, $$t, $$f, $$t }}) * (($lobj_proto, "@extensible") -> $$t) * (($lobj_proto, "@proto") -> $$null) * (($lobj_proto, "@class") -> "Object") * empty_fields($lerr_proto : -{ "@class", "@extensible", "@proto", "message" }-) * (($lerr_proto, "message") -> {{ "d", "", $$t, $$f, $$t }}) * (($lerr_proto, "@extensible") -> $$t) * (($lerr_proto, "@proto") -> $lobj_proto) * (($lerr_proto, "@class") -> "Error") * types();

pred desc_enum (d, v): 
(v == l-nth(_lvar_518, 3.)) * (d == _lvar_518) * types(d : $$list_type, _lvar_518 : $$list_type);

pred desc_set (d, v): 
(v == l-nth(_lvar_517, 2.)) * (d == _lvar_517) * types(d : $$list_type, _lvar_517 : $$list_type);

pred desc_conf (d, v): 
(v == l-nth(_lvar_520, 4.)) * (d == _lvar_520) * types(d : $$list_type, _lvar_520 : $$list_type);

pred desc_val (d, v): 
(v == l-nth(_lvar_519, 1.)) * (d == _lvar_519) * types(d : $$list_type, _lvar_519 : $$list_type);

pred DataDescriptor (d): 
(d == {{ "d", #dval, #dwrit, #denum, #dconf }}) * (! (#dval == $$empty)) * types(#denum : $$boolean_type, d : $$list_type, #dwrit : $$boolean_type, #dconf : $$boolean_type);

pred GenericDescriptor (d): 
(d == {{ "g", #genum, #gconf, #gval, #gwrit, #gget, #gset }}) * types(d : $$list_type);

pred Pi (l, prop, lcls, d, ls, ltf, lpv): 
((_$l_l, _lvar_prop) -> None) * ((_$l_l, "@class") -> #cls) * ((_$l_l, "@proto") -> $$null) * (lcls == {{ #cls }}) * (l == _$l_l) * (prop == _lvar_prop) * (ltf == {{ $$f }}) * (ls == {{ _$l_l }}) * (d == $$undefined) * (lpv == {{ "" }}) * (! (s-nth(_lvar_prop, 0.) == "@")) * (! (_lvar_prop == "")) * (! (#cls == "String")) * types(ls : $$list_type, lcls : $$list_type, _lvar_prop : $$string_type, d : $$undefined_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, ltf : $$list_type, lpv : $$list_type),
 ((_$l_l, _lvar_prop) -> {{ "d", _lvar_4, _lvar_5, _lvar_6, _lvar_7 }}) * ((_$l_l, "@class") -> #cls) * (lcls == {{ #cls }}) * (l == _$l_l) * (prop == _lvar_prop) * (ltf == {{ $$f }}) * (ls == {{ _$l_l }}) * (d == {{ "d", _lvar_4, _lvar_5, _lvar_6, _lvar_7 }}) * (lpv == {{ "" }}) * (! (_lvar_4 == $$empty)) * (! (s-nth(_lvar_prop, 0.) == "@")) * (! (_lvar_prop == "")) * (! (#cls == "String")) * types(lcls : $$list_type, ls : $$list_type, _lvar_prop : $$string_type, l : $$object_type, d : $$list_type, _lvar_6 : $$boolean_type, prop : $$string_type, #cls : $$string_type, ltf : $$list_type, _lvar_5 : $$boolean_type, lpv : $$list_type, _lvar_7 : $$boolean_type),
 ((_$l_l, _lvar_prop) -> None) * ((_$l_l, "@proto") -> #lp) * ((_$l_l, "@class") -> #cls) * (lcls == (#cls :: (#pcls :: #ocls))) * (l == _$l_l) * (prop == _lvar_prop) * (ltf == ($$f :: (#ptf :: #otf))) * (ls == (_$l_l :: (#lp :: #ols))) * (d == _lvar_d) * (lpv == ("" :: (#ppv :: #otv))) * (! (s-nth(_lvar_prop, 0.) == "@")) * (! (_lvar_prop == "")) * (! (#cls == "String")) * (#lpv == (#ppv :: #otv)) * (#ltf == (#ptf :: #otf)) * (#lls == (#lp :: #ols)) * (#lcls == (#pcls :: #ocls)) * types(#ocls : $$list_type, #otv : $$list_type, #otf : $$list_type, #lcls : $$list_type, lcls : $$list_type, ls : $$list_type, #lp : $$object_type, _lvar_prop : $$string_type, l : $$object_type, #ols : $$list_type, prop : $$string_type, #cls : $$string_type, #ppv : $$string_type, #ptf : $$boolean_type, ltf : $$list_type, #lls : $$list_type, lpv : $$list_type, #pcls : $$string_type, #ltf : $$list_type, #lpv : $$list_type) * Pi(#lp, _lvar_prop, (#pcls :: #ocls), _lvar_d, (#lp :: #ols), (#ptf :: #otf), (#ppv :: #otv));

pred isReferenceError (l): 
empty_fields(_$l_l : -{ "@class", "@extensible", "@proto" }-) * ((_$l_l, "@extensible") -> $$t) * ((_$l_l, "@class") -> "Error") * ((_$l_l, "@proto") -> $lrferr_proto) * (l == _$l_l) * types(l : $$object_type);

pred initialHeapPre (): 
empty_fields($lfun_proto : -{  }-) * empty_fields($lerr : -{  }-) * (($lg, "@extensible") -> None) * (($lg, "@proto") -> None) * (($lg, "@class") -> None) * empty_fields($lop_hasOwnProperty : -{  }-) * empty_fields($lobj_proto : -{  }-) * empty_fields($lerr_proto : -{  }-) * types();

pred isTypeError (l): 
empty_fields(_$l_l : -{ "@class", "@extensible", "@proto" }-) * ((_$l_l, "@extensible") -> $$t) * ((_$l_l, "@class") -> "Error") * ((_$l_l, "@proto") -> $lterr_proto) * (l == _$l_l) * types(l : $$object_type);

pred isSyntaxError (l): 
empty_fields(_$l_l : -{ "@class", "@extensible", "@proto" }-) * ((_$l_l, "@extensible") -> $$t) * ((_$l_l, "@class") -> "Error") * ((_$l_l, "@proto") -> $lserr_proto) * (l == _$l_l) * types(l : $$object_type);

pred desc_writ (d, v): 
(v == l-nth(_lvar_522, 2.)) * (d == _lvar_522) * types(_lvar_522 : $$list_type, d : $$list_type);

pred function_object (l, xsc, call, construct, len, prototype): 
empty_fields(_$l_l : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope", "arguments", "caller", "length", "prototype" }-) * ((_$l_l, "prototype") -> {{ "d", _lvar_prototype, $$t, $$f, $$f }}) * ((_$l_l, "arguments") -> {{ "a", $lthrow_type_error, $lthrow_type_error, $$f, $$f }}) * ((_$l_l, "caller") -> {{ "a", $lthrow_type_error, $lthrow_type_error, $$f, $$f }}) * ((_$l_l, "@construct") -> _lvar_construct) * ((_$l_l, "@call") -> _lvar_call) * ((_$l_l, "length") -> {{ "d", _lvar_len, $$f, $$f, $$f }}) * ((_$l_l, "@scope") -> _lvar_xsc) * ((_$l_l, "@extensible") -> $$t) * ((_$l_l, "@class") -> "Function") * ((_$l_l, "@proto") -> $lfun_proto) * (call == _lvar_call) * (len == _lvar_len) * (construct == _lvar_construct) * (prototype == _lvar_prototype) * (xsc == _lvar_xsc) * (l == _$l_l) * types(_lvar_prototype : $$object_type, _lvar_call : $$string_type, construct : $$string_type, prototype : $$object_type, xsc : $$list_type, l : $$object_type, call : $$string_type, len : $$number_type, _lvar_construct : $$string_type, _lvar_xsc : $$list_type, _lvar_len : $$number_type);

pred isNamedProperty (prop): 
(prop == _lvar_prop) * (! (s-nth(_lvar_prop, 0.) == "@")) * (! (_lvar_prop == "")) * types(_lvar_prop : $$string_type, prop : $$string_type);

pred desc_get (d, v): 
(v == l-nth(_lvar_525, 1.)) * (d == _lvar_525) * types(_lvar_525 : $$list_type, d : $$list_type);

pred Cell_o (l, prop, d): 
((_$l_l, _lvar_prop) -> None) * (l == _$l_l) * (prop == _lvar_prop) * (d == None) * (! (s-nth(_lvar_prop, 0.) == "@")) * (! (_lvar_prop == "")) * types(_lvar_prop : $$string_type, d : $$none_type, l : $$object_type, prop : $$string_type),
 ((_$l_l, _lvar_prop) -> {{ "d", _lvar_12, _lvar_13, _lvar_14, _lvar_15 }}) * (l == _$l_l) * (prop == _lvar_prop) * (d == {{ "d", _lvar_12, _lvar_13, _lvar_14, _lvar_15 }}) * (! (_lvar_12 == $$empty)) * (! (s-nth(_lvar_prop, 0.) == "@")) * (! (_lvar_prop == "")) * types(_lvar_13 : $$boolean_type, _lvar_prop : $$string_type, l : $$object_type, d : $$list_type, prop : $$string_type, _lvar_14 : $$boolean_type, _lvar_15 : $$boolean_type);

pred isInternalProperty (prop): 
(prop == _lvar_prop) * (s-nth(_lvar_prop, 0.) == "@") * (! (_lvar_prop == "")) * types(_lvar_prop : $$string_type, prop : $$string_type);


spec TypeError_call(xsc, vthis, v)
[[ (v == $$undefined) * types(v : $$undefined_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * (xret == _$l_xret) * types(xret : $$object_type) ]]
normal

proc TypeError_call (xsc, vthis, v) {
			xret := new();
			xret := "create_default_object"(xret, $lterr_proto, "Error", $$t);
			xret := "Error_construct"($$undefined, xret, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec TypeError(v)
[[ (v == $$undefined) * types(v : $$undefined_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * (xret == _$l_xret) * types(xret : $$object_type) ]]
normal

proc TypeError (v) {
			xret := "TypeError_call"($$undefined, $$undefined, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__isCallable(l)
[[ ((_$l_l, "@call") -> None) * (l == _$l_l) * types(l : $$object_type) ]]
[[ ((_$l_l, "@call") -> None) * (l == _$l_l) * (xret == $$f) * types(l : $$object_type, xret : $$boolean_type) ]]
normal;

 [[ ((_$l_l, "@call") -> #y) * (l == _$l_l) * (! (#y == None)) * types(l : $$object_type) ]]
[[ ((_$l_l, "@call") -> #y) * (l == _$l_l) * (xret == $$t) * types(l : $$object_type, xret : $$boolean_type) ]]
normal

proc i__isCallable (l) {
			xret := $$f;
			goto [(typeOf(l) = $$object_type)] obj rlab;
	obj:		xret := hasField(l,"@call");
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec defineOwnProperty(l, prop, desc, throw)
[[ ((_$l_#l, "@extensible") -> $$f) * ((_$l_#l, #prop) -> None) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == #desc) * (throw == $$t) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (! (#cls == "Array")) * types(#desc : $$list_type, l : $$object_type, #cls : $$string_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_#l, "@extensible") -> $$f) * ((_$l_#l, #prop) -> None) * ((_$l_#l, "@class") -> #cls) * (xret == _$l_xret) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * types(#desc : $$list_type, #cls : $$string_type, xret : $$object_type, #prop : $$string_type) ]]
error;

 [[ ((_$l_#l, "@extensible") -> $$f) * ((_$l_#l, #prop) -> None) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == #desc) * (throw == $$f) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (! (#cls == "Array")) * types(#desc : $$list_type, l : $$object_type, #cls : $$string_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, "@extensible") -> $$f) * ((_$l_#l, #prop) -> None) * ((_$l_#l, "@class") -> #cls) * (xret == $$f) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * types(#desc : $$list_type, #cls : $$string_type, xret : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, "@extensible") -> $$t) * ((_$l_#l, #prop) -> None) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_365, _lvar_366, _lvar_367, _lvar_368 }}) * (throw == #throw) * (! (_lvar_365 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (! (#cls == "Array")) * (#desc == {{ "d", _lvar_365, _lvar_366, _lvar_367, _lvar_368 }}) * types(_lvar_367 : $$boolean_type, #desc : $$list_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, _lvar_366 : $$boolean_type, #throw : $$boolean_type, desc : $$list_type, throw : $$boolean_type, #prop : $$string_type, _lvar_368 : $$boolean_type) ]]
[[ ((_$l_#l, "@extensible") -> $$t) * ((_$l_#l, #prop) -> #desc) * ((_$l_#l, "@class") -> #cls) * (xret == $$t) * (! (#cls == "String")) * types(#desc : $$list_type, #cls : $$string_type, #throw : $$boolean_type, xret : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_373, _lvar_374, _lvar_375, $$t }}) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_377, _lvar_378, _lvar_379, _lvar_380 }}) * (throw == #throw) * (! (_lvar_373 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (! (#cls == "Array")) * (! (_lvar_377 == $$empty)) * (#desc == {{ "d", _lvar_377, _lvar_378, _lvar_379, _lvar_380 }}) * (#dcur == {{ "d", _lvar_373, _lvar_374, _lvar_375, $$t }}) * types(_lvar_374 : $$boolean_type, #dcur : $$list_type, #desc : $$list_type, l : $$object_type, _lvar_375 : $$boolean_type, #cls : $$string_type, prop : $$string_type, _lvar_380 : $$boolean_type, #throw : $$boolean_type, desc : $$list_type, #ext : $$boolean_type, _lvar_379 : $$boolean_type, _lvar_378 : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #desc) * ((_$l_#l, "@class") -> #cls) * (xret == $$t) * (! (#cls == "String")) * types(#dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #throw : $$boolean_type, #ext : $$boolean_type, xret : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_381, _lvar_382, _lvar_383, $$f }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_385, _lvar_386, _lvar_387, $$t }}) * (throw == $$t) * (! (_lvar_381 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (! (#cls == "Array")) * (! (_lvar_385 == $$empty)) * (#desc == {{ "d", _lvar_385, _lvar_386, _lvar_387, $$t }}) * (#dcur == {{ "d", _lvar_381, _lvar_382, _lvar_383, $$f }}) * types(_lvar_387 : $$boolean_type, #dcur : $$list_type, #desc : $$list_type, l : $$object_type, _lvar_383 : $$boolean_type, #cls : $$string_type, _lvar_382 : $$boolean_type, prop : $$string_type, desc : $$list_type, #ext : $$boolean_type, _lvar_386 : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_#l, #prop) -> #dcur) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (xret == _$l_xret) * (! (#cls == "String")) * types(#dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #ext : $$boolean_type, xret : $$object_type, #prop : $$string_type) ]]
error;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_389, _lvar_390, _lvar_391, $$f }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_393, _lvar_394, _lvar_395, $$t }}) * (throw == $$f) * (! (_lvar_389 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (! (#cls == "Array")) * (! (_lvar_393 == $$empty)) * (#desc == {{ "d", _lvar_393, _lvar_394, _lvar_395, $$t }}) * (#dcur == {{ "d", _lvar_389, _lvar_390, _lvar_391, $$f }}) * types(_lvar_390 : $$boolean_type, _lvar_391 : $$boolean_type, #dcur : $$list_type, #desc : $$list_type, _lvar_394 : $$boolean_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, _lvar_395 : $$boolean_type, desc : $$list_type, #ext : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, #prop) -> #dcur) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (xret == $$f) * (! (#cls == "String")) * types(#dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #ext : $$boolean_type, xret : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_397, _lvar_398, #ec, $$f }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_401, _lvar_402, #ed, $$f }}) * (throw == $$t) * (! (_lvar_397 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (#ed == #ec)) * (! (_lvar_401 == $$empty)) * (#desc == {{ "d", _lvar_401, _lvar_402, #ed, $$f }}) * (#dcur == {{ "d", _lvar_397, _lvar_398, #ec, $$f }}) * types(#ec : $$boolean_type, #dcur : $$list_type, #ed : $$boolean_type, #desc : $$list_type, l : $$object_type, _lvar_402 : $$boolean_type, #cls : $$string_type, prop : $$string_type, desc : $$list_type, #ext : $$boolean_type, throw : $$boolean_type, #prop : $$string_type, _lvar_398 : $$boolean_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_#l, #prop) -> #dcur) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (xret == _$l_xret) * (! (#cls == "String")) * types(#ec : $$boolean_type, #ed : $$boolean_type, #dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #ext : $$boolean_type, xret : $$object_type, #prop : $$string_type) ]]
error;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_405, _lvar_406, #ec, $$f }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_409, _lvar_410, #ed, $$f }}) * (throw == $$f) * (! (_lvar_405 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (#ed == #ec)) * (! (_lvar_409 == $$empty)) * (#desc == {{ "d", _lvar_409, _lvar_410, #ed, $$f }}) * (#dcur == {{ "d", _lvar_405, _lvar_406, #ec, $$f }}) * types(#ec : $$boolean_type, #dcur : $$list_type, #ed : $$boolean_type, #desc : $$list_type, _lvar_410 : $$boolean_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, desc : $$list_type, _lvar_406 : $$boolean_type, #ext : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, #prop) -> #dcur) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (xret == $$f) * (! (#cls == "String")) * types(#ec : $$boolean_type, #ed : $$boolean_type, #dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #ext : $$boolean_type, xret : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_413, $$f, #enum, $$f }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_417, $$t, #enum, $$f }}) * (throw == $$t) * (! (_lvar_413 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (_lvar_417 == $$empty)) * (#desc == {{ "d", _lvar_417, $$t, #enum, $$f }}) * (#dcur == {{ "d", _lvar_413, $$f, #enum, $$f }}) * types(#dcur : $$list_type, #desc : $$list_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, desc : $$list_type, #ext : $$boolean_type, #enum : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_#l, #prop) -> #dcur) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (xret == _$l_xret) * (! (#cls == "String")) * types(#dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #ext : $$boolean_type, #enum : $$boolean_type, xret : $$object_type, #prop : $$string_type) ]]
error;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_421, $$f, #enum, $$f }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_425, $$t, #enum, $$f }}) * (throw == $$f) * (! (_lvar_421 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (_lvar_425 == $$empty)) * (#desc == {{ "d", _lvar_425, $$t, #enum, $$f }}) * (#dcur == {{ "d", _lvar_421, $$f, #enum, $$f }}) * types(#dcur : $$list_type, #desc : $$list_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, desc : $$list_type, #ext : $$boolean_type, #enum : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, #prop) -> #dcur) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (xret == $$f) * (! (#cls == "String")) * types(#dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #ext : $$boolean_type, #enum : $$boolean_type, xret : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_429, $$t, #enum, $$f }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_433, _lvar_434, #enum, $$f }}) * (throw == $$f) * (! (_lvar_429 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (_lvar_433 == $$empty)) * (#desc == {{ "d", _lvar_433, _lvar_434, #enum, $$f }}) * (#dcur == {{ "d", _lvar_429, $$t, #enum, $$f }}) * types(#dcur : $$list_type, #desc : $$list_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, desc : $$list_type, _lvar_434 : $$boolean_type, #ext : $$boolean_type, #enum : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, #prop) -> #desc) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (xret == $$t) * (! (#cls == "String")) * types(#dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #ext : $$boolean_type, #enum : $$boolean_type, xret : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_437, $$t, #dec, #dcc }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "g", $$empty, $$empty, #gval, $$empty, $$empty, $$empty }}) * (throw == #throw) * (! (_lvar_437 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (#gval == $$empty)) * (#desc == {{ "g", $$empty, $$empty, #gval, $$empty, $$empty, $$empty }}) * (#dcur == {{ "d", _lvar_437, $$t, #dec, #dcc }}) * types(#dcur : $$list_type, #desc : $$list_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, #throw : $$boolean_type, desc : $$list_type, #ext : $$boolean_type, #dec : $$boolean_type, #dcc : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, #prop) -> {{ "d", #gval, $$t, #dec, #dcc }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (xret == $$t) * types(#dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #throw : $$boolean_type, #ext : $$boolean_type, #dec : $$boolean_type, xret : $$boolean_type, #dcc : $$boolean_type, #prop : $$string_type) ]]
normal

proc defineOwnProperty (l, prop, desc, throw) {
			class := [l, "@class"];
			goto [(class = "Array")] adop odop;
	adop:		xret := "a__defineOwnProperty"(l, prop, desc, throw) with elab;
			goto rlab;
	odop:		xret := "o__defineOwnProperty"(l, prop, desc, throw) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__strictEquality(v1, v2)
[[ (v1 == #v1) * (v2 == #v2) * (#v1 == #v2) * types() ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (v1 == #v1) * (v2 == #v2) * (! (#v1 == #v2)) * types() ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal

proc i__strictEquality (v1, v2) {
			xret := (v1 = v2);
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__isDataDescriptor(desc)
[[ (desc == $$undefined) * types(desc : $$undefined_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal;

 [[ (desc == {{ "d", _lvar_327, _lvar_328, _lvar_329, _lvar_330 }}) * (! (_lvar_327 == $$empty)) * types(_lvar_330 : $$boolean_type, _lvar_328 : $$boolean_type, _lvar_329 : $$boolean_type, desc : $$list_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (desc == {{ "g", _lvar_331, _lvar_332, $$empty, $$empty, _lvar_335, _lvar_336 }}) * types(_lvar_333 : $$empty_type, _lvar_334 : $$empty_type, desc : $$list_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal;

 [[ (desc == {{ "g", _lvar_337, _lvar_338, _lvar_339, _lvar_340, _lvar_341, _lvar_342 }}) * (! (_lvar_339 == $$empty)) * types(desc : $$list_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (desc == {{ "g", _lvar_343, _lvar_344, _lvar_345, _lvar_346, _lvar_347, _lvar_348 }}) * (! (_lvar_346 == $$empty)) * types(desc : $$list_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal

proc i__isDataDescriptor (desc) {
			goto [(desc = $$undefined)] rf cont;
	cont:		d := l-nth(desc, 0.);
			goto [(d = "d")] rt gen;
	gen:		goto [(d = "g")] test rf;
	test:		v := l-nth(desc, 3.);
			w := l-nth(desc, 4.);
			goto [((v = $$empty) and (w = $$empty))] rf rt;
	rt:		xret := $$t;
			goto rlab;
	rf:		xret := $$f;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec Error_construct(xsc, vthis, v)
[[ ((_$l_#vthis, "@extensible") -> #ext) * ((_$l_#vthis, "@class") -> #cls) * (vthis == _$l_#vthis) * (v == $$undefined) * types(vthis : $$object_type, v : $$undefined_type) ]]
[[ ((_$l_#vthis, "@extensible") -> $$t) * ((_$l_#vthis, "@class") -> "Error") * (xret == _$l_#vthis) * types(xret : $$object_type) ]]
normal;

 [[ ((_$l_#vthis, "@extensible") -> #ext) * ((_$l_#vthis, "@class") -> #cls) * (vthis == _$l_#vthis) * (v == #m) * types(vthis : $$object_type, #m : $$string_type) ]]
[[ ((_$l_#vthis, "message") -> {{ "d", #m, $$t, $$f, $$t }}) * ((_$l_#vthis, "@extensible") -> $$t) * ((_$l_#vthis, "@class") -> "Error") * (xret == _$l_#vthis) * types(#m : $$string_type, xret : $$object_type) ]]
normal

proc Error_construct (xsc, vthis, v) {
			xret := vthis;
			[vthis, "@class"] := "Error";
			[vthis, "@extensible"] := $$t;
			goto [(v = $$undefined)] rlab mess;
	mess:		xerr := "i__toString"(v) with elab;
			[xret, "message"] := {{ "d", xerr, $$t, $$f, $$t }};
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xerr, elab;
};


spec canPut(l, prop)
[[ ((_$l_#l, "@extensible") -> #ext) * (l == _$l_#l) * (prop == #prop) * types(l : $$object_type, #ext : $$boolean_type) * Pi(_$l_#l, #prop, #g_aux_0, $$undefined, #g_aux_2, #g_aux_3, #g_aux_4) ]]
[[ ((_$l_#l, "@extensible") -> #ext) * (xret == #ext) * types(#ext : $$boolean_type) * Pi(_$l_#l, #prop, #g_aux_0, $$undefined, #g_aux_2, #g_aux_3, #g_aux_4) ]]
normal;

 [[ (l == #l) * (prop == #prop) * (! (_lvar_16 == $$empty)) * (#g_aux_1 == {{ "d", _lvar_16, #writ, _lvar_18, _lvar_19 }}) * types(#g_aux_1 : $$list_type, #writ : $$boolean_type, _lvar_18 : $$boolean_type, _lvar_19 : $$boolean_type) * Pi(#l, #prop, #g_aux_0, {{ "d", _lvar_16, #writ, _lvar_18, _lvar_19 }}, {{ #l }}, #g_aux_3, #g_aux_4) ]]
[[ (xret == #writ) * types(#g_aux_1 : $$list_type, #writ : $$boolean_type, xret : $$boolean_type) * Pi(#l, #prop, #g_aux_0, #g_aux_1, {{ #l }}, #g_aux_3, #g_aux_4) ]]
normal;

 [[ ((_$l_#l, "@extensible") -> $$f) * (l == _$l_#l) * (prop == #prop) * (! (_lvar_22 == $$empty)) * (#g_aux_2 == (_$l_#l :: (#lp :: #other))) * (#g_aux_1 == {{ "d", _lvar_22, _lvar_23, _lvar_24, _lvar_25 }}) * types(#g_aux_1 : $$list_type, _lvar_25 : $$boolean_type, #lp : $$object_type, #g_aux_2 : $$list_type, _lvar_23 : $$boolean_type, l : $$object_type, #other : $$list_type, _lvar_24 : $$boolean_type) * Pi(_$l_#l, #prop, #g_aux_0, {{ "d", _lvar_22, _lvar_23, _lvar_24, _lvar_25 }}, (_$l_#l :: (#lp :: #other)), #g_aux_3, #g_aux_4) ]]
[[ ((_$l_#l, "@extensible") -> $$f) * (xret == $$f) * types(#g_aux_1 : $$list_type, #lp : $$object_type, #g_aux_2 : $$list_type, #other : $$list_type, xret : $$boolean_type) * Pi(_$l_#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) ]]
normal;

 [[ ((_$l_#l, "@extensible") -> $$t) * (l == _$l_#l) * (prop == #prop) * (! (_lvar_26 == $$empty)) * (#g_aux_2 == (_$l_#l :: (#lp :: #other))) * (#g_aux_1 == {{ "d", _lvar_26, #writ, _lvar_28, _lvar_29 }}) * types(#g_aux_1 : $$list_type, _lvar_28 : $$boolean_type, #writ : $$boolean_type, #lp : $$object_type, #g_aux_2 : $$list_type, _lvar_29 : $$boolean_type, l : $$object_type, #other : $$list_type) * Pi(_$l_#l, #prop, #g_aux_0, {{ "d", _lvar_26, #writ, _lvar_28, _lvar_29 }}, (_$l_#l :: (#lp :: #other)), #g_aux_3, #g_aux_4) ]]
[[ ((_$l_#l, "@extensible") -> $$t) * (xret == #writ) * types(#g_aux_1 : $$list_type, #writ : $$boolean_type, #lp : $$object_type, #g_aux_2 : $$list_type, #other : $$list_type) * Pi(_$l_#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) ]]
normal

proc canPut (l, prop) {
			[* unfold Pi(#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) *]
			xret := "getOwnProperty"(l, prop) with elab;
			[* fold Pi(#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) *]
	op:		goto [(xret = $$undefined)] nop odesc;
	odesc:		d := l-nth(xret, 0.);
			goto [(d = "d")] odd nop;
	odd:		xret := l-nth(xret, 2.);
			goto rlab;
	nop:		e := [l, "@extensible"];
			xret := "getProperty"(l, prop) with elab;
			goto [(xret = $$undefined)] ext desc;
	desc:		d := l-nth(xret, 0.);
			v := l-nth(xret, 2.);
			goto [(d = "d")] dd ad;
	dd:		goto [e] wr ext;
	wr:		xret := v;
			goto rlab;
	ad:		xret := (not (v = $$undefined));
			goto rlab;
	ext:		xret := e;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec setupInitialHeap()
[[ empty_fields($lfun_proto : -{  }-) * empty_fields($lerr : -{  }-) * (($lg, "@extensible") -> None) * (($lg, "@proto") -> None) * (($lg, "@class") -> None) * empty_fields($lop_hasOwnProperty : -{  }-) * empty_fields($lobj_proto : -{  }-) * empty_fields($lerr_proto : -{  }-) * types() ]]
[[ empty_fields($lfun_proto : -{ "@call", "@class", "@extensible", "@proto", "@scope", "length" }-) * (($lfun_proto, "@call") -> "FP_default") * (($lfun_proto, "length") -> {{ "d", 0., $$f, $$f, $$f }}) * (($lfun_proto, "@scope") -> $$empty) * (($lfun_proto, "@extensible") -> $$t) * (($lfun_proto, "@proto") -> $lobj_proto) * (($lfun_proto, "@class") -> "Function") * empty_fields($lerr : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope", "length", "prototype" }-) * (($lerr, "prototype") -> {{ "d", $lerr_proto, $$f, $$f, $$f }}) * (($lerr, "@construct") -> "Error_construct") * (($lerr, "@call") -> "Error_call") * (($lerr, "length") -> {{ "d", 1., $$f, $$f, $$f }}) * (($lerr, "@scope") -> $$empty) * (($lerr, "@extensible") -> $$t) * (($lerr, "@proto") -> $lfun_proto) * (($lerr, "@class") -> "Function") * (($lg, "Error") -> {{ "d", $lerr, $$t, $$f, $$t }}) * (($lg, "@extensible") -> $$t) * (($lg, "@proto") -> $lobj_proto) * (($lg, "@class") -> "Object") * empty_fields($lop_hasOwnProperty : -{ "@call", "@class", "@extensible", "@proto", "@scope", "length" }-) * (($lop_hasOwnProperty, "@call") -> "OP_hasOwnProperty") * (($lop_hasOwnProperty, "length") -> {{ "d", 1., $$f, $$f, $$f }}) * (($lop_hasOwnProperty, "@scope") -> $$empty) * (($lop_hasOwnProperty, "@extensible") -> $$t) * (($lop_hasOwnProperty, "@proto") -> $lfun_proto) * (($lop_hasOwnProperty, "@class") -> "Function") * empty_fields($lobj_proto : -{ "@class", "@extensible", "@proto", "hasOwnProperty" }-) * (($lobj_proto, "hasOwnProperty") -> {{ "d", $lop_hasOwnProperty, $$t, $$f, $$t }}) * (($lobj_proto, "@extensible") -> $$t) * (($lobj_proto, "@proto") -> $$null) * (($lobj_proto, "@class") -> "Object") * empty_fields($lerr_proto : -{ "@class", "@extensible", "@proto", "message" }-) * (($lerr_proto, "message") -> {{ "d", "", $$t, $$f, $$t }}) * (($lerr_proto, "@extensible") -> $$t) * (($lerr_proto, "@proto") -> $lobj_proto) * (($lerr_proto, "@class") -> "Error") * (xret == $$empty) * types(xret : $$empty_type) ]]
normal

proc setupInitialHeap () {
			xret := "create_default_object"($lg, $lobj_proto, "Object", $$t);
			xret := "create_default_object"($lobj_proto, $$null, "Object", $$t);
			[$lobj_proto, "hasOwnProperty"] := {{ "d", $lop_hasOwnProperty, $$t, $$f, $$t }};
			xret := "create_object_with_call_construct"($lop_hasOwnProperty, "OP_hasOwnProperty", $$empty, 1.);
			xret := "create_object_with_call_construct"($lfun_proto, "FP_default", $$empty, 0.);
			[$lfun_proto, "@proto"] := $lobj_proto;
			xret := "create_object_with_call_construct"($lerr, "Error_call", "Error_construct", 1.);
			[$lg, "Error"] := {{ "d", $lerr, $$t, $$f, $$t }};
			[$lerr, "prototype"] := {{ "d", $lerr_proto, $$f, $$f, $$f }};
			xret := "create_default_object"($lerr_proto, $lobj_proto, "Error", $$t);
			[$lerr_proto, "message"] := {{ "d", "", $$t, $$f, $$t }};
	rlab:		xret := $$empty
} with {
	ret: xret, rlab;
};


spec copy_object(l, fields)
[[ ((_$l_#l, #f) -> #v) * (l == _$l_#l) * (fields == {{ #f }}) * (! (s-nth(#f, 0.) == "@")) * (! (#f == "")) * (#fields == {{ #f }}) * types(#f : $$string_type, l : $$object_type, #fields : $$list_type, fields : $$list_type) ]]
[[ empty_fields(_$l_xret : -{ "@proto", #f }-) * ((_$l_xret, "@proto") -> $$null) * ((_$l_xret, #f) -> #v) * ((_$l_#l, #f) -> #v) * (xret == _$l_xret) * types(#f : $$string_type, #fields : $$list_type, xret : $$object_type) ]]
normal;

 [[ ((_$l_#l, "main") -> #v2) * ((_$l_#l, #f1) -> #v1) * (l == _$l_#l) * (fields == {{ #f1, "main" }}) * (! (#f1 == "main")) * (! (s-nth(#f1, 0.) == "@")) * (! (#f1 == "")) * (#fields == {{ #f1, "main" }}) * types(#f1 : $$string_type, l : $$object_type, #fields : $$list_type, fields : $$list_type) ]]
[[ empty_fields(_$l_xret : -{ "@proto", "main", #f1 }-) * ((_$l_xret, "@proto") -> $$null) * ((_$l_xret, "main") -> #v2) * ((_$l_xret, #f1) -> #v1) * ((_$l_#l, "main") -> #v2) * ((_$l_#l, #f1) -> #v1) * (xret == _$l_xret) * (! (#f1 == "main")) * types(#f1 : $$string_type, #fields : $$list_type, xret : $$object_type) ]]
normal

proc copy_object (l, fields) {
			xret := new();
	rlab:		xret := "copy_object_rec"(l, fields, xret)
} with {
	ret: xret, rlab;
};


spec i__typeOf(v)
[[ (v == $$undefined) * (#v == $$undefined) * types(v : $$undefined_type, #v : $$undefined_type) ]]
[[ (xret == "undefined") * (#v == $$undefined) * types(#v : $$undefined_type, xret : $$string_type) ]]
normal;

 [[ (v == $$null) * (#v == $$null) * types(v : $$null_type, #v : $$null_type) ]]
[[ (xret == "object") * (#v == $$null) * types(#v : $$null_type, xret : $$string_type) ]]
normal;

 [[ (v == #v) * types(#v : $$boolean_type) ]]
[[ (xret == "boolean") * types(#v : $$boolean_type, xret : $$string_type) ]]
normal;

 [[ (v == #v) * types(#v : $$number_type) ]]
[[ (xret == "number") * types(#v : $$number_type, xret : $$string_type) ]]
normal;

 [[ (v == #v) * types(#v : $$string_type) ]]
[[ (xret == "string") * types(#v : $$string_type, xret : $$string_type) ]]
normal

proc i__typeOf (v) {
	iu:		goto [(v = $$undefined)] undef in;
	undef:		xret := "undefined";
			goto rlab;
	in:		goto [(v = $$null)] null ib;
	null:		xret := "object";
			goto rlab;
	ib:		goto [(typeOf(v) = $$boolean_type)] bool inum;
	bool:		xret := "boolean";
			goto rlab;
	inum:		goto [(typeOf(v) = $$number_type)] num is;
	num:		xret := "number";
			goto rlab;
	is:		goto [(typeOf(v) = $$string_type)] str io;
	str:		xret := "string";
			goto rlab;
	io:		goto [(typeOf(v) = $$object_type)] obj oops;
	obj:		xret := hasField(v,"@call");
			goto [xret] isfun isobj;
	isobj:		xret := "object";
			goto rlab;
	isfun:		xret := "function";
			goto rlab;
	oops:		xret := "typeOf: This should not happen.";
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec create_function_object(xsc, call, construct, params)
[[ (call == #call) * (params == #params) * (construct == #construct) * (xsc == #xsc) * types(#construct : $$string_type, #params : $$list_type, #xsc : $$list_type, #call : $$string_type) ]]
[[ empty_fields(_$l_xret : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope", "arguments", "caller", "length", "prototype" }-) * ((_$l_xret, "prototype") -> {{ "d", _$l_#prototype, $$t, $$f, $$f }}) * ((_$l_xret, "arguments") -> {{ "a", $lthrow_type_error, $lthrow_type_error, $$f, $$f }}) * ((_$l_xret, "caller") -> {{ "a", $lthrow_type_error, $lthrow_type_error, $$f, $$f }}) * ((_$l_xret, "@construct") -> #construct) * ((_$l_xret, "@call") -> #call) * ((_$l_xret, "length") -> {{ "d", (l-len #params), $$f, $$f, $$f }}) * ((_$l_xret, "@scope") -> #xsc) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Function") * ((_$l_xret, "@proto") -> $lfun_proto) * empty_fields(_$l_#prototype : -{ "@class", "@extensible", "@proto", "constructor" }-) * ((_$l_#prototype, "constructor") -> {{ "d", _$l_xret, $$t, $$f, $$t }}) * ((_$l_#prototype, "@extensible") -> $$t) * ((_$l_#prototype, "@class") -> "Object") * ((_$l_#prototype, "@proto") -> $lobj_proto) * (xret == _$l_xret) * types(#construct : $$string_type, #params : $$list_type, xret : $$object_type, #xsc : $$list_type, #call : $$string_type) ]]
normal

proc create_function_object (xsc, call, construct, params) {
			len := (l-len params);
			l := new();
			l := "create_object_with_call_construct"(l, call, construct, len);
			[l, "@scope"] := xsc;
			prototype := new();
			prototype := "create_default_object"(prototype, $lobj_proto, "Object", $$t);
			[prototype, "constructor"] := {{ "d", l, $$t, $$f, $$t }};
			[l, "prototype"] := {{ "d", prototype, $$t, $$f, $$f }};
			[l, "caller"] := {{ "a", $lthrow_type_error, $lthrow_type_error, $$f, $$f }};
			[l, "arguments"] := {{ "a", $lthrow_type_error, $lthrow_type_error, $$f, $$f }};
			xret := l;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__abstractComparison(v1, v2, leftFirst)
[[ (v1 == #v1) * (v2 == #v2) * (leftFirst == #leftFirst) * (#v1 <# #v2) * types(#leftFirst : $$boolean_type, #v2 : $$number_type, #v1 : $$number_type) ]]
[[ (xret == $$t) * (#v1 <# #v2) * types(#leftFirst : $$boolean_type, #v2 : $$number_type, xret : $$boolean_type, #v1 : $$number_type) ]]
normal;

 [[ (v1 == #v1) * (v2 == #v2) * (leftFirst == #leftFirst) * (#v1 == #v2) * types(#leftFirst : $$boolean_type, v2 : $$number_type, #v2 : $$number_type, v1 : $$number_type, #v1 : $$number_type, leftFirst : $$boolean_type) ]]
[[ (xret == $$f) * (#v1 == #v2) * types(#leftFirst : $$boolean_type, #v2 : $$number_type, xret : $$boolean_type, #v1 : $$number_type) ]]
normal;

 [[ (v1 == #v1) * (v2 == #v2) * (leftFirst == #leftFirst) * (#v2 <# #v1) * types(#leftFirst : $$boolean_type, #v2 : $$number_type, #v1 : $$number_type) ]]
[[ (xret == $$f) * (#v2 <# #v1) * types(#leftFirst : $$boolean_type, #v2 : $$number_type, xret : $$boolean_type, #v1 : $$number_type) ]]
normal

proc i__abstractComparison (v1, v2, leftFirst) {
			goto [((leftFirst = $$empty) or (leftFirst = $$t))] eleft eright;
	eleft:		xret := "i__toPrimitive"(v1, "Number") with elab;
			px := xret;
			xret := "i__toPrimitive"(v2, "Number") with elab;
			py := xret;
			goto is_str;
	eright:		xret := "i__toPrimitive"(v2, "Number") with elab;
			py := xret;
			xret := "i__toPrimitive"(v1, "Number") with elab;
			px := xret;
	is_str:		goto [((typeOf(px) = $$string_type) and (typeOf(py) = $$string_type))] str num;
	str:		xret := (px <s py);
			goto rlab;
	num:		xret := "i__toNumber"(px) with elab;
			nx := xret;
			xret := "i__toNumber"(py) with elab;
			ny := xret;
			goto [((not (nx = nx)) or (not (ny = ny)))] ru eq;
	eq:		goto [(nx = ny)] rf sl;
	sl:		xret := (nx < ny);
			goto rlab;
	ru:		xret := $$undefined;
			goto rlab;
	rt:		xret := $$t;
			goto rlab;
	rf:		xret := $$f;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__toNumber(v)
[[ (v == $$t) * types(v : $$boolean_type) ]]
[[ (xret == 1.) * types(xret : $$number_type) ]]
normal;

 [[ (v == $$f) * types(v : $$boolean_type) ]]
[[ (xret == 0.) * types(xret : $$number_type) ]]
normal;

 [[ (v == #v) * types(#v : $$number_type) ]]
[[ (xret == #v) * types(#v : $$number_type) ]]
normal;

 [[ (v == #v) * types(#v : $$string_type) ]]
[[ (xret == (string_to_num #v)) * types(#v : $$string_type, xret : $$number_type) ]]
normal

proc i__toNumber (v) {
	iu:		goto [(v = $$undefined)] undef in;
	undef:		xret := nan;
			goto rlab;
	in:		goto [(v = $$null)] null ib;
	null:		xret := 0.;
			goto rlab;
	ib:		goto [(typeOf(v) = $$boolean_type)] bool inum;
	bool:		goto [(v = $$t)] is_t is_f;
	is_t:		xret := 1.;
			goto rlab;
	is_f:		xret := 0.;
			goto rlab;
	inum:		goto [(typeOf(v) = $$number_type)] num is;
	num:		xret := v;
			goto rlab;
	is:		goto [(typeOf(v) = $$string_type)] str io;
	str:		xret := (string_to_num v);
			goto rlab;
	io:		goto [(typeOf(v) = $$object_type)] obj oops;
	obj:		xret := "i__toPrimitive"(v, "Number") with elab;
			xret := "i__toNumber"(xret);
			goto rlab;
	oops:		xret := "TypeError"("ToNumber: This should not happen.");
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec ReferenceError(v)
[[ (v == $$undefined) * types(v : $$undefined_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lrferr_proto) * (xret == _$l_xret) * types(xret : $$object_type) ]]
normal

proc ReferenceError (v) {
			xret := "ReferenceError_call"($$undefined, $$undefined, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec create_default_object(l, pr, cl, ext)
[[ ((_$l_#l, "@extensible") -> #v3) * ((_$l_#l, "@class") -> #v2) * ((_$l_#l, "@proto") -> #v1) * (cl == $$undefined) * (l == _$l_#l) * (ext == $$undefined) * (pr == #pr) * (#ext == $$undefined) * (#cl == $$undefined) * types(l : $$object_type, #cl : $$undefined_type, cl : $$undefined_type, #ext : $$undefined_type, ext : $$undefined_type) ]]
[[ ((_$l_#l, "@extensible") -> $$t) * ((_$l_#l, "@class") -> "Object") * ((_$l_#l, "@proto") -> #pr) * (xret == _$l_#l) * (#ext == $$undefined) * (#cl == $$undefined) * types(#cl : $$undefined_type, #ext : $$undefined_type, xret : $$object_type) ]]
normal;

 [[ ((_$l_#l, "@extensible") -> #v3) * ((_$l_#l, "@class") -> #v2) * ((_$l_#l, "@proto") -> #v1) * (cl == #cl) * (l == _$l_#l) * (ext == #ext) * (pr == #pr) * types(l : $$object_type, #cl : $$string_type, #ext : $$boolean_type) ]]
[[ ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cl) * ((_$l_#l, "@proto") -> #pr) * (xret == _$l_#l) * types(#cl : $$string_type, #ext : $$boolean_type, xret : $$object_type) ]]
normal

proc create_default_object (l, pr, cl, ext) {
			goto [(cl = $$undefined)] scl text;
	scl:		cl := "Object";
	text:		goto [(ext = $$undefined)] sext setall;
	sext:		ext := $$t;
	setall:		[l, "@proto"] := pr;
			[l, "@class"] := cl;
			[l, "@extensible"] := ext;
	rlab:		xret := l
} with {
	ret: xret, rlab;
};


spec o__defineOwnProperty(l, prop, desc, throw)
[[ ((_$l_#l, "@extensible") -> $$f) * ((_$l_#l, #prop) -> None) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == #desc) * (throw == $$t) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * types(#desc : $$list_type, l : $$object_type, #cls : $$string_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, "@extensible") -> $$f) * ((_$l_#l, #prop) -> None) * ((_$l_#l, "@class") -> #cls) * empty_fields(_$l_xerr : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xerr, "@extensible") -> $$t) * ((_$l_xerr, "@class") -> "Error") * ((_$l_xerr, "@proto") -> $lterr_proto) * (xerr == _$l_xerr) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * types(#desc : $$list_type, #cls : $$string_type, xerr : $$object_type, #prop : $$string_type) ]]
error;

 [[ ((_$l_#l, "@extensible") -> $$f) * ((_$l_#l, #prop) -> None) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == #desc) * (throw == $$f) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * types(#desc : $$list_type, l : $$object_type, #cls : $$string_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, "@extensible") -> $$f) * ((_$l_#l, #prop) -> None) * ((_$l_#l, "@class") -> #cls) * (xret == $$f) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * types(#desc : $$list_type, #cls : $$string_type, xret : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, "@extensible") -> $$t) * ((_$l_#l, #prop) -> None) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_114, _lvar_115, _lvar_116, _lvar_117 }}) * (throw == #throw) * (! (_lvar_114 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (#desc == {{ "d", _lvar_114, _lvar_115, _lvar_116, _lvar_117 }}) * types(#desc : $$list_type, _lvar_117 : $$boolean_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, #throw : $$boolean_type, desc : $$list_type, _lvar_115 : $$boolean_type, throw : $$boolean_type, #prop : $$string_type, _lvar_116 : $$boolean_type) ]]
[[ ((_$l_#l, "@extensible") -> $$t) * ((_$l_#l, #prop) -> #desc) * ((_$l_#l, "@class") -> #cls) * (xret == $$t) * (! (#cls == "String")) * types(#desc : $$list_type, #cls : $$string_type, #throw : $$boolean_type, xret : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> {{ "d", _lvar_122, _lvar_123, _lvar_124, $$t }}) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_126, _lvar_127, _lvar_128, _lvar_129 }}) * (throw == #throw) * (! (_lvar_122 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (! (_lvar_126 == $$empty)) * (#desc == {{ "d", _lvar_126, _lvar_127, _lvar_128, _lvar_129 }}) * (#dcur == {{ "d", _lvar_122, _lvar_123, _lvar_124, $$t }}) * types(#dcur : $$list_type, #desc : $$list_type, _lvar_128 : $$boolean_type, _lvar_127 : $$boolean_type, _lvar_123 : $$boolean_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, #throw : $$boolean_type, desc : $$list_type, #ext : $$boolean_type, _lvar_129 : $$boolean_type, throw : $$boolean_type, #prop : $$string_type, _lvar_124 : $$boolean_type) ]]
[[ ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, #prop) -> #desc) * ((_$l_#l, "@class") -> #cls) * (xret == $$t) * (! (#cls == "String")) * types(#dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #throw : $$boolean_type, #ext : $$boolean_type, xret : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_130, _lvar_131, _lvar_132, $$f }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_134, _lvar_135, _lvar_136, $$t }}) * (throw == $$t) * (! (_lvar_130 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (! (_lvar_134 == $$empty)) * (#desc == {{ "d", _lvar_134, _lvar_135, _lvar_136, $$t }}) * (#dcur == {{ "d", _lvar_130, _lvar_131, _lvar_132, $$f }}) * types(_lvar_135 : $$boolean_type, #dcur : $$list_type, #desc : $$list_type, _lvar_136 : $$boolean_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, desc : $$list_type, #ext : $$boolean_type, _lvar_131 : $$boolean_type, throw : $$boolean_type, #prop : $$string_type, _lvar_132 : $$boolean_type) ]]
[[ ((_$l_#l, #prop) -> #dcur) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * empty_fields(_$l_xerr : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xerr, "@extensible") -> $$t) * ((_$l_xerr, "@class") -> "Error") * ((_$l_xerr, "@proto") -> $lterr_proto) * (xerr == _$l_xerr) * (! (#cls == "String")) * types(#dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #ext : $$boolean_type, xerr : $$object_type, #prop : $$string_type) ]]
error;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_138, _lvar_139, _lvar_140, $$f }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_142, _lvar_143, _lvar_144, $$t }}) * (throw == $$f) * (! (_lvar_138 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (! (_lvar_142 == $$empty)) * (#desc == {{ "d", _lvar_142, _lvar_143, _lvar_144, $$t }}) * (#dcur == {{ "d", _lvar_138, _lvar_139, _lvar_140, $$f }}) * types(#dcur : $$list_type, #desc : $$list_type, _lvar_140 : $$boolean_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, _lvar_143 : $$boolean_type, desc : $$list_type, #ext : $$boolean_type, _lvar_144 : $$boolean_type, _lvar_139 : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, #prop) -> #dcur) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (xret == $$f) * (! (#cls == "String")) * types(#dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #ext : $$boolean_type, xret : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_146, _lvar_147, #ec, $$f }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_150, _lvar_151, #ed, $$f }}) * (throw == $$t) * (! (_lvar_146 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (! (#ed == #ec)) * (! (_lvar_150 == $$empty)) * (#desc == {{ "d", _lvar_150, _lvar_151, #ed, $$f }}) * (#dcur == {{ "d", _lvar_146, _lvar_147, #ec, $$f }}) * types(#ec : $$boolean_type, #dcur : $$list_type, #ed : $$boolean_type, #desc : $$list_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, desc : $$list_type, _lvar_151 : $$boolean_type, #ext : $$boolean_type, _lvar_147 : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, #prop) -> #dcur) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * empty_fields(_$l_xerr : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xerr, "@extensible") -> $$t) * ((_$l_xerr, "@class") -> "Error") * ((_$l_xerr, "@proto") -> $lterr_proto) * (xerr == _$l_xerr) * (! (#cls == "String")) * types(#ec : $$boolean_type, #ed : $$boolean_type, #dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #ext : $$boolean_type, xerr : $$object_type, #prop : $$string_type) ]]
error;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_154, _lvar_155, #ec, $$f }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_158, _lvar_159, #ed, $$f }}) * (throw == $$f) * (! (_lvar_154 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (! (#ed == #ec)) * (! (_lvar_158 == $$empty)) * (#desc == {{ "d", _lvar_158, _lvar_159, #ed, $$f }}) * (#dcur == {{ "d", _lvar_154, _lvar_155, #ec, $$f }}) * types(#ec : $$boolean_type, #dcur : $$list_type, #ed : $$boolean_type, _lvar_159 : $$boolean_type, #desc : $$list_type, l : $$object_type, #cls : $$string_type, _lvar_155 : $$boolean_type, prop : $$string_type, desc : $$list_type, #ext : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, #prop) -> #dcur) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (xret == $$f) * (! (#cls == "String")) * types(#ec : $$boolean_type, #ed : $$boolean_type, #dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #ext : $$boolean_type, xret : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_162, $$f, #enum, $$f }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_166, $$t, #enum, $$f }}) * (throw == $$t) * (! (_lvar_162 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (! (_lvar_166 == $$empty)) * (#desc == {{ "d", _lvar_166, $$t, #enum, $$f }}) * (#dcur == {{ "d", _lvar_162, $$f, #enum, $$f }}) * types(#dcur : $$list_type, #desc : $$list_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, desc : $$list_type, #ext : $$boolean_type, #enum : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, #prop) -> #dcur) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * empty_fields(_$l_xerr : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xerr, "@extensible") -> $$t) * ((_$l_xerr, "@class") -> "Error") * ((_$l_xerr, "@proto") -> $lterr_proto) * (xerr == _$l_xerr) * (! (#cls == "String")) * types(#dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #ext : $$boolean_type, xerr : $$object_type, #enum : $$boolean_type, #prop : $$string_type) ]]
error;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_170, $$f, #enum, $$f }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_174, $$t, #enum, $$f }}) * (throw == $$f) * (! (_lvar_170 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (! (_lvar_174 == $$empty)) * (#desc == {{ "d", _lvar_174, $$t, #enum, $$f }}) * (#dcur == {{ "d", _lvar_170, $$f, #enum, $$f }}) * types(#dcur : $$list_type, #desc : $$list_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, desc : $$list_type, #ext : $$boolean_type, #enum : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, #prop) -> #dcur) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (xret == $$f) * (! (#cls == "String")) * types(#dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #ext : $$boolean_type, #enum : $$boolean_type, xret : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_178, $$t, #enum, $$f }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "d", _lvar_182, _lvar_183, #enum, $$f }}) * (throw == #throw) * (! (_lvar_178 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (! (_lvar_182 == $$empty)) * (#desc == {{ "d", _lvar_182, _lvar_183, #enum, $$f }}) * (#dcur == {{ "d", _lvar_178, $$t, #enum, $$f }}) * types(#dcur : $$list_type, #desc : $$list_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, _lvar_183 : $$boolean_type, #throw : $$boolean_type, desc : $$list_type, #ext : $$boolean_type, #enum : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, #prop) -> #desc) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (xret == $$t) * (! (#cls == "String")) * types(#dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #throw : $$boolean_type, #ext : $$boolean_type, #enum : $$boolean_type, xret : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_186, $$t, #dec, #dcc }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (l == _$l_#l) * (prop == #prop) * (desc == {{ "g", $$empty, $$empty, #gval, $$empty, $$empty, $$empty }}) * (throw == #throw) * (! (_lvar_186 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#cls == "String")) * (! (#gval == $$empty)) * (#desc == {{ "g", $$empty, $$empty, #gval, $$empty, $$empty, $$empty }}) * (#dcur == {{ "d", _lvar_186, $$t, #dec, #dcc }}) * types(#dcur : $$list_type, #desc : $$list_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, #throw : $$boolean_type, desc : $$list_type, #ext : $$boolean_type, #dec : $$boolean_type, #dcc : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) ]]
[[ ((_$l_#l, #prop) -> {{ "d", #gval, $$t, #dec, #dcc }}) * ((_$l_#l, "@extensible") -> #ext) * ((_$l_#l, "@class") -> #cls) * (xret == $$t) * types(#dcur : $$list_type, #desc : $$list_type, #cls : $$string_type, #throw : $$boolean_type, #ext : $$boolean_type, #dec : $$boolean_type, xret : $$boolean_type, #dcc : $$boolean_type, #prop : $$string_type) ]]
normal

proc o__defineOwnProperty (l, prop, desc, throw) {
			xret := $$t;
			current := "getOwnProperty"(l, prop) with celab;
			extensible := [l, "@extensible"];
			goto [(current = $$undefined)] cuf getall;
	cuf:		goto [(extensible = $$f)] reject l4;
	l4:		gd := "i__isGenericDescriptor"(desc);
			dd := "i__isDataDescriptor"(desc);
			goto [(gd or dd)] l4a1 l4b;
	l4a1:		ndesc := "i__toDataDescriptor"(desc);
			[l, prop] := ndesc;
			goto acc_t;
	l4b:		ndesc := "i__toAccessorDescriptor"(desc);
			[l, prop] := ndesc;
			goto acc_t;
	getall:		goto [(l-nth(desc, 0.) = "d")] ddd odd;
	ddd:		de := l-nth(desc, 3.);
			dc := l-nth(desc, 4.);
			dv := l-nth(desc, 1.);
			dw := l-nth(desc, 2.);
			dg := $$empty;
			ds := $$empty;
			goto l5;
	odd:		goto [(l-nth(desc, 0.) = "a")] add gdd;
	add:		de := l-nth(desc, 3.);
			dc := l-nth(desc, 4.);
			dv := $$empty;
			dw := $$empty;
			dg := l-nth(desc, 1.);
			ds := l-nth(desc, 2.);
			goto l5;
	gdd:		de := l-nth(desc, 1.);
			dc := l-nth(desc, 2.);
			dv := l-nth(desc, 3.);
			dw := l-nth(desc, 4.);
			dg := l-nth(desc, 5.);
			ds := l-nth(desc, 6.);
	l5:		goto [((((((de = $$empty) and (dc = $$empty)) and (dv = $$empty)) and (dw = $$empty)) and (dg = $$empty)) and (ds = $$empty))] acc_t l6;
	l6:		goto [(l-nth(current, 0.) = "d")] chd cha;
	chd:		goto [((dg = $$empty) and (ds = $$empty))] chd1 l7;
	chd1:		t1 := "i__sameValue"(dc, l-nth(current, 4.));
			goto [t1] chd2 l7;
	chd2:		t2 := "i__sameValue"(de, l-nth(current, 3.));
			goto [t2] chd3 l7;
	chd3:		t3 := "i__sameValue"(dw, l-nth(current, 2.));
			goto [t3] chd4 l7;
	chd4:		t4 := "i__sameValue"(dv, l-nth(current, 1.));
			goto [t4] acc_t l7;
	cha:		goto [((dv = $$empty) and (dw = $$empty))] cha1 l7;
	cha1:		t1 := "i__sameValue"(dc, l-nth(current, 4.));
			goto [t1] cha2 l7;
	cha2:		t2 := "i__sameValue"(de, l-nth(current, 3.));
			goto [t2] cha3 l7;
	cha3:		t3 := "i__sameValue"(ds, l-nth(current, 2.));
			goto [t3] cha4 l7;
	cha4:		t4 := "i__sameValue"(dg, l-nth(current, 1.));
			goto [t4] acc_t l7;
	l7:		cc := l-nth(current, 4.);
			ce := l-nth(current, 3.);
			goto [(cc = $$f)] l71 l8;
	l71:		goto [(dc = $$t)] reject l72;
	l72:		goto [(de = $$empty)] l8 l73;
	l73:		goto [(not (ce = de))] reject l8;
	l8:		ct := l-nth(current, 0.);
			cvg := l-nth(current, 1.);
			cws := l-nth(current, 2.);
			gd := "i__isGenericDescriptor"(desc);
			goto [gd] l12 l9;
	l9:		cdd := "i__isDataDescriptor"(current);
			ddd := "i__isDataDescriptor"(desc);
			goto [(not (cdd = ddd))] l9a l10;
	l9a:		goto [(cc = $$f)] reject change;
	change:		goto [(cdd = $$t)] toa tod;
	toa:		goto [(dg = $$empty)] sg gs;
	sg:		dg := $$undefined;
	gs:		goto [(ds = $$empty)] ss ge1;
	ss:		ds := $$undefined;
	ge1:		goto [(de = $$empty)] se1 gc1;
	se1:		de := ce;
	gc1:		goto [(dc = $$empty)] sc1 spa;
	sc1:		dc := cc;
	spa:		[l, prop] := {{ "a", dg, ds, de, dc }};
			goto acc_t;
	tod:		goto [(dv = $$empty)] sv gw;
	sv:		dv := $$undefined;
	gw:		goto [(dw = $$empty)] sw ge2;
	sw:		dw := $$f;
	ge2:		goto [(de = $$empty)] se2 gc2;
	se2:		de := ce;
	gc2:		goto [(dc = $$empty)] sc2 spd;
	sc2:		dc := cc;
	spd:		[l, prop] := {{ "d", dv, dw, de, dc }};
			goto acc_t;
	l10:		goto [(cdd = $$t)] l10a l11;
	l10a:		goto [(cc = $$f)] l10ai l12;
	l10ai:		goto [((cws = $$f) and (dw = $$t))] reject l10aii;
	l10aii:		goto [((cws = $$f) and (not (dv = $$empty)))] sv l12;
	sv:		t1 := "i__sameValue"(cvg, dv);
			goto [(not t1)] reject l12;
	l11:		t1 := "i__sameValue"(dg, l-nth(current, 1.));
			t2 := "i__sameValue"(ds, l-nth(current, 2.));
			goto [((cc = $$f) and (((not (dg = $$empty)) and (not t1)) or ((not (ds = $$empty)) and (not t2))))] reject l12;
	l12:		re := de;
			rc := dc;
			goto [(de = $$empty)] rec red;
	rec:		re := l-nth(current, 3.);
	red:		goto [(dc = $$empty)] rcd rd;
	rcd:		rc := l-nth(current, 4.);
	rd:		goto [(ct = "d")] l12d l12a;
	l12d:		rv := dv;
			rw := dw;
			goto [(dv = $$empty)] rvc rvd;
	rvc:		rv := l-nth(current, 1.);
	rvd:		goto [(dw = $$empty)] rwd setd;
	rwd:		rw := l-nth(current, 2.);
	setd:		[l, prop] := {{ "d", rv, rw, re, rc }};
			goto acc_t;
	l12a:		rg := dg;
			rs := ds;
			goto [(dg = $$empty)] rgc rgd;
	rgc:		rg := l-nth(current, 1.);
	rgd:		goto [(ds = $$empty)] rsd seta;
	rsd:		rs := l-nth(current, 2.);
	seta:		[l, prop] := {{ "a", rg, rs, re, rc }};
			goto acc_t;
	acc_t:		xret := $$t;
			goto rlab;
	acc_f:		xret := $$f;
	rlab:		skip;
	celab:		xerr := current;
			goto elab;
	reject:		goto [throw] tt acc_f;
	tt:		xerr := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xerr, elab;
};


spec i__toPrimitive(v, hint)
[[ (v == $$undefined) * types(v : $$undefined_type) ]]
[[ (xret == $$undefined) * types(xret : $$undefined_type) ]]
normal;

 [[ (v == $$null) * types(v : $$null_type) ]]
[[ (xret == $$null) * types(xret : $$null_type) ]]
normal;

 [[ (v == #v) * types(#v : $$number_type) ]]
[[ (xret == #v) * types(#v : $$number_type) ]]
normal;

 [[ (v == #v) * types(#v : $$boolean_type) ]]
[[ (xret == #v) * types(#v : $$boolean_type) ]]
normal;

 [[ (v == #v) * types(#v : $$string_type) ]]
[[ (xret == #v) * types(#v : $$string_type) ]]
normal

proc i__toPrimitive (v, hint) {
			xret := v;
			tv := typeOf(v);
	iu:		goto [(((((v = $$undefined) or (v = $$null)) or (typeOf(v) = $$boolean_type)) or (typeOf(v) = $$number_type)) or (typeOf(v) = $$string_type))] rlab is_obj;
	is_obj:		print := "object";
			goto [(typeOf(v) = $$object_type)] obj oops;
	obj:		xret := "defaultValue"(v, hint) with elab;
			goto rlab;
	oops:		xret := "ToPrimitive: This should not happen.";
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__isAccessorDescriptor(desc)
[[ (desc == $$undefined) * types(desc : $$undefined_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal;

 [[ (desc == {{ "d", _lvar_58, _lvar_59, _lvar_60, _lvar_61 }}) * (! (_lvar_58 == $$empty)) * types(_lvar_59 : $$boolean_type, _lvar_61 : $$boolean_type, desc : $$list_type, _lvar_60 : $$boolean_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal;

 [[ (desc == {{ "g", _lvar_62, _lvar_63, _lvar_64, _lvar_65, $$empty, $$empty }}) * types(_lvar_67 : $$empty_type, desc : $$list_type, _lvar_66 : $$empty_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal;

 [[ (desc == {{ "g", _lvar_68, _lvar_69, _lvar_70, _lvar_71, _lvar_72, _lvar_73 }}) * (! (_lvar_72 == $$empty)) * types(desc : $$list_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (desc == {{ "g", _lvar_74, _lvar_75, _lvar_76, _lvar_77, _lvar_78, _lvar_79 }}) * (! (_lvar_79 == $$empty)) * types(desc : $$list_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal

proc i__isAccessorDescriptor (desc) {
			goto [(desc = $$undefined)] rf cont;
	cont:		d := l-nth(desc, 0.);
			goto [(d = "a")] rt gen;
	gen:		goto [(d = "g")] test rf;
	test:		g := l-nth(desc, 5.);
			s := l-nth(desc, 6.);
			goto [((g = $$empty) and (s = $$empty))] rf rt;
	rt:		xret := $$t;
			goto rlab;
	rf:		xret := $$f;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec o__getOwnProperty(l, prop)
[[ ((_$l_#l, #prop) -> None) * (l == _$l_#l) * (prop == #prop) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * types(l : $$object_type, #prop : $$string_type) ]]
[[ ((_$l_#l, #prop) -> None) * (xret == $$undefined) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * types(xret : $$undefined_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, #prop) -> {{ "d", _lvar_39, _lvar_40, _lvar_41, _lvar_42 }}) * (l == _$l_#l) * (prop == #prop) * (! (_lvar_39 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (#dx == {{ "d", _lvar_39, _lvar_40, _lvar_41, _lvar_42 }}) * types(_lvar_41 : $$boolean_type, l : $$object_type, _lvar_42 : $$boolean_type, prop : $$string_type, _lvar_40 : $$boolean_type, #prop : $$string_type, #dx : $$list_type) ]]
[[ ((_$l_#l, #prop) -> {{ "d", _lvar_43, _lvar_44, _lvar_45, _lvar_46 }}) * (xret == {{ "d", _lvar_43, _lvar_44, _lvar_45, _lvar_46 }}) * (! (_lvar_43 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (#dx == {{ "d", _lvar_43, _lvar_44, _lvar_45, _lvar_46 }}) * types(_lvar_46 : $$boolean_type, _lvar_44 : $$boolean_type, _lvar_45 : $$boolean_type, xret : $$list_type, #prop : $$string_type, #dx : $$list_type) ]]
normal

proc o__getOwnProperty (l, prop) {
			x := hasField(l,prop);
			goto [x] hp nhp;
	nhp:		xret := $$undefined;
			goto rlab;
	hp:		xret := [l, prop];
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__toInteger(v)
[[ (v == #v) * types(#v : $$string_type) ]]
[[ (xret == (num_to_int (string_to_num #v))) * types(#v : $$string_type, xret : $$number_type) ]]
normal

proc i__toInteger (v) {
			xret := "i__toNumber"(v) with elab;
			xret := (num_to_int xret);
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec deleteProperty(l, prop, throw)
[[ (l == #l) * (prop == #prop) * (#desc == $$undefined) * types(#desc : $$undefined_type, l : $$object_type, prop : $$string_type, #l : $$object_type, #clsx : $$list_type, #prop : $$string_type) * Pi(#l, #prop, #clsx, $$undefined, #gp_aux_2, #gp_aux_3, #gp_aux_4) ]]
[[ (xret == $$t) * (#desc == $$undefined) * types(#desc : $$undefined_type, #l : $$object_type, #clsx : $$list_type, xret : $$boolean_type, #prop : $$string_type) * Pi(#l, #prop, #clsx, $$undefined, #gp_aux_2, #gp_aux_3, #gp_aux_4) ]]
normal;

 [[ (l == #l) * (prop == #prop) * (! (_lvar_465 == $$empty)) * (#desc == {{ "d", _lvar_465, _lvar_466, _lvar_467, $$t }}) * types(_lvar_467 : $$boolean_type, #desc : $$list_type, _lvar_466 : $$boolean_type, l : $$object_type, prop : $$string_type, #l : $$object_type, #clsx : $$list_type, #prop : $$string_type) * Pi(#l, #prop, #clsx, {{ "d", _lvar_465, _lvar_466, _lvar_467, $$t }}, {{ #l }}, #gp_aux_3, #gp_aux_4) ]]
[[ (xret == $$t) * types(#desc : $$list_type, #l : $$object_type, #clsx : $$list_type, xret : $$boolean_type, #prop : $$string_type) * Pi(#l, #prop, #clsx, #desc, {{ #l }}, #gp_aux_3, #gp_aux_4) ]]
normal;

 [[ (l == #l) * (prop == #prop) * (throw == $$t) * (! (_lvar_471 == $$empty)) * (#desc == {{ "d", _lvar_471, _lvar_472, _lvar_473, $$f }}) * types(_lvar_472 : $$boolean_type, #desc : $$list_type, l : $$object_type, _lvar_473 : $$boolean_type, prop : $$string_type, #l : $$object_type, #clsx : $$list_type, throw : $$boolean_type, #prop : $$string_type) * Pi(#l, #prop, #clsx, {{ "d", _lvar_471, _lvar_472, _lvar_473, $$f }}, {{ #l }}, #gp_aux_3, #gp_aux_4) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * (xret == _$l_xret) * types(#desc : $$list_type, #l : $$object_type, #clsx : $$list_type, xret : $$object_type, #prop : $$string_type) * Pi(#l, #prop, #clsx, #desc, {{ #l }}, #gp_aux_3, #gp_aux_4) ]]
error;

 [[ (l == #l) * (prop == #prop) * (throw == $$f) * (! (_lvar_477 == $$empty)) * (#desc == {{ "d", _lvar_477, _lvar_478, _lvar_479, $$f }}) * types(#desc : $$list_type, _lvar_479 : $$boolean_type, l : $$object_type, _lvar_478 : $$boolean_type, prop : $$string_type, #l : $$object_type, #clsx : $$list_type, throw : $$boolean_type, #prop : $$string_type) * Pi(#l, #prop, #clsx, {{ "d", _lvar_477, _lvar_478, _lvar_479, $$f }}, {{ #l }}, #gp_aux_3, #gp_aux_4) ]]
[[ (xret == $$f) * types(#desc : $$list_type, #l : $$object_type, #clsx : $$list_type, xret : $$boolean_type, #prop : $$string_type) * Pi(#l, #prop, #clsx, #desc, {{ #l }}, #gp_aux_3, #gp_aux_4) ]]
error

proc deleteProperty (l, prop, throw) {
			[* unfold Pi(#l, #prop, #clsx, #desc, #g_aux_2, #g_aux_3, #g_aux_4) *]
			xret := "getOwnProperty"(l, prop) with elab;
			[* fold Pi(#l, #prop, #clsx, #desc, #g_aux_2, #g_aux_3, #g_aux_4) *]
			goto [(xret = $$undefined)] dt cont;
	cont:		c := l-nth(xret, 4.);
			goto [c] del reject;
	del:		delete(l,prop);
	dt:		xret := $$t;
			goto rlab;
	df:		xret := $$f;
	rlab:		skip;
	reject:		goto [throw] tt df;
	tt:		xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec getOwnProperty(l, prop)
[[ ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> None) * (l == _$l_#l) * (prop == #prop) * (! (#cls == "String")) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * types(l : $$object_type, #cls : $$string_type, #prop : $$string_type) ]]
[[ ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> None) * (xret == $$undefined) * (! (#cls == "String")) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * types(#cls : $$string_type, xret : $$undefined_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> {{ "d", _lvar_453, _lvar_454, _lvar_455, _lvar_456 }}) * (l == _$l_#l) * (prop == #prop) * (! (#cls == "String")) * (! (_lvar_453 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (#dx == {{ "d", _lvar_453, _lvar_454, _lvar_455, _lvar_456 }}) * types(_lvar_456 : $$boolean_type, _lvar_455 : $$boolean_type, l : $$object_type, _lvar_454 : $$boolean_type, #cls : $$string_type, prop : $$string_type, #prop : $$string_type, #dx : $$list_type) ]]
[[ ((_$l_#l, "@class") -> #cls) * ((_$l_#l, #prop) -> {{ "d", _lvar_457, _lvar_458, _lvar_459, _lvar_460 }}) * (xret == {{ "d", _lvar_457, _lvar_458, _lvar_459, _lvar_460 }}) * (! (#cls == "String")) * (! (_lvar_457 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (#dx == {{ "d", _lvar_457, _lvar_458, _lvar_459, _lvar_460 }}) * types(_lvar_458 : $$boolean_type, _lvar_460 : $$boolean_type, _lvar_459 : $$boolean_type, #cls : $$string_type, xret : $$list_type, #prop : $$string_type, #dx : $$list_type) ]]
normal

proc getOwnProperty (l, prop) {
			class := [l, "@class"];
			goto [(class = "String")] sgop ogop;
	sgop:		xret := "s__getOwnProperty"(l, prop) with elab;
			goto rlab;
	ogop:		xret := "o__getOwnProperty"(l, prop) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__toString(v)
[[ (v == #v) * types(#v : $$number_type) ]]
[[ (xret == (num_to_string #v)) * types(#v : $$number_type, xret : $$string_type) ]]
normal;

 [[ (v == #v) * types(#v : $$string_type) ]]
[[ (xret == #v) * types(#v : $$string_type, xret : $$string_type) ]]
normal

proc i__toString (v) {
	iu:		goto [(v = $$undefined)] undef in;
	undef:		xret := "undefined";
			goto rlab;
	in:		goto [(v = $$null)] null ib;
	null:		xret := "null";
			goto rlab;
	ib:		goto [(typeOf(v) = $$boolean_type)] bool inum;
	bool:		goto [(v = $$t)] is_t is_f;
	is_t:		xret := "true";
			goto rlab;
	is_f:		xret := "false";
			goto rlab;
	inum:		goto [(typeOf(v) = $$number_type)] num is;
	num:		xret := (num_to_string v);
			goto rlab;
	is:		goto [(typeOf(v) = $$string_type)] str io;
	str:		xret := v;
			goto rlab;
	io:		goto [(typeOf(v) = $$object_type)] obj oops;
	obj:		xret := "i__toPrimitive"(v, "String") with elab;
			xret := "i__toString"(xret) with elab;
			goto rlab;
	oops:		xret := "TypeError"("ToString: This should not happen.");
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__checkAssignmentErrors(v)
[[ (v == $$undefined) * types(v : $$undefined_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (v == $$null) * types(v : $$null_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (v == _lvar_v) * types(v : $$number_type, _lvar_v : $$number_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (v == _lvar_v) * types(v : $$boolean_type, _lvar_v : $$boolean_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (v == _lvar_v) * types(v : $$string_type, _lvar_v : $$string_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (v == _lvar_v) * types(v : $$object_type, _lvar_v : $$object_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (v == {{ "v", #l, #prop }}) * (! (#prop == "arguments")) * (! (#prop == "eval")) * (#v == {{ "v", #l, #prop }}) * types(v : $$list_type, #v : $$list_type, #l : $$object_type, #prop : $$string_type) ]]
[[ (xret == $$t) * types(#v : $$list_type, #l : $$object_type, xret : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ (v == {{ "v", #l, "eval" }}) * (#v == {{ "v", #l, "eval" }}) * types(v : $$list_type, #v : $$list_type, #l : $$object_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lserr_proto) * (xret == _$l_xret) * types(#v : $$list_type, #l : $$object_type, xret : $$object_type) ]]
error;

 [[ (v == {{ "v", #l, "arguments" }}) * (#v == {{ "v", #l, "arguments" }}) * types(v : $$list_type, #v : $$list_type, #l : $$object_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lserr_proto) * (xret == _$l_xret) * types(#v : $$list_type, #l : $$object_type, xret : $$object_type) ]]
error;

 [[ (v == {{ "o", #base, #field }}) * (#v == {{ "o", #base, #field }}) * types(#field : $$string_type, v : $$list_type, #v : $$list_type, #base : $$object_type) ]]
[[ (xret == $$t) * types(#field : $$string_type, #v : $$list_type, #base : $$object_type, xret : $$boolean_type) ]]
normal

proc i__checkAssignmentErrors (v) {
			tv := typeOf(v);
			goto [(tv = $$list_type)] isref rlab;
	isref:		goto [((l-nth(v, 0.) = "v") or (l-nth(v, 0.) = "o"))] prep rlab;
	prep:		fv := l-nth(v, 2.);
	csyn:		goto [((l-nth(v, 0.) = "v") and ((fv = "eval") or (fv = "arguments")))] se rlab;
	rlab:		xret := $$t;
	se:		xret := "SyntaxError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec put(l, prop, value, throw)
[[ ((_$l_#l, "@extensible") -> $$f) * (l == _$l_#l) * (prop == #prop) * (value == #value) * (throw == $$t) * (! (#value == $$empty)) * types(l : $$object_type, throw : $$boolean_type, #prop : $$string_type) * Pi(_$l_#l, #prop, #g_aux_0, $$undefined, #g_aux_2, #g_aux_3, #g_aux_4) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_#l, "@extensible") -> $$f) * (xret == _$l_xret) * types(xret : $$object_type, #prop : $$string_type) * Pi(_$l_#l, #prop, #g_aux_0, $$undefined, #g_aux_2, #g_aux_3, #g_aux_4) ]]
error;

 [[ (l == #l) * (prop == #prop) * (value == #value) * (throw == $$t) * (! (_lvar_278 == $$empty)) * (! (#value == $$empty)) * (#g_aux_1 == {{ "d", _lvar_278, $$f, _lvar_280, _lvar_281 }}) * types(#g_aux_1 : $$list_type, _lvar_281 : $$boolean_type, l : $$object_type, prop : $$string_type, #l : $$object_type, _lvar_280 : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) * Pi(#l, #prop, #g_aux_0, {{ "d", _lvar_278, $$f, _lvar_280, _lvar_281 }}, {{ #l }}, #g_aux_3, #g_aux_4) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * (xret == _$l_xret) * types(#g_aux_1 : $$list_type, #l : $$object_type, xret : $$object_type, #prop : $$string_type) * Pi(#l, #prop, #g_aux_0, #g_aux_1, {{ #l }}, #g_aux_3, #g_aux_4) ]]
error;

 [[ ((_$l_#l, "@extensible") -> $$f) * (l == _$l_#l) * (prop == #prop) * (value == #value) * (throw == $$t) * (! (_lvar_284 == $$empty)) * (! (#value == $$empty)) * (#g_aux_2 == (_$l_#l :: (#lp :: #other))) * (#g_aux_1 == {{ "d", _lvar_284, _lvar_285, _lvar_286, _lvar_287 }}) * types(#g_aux_1 : $$list_type, _lvar_285 : $$boolean_type, _lvar_287 : $$boolean_type, #lp : $$object_type, #g_aux_2 : $$list_type, l : $$object_type, #other : $$list_type, prop : $$string_type, throw : $$boolean_type, #prop : $$string_type, _lvar_286 : $$boolean_type) * Pi(_$l_#l, #prop, #g_aux_0, {{ "d", _lvar_284, _lvar_285, _lvar_286, _lvar_287 }}, (_$l_#l :: (#lp :: #other)), #g_aux_3, #g_aux_4) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_#l, "@extensible") -> $$f) * (xret == _$l_xret) * types(#g_aux_1 : $$list_type, #lp : $$object_type, #g_aux_2 : $$list_type, #other : $$list_type, xret : $$object_type, #prop : $$string_type) * Pi(_$l_#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) ]]
error;

 [[ ((_$l_#l, "@extensible") -> $$t) * (l == _$l_#l) * (prop == #prop) * (value == #value) * (throw == $$t) * (! (_lvar_288 == $$empty)) * (! (#value == $$empty)) * (#g_aux_2 == (_$l_#l :: (#lp :: #other))) * (#g_aux_1 == {{ "d", _lvar_288, $$f, _lvar_290, _lvar_291 }}) * types(#g_aux_1 : $$list_type, _lvar_290 : $$boolean_type, #lp : $$object_type, #g_aux_2 : $$list_type, l : $$object_type, #other : $$list_type, prop : $$string_type, _lvar_291 : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) * Pi(_$l_#l, #prop, #g_aux_0, {{ "d", _lvar_288, $$f, _lvar_290, _lvar_291 }}, (_$l_#l :: (#lp :: #other)), #g_aux_3, #g_aux_4) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_#l, "@extensible") -> $$t) * (xret == _$l_xret) * types(#g_aux_1 : $$list_type, #lp : $$object_type, #g_aux_2 : $$list_type, #other : $$list_type, xret : $$object_type, #prop : $$string_type) * Pi(_$l_#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) ]]
error;

 [[ ((_$l_#l, "@extensible") -> $$t) * (l == _$l_#l) * (prop == #prop) * (value == #value) * (throw == #throw) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (#value == $$empty)) * types(l : $$object_type, #cls : $$string_type, prop : $$string_type, #throw : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) * Pi(_$l_#l, #prop, {{ #cls }}, $$undefined, {{ _$l_#l }}, {{ $$f }}, {{ "" }}) ]]
[[ ((_$l_#l, "@extensible") -> $$t) * ((_$l_#l, "@proto") -> $$null) * (xret == $$empty) * types(#cls : $$string_type, #throw : $$boolean_type, xret : $$empty_type, #prop : $$string_type) * Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #value, $$t, $$t, $$t }}, {{ _$l_#l }}, {{ $$f }}, {{ "" }}) ]]
normal;

 [[ ((_$l_#l, "@extensible") -> $$t) * (l == _$l_#l) * (prop == #prop) * (value == #value) * (throw == #throw) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (#value == $$empty)) * types(#lllp : $$list_type, #lp : $$object_type, #pv : $$string_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, #throw : $$boolean_type, #lltf : $$list_type, #ccls : $$string_type, #llcls : $$list_type, #tf : $$boolean_type, throw : $$boolean_type, #prop : $$string_type, #llpv : $$list_type) * Pi(_$l_#l, #prop, (#cls :: (#ccls :: #llcls)), $$undefined, (_$l_#l :: (#lp :: #lllp)), ($$f :: (#tf :: #lltf)), ("" :: (#pv :: #llpv))) ]]
[[ ((_$l_#l, "@extensible") -> $$t) * ((_$l_#l, "@proto") -> #lp) * (xret == $$empty) * types(#lllp : $$list_type, #lp : $$object_type, #pv : $$string_type, #cls : $$string_type, #throw : $$boolean_type, #lltf : $$list_type, #ccls : $$string_type, xret : $$empty_type, #llcls : $$list_type, #tf : $$boolean_type, #prop : $$string_type, #llpv : $$list_type) * Pi(#lp, #prop, (#ccls :: #llcls), $$undefined, (#lp :: #lllp), (#tf :: #lltf), (#pv :: #llpv)) * Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #value, $$t, $$t, $$t }}, {{ _$l_#l }}, {{ $$f }}, {{ "" }}) ]]
normal;

 [[ ((_$l_#l, "@extensible") -> #ext) * (l == _$l_#l) * (prop == #prop) * (value == #value) * (throw == #throw) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (#dval == $$empty)) * (! (#value == $$empty)) * types(#denum : $$boolean_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, #throw : $$boolean_type, #ext : $$boolean_type, #dconf : $$boolean_type, throw : $$boolean_type, #prop : $$string_type) * Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #dval, $$t, #denum, #dconf }}, {{ _$l_#l }}, #g_aux_3, #g_aux_4) ]]
[[ ((_$l_#l, "@extensible") -> #ext) * (xret == $$empty) * types(#denum : $$boolean_type, #cls : $$string_type, #throw : $$boolean_type, #ext : $$boolean_type, xret : $$empty_type, #dconf : $$boolean_type, #prop : $$string_type) * Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #value, $$t, #denum, #dconf }}, {{ _$l_#l }}, #g_aux_3, #g_aux_4) ]]
normal;

 [[ ((_$l_#l, "@extensible") -> $$t) * (l == _$l_#l) * (prop == #prop) * (value == #value) * (throw == #throw) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (#dcval == $$empty)) * (! (#value == $$empty)) * types(#ocls : $$list_type, #lllp : $$list_type, #dcenum : $$boolean_type, #lp : $$object_type, #pv : $$string_type, l : $$object_type, #cls : $$string_type, prop : $$string_type, #throw : $$boolean_type, #lltf : $$list_type, #dcconf : $$boolean_type, #tf : $$boolean_type, throw : $$boolean_type, #prop : $$string_type, #pcls : $$string_type, #llpv : $$list_type) * Pi(_$l_#l, #prop, (#cls :: (#pcls :: #ocls)), {{ "d", #dcval, $$t, #dcenum, #dcconf }}, (_$l_#l :: (#lp :: #lllp)), ($$f :: (#tf :: #lltf)), ("" :: (#pv :: #llpv))) ]]
[[ ((_$l_#l, "@extensible") -> $$t) * ((_$l_#l, "@proto") -> #lp) * (xret == $$empty) * types(#ocls : $$list_type, #lllp : $$list_type, #dcenum : $$boolean_type, #lp : $$object_type, #pv : $$string_type, #cls : $$string_type, #throw : $$boolean_type, #lltf : $$list_type, xret : $$empty_type, #dcconf : $$boolean_type, #tf : $$boolean_type, #prop : $$string_type, #pcls : $$string_type, #llpv : $$list_type) * Pi(#lp, #prop, (#pcls :: #ocls), {{ "d", #dcval, $$t, #dcenum, #dcconf }}, (#lp :: #lllp), (#tf :: #lltf), (#pv :: #llpv)) * Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #value, $$t, $$t, $$t }}, {{ _$l_#l }}, {{ $$f }}, {{ "" }}) ]]
normal

proc put (l, prop, value, throw) {
			xret := "canPut"(l, prop) with elab;
			goto [xret] cp reject;
			[* unfold Pi(#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) *]
	cp:		xret := "getOwnProperty"(l, prop) with elab;
			dd := "i__isDataDescriptor"(xret);
			goto [dd] dd gp;
	dd:		desc := {{ "g", $$empty, $$empty, value, $$empty, $$empty, $$empty }};
			xret := "defineOwnProperty"(l, prop, desc, throw) with elab;
			[* fold Pi(#l, #prop, #g_aux_new_1, {{ "d", #value, $$t, #denum, #dconf }}, {{ #l }}, #g_aux_new_3, #g_aux_new_4) *]
			goto remp;
			[* fold Pi(#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) *]
	gp:		xret := "getProperty"(l, prop) with elab;
			ad := "i__isAccessorDescriptor"(xret);
			goto [ad] ad def;
	ad:		s := l-nth(xret, 2.);
			xsc := [s, "@scope"];
			fun := [s, "@call"];
			xret := fun(xsc, l, value) with elab;
			goto remp;
	def:		desc := {{ "d", value, $$t, $$t, $$t }};
			[* unfold Pi(#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) *]
			xret := "defineOwnProperty"(l, prop, desc, throw) with elab;
			[* fold Pi(#l, #prop, #g_aux_new_1, {{ "d", #value, $$t, $$t, $$t }}, {{ #l }}, #g_aux_new_3, #g_aux_new_4) *]
			skip;
	remp:		xret := $$empty;
	rlab:		skip;
	reject:		xret := $$empty;
			goto [throw] tt rlab;
	tt:		xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__putValue(v, w)
[[ (v == $$undefined) * types(v : $$undefined_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lrferr_proto) * (xret == _$l_xret) * types(xret : $$object_type) ]]
error;

 [[ (v == $$null) * types(v : $$null_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lrferr_proto) * (xret == _$l_xret) * types(xret : $$object_type) ]]
error;

 [[ (v == _lvar_v) * types(v : $$number_type, _lvar_v : $$number_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lrferr_proto) * (xret == _$l_xret) * types(xret : $$object_type) ]]
error;

 [[ (v == _lvar_v) * types(v : $$boolean_type, _lvar_v : $$boolean_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lrferr_proto) * (xret == _$l_xret) * types(xret : $$object_type) ]]
error;

 [[ (v == _lvar_v) * types(v : $$string_type, _lvar_v : $$string_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lrferr_proto) * (xret == _$l_xret) * types(xret : $$object_type) ]]
error;

 [[ (v == _lvar_v) * types(v : $$object_type, _lvar_v : $$object_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lrferr_proto) * (xret == _$l_xret) * types(xret : $$object_type) ]]
error;

 [[ ((_$l_#obj, #field) -> #oldvalue) * (w == #w) * (v == {{ "v", _$l_#obj, #field }}) * (! (s-nth(#field, 0.) == "@")) * (! (#field == "")) * (! (#w == $$empty)) * types(#field : $$string_type, v : $$list_type) ]]
[[ ((_$l_#obj, #field) -> #w) * (xret == $$empty) * types(#field : $$string_type, xret : $$empty_type) ]]
normal;

 [[ ((_$l_#l, "@extensible") -> $$f) * (w == #w) * (v == {{ "o", _$l_#l, #prop }}) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#w == $$empty)) * types(v : $$list_type, #cls : $$list_type, #prop : $$string_type) * Pi(_$l_#l, #prop, #cls, $$undefined, #g_aux_4, #g_aux_5, #g_aux_6) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_#l, "@extensible") -> $$f) * (xret == _$l_xret) * types(#cls : $$list_type, xret : $$object_type, #prop : $$string_type) * Pi(_$l_#l, #prop, #cls, $$undefined, #g_aux_4, #g_aux_5, #g_aux_6) ]]
error;

 [[ (w == #w) * (v == {{ "o", #l, #prop }}) * (! (_lvar_195 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#w == $$empty)) * (#g_aux_1 == {{ "d", _lvar_195, $$f, _lvar_197, _lvar_198 }}) * types(#g_aux_1 : $$list_type, _lvar_197 : $$boolean_type, v : $$list_type, _lvar_198 : $$boolean_type, #cls : $$list_type, #l : $$object_type, #prop : $$string_type) * Pi(#l, #prop, #cls, {{ "d", _lvar_195, $$f, _lvar_197, _lvar_198 }}, {{ #l }}, #g_aux_3, #g_aux_4) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * (xret == _$l_xret) * types(#g_aux_1 : $$list_type, #cls : $$list_type, #l : $$object_type, xret : $$object_type, #prop : $$string_type) * Pi(#l, #prop, #cls, #g_aux_1, {{ #l }}, #g_aux_3, #g_aux_4) ]]
error;

 [[ ((_$l_#l, "@extensible") -> $$f) * (w == #w) * (v == {{ "o", _$l_#l, #prop }}) * (! (_lvar_201 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#w == $$empty)) * (#g_aux_2 == (_$l_#l :: (#lp :: #other))) * (#g_aux_1 == {{ "d", _lvar_201, _lvar_202, _lvar_203, _lvar_204 }}) * types(#g_aux_1 : $$list_type, v : $$list_type, _lvar_202 : $$boolean_type, #lp : $$object_type, #g_aux_2 : $$list_type, #other : $$list_type, _lvar_203 : $$boolean_type, #cls : $$list_type, _lvar_204 : $$boolean_type, #prop : $$string_type) * Pi(_$l_#l, #prop, #cls, {{ "d", _lvar_201, _lvar_202, _lvar_203, _lvar_204 }}, (_$l_#l :: (#lp :: #other)), #g_aux_3, #g_aux_4) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_#l, "@extensible") -> $$f) * (xret == _$l_xret) * types(#g_aux_1 : $$list_type, #lp : $$object_type, #g_aux_2 : $$list_type, #other : $$list_type, #cls : $$list_type, xret : $$object_type, #prop : $$string_type) * Pi(_$l_#l, #prop, #cls, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) ]]
error;

 [[ ((_$l_#l, "@extensible") -> $$t) * (w == #w) * (v == {{ "o", _$l_#l, #prop }}) * (! (_lvar_205 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#w == $$empty)) * (#g_aux_2 == (_$l_#l :: (#lp :: #other))) * (#g_aux_1 == {{ "d", _lvar_205, $$f, _lvar_207, _lvar_208 }}) * types(#g_aux_1 : $$list_type, v : $$list_type, #lp : $$object_type, #g_aux_2 : $$list_type, #other : $$list_type, #cls : $$list_type, #prop : $$string_type, _lvar_207 : $$boolean_type, _lvar_208 : $$boolean_type) * Pi(_$l_#l, #prop, #cls, {{ "d", _lvar_205, $$f, _lvar_207, _lvar_208 }}, (_$l_#l :: (#lp :: #other)), #g_aux_3, #g_aux_4) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * ((_$l_#l, "@extensible") -> $$t) * (xret == _$l_xret) * types(#g_aux_1 : $$list_type, #lp : $$object_type, #g_aux_2 : $$list_type, #other : $$list_type, #cls : $$list_type, xret : $$object_type, #prop : $$string_type) * Pi(_$l_#l, #prop, #cls, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) ]]
error;

 [[ (($lg, "@extensible") -> $$f) * (w == #w) * (v == {{ "v", $lg, #prop }}) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#w == $$empty)) * types(v : $$list_type, #prop : $$string_type) * Pi($lg, #prop, {{ "Object" }}, $$undefined, #g_aux_4, #g_aux_5, #g_aux_6) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * (($lg, "@extensible") -> $$f) * (xret == _$l_xret) * types(xret : $$object_type, #prop : $$string_type) * Pi($lg, #prop, {{ "Object" }}, $$undefined, #g_aux_4, #g_aux_5, #g_aux_6) ]]
error;

 [[ (($lg, "@extensible") -> $$f) * (w == #w) * (v == {{ "v", $lg, #prop }}) * (! (_lvar_209 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#w == $$empty)) * (#g_aux_1 == {{ "d", _lvar_209, $$f, _lvar_211, _lvar_212 }}) * types(#g_aux_1 : $$list_type, _lvar_212 : $$boolean_type, v : $$list_type, #prop : $$string_type, _lvar_211 : $$boolean_type) * Pi($lg, #prop, {{ "Object" }}, {{ "d", _lvar_209, $$f, _lvar_211, _lvar_212 }}, {{ $lg }}, #g_aux_3, #g_aux_4) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * (($lg, "@extensible") -> $$f) * (xret == _$l_xret) * types(#g_aux_1 : $$list_type, xret : $$object_type, #prop : $$string_type) * Pi($lg, #prop, {{ "Object" }}, #g_aux_1, {{ $lg }}, #g_aux_3, #g_aux_4) ]]
error;

 [[ (($lg, "@extensible") -> $$f) * (w == #w) * (v == {{ "v", $lg, #prop }}) * (! (_lvar_213 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#w == $$empty)) * (#g_aux_2 == ($lg :: (#lp :: #other))) * (#g_aux_1 == {{ "d", _lvar_213, _lvar_214, _lvar_215, _lvar_216 }}) * types(#g_aux_1 : $$list_type, _lvar_215 : $$boolean_type, v : $$list_type, _lvar_214 : $$boolean_type, #lp : $$object_type, #g_aux_2 : $$list_type, #other : $$list_type, _lvar_216 : $$boolean_type, #prop : $$string_type) * Pi($lg, #prop, {{ "Object" }}, {{ "d", _lvar_213, _lvar_214, _lvar_215, _lvar_216 }}, ($lg :: (#lp :: #other)), #g_aux_3, #g_aux_4) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * (($lg, "@extensible") -> $$f) * (xret == _$l_xret) * types(#g_aux_1 : $$list_type, #lp : $$object_type, #g_aux_2 : $$list_type, #other : $$list_type, xret : $$object_type, #prop : $$string_type) * Pi($lg, #prop, {{ "Object" }}, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) ]]
error;

 [[ (($lg, "@extensible") -> $$t) * (w == #w) * (v == {{ "v", $lg, #prop }}) * (! (_lvar_217 == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#w == $$empty)) * (#g_aux_2 == ($lg :: (#lp :: #other))) * (#g_aux_1 == {{ "d", _lvar_217, $$f, _lvar_219, _lvar_220 }}) * types(#g_aux_1 : $$list_type, _lvar_219 : $$boolean_type, v : $$list_type, #lp : $$object_type, #g_aux_2 : $$list_type, #other : $$list_type, _lvar_220 : $$boolean_type, #prop : $$string_type) * Pi($lg, #prop, {{ "Object" }}, {{ "d", _lvar_217, $$f, _lvar_219, _lvar_220 }}, ($lg :: (#lp :: #other)), #g_aux_3, #g_aux_4) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * (($lg, "@extensible") -> $$t) * (xret == _$l_xret) * types(#g_aux_1 : $$list_type, #lp : $$object_type, #g_aux_2 : $$list_type, #other : $$list_type, xret : $$object_type, #prop : $$string_type) * Pi($lg, #prop, {{ "Object" }}, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) ]]
error;

 [[ ((_$l_#l, "@extensible") -> $$t) * (w == #w) * (v == {{ "o", _$l_#l, #prop }}) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#w == $$empty)) * types(v : $$list_type, #cls : $$string_type, #prop : $$string_type) * Pi(_$l_#l, #prop, {{ #cls }}, $$undefined, {{ _$l_#l }}, {{ $$f }}, {{ "" }}) ]]
[[ ((_$l_#l, "@extensible") -> $$t) * ((_$l_#l, "@proto") -> $$null) * (xret == $$empty) * types(#cls : $$string_type, xret : $$empty_type, #prop : $$string_type) * Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #w, $$t, $$t, $$t }}, {{ _$l_#l }}, {{ $$f }}, {{ "" }}) ]]
normal;

 [[ ((_$l_#l, "@extensible") -> $$t) * (w == #w) * (v == {{ "o", _$l_#l, #prop }}) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#w == $$empty)) * types(#ocls : $$list_type, v : $$list_type, #lllp : $$list_type, #lp : $$object_type, #pv : $$string_type, #cls : $$string_type, #lltf : $$list_type, #tf : $$boolean_type, #prop : $$string_type, #pcls : $$string_type, #llpv : $$list_type) * Pi(_$l_#l, #prop, (#cls :: (#pcls :: #ocls)), $$undefined, (_$l_#l :: (#lp :: #lllp)), ($$f :: (#tf :: #lltf)), ("" :: (#pv :: #llpv))) ]]
[[ ((_$l_#l, "@extensible") -> $$t) * ((_$l_#l, "@proto") -> #lp) * (xret == $$empty) * types(#ocls : $$list_type, #lllp : $$list_type, #lp : $$object_type, #pv : $$string_type, #cls : $$string_type, #lltf : $$list_type, xret : $$empty_type, #tf : $$boolean_type, #prop : $$string_type, #pcls : $$string_type, #llpv : $$list_type) * Pi(#lp, #prop, (#pcls :: #ocls), $$undefined, (#lp :: #lllp), (#tf :: #lltf), (#pv :: #llpv)) * Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #w, $$t, $$t, $$t }}, {{ _$l_#l }}, {{ $$f }}, {{ "" }}) ]]
normal;

 [[ (($lg, "@extensible") -> $$t) * (w == #w) * (v == {{ "v", $lg, #prop }}) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#w == $$empty)) * types(#ocls : $$list_type, v : $$list_type, #lllp : $$list_type, #lp : $$object_type, #pv : $$string_type, #lltf : $$list_type, #tf : $$boolean_type, #prop : $$string_type, #pcls : $$string_type, #llpv : $$list_type) * Pi($lg, #prop, ("Object" :: (#pcls :: #ocls)), $$undefined, ($lg :: (#lp :: #lllp)), ($$f :: (#tf :: #lltf)), ("" :: (#pv :: #llpv))) ]]
[[ (($lg, "@extensible") -> $$t) * (($lg, "@proto") -> #lp) * (xret == $$empty) * types(#ocls : $$list_type, #lllp : $$list_type, #lp : $$object_type, #pv : $$string_type, #lltf : $$list_type, xret : $$empty_type, #tf : $$boolean_type, #prop : $$string_type, #pcls : $$string_type, #llpv : $$list_type) * Pi(#lp, #prop, (#pcls :: #ocls), $$undefined, (#lp :: #lllp), (#tf :: #lltf), (#pv :: #llpv)) * Pi($lg, #prop, {{ "Object" }}, {{ "d", #w, $$t, $$t, $$t }}, {{ $lg }}, {{ $$f }}, {{ "" }}) ]]
normal;

 [[ ((_$l_#l, "@extensible") -> #ext) * (w == #w) * (v == {{ "o", _$l_#l, #prop }}) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (#dval == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#w == $$empty)) * types(#denum : $$boolean_type, v : $$list_type, #cls : $$string_type, #ext : $$boolean_type, #dconf : $$boolean_type, #prop : $$string_type) * Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #dval, $$t, #denum, #dconf }}, {{ _$l_#l }}, #g_aux_3, #g_aux_4) ]]
[[ ((_$l_#l, "@extensible") -> #ext) * (xret == $$empty) * types(#denum : $$boolean_type, #cls : $$string_type, #ext : $$boolean_type, xret : $$empty_type, #dconf : $$boolean_type, #prop : $$string_type) * Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #w, $$t, #denum, #dconf }}, {{ _$l_#l }}, #g_aux_3, #g_aux_4) ]]
normal;

 [[ (($lg, "@extensible") -> #ext) * (w == #w) * (v == {{ "v", $lg, #prop }}) * (! (#dval == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#w == $$empty)) * types(#denum : $$boolean_type, v : $$list_type, #ext : $$boolean_type, #dconf : $$boolean_type, #prop : $$string_type) * Pi($lg, #prop, {{ "Object" }}, {{ "d", #dval, $$t, #denum, #dconf }}, {{ $lg }}, #g_aux_3, #g_aux_4) ]]
[[ (($lg, "@extensible") -> #ext) * (xret == $$empty) * types(#denum : $$boolean_type, #ext : $$boolean_type, xret : $$empty_type, #dconf : $$boolean_type, #prop : $$string_type) * Pi($lg, #prop, {{ "Object" }}, {{ "d", #w, $$t, #denum, #dconf }}, {{ $lg }}, #g_aux_3, #g_aux_4) ]]
normal;

 [[ ((_$l_#l, "@extensible") -> $$t) * (w == #w) * (v == {{ "o", _$l_#l, #prop }}) * (! (#cls == "Array")) * (! (#cls == "String")) * (! (#dcval == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#w == $$empty)) * types(#ocls : $$list_type, v : $$list_type, #lllp : $$list_type, #dcenum : $$boolean_type, #lp : $$object_type, #pv : $$string_type, #cls : $$string_type, #lltf : $$list_type, #dcconf : $$boolean_type, #tf : $$boolean_type, #prop : $$string_type, #pcls : $$string_type, #llpv : $$list_type) * Pi(_$l_#l, #prop, (#cls :: (#pcls :: #ocls)), {{ "d", #dcval, $$t, #dcenum, #dcconf }}, (_$l_#l :: (#lp :: #lllp)), ($$f :: (#tf :: #lltf)), ("" :: (#pv :: #llpv))) ]]
[[ ((_$l_#l, "@extensible") -> $$t) * ((_$l_#l, "@proto") -> #lp) * (xret == $$empty) * types(#ocls : $$list_type, #lllp : $$list_type, #dcenum : $$boolean_type, #lp : $$object_type, #pv : $$string_type, #cls : $$string_type, #lltf : $$list_type, xret : $$empty_type, #dcconf : $$boolean_type, #tf : $$boolean_type, #prop : $$string_type, #pcls : $$string_type, #llpv : $$list_type) * Pi(#lp, #prop, (#pcls :: #ocls), {{ "d", #dcval, $$t, #dcenum, #dcconf }}, (#lp :: #lllp), (#tf :: #lltf), (#pv :: #llpv)) * Pi(_$l_#l, #prop, {{ #cls }}, {{ "d", #w, $$t, $$t, $$t }}, {{ _$l_#l }}, {{ $$f }}, {{ "" }}) ]]
normal;

 [[ (($lg, "@extensible") -> $$t) * (w == #w) * (v == {{ "v", $lg, #prop }}) * (! (#dcval == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * (! (#w == $$empty)) * types(#ocls : $$list_type, v : $$list_type, #lllp : $$list_type, #dcenum : $$boolean_type, #lp : $$object_type, #pv : $$string_type, #lltf : $$list_type, #dcconf : $$boolean_type, #tf : $$boolean_type, #prop : $$string_type, #pcls : $$string_type, #llpv : $$list_type) * Pi($lg, #prop, ("Object" :: (#pcls :: #ocls)), {{ "d", #dcval, $$t, #dcenum, #dcconf }}, ($lg :: (#lp :: #lllp)), ($$f :: (#tf :: #lltf)), ("" :: (#pv :: #llpv))) ]]
[[ (($lg, "@extensible") -> $$t) * (($lg, "@proto") -> #lp) * (xret == $$empty) * types(#ocls : $$list_type, #lllp : $$list_type, #dcenum : $$boolean_type, #lp : $$object_type, #pv : $$string_type, #lltf : $$list_type, xret : $$empty_type, #dcconf : $$boolean_type, #tf : $$boolean_type, #prop : $$string_type, #pcls : $$string_type, #llpv : $$list_type) * Pi(#lp, #prop, (#pcls :: #ocls), {{ "d", #dcval, $$t, #dcenum, #dcconf }}, (#lp :: #lllp), (#tf :: #lltf), (#pv :: #llpv)) * Pi($lg, #prop, {{ "Object" }}, {{ "d", #w, $$t, $$t, $$t }}, {{ $lg }}, {{ $$f }}, {{ "" }}) ]]
normal

proc i__putValue (v, w) {
			goto [(typeOf(v) = $$list_type)] isref throw;
	isref:		goto [((l-nth(v, 0.) = "v") or (l-nth(v, 0.) = "o"))] init throw;
	init:		rbase := l-nth(v, 1.);
			rfield := l-nth(v, 2.);
			goto [(rbase = $$undefined)] throw prim;
	prim:		prim := "i__isPrimitive"(rbase);
			goto [prim] is_pr refr;
	refr:		goto [(l-nth(v, 0.) = "o")] oref vref;
	oref:		xret := "put"(rbase, rfield, w, $$t) with elab;
			goto dflt;
	vref:		goto [(rbase = $lg)] lg er;
	lg:		xret := "put"(rbase, rfield, w, $$t) with elab;
			goto dflt;
	er:		[rbase, rfield] := w;
	dflt:		xret := $$empty;
	rlab:		skip;
	throw:		xret := "ReferenceError"();
	elab:		skip;
	is_pr:		xret := "i__toObject"(rbase) with elab;
			l := xret;
			xret := "canPut"(l, rfield) with elab;
			goto [xret] cp reject;
	cp:		xret := "getProperty"(l, rfield) with elab;
			dd := "i__isDataDescriptor"(xret);
			goto [dd] reject is_ad;
	is_ad:		ad := "i__isAccessorDescriptor"(xret);
			goto [ad] ad reject;
	ad:		s := l-nth(xret, 2.);
			xsc := [s, "@scope"];
			fun := [s, "@call"];
			xret := fun(xsc, rbase, w) with elab;
			goto dflt;
	reject:		xret := "TypeError"();
			goto elab
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec OP_hasOwnProperty(xsc, vthis, v)
[[ ((_$l_#l, #prop) -> {{ "d", #v, #wr, #en, #co }}) * ((_$l_#l, "@class") -> "Object") * (vthis == _$l_#l) * (v == #prop) * (! (#v == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * types(vthis : $$object_type, #en : $$boolean_type, v : $$string_type, #wr : $$boolean_type, #prop : $$string_type, #co : $$boolean_type) ]]
[[ ((_$l_#l, #prop) -> {{ "d", #v, #wr, #en, #co }}) * ((_$l_#l, "@class") -> "Object") * (xret == $$t) * (! (#v == $$empty)) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * types(#en : $$boolean_type, #wr : $$boolean_type, xret : $$boolean_type, #co : $$boolean_type, #prop : $$string_type) ]]
normal;

 [[ ((_$l_#l, #prop) -> None) * ((_$l_#l, "@class") -> "Object") * (vthis == _$l_#l) * (v == #prop) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * types(vthis : $$object_type, #prop : $$string_type) ]]
[[ ((_$l_#l, #prop) -> None) * ((_$l_#l, "@class") -> "Object") * (xret == $$f) * (! (s-nth(#prop, 0.) == "@")) * (! (#prop == "")) * types(xret : $$boolean_type, #prop : $$string_type) ]]
normal

proc OP_hasOwnProperty (xsc, vthis, v) {
			xret := "i__toString"(v) with elab;
			p := xret;
			xret := "i__toObject"(vthis) with elab;
			xret := "getOwnProperty"(xret, p) with elab;
			xret := (not (xret = $$undefined));
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec hasProperty(l, prop)
[[ (l == #l) * (prop == #prop) * types(#l : $$object_type, #prop : $$string_type) * Pi(#l, #prop, #gp_aux_0, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4) ]]
[[ (xret == (not (#gp_aux_1 = $$undefined))) * types(#l : $$object_type, xret : $$boolean_type, #prop : $$string_type) * Pi(#l, #prop, #gp_aux_0, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4) ]]
normal

proc hasProperty (l, prop) {
			xret := "getProperty"(l, prop) with elab;
	rlab:		xret := (not (xret = $$undefined));
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec create_object_with_call_construct(l, call, construct, len)
[[ empty_fields(_$l_#l : -{ "@proto" }-) * ((_$l_#l, "@proto") -> $$null) * (call == #call) * (len == #len) * (construct == #construct) * (l == _$l_#l) * types(#construct : $$string_type, #len : $$number_type, l : $$object_type, #call : $$string_type) ]]
[[ empty_fields(_$l_#l : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope", "length" }-) * ((_$l_#l, "@construct") -> #construct) * ((_$l_#l, "@call") -> #call) * ((_$l_#l, "length") -> {{ "d", #len, $$f, $$f, $$f }}) * ((_$l_#l, "@scope") -> $$empty) * ((_$l_#l, "@extensible") -> $$t) * ((_$l_#l, "@class") -> "Function") * ((_$l_#l, "@proto") -> $lfun_proto) * (xret == _$l_#l) * types(#construct : $$string_type, #len : $$number_type, xret : $$object_type, #call : $$string_type) ]]
normal;

 [[ empty_fields(_$l_#l : -{  }-) * (call == #call) * (len == #len) * (construct == $$empty) * (l == _$l_#l) * types(construct : $$empty_type, #len : $$number_type, l : $$object_type, call : $$string_type, len : $$number_type, #call : $$string_type) ]]
[[ empty_fields(_$l_#l : -{ "@call", "@class", "@extensible", "@proto", "@scope", "length" }-) * ((_$l_#l, "@call") -> #call) * ((_$l_#l, "length") -> {{ "d", #len, $$f, $$f, $$f }}) * ((_$l_#l, "@scope") -> $$empty) * ((_$l_#l, "@extensible") -> $$t) * ((_$l_#l, "@class") -> "Function") * ((_$l_#l, "@proto") -> $lfun_proto) * (xret == _$l_#l) * types(#len : $$number_type, xret : $$object_type, #call : $$string_type) ]]
normal;

 [[ empty_fields(_$l_#l : -{  }-) * (call == #call) * (len == #len) * (construct == #construct) * (l == _$l_#l) * types(#construct : $$string_type, #len : $$number_type, l : $$object_type, #call : $$string_type) ]]
[[ empty_fields(_$l_#l : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope", "length" }-) * ((_$l_#l, "@construct") -> #construct) * ((_$l_#l, "@call") -> #call) * ((_$l_#l, "length") -> {{ "d", #len, $$f, $$f, $$f }}) * ((_$l_#l, "@scope") -> $$empty) * ((_$l_#l, "@extensible") -> $$t) * ((_$l_#l, "@class") -> "Function") * ((_$l_#l, "@proto") -> $lfun_proto) * (xret == _$l_#l) * types(#construct : $$string_type, #len : $$number_type, xret : $$object_type, #call : $$string_type) ]]
normal

proc create_object_with_call_construct (l, call, construct, len) {
			xret := "create_default_object"(l, $lfun_proto, "Function", $$t);
			[xret, "@scope"] := $$empty;
			[xret, "length"] := {{ "d", len, $$f, $$f, $$f }};
			[xret, "@call"] := call;
			goto [(construct = $$empty)] rlab cstr;
	cstr:		[xret, "@construct"] := construct;
	rlab:		xret := l
} with {
	ret: xret, rlab;
};


spec i__isPrimitive(v)
[[ (v == $$undefined) * types(v : $$undefined_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (v == $$null) * types(v : $$null_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (v == _lvar_v) * types(v : $$number_type, _lvar_v : $$number_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (v == _lvar_v) * types(v : $$boolean_type, _lvar_v : $$boolean_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (v == _lvar_v) * types(v : $$string_type, _lvar_v : $$string_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (v == _lvar_v) * types(v : $$object_type, _lvar_v : $$object_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal

proc i__isPrimitive (v) {
			tv := typeOf(v);
	iu:		goto [(((((v = $$undefined) or (v = $$null)) or (typeOf(v) = $$boolean_type)) or (typeOf(v) = $$number_type)) or (typeOf(v) = $$string_type))] rt rf;
	rt:		xret := $$t;
			goto rlab;
	rf:		xret := $$f;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec copy_object_rec(lf, fields, lt)
[[ (fields == $$nil) * types(fields : $$list_type) ]]
[[ (xret == #lt) * types() ]]
normal;

 [[ ((_$l_#lf, #f) -> #v) * ((_$l_#lt, "@proto") -> $$null) * ((_$l_#lt, #f) -> None) * (lt == _$l_#lt) * (fields == {{ #f }}) * (lf == _$l_#lf) * (! (s-nth(#f, 0.) == "@")) * (! (#f == "")) * (#fields == {{ #f }}) * types(#f : $$string_type, lt : $$object_type, lf : $$object_type, #fields : $$list_type, fields : $$list_type) ]]
[[ ((_$l_#lf, #f) -> #v) * ((_$l_#lt, "@proto") -> $$null) * ((_$l_#lt, #f) -> #v) * (xret == _$l_#lt) * types(#f : $$string_type, #fields : $$list_type, xret : $$object_type) ]]
normal;

 [[ ((_$l_#lf, "main") -> #v2) * ((_$l_#lf, #f1) -> #v1) * ((_$l_#lt, "@proto") -> $$null) * ((_$l_#lt, "main") -> None) * ((_$l_#lt, #f1) -> None) * (lt == _$l_#lt) * (fields == {{ #f1, "main" }}) * (lf == _$l_#lf) * (! (s-nth(#f1, 0.) == "@")) * (! (#f1 == "")) * (#fields == {{ #f1, "main" }}) * types(#f1 : $$string_type, lt : $$object_type, lf : $$object_type, #fields : $$list_type, fields : $$list_type) ]]
[[ ((_$l_#lf, "main") -> #v2) * ((_$l_#lf, #f1) -> #v1) * ((_$l_#lt, "@proto") -> $$null) * ((_$l_#lt, "main") -> #v2) * ((_$l_#lt, #f1) -> #v1) * (xret == _$l_#lt) * types(#f1 : $$string_type, #fields : $$list_type, xret : $$object_type) ]]
normal

proc copy_object_rec (lf, fields, lt) {
			goto [(fields = $$nil)] rlab next;
	next:		head := l-nth(fields, 0.);
			tail := (cdr fields);
			val := [lf, head];
			[lt, head] := val;
			xret := "copy_object_rec"(lf, tail, lt);
	rlab:		xret := lt
} with {
	ret: xret, rlab;
};


spec i__isGenericDescriptor(desc)
[[ (desc == $$undefined) * types(desc : $$undefined_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal;

 [[ (desc == {{ "d", _lvar_483, _lvar_484, _lvar_485, _lvar_486 }}) * (! (_lvar_483 == $$empty)) * types(_lvar_484 : $$boolean_type, _lvar_485 : $$boolean_type, desc : $$list_type, _lvar_486 : $$boolean_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal;

 [[ (desc == {{ "g", _lvar_487, _lvar_488, $$empty, $$empty, $$empty, $$empty }}) * types(_lvar_491 : $$empty_type, _lvar_489 : $$empty_type, _lvar_490 : $$empty_type, _lvar_492 : $$empty_type, desc : $$list_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (desc == {{ "g", _lvar_493, _lvar_494, _lvar_495, _lvar_496, _lvar_497, _lvar_498 }}) * (! (_lvar_495 == $$empty)) * types(desc : $$list_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal;

 [[ (desc == {{ "g", _lvar_499, _lvar_500, _lvar_501, _lvar_502, _lvar_503, _lvar_504 }}) * (! (_lvar_502 == $$empty)) * types(desc : $$list_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal;

 [[ (desc == {{ "g", _lvar_505, _lvar_506, _lvar_507, _lvar_508, _lvar_509, _lvar_510 }}) * (! (_lvar_509 == $$empty)) * types(desc : $$list_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal;

 [[ (desc == {{ "g", _lvar_511, _lvar_512, _lvar_513, _lvar_514, _lvar_515, _lvar_516 }}) * (! (_lvar_516 == $$empty)) * types(desc : $$list_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal

proc i__isGenericDescriptor (desc) {
			goto [(desc = $$undefined)] rf cont;
	cont:		dd := "i__isDataDescriptor"(desc);
			ad := "i__isAccessorDescriptor"(desc);
			xret := (not (dd or ad));
			goto rlab;
	rf:		xret := $$f;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__toDataDescriptor(desc)
[[ (desc == {{ "d", _lvar_461, _lvar_462, _lvar_463, _lvar_464 }}) * (! (_lvar_461 == $$empty)) * (#desc == {{ "d", _lvar_461, _lvar_462, _lvar_463, _lvar_464 }}) * types(_lvar_462 : $$boolean_type, #desc : $$list_type, _lvar_464 : $$boolean_type, desc : $$list_type, _lvar_463 : $$boolean_type) ]]
[[ (xret == #desc) * types(#desc : $$list_type) ]]
normal

proc i__toDataDescriptor (desc) {
			d := l-nth(desc, 0.);
			goto [(d = "d")] rd cstr;
	cstr:		goto [(d = "a")] ra gen;
	ra:		xret := {{ "d", $$undefined, $$f, l-nth(desc, 3.), l-nth(desc, 4.) }};
			goto rlab;
	gen:		e := l-nth(desc, 1.);
			c := l-nth(desc, 2.);
			v := l-nth(desc, 3.);
			w := l-nth(desc, 4.);
			goto [(e = $$empty)] fixe c;
	fixe:		e := $$f;
	c:		goto [(c = $$empty)] fixc v;
	fixc:		c := $$f;
	v:		goto [(v = $$empty)] fixv w;
	fixv:		v := $$undefined;
	w:		goto [(w = $$empty)] fixw fixed;
	fixw:		w := $$f;
	fixed:		xret := {{ "d", v, w, e, c }};
			goto rlab;
	rd:		xret := desc;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__sameValue(v1, v2)
[[ (v1 == #v1) * (v2 == #v2) * (#v2 == 0.) * (#v1 == 0.) * types(v2 : $$number_type, #v2 : $$number_type, v1 : $$number_type, #v1 : $$number_type) ]]
[[ (xret == $$t) * types(#v2 : $$number_type, xret : $$boolean_type, #v1 : $$number_type) ]]
normal;

 [[ (v1 == #v1) * (v2 == #v2) * (#v2 == -0.) * (#v1 == -0.) * types(v2 : $$number_type, #v2 : $$number_type, v1 : $$number_type, #v1 : $$number_type) ]]
[[ (xret == $$t) * types(#v2 : $$number_type, xret : $$boolean_type, #v1 : $$number_type) ]]
normal;

 [[ (v1 == #v1) * (v2 == #v2) * (#v2 == 0.) * (#v1 == -0.) * types(v2 : $$number_type, #v2 : $$number_type, v1 : $$number_type, #v1 : $$number_type) ]]
[[ (xret == $$f) * types(#v2 : $$number_type, xret : $$boolean_type, #v1 : $$number_type) ]]
normal;

 [[ (v1 == #v1) * (v2 == #v2) * (#v2 == -0.) * (#v1 == 0.) * types(v2 : $$number_type, #v2 : $$number_type, v1 : $$number_type, #v1 : $$number_type) ]]
[[ (xret == $$f) * types(#v2 : $$number_type, xret : $$boolean_type, #v1 : $$number_type) ]]
normal;

 [[ (v1 == #v1) * (v2 == #v2) * (#v1 == #v2) * types() ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (v1 == #v1) * (v2 == #v2) * (! (#v1 == #v2)) * types() ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal

proc i__sameValue (v1, v2) {
			xret := (v1 = v2);
			goto [(typeOf(v1) = $$number_type)] test2 rlab;
	test2:		goto [(typeOf(v2) = $$number_type)] inan1 rlab;
	inan1:		goto [(not (v1 = v1))] inan2 zero1;
	inan2:		goto [(not (v2 = v2))] rt zero1;
	zero1:		goto [(v1 = 0.)] zero2 rlab;
	zero2:		goto [(v2 = 0.)] fix rlab;
	fix:		sv1 := (m_sgn v1);
			sv2 := (m_sgn v2);
			xret := (sv1 = sv2);
			goto rlab;
	rt:		xret := $$t;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__toObject(v)
[[ (v == #v) * types(#v : $$object_type) ]]
[[ (xret == #v) * types(#v : $$object_type) ]]
normal

proc i__toObject (v) {
	iu:		goto [(v = $$undefined)] throw in;
	in:		goto [(v = $$null)] throw ib;
	ib:		goto [(typeOf(v) = $$boolean_type)] bool inum;
	bool:		xret := "Boolean_construct"($$undefined, $$undefined, v);
			goto rlab;
	inum:		goto [(typeOf(v) = $$number_type)] num is;
	num:		xret := "Number_construct"($$undefined, $$undefined, v);
			goto rlab;
	is:		goto [(typeOf(v) = $$string_type)] str io;
	str:		xret := "String_construct"($$undefined, $$undefined, v);
			goto rlab;
	io:		goto [(typeOf(v) = $$object_type)] obj oops;
	obj:		xret := v;
			goto rlab;
	oops:		xret := "ToObject: This should not happen.";
	rlab:		skip;
	throw:		xret := "Here!";
			xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__toBoolean(v)
[[ (v == #v) * types(#v : $$boolean_type) ]]
[[ (xret == #v) * types(#v : $$boolean_type) ]]
normal;

 [[ (v == 0.) * types(v : $$number_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal;

 [[ (v == #v) * (! (#v == 0.)) * types(#v : $$number_type) ]]
[[ (xret == $$t) * types(#v : $$number_type, xret : $$boolean_type) ]]
normal;

 [[ (v == #v) * types(#v : $$object_type) ]]
[[ (xret == $$t) * types(#v : $$object_type, xret : $$boolean_type) ]]
normal;

 [[ (v == $$null) * types(v : $$null_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal

proc i__toBoolean (v) {
	iu:		goto [(v = $$undefined)] undef in;
	undef:		xret := $$f;
			goto rlab;
	in:		goto [(v = $$null)] null ib;
	null:		xret := $$f;
			goto rlab;
	ib:		goto [(typeOf(v) = $$boolean_type)] bool inum;
	bool:		xret := v;
			goto rlab;
	inum:		goto [(typeOf(v) = $$number_type)] num is;
	num:		goto [((v = 0.) or (not (v = v)))] is_f is_t;
	is:		goto [(typeOf(v) = $$string_type)] str io;
	str:		goto [(v = "")] is_f is_t;
			goto rlab;
	io:		goto [(typeOf(v) = $$object_type)] obj oops;
	obj:		xret := $$t;
			goto rlab;
	is_t:		xret := $$t;
			goto rlab;
	is_f:		xret := $$f;
			goto rlab;
	oops:		xret := "ToBoolean: This should not happen.";
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec getProperty(l, prop)
[[ (l == #l) * (prop == #prop) * types(#l : $$object_type, #prop : $$string_type) * Pi(#l, #prop, #gp_aux_0, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4) ]]
[[ (xret == #gp_aux_1) * types(#l : $$object_type, #prop : $$string_type) * Pi(#l, #prop, #gp_aux_0, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4) ]]
normal

proc getProperty (l, prop) {
			[* unfold Pi(#l, #prop, #gp_aux_0, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4) *]
	start:		xret := "getOwnProperty"(l, prop) with elab;
			goto [(xret = $$undefined)] next rlab;
	next:		proto := [l, "@proto"];
			goto [(proto = $$null)] rlab call;
	call:		xret := "getProperty"(proto, prop) with elab;
			[* fold Pi(#l, #prop, #gp_aux_0, #gp_aux_1, #gp_aux_2, #gp_aux_3, #gp_aux_4) *]
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec get(l, prop)
[[ (l == #l) * (prop == #prop) * (! (_lvar_191 == $$empty)) * (#g_aux_1 == {{ "d", _lvar_191, _lvar_192, _lvar_193, _lvar_194 }}) * types(_lvar_192 : $$boolean_type, #g_aux_1 : $$list_type, _lvar_193 : $$boolean_type, l : $$object_type, prop : $$string_type, #l : $$object_type, _lvar_194 : $$boolean_type, #prop : $$string_type) * Pi(#l, #prop, #g_aux_0, {{ "d", _lvar_191, _lvar_192, _lvar_193, _lvar_194 }}, #g_aux_2, #g_aux_3, #g_aux_4) ]]
[[ (xret == l-nth(#g_aux_1, 1.)) * types(#g_aux_1 : $$list_type, #l : $$object_type, #prop : $$string_type) * Pi(#l, #prop, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) ]]
normal;

 [[ (l == #l) * (prop == #prop) * (#g_aux_1 == $$undefined) * types(#g_aux_1 : $$undefined_type, l : $$object_type, prop : $$string_type, #l : $$object_type, #prop : $$string_type) * Pi(#l, #prop, #g_aux_0, $$undefined, #g_aux_2, #g_aux_3, #g_aux_4) ]]
[[ (xret == $$undefined) * (#g_aux_1 == $$undefined) * types(#g_aux_1 : $$undefined_type, #l : $$object_type, xret : $$undefined_type, #prop : $$string_type) * Pi(#l, #prop, #g_aux_0, $$undefined, #g_aux_2, #g_aux_3, #g_aux_4) ]]
normal

proc get (l, prop) {
			xret := "getProperty"(l, prop) with elab;
			goto [(xret = $$undefined)] rlab def;
	def:		d := l-nth(xret, 0.);
			xret := l-nth(xret, 1.);
			goto [(d = "d")] rlab acc;
	acc:		goto [(xret = $$undefined)] rlab get;
	get:		xsc := [xret, "@scope"];
			fun := [xret, "@call"];
			xret := fun(xsc, l) with elab;
			goto [(xret = $$empty)] undef rlab;
	undef:		xret := $$undefined;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__checkObjectCoercible(v)
[[ (v == $$undefined) * types(v : $$undefined_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * (xret == _$l_xret) * types(xret : $$object_type) ]]
normal;

 [[ (v == $$null) * types(v : $$null_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lterr_proto) * (xret == _$l_xret) * types(xret : $$object_type) ]]
normal;

 [[ (v == _lvar_v) * types(v : $$number_type, _lvar_v : $$number_type) ]]
[[ (xret == $$empty) * types(xret : $$empty_type) ]]
normal;

 [[ (v == _lvar_v) * types(v : $$boolean_type, _lvar_v : $$boolean_type) ]]
[[ (xret == $$empty) * types(xret : $$empty_type) ]]
normal;

 [[ (v == _lvar_v) * types(v : $$string_type, _lvar_v : $$string_type) ]]
[[ (xret == $$empty) * types(xret : $$empty_type) ]]
normal;

 [[ (v == _lvar_v) * types(v : $$object_type, _lvar_v : $$object_type) ]]
[[ (xret == $$empty) * types(xret : $$empty_type) ]]
normal

proc i__checkObjectCoercible (v) {
			xret := $$empty;
	iu:		goto [(v = $$undefined)] throw in;
	in:		goto [(v = $$null)] throw other;
	other:		goto [((((typeOf(v) = $$boolean_type) or (typeOf(v) = $$number_type)) or (typeOf(v) = $$string_type)) or (typeOf(v) = $$object_type))] rlab oops;
	oops:		xret := "CheckObjectCoercible: This should not happen.";
	rlab:		skip;
	throw:		xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec SyntaxError_call(xsc, vthis, v)
[[ (v == $$undefined) * types(v : $$undefined_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lserr_proto) * (xret == _$l_xret) * types(xret : $$object_type) ]]
normal

proc SyntaxError_call (xsc, vthis, v) {
			xret := new();
			xret := "create_default_object"(xret, $lserr_proto, "Error", $$t);
			xret := "Error_construct"($$undefined, xret, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__getValue(v)
[[ (v == {{ "o", #obj, #field }}) * (! (_lvar_50 == $$empty)) * (! (s-nth(#field, 0.) == "@")) * (! (#field == "")) * (#g_aux_1 == {{ "d", _lvar_50, _lvar_51, _lvar_52, _lvar_53 }}) * types(#g_aux_1 : $$list_type, _lvar_53 : $$boolean_type, #field : $$string_type, v : $$list_type, #obj : $$object_type, _lvar_51 : $$boolean_type, _lvar_52 : $$boolean_type) * Pi(#obj, #field, #g_aux_0, {{ "d", _lvar_50, _lvar_51, _lvar_52, _lvar_53 }}, #g_aux_2, #g_aux_3, #g_aux_4) ]]
[[ (xret == l-nth(#g_aux_1, 1.)) * types(#g_aux_1 : $$list_type, #field : $$string_type, #obj : $$object_type) * Pi(#obj, #field, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) ]]
normal;

 [[ ((_$l_#obj, #field) -> #value) * (v == {{ "v", _$l_#obj, #field }}) * (! (s-nth(#field, 0.) == "@")) * (! (#field == "")) * types(#field : $$string_type, v : $$list_type) ]]
[[ ((_$l_#obj, #field) -> #value) * (xret == #value) * types(#field : $$string_type) ]]
normal;

 [[ (v == {{ "v", $lg, #field }}) * (! (_lvar_54 == $$empty)) * (! (s-nth(#field, 0.) == "@")) * (! (#field == "")) * (#g_aux_1 == {{ "d", _lvar_54, _lvar_55, _lvar_56, _lvar_57 }}) * types(#g_aux_1 : $$list_type, #field : $$string_type, v : $$list_type, _lvar_57 : $$boolean_type, _lvar_55 : $$boolean_type, _lvar_56 : $$boolean_type) * Pi($lg, #field, #g_aux_0, {{ "d", _lvar_54, _lvar_55, _lvar_56, _lvar_57 }}, #g_aux_2, #g_aux_3, #g_aux_4) ]]
[[ (xret == l-nth(#g_aux_1, 1.)) * types(#g_aux_1 : $$list_type, #field : $$string_type) * Pi($lg, #field, #g_aux_0, #g_aux_1, #g_aux_2, #g_aux_3, #g_aux_4) ]]
normal;

 [[ (v == {{ "o", #obj, #field }}) * (! (s-nth(#field, 0.) == "@")) * (! (#field == "")) * (#g_aux_1 == $$undefined) * types(#g_aux_1 : $$undefined_type, #field : $$string_type, v : $$list_type, #obj : $$object_type) * Pi(#obj, #field, #g_aux_0, $$undefined, #g_aux_2, #g_aux_3, #g_aux_4) ]]
[[ (xret == $$undefined) * (#g_aux_1 == $$undefined) * types(#g_aux_1 : $$undefined_type, #field : $$string_type, #obj : $$object_type, xret : $$undefined_type) * Pi(#obj, #field, #g_aux_0, $$undefined, #g_aux_2, #g_aux_3, #g_aux_4) ]]
normal;

 [[ (v == {{ "v", $lg, #field }}) * (! (s-nth(#field, 0.) == "@")) * (! (#field == "")) * (#g_aux_1 == $$undefined) * types(#g_aux_1 : $$undefined_type, #field : $$string_type, v : $$list_type) * Pi($lg, #field, #g_aux_0, $$undefined, #g_aux_2, #g_aux_3, #g_aux_4) ]]
[[ (xret == $$undefined) * (#g_aux_1 == $$undefined) * types(#g_aux_1 : $$undefined_type, #field : $$string_type, xret : $$undefined_type) * Pi($lg, #field, #g_aux_0, $$undefined, #g_aux_2, #g_aux_3, #g_aux_4) ]]
normal;

 [[ (v == $$null) * types(v : $$null_type) ]]
[[ (xret == $$null) * types(xret : $$null_type) ]]
normal;

 [[ (v == #v) * types(#v : $$object_type) ]]
[[ (xret == #v) * types(#v : $$object_type) ]]
normal;

 [[ (v == #v) * types(#v : $$number_type) ]]
[[ (xret == #v) * types(#v : $$number_type) ]]
normal;

 [[ (v == #v) * types(#v : $$boolean_type) ]]
[[ (xret == #v) * types(#v : $$boolean_type) ]]
normal;

 [[ (v == #v) * types(#v : $$string_type) ]]
[[ (xret == #v) * types(#v : $$string_type) ]]
normal;

 [[ (v == $$undefined) * types(v : $$undefined_type) ]]
[[ (xret == $$undefined) * types(xret : $$undefined_type) ]]
normal;

 [[ (v == {{ "o", $$undefined, #field }}) * (! (s-nth(#field, 0.) == "@")) * (! (#field == "")) * types(#field : $$string_type, v : $$list_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lrferr_proto) * (xret == _$l_xret) * types(#field : $$string_type, xret : $$object_type) ]]
error;

 [[ (v == {{ "v", $$undefined, #field }}) * (! (s-nth(#field, 0.) == "@")) * (! (#field == "")) * types(#field : $$string_type, v : $$list_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lrferr_proto) * (xret == _$l_xret) * types(#field : $$string_type, xret : $$object_type) ]]
error

proc i__getValue (v) {
			goto [(typeOf(v) = $$list_type)] rcand dflt;
	rcand:		rtype := l-nth(v, 0.);
			goto [((rtype = "v") or (rtype = "o"))] init dflt;
	init:		rbase := l-nth(v, 1.);
			rfield := l-nth(v, 2.);
			goto [(rbase = $$undefined)] throw prim;
	prim:		prim := "i__isPrimitive"(rbase);
			goto [prim] is_pr ref;
	is_pr:		xret := "i__toObject"(rbase) with elab;
			xret := "getProperty"(xret, rfield) with elab;
			goto [(xret = $$undefined)] rlab def;
	def:		d := l-nth(xret, 0.);
			xret := l-nth(xret, 1.);
			goto [(d = "d")] rlab acc;
	acc:		goto [(xret = $$undefined)] rlab get;
	get:		xsc := [xret, "@scope"];
			fun := [xret, "@call"];
			xret := fun(xsc, rbase) with elab;
			goto [(xret = $$empty)] undef rlab;
	undef:		xret := $$undefined;
	ref:		goto [(l-nth(v, 0.) = "o")] oref vref;
	oref:		xret := "get"(rbase, rfield) with elab;
			goto rlab;
	vref:		goto [(rbase = $lg)] lg er;
	lg:		xret := "get"(rbase, rfield) with elab;
			goto rlab;
	er:		xret := [rbase, rfield];
			goto rlab;
	dflt:		xret := v;
	rlab:		skip;
	throw:		xret := "ReferenceError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec ReferenceError_call(xsc, vthis, v)
[[ (v == $$undefined) * types(v : $$undefined_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lrferr_proto) * (xret == _$l_xret) * types(xret : $$object_type) ]]
normal

proc ReferenceError_call (xsc, vthis, v) {
			xret := new();
			xret := "create_default_object"(xret, $lrferr_proto, "Error", $$t);
			xret := "Error_construct"($$undefined, xret, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec SyntaxError(v)
[[ (v == $$undefined) * types(v : $$undefined_type) ]]
[[ empty_fields(_$l_xret : -{ "@class", "@extensible", "@proto" }-) * ((_$l_xret, "@extensible") -> $$t) * ((_$l_xret, "@class") -> "Error") * ((_$l_xret, "@proto") -> $lserr_proto) * (xret == _$l_xret) * types(xret : $$object_type) ]]
normal

proc SyntaxError (v) {
			xret := "SyntaxError_call"($$undefined, $$undefined, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__abstractEquality(v1, v2)
[[ (v1 == $$null) * (v2 == $$null) * types(v2 : $$null_type, v1 : $$null_type) ]]
[[ (xret == $$t) * types(xret : $$boolean_type) ]]
normal;

 [[ (v1 == _lvar_v1) * (v2 == $$null) * types(_lvar_v1 : $$object_type, _lvar_v2 : $$null_type, v2 : $$null_type, v1 : $$object_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal;

 [[ (v1 == _lvar_v1) * (v2 == _lvar_v2) * (! (_lvar_v1 == _lvar_v2)) * types(_lvar_v1 : $$number_type, _lvar_v2 : $$number_type, v2 : $$number_type, v1 : $$number_type) ]]
[[ (xret == $$f) * types(xret : $$boolean_type) ]]
normal

proc i__abstractEquality (v1, v2) {
			tv1 := typeOf(v1);
			tv2 := typeOf(v2);
			goto [(tv1 = tv2)] same diff;
	same:		goto [((((((tv1 = $$undefined_type) or (tv1 = $$null_type)) or (tv1 = $$boolean_type)) or (tv1 = $$number_type)) or (tv1 = $$string_type)) or (tv1 = $$object_type))] ieq oops;
	ieq:		xret := (v1 = v2);
			goto rlab;
	diff:		goto [(((tv1 = $$undefined_type) and (tv2 = $$null_type)) or ((tv1 = $$null_type) and (tv2 = $$undefined_type)))] rt dns;
	dns:		goto [((tv1 = $$number_type) and (tv2 = $$string_type))] tn2 dsn;
	tn2:		xret := "i__toNumber"(v2) with elab;
			xret := "i__abstractEquality"(v1, xret) with elab;
			goto rlab;
	dsn:		goto [((tv1 = $$string_type) and (tv2 = $$number_type))] tn1 s1b;
	tn1:		xret := "i__toNumber"(v1) with elab;
			xret := "i__abstractEquality"(xret, v2) with elab;
			goto rlab;
	s1b:		goto [(tv1 = $$boolean_type)] tn1 s2b;
	s2b:		goto [(tv2 = $$boolean_type)] tn2 s2o;
	s2o:		goto [(((tv1 = $$number_type) or (tv1 = $$string_type)) and (tv2 = $$object_type))] tp2 s1o;
	tp2:		xret := "i__toPrimitive"(v2) with elab;
			xret := "i__abstractEquality"(v1, xret) with elab;
			goto rlab;
	s1o:		goto [((tv1 = $$object_type) and ((tv2 = $$number_type) or (tv2 = $$string_type)))] tp1 rf;
	tp1:		xret := "i__toPrimitive"(v1) with elab;
			xret := "i__abstractEquality"(xret, v2) with elab;
			goto rlab;
	rt:		xret := $$t;
			goto rlab;
	rf:		xret := $$f;
			goto rlab;
	oops:		xret := "AbstractEquality: This should not happen.";
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};



