import javert_js_predicates.jsil; 

spec TypeError_call(xsc, vthis, v)
[[ types() * (v == undefined) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * Extensible (_$l__lvar_805, true) * MetaData (_$l__lvar_805, null) * empty_fields(_$l__lvar_805 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_805, "@proto") ->@d $lterr_proto) * ((_$l__lvar_805, "@extensible") ->@d true) * ((_$l__lvar_805, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_805) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc TypeError_call (xsc, vthis, v) {
			xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lterr_proto, "Error", true);
			xret := "Error_construct"(undefined, xret, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec TypeError(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_715, true) * MetaData (_$l__lvar_715, null) * empty_fields(_$l__lvar_715 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_715, "@proto") ->@d $lterr_proto) * ((_$l__lvar_715, "@extensible") ->@d true) * ((_$l__lvar_715, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_715) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc TypeError (v) {
			xret := "TypeError_call"(undefined, undefined, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__isCallable(l)
[[ types() * (l == _$l_l) * ((_$l_#md, "@call") ->@d none) * MetaData (_$l_l, _$l_#md) ]]
[[ types() * (xret == false) * (l == _$l_l) * ((_$l_#md, "@call") ->@d none) * MetaData (_$l_l, _$l_#md) ]]
normal;

 [[ types() * (! (#y == none)) * (l == _$l_l) * ((_$l_#md, "@call") ->@d #y) * MetaData (_$l_l, _$l_#md) ]]
[[ types() * (xret == true) * (l == _$l_l) * ((_$l_#md, "@call") ->@d #y) * MetaData (_$l_l, _$l_#md) ]]
normal

proc i__isCallable (l) {
			xret := false;
			goto [((typeOf l) = Obj)] obj rlab;
	obj:		m := metadata (l);
			xret := hasField(m,"@call");
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec defineOwnProperty(l, prop, desc, throw)
[[ types(#cls : Str, #throw : Bool, _lvar_373 : Bool, #prop : Str, #desc : List, _lvar_372 : Bool, _lvar_371 : Bool) * (#desc == {{ "d", _lvar_370, _lvar_371, _lvar_372, _lvar_373 }}) * (! (_lvar_370 == empty)) * (! (#cls == "Array")) * (! (#cls == "String")) * (throw == #throw) * (desc == {{ "d", _lvar_370, _lvar_371, _lvar_372, _lvar_373 }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#cls : Str, #throw : Bool, _lvar_375 : Bool, _lvar_377 : Bool, #prop : Str, #desc : List, _lvar_376 : Bool) * (#desc == {{ "d", _lvar_374, _lvar_375, _lvar_376, _lvar_377 }}) * (! (_lvar_374 == empty)) * (throw == _lvar_throw) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d true) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_374, _lvar_375, _lvar_376, _lvar_377 }}) ]]
normal;

 [[ types(#cls : Str, #dec : Bool, #dcc : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_386, true, #dec, #dcc }}) * (#desc == {{ "g", empty, empty, #gval, empty, empty, empty }}) * (! (_lvar_386 == empty)) * (! (#gval == empty)) * (! (#cls == "Array")) * (throw == #throw) * (desc == {{ "g", empty, empty, #gval, empty, empty, empty }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_386, true, #dec, #dcc }}) ]]
[[ types(#cls : Str, #dec : Bool, #dcc : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (! (#gval == empty)) * (throw == _lvar_throw) * (xret == true) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", #gval, true, #dec, #dcc }}) ]]
normal;

 [[ types(_lvar_415 : Bool, _lvar_407 : Bool, #cls : Str, _lvar_416 : Bool, _lvar_417 : Bool, _lvar_408 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_406, _lvar_407, _lvar_408, true }}) * (#desc == {{ "d", _lvar_414, _lvar_415, _lvar_416, _lvar_417 }}) * (! (_lvar_414 == empty)) * (! (_lvar_406 == empty)) * (! (#cls == "Array")) * (throw == #throw) * (desc == {{ "d", _lvar_414, _lvar_415, _lvar_416, _lvar_417 }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_406, _lvar_407, _lvar_408, true }}) ]]
[[ types(_lvar_420 : Bool, _lvar_421 : Bool, #cls : Str, _lvar_419 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#desc == {{ "d", _lvar_418, _lvar_419, _lvar_420, _lvar_421 }}) * (! (_lvar_418 == empty)) * (! (#cls == "Array")) * (throw == _lvar_throw) * (xret == true) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_418, _lvar_419, _lvar_420, _lvar_421 }}) ]]
normal;

 [[ types(#cls : Str, #enum : Bool, #prop : Str, #dcur : List, #desc : List, _lvar_427 : Bool, #ext : Bool) * (#dcur == {{ "d", _lvar_434, true, #enum, false }}) * (#desc == {{ "d", _lvar_426, _lvar_427, #enum, false }}) * (! (_lvar_434 == empty)) * (! (_lvar_426 == empty)) * (! (#cls == "Array")) * (throw == #throw) * (desc == {{ "d", _lvar_426, _lvar_427, #enum, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_434, true, #enum, false }}) ]]
[[ types(#cls : Str, #enum : Bool, _lvar_444 : Bool, _lvar_445 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, _lvar_443 : Bool) * (#desc == {{ "d", _lvar_442, _lvar_443, _lvar_444, _lvar_445 }}) * (! (_lvar_442 == empty)) * (throw == _lvar_throw) * (xret == true) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_442, _lvar_443, _lvar_444, _lvar_445 }}) ]]
normal;

 [[ types(#cls : Str, #prop : Str) * (! (#cls == "Array")) * (throw == true) * (desc == #desc) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d false) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#cls : Str, #prop : Str) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d false) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_458) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_458, true) * MetaData (_$l__lvar_458, null) * empty_fields(_$l__lvar_458 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_458, "@proto") ->@d $lterr_proto) * ((_$l__lvar_458, "@extensible") ->@d true) * ((_$l__lvar_458, "@class") ->@d "Error") ]]
error;

 [[ types(#cls : Str, #prop : Str) * (! (#cls == "Array")) * (throw == false) * (desc == #desc) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d false) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#cls : Str, #prop : Str) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d false) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(_lvar_497 : Bool, #cls : Str, _lvar_484 : Bool, #prop : Str, _lvar_496 : Bool, _lvar_485 : Bool, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_495, _lvar_496, _lvar_497, false }}) * (#desc == {{ "d", _lvar_483, _lvar_484, _lvar_485, true }}) * (! (_lvar_495 == empty)) * (! (_lvar_483 == empty)) * (! (#cls == "Array")) * (throw == true) * (desc == {{ "d", _lvar_483, _lvar_484, _lvar_485, true }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_495, _lvar_496, _lvar_497, false }}) ]]
[[ types(#cls : Str, _lvar_505 : Bool, _lvar_506 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, _lvar_507 : Bool) * (#dcur == {{ "d", _lvar_504, _lvar_505, _lvar_506, _lvar_507 }}) * (! (_lvar_504 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * Extensible (_$l__lvar_503, true) * MetaData (_$l__lvar_503, null) * empty_fields(_$l__lvar_503 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_503, "@proto") ->@d $lterr_proto) * ((_$l__lvar_503, "@extensible") ->@d true) * ((_$l__lvar_503, "@class") ->@d "Error") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_504, _lvar_505, _lvar_506, _lvar_507 }}) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_503) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#cls : Str, _lvar_484 : Bool, _lvar_501 : Bool, #prop : Str, _lvar_485 : Bool, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "a", _lvar_500, _lvar_499, _lvar_501, false }}) * (#desc == {{ "d", _lvar_483, _lvar_484, _lvar_485, true }}) * (! (_lvar_500 == empty)) * (! (_lvar_499 == empty)) * (! (_lvar_483 == empty)) * (! (#cls == "Array")) * (throw == true) * (desc == {{ "d", _lvar_483, _lvar_484, _lvar_485, true }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_500, _lvar_499, _lvar_501, false }}) ]]
[[ types(_lvar_511 : Bool, #cls : Str, _lvar_510 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "a", _lvar_509, _lvar_508, _lvar_510, _lvar_511 }}) * (! (_lvar_509 == empty)) * (! (_lvar_508 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * Extensible (_$l__lvar_503, true) * MetaData (_$l__lvar_503, null) * empty_fields(_$l__lvar_503 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_503, "@proto") ->@d $lterr_proto) * ((_$l__lvar_503, "@extensible") ->@d true) * ((_$l__lvar_503, "@class") ->@d "Error") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_509, _lvar_508, _lvar_510, _lvar_511 }}) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_503) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#cls : Str, _lvar_513 : Bool, _lvar_525 : Bool, _lvar_514 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool, _lvar_526 : Bool) * (#dcur == {{ "d", _lvar_524, _lvar_525, _lvar_526, false }}) * (#desc == {{ "d", _lvar_512, _lvar_513, _lvar_514, true }}) * (! (_lvar_524 == empty)) * (! (_lvar_512 == empty)) * (! (#cls == "Array")) * (throw == false) * (desc == {{ "d", _lvar_512, _lvar_513, _lvar_514, true }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_524, _lvar_525, _lvar_526, false }}) ]]
[[ types(_lvar_535 : Bool, #cls : Str, _lvar_534 : Bool, _lvar_533 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_532, _lvar_533, _lvar_534, _lvar_535 }}) * (! (_lvar_532 == empty)) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_532, _lvar_533, _lvar_534, _lvar_535 }}) ]]
normal;

 [[ types(#cls : Str, _lvar_513 : Bool, _lvar_530 : Bool, _lvar_514 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "a", _lvar_529, _lvar_528, _lvar_530, false }}) * (#desc == {{ "d", _lvar_512, _lvar_513, _lvar_514, true }}) * (! (_lvar_529 == empty)) * (! (_lvar_528 == empty)) * (! (_lvar_512 == empty)) * (! (#cls == "Array")) * (throw == false) * (desc == {{ "d", _lvar_512, _lvar_513, _lvar_514, true }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_529, _lvar_528, _lvar_530, false }}) ]]
[[ types(#cls : Str, _lvar_539 : Bool, _lvar_538 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "a", _lvar_537, _lvar_536, _lvar_538, _lvar_539 }}) * (! (_lvar_537 == empty)) * (! (_lvar_536 == empty)) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_537, _lvar_536, _lvar_538, _lvar_539 }}) ]]
normal;

 [[ types(#ed : Bool, #cls : Str, #ec : Bool, _lvar_553 : Bool, #prop : Str, _lvar_541 : Bool, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_552, _lvar_553, #ec, false }}) * (#desc == {{ "d", _lvar_540, _lvar_541, #ed, false }}) * (! (_lvar_552 == empty)) * (! (_lvar_540 == empty)) * (! (#ed == #ec)) * (! (#cls == "Array")) * (throw == true) * (desc == {{ "d", _lvar_540, _lvar_541, #ed, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_552, _lvar_553, #ec, false }}) ]]
[[ types(#ed : Bool, #cls : Str, _lvar_562 : Bool, _lvar_564 : Bool, #ec : Bool, #prop : Str, #dcur : List, #desc : List, _lvar_563 : Bool, #ext : Bool) * (#dcur == {{ "d", _lvar_561, _lvar_562, _lvar_563, _lvar_564 }}) * (! (_lvar_561 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_561, _lvar_562, _lvar_563, _lvar_564 }}) * Extensible (_$l__lvar_560, true) * MetaData (_$l__lvar_560, null) * empty_fields(_$l__lvar_560 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_560, "@proto") ->@d $lterr_proto) * ((_$l__lvar_560, "@extensible") ->@d true) * ((_$l__lvar_560, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_560) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#ed : Bool, #cls : Str, #ec : Bool, #prop : Str, _lvar_541 : Bool, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "a", _lvar_557, _lvar_556, #ec, false }}) * (#desc == {{ "d", _lvar_540, _lvar_541, #ed, false }}) * (! (_lvar_557 == empty)) * (! (_lvar_556 == empty)) * (! (_lvar_540 == empty)) * (! (#ed == #ec)) * (! (#cls == "Array")) * (throw == true) * (desc == {{ "d", _lvar_540, _lvar_541, #ed, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_557, _lvar_556, #ec, false }}) ]]
[[ types(#ed : Bool, #cls : Str, _lvar_567 : Bool, #ec : Bool, #prop : Str, #dcur : List, #desc : List, _lvar_568 : Bool, #ext : Bool) * (#dcur == {{ "a", _lvar_566, _lvar_565, _lvar_567, _lvar_568 }}) * (! (_lvar_566 == empty)) * (! (_lvar_565 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_566, _lvar_565, _lvar_567, _lvar_568 }}) * Extensible (_$l__lvar_560, true) * MetaData (_$l__lvar_560, null) * empty_fields(_$l__lvar_560 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_560, "@proto") ->@d $lterr_proto) * ((_$l__lvar_560, "@extensible") ->@d true) * ((_$l__lvar_560, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_560) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#ed : Bool, #cls : Str, _lvar_570 : Bool, #ec : Bool, _lvar_582 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_581, _lvar_582, #ec, false }}) * (#desc == {{ "d", _lvar_569, _lvar_570, #ed, false }}) * (! (_lvar_581 == empty)) * (! (_lvar_569 == empty)) * (! (#ed == #ec)) * (! (#cls == "Array")) * (throw == false) * (desc == {{ "d", _lvar_569, _lvar_570, #ed, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_581, _lvar_582, #ec, false }}) ]]
[[ types(#ed : Bool, #cls : Str, _lvar_591 : Bool, #ec : Bool, #prop : Str, #dcur : List, #desc : List, _lvar_590 : Bool, #ext : Bool, _lvar_592 : Bool) * (#dcur == {{ "d", _lvar_589, _lvar_590, _lvar_591, _lvar_592 }}) * (! (_lvar_589 == empty)) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_589, _lvar_590, _lvar_591, _lvar_592 }}) ]]
normal;

 [[ types(#ed : Bool, #cls : Str, _lvar_570 : Bool, #ec : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "a", _lvar_586, _lvar_585, #ec, false }}) * (#desc == {{ "d", _lvar_569, _lvar_570, #ed, false }}) * (! (_lvar_586 == empty)) * (! (_lvar_585 == empty)) * (! (_lvar_569 == empty)) * (! (#ed == #ec)) * (! (#cls == "Array")) * (throw == false) * (desc == {{ "d", _lvar_569, _lvar_570, #ed, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_586, _lvar_585, #ec, false }}) ]]
[[ types(#ed : Bool, #cls : Str, _lvar_596 : Bool, #ec : Bool, _lvar_595 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "a", _lvar_594, _lvar_593, _lvar_595, _lvar_596 }}) * (! (_lvar_594 == empty)) * (! (_lvar_593 == empty)) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_594, _lvar_593, _lvar_595, _lvar_596 }}) ]]
normal;

 [[ types(#en : Bool, #cls : Str, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_605, false, #en, false }}) * (#desc == {{ "d", _lvar_597, true, #en, false }}) * (! (_lvar_605 == empty)) * (! (_lvar_597 == empty)) * (! (#cls == "Array")) * (throw == true) * (desc == {{ "d", _lvar_597, true, #en, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_605, false, #en, false }}) ]]
[[ types(#en : Bool, #cls : Str, _lvar_616 : Bool, _lvar_617 : Bool, #prop : Str, #dcur : List, #desc : List, _lvar_615 : Bool, #ext : Bool) * (#dcur == {{ "d", _lvar_614, _lvar_615, _lvar_616, _lvar_617 }}) * (! (_lvar_614 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_614, _lvar_615, _lvar_616, _lvar_617 }}) * Extensible (_$l__lvar_613, true) * MetaData (_$l__lvar_613, null) * empty_fields(_$l__lvar_613 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_613, "@proto") ->@d $lterr_proto) * ((_$l__lvar_613, "@extensible") ->@d true) * ((_$l__lvar_613, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_613) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#en : Bool, #cls : Str, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_630, false, #en, false }}) * (#desc == {{ "d", _lvar_622, true, #en, false }}) * (! (_lvar_630 == empty)) * (! (_lvar_622 == empty)) * (! (#cls == "Array")) * (throw == false) * (desc == {{ "d", _lvar_622, true, #en, false }}) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_630, false, #en, false }}) ]]
[[ types(#en : Bool, #cls : Str, _lvar_639 : Bool, _lvar_641 : Bool, _lvar_640 : Bool, #prop : Str, #dcur : List, #desc : List, #ext : Bool) * (#dcur == {{ "d", _lvar_638, _lvar_639, _lvar_640, _lvar_641 }}) * (! (_lvar_638 == empty)) * (throw == _lvar_throw) * (xret == false) * (desc == _lvar_desc) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_638, _lvar_639, _lvar_640, _lvar_641 }}) ]]
normal

proc defineOwnProperty (l, prop, desc, throw) {
			m := metadata (l);
			class := [m, "@class"];
			goto [(class = "Array")] adop odop;
	adop:		xret := "a__defineOwnProperty"(l, prop, desc, throw) with elab;
			goto rlab;
	odop:		xret := "o__defineOwnProperty"(l, prop, desc, throw) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__strictEquality(v1, v2)
[[ types() * (#v1 == #v2) * (v2 == #v2) * (v1 == #v2) ]]
[[ types() * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (! (#v1 == #v2)) * (v2 == #v2) * (v1 == #v1) ]]
[[ types() * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal

proc i__strictEquality (v1, v2) {
			xret := (v1 = v2);
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec Error_construct(xsc, vthis, v)
[[ types() * (v == undefined) * (xsc == _lvar_xsc) * (vthis == _$l_#vthis) * Extensible (_$l_#mvt, true) * MetaData (_$l_#mvt, null) * ((_$l_#mvt, "@extensible") ->@d #oe) * ((_$l_#mvt, "@class") ->@d #oc) * Extensible (_$l_#vthis, true) * MetaData (_$l_#vthis, _$l_#mvt) ]]
[[ types() * (xret == _$l_#vthis) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * Extensible (_$l_#mvt, true) * MetaData (_$l_#mvt, null) * ((_$l_#mvt, "@extensible") ->@d true) * ((_$l_#mvt, "@class") ->@d "Error") * Extensible (_$l_#vthis, true) * MetaData (_$l_#vthis, _$l_#mvt) ]]
normal;

 [[ types(#m : Str) * (v == #m) * (xsc == _lvar_xsc) * (vthis == _$l_#vthis) * ((_$l_#mvt, "@extensible") ->@d #oe) * ((_$l_#mvt, "@class") ->@d #oc) * MetaData (_$l_#vthis, _$l_#mvt) * ((_$l_#vthis, "message") ->@d #om) ]]
[[ types(#m : Str) * (xret == _$l_#vthis) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * ((_$l_#mvt, "@extensible") ->@d true) * ((_$l_#mvt, "@class") ->@d "Error") * MetaData (_$l_#vthis, _$l_#mvt) * ((_$l_#vthis, "message") ->@d {{ "d", #m, true, false, true }}) ]]
normal

proc Error_construct (xsc, vthis, v) {
			xret := vthis;
			m := metadata (vthis);
			[m, "@class"] := "Error";
			[m, "@extensible"] := true;
			goto [(v = undefined)] rlab mess;
	mess:		xerr := "i__toString"(v) with elab;
			[xret, "message"] := {{ "d", xerr, true, false, true }};
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xerr, elab;
};


spec canPut(l, prop)
[[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str, #ext : Bool) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str, #ext : Bool) * (xret == #ext) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(#l, #prop, {{ "d", _lvar_89, #writ, _lvar_91, _lvar_92 }}, {{ #l }}, #lcls, #lpv) * types(_lvar_92 : Bool, #l : Obj, #lpv : List, _lvar_91 : Bool, #lcls : List, #prop : Str, #writ : Bool, #d : List) * (#d == {{ "d", _lvar_89, #writ, _lvar_91, _lvar_92 }}) * (! (_lvar_89 == empty)) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #d, {{ #l }}, #lcls, #lpv) * types(#l : Obj, #lpv : List, #lcls : List, #prop : Str, #writ : Bool, #d : List) * (xret == #writ) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_95, _lvar_96, _lvar_97, _lvar_98 }}, (_$l_#l :: (#lp :: #other)), #lcls, #lpv) * types(_lvar_97 : Bool, _lvar_96 : Bool, _lvar_98 : Bool, #lpv : List, #lcls : List, #ls : List, #prop : Str, #other : List, #d : List) * (#ls == (_$l_#l :: (#lp :: #other))) * (#d == {{ "d", _lvar_95, _lvar_96, _lvar_97, _lvar_98 }}) * (! (_lvar_95 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str, #other : List, #d : List) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_99, #writ, _lvar_101, _lvar_102 }}, (_$l_#l :: (#lp :: #other)), #lcls, #lpv) * types(_lvar_102 : Bool, #lpv : List, #lcls : List, _lvar_101 : Bool, #ls : List, #prop : Str, #writ : Bool, #other : List, #d : List) * (#ls == (_$l_#l :: (#lp :: #other))) * (#d == {{ "d", _lvar_99, #writ, _lvar_101, _lvar_102 }}) * (! (_lvar_99 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str, #writ : Bool, #other : List, #d : List) * (xret == #writ) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal

proc canPut (l, prop) {
			[* unfold Pi(#l, #prop, #d, #ls, #lcls, #lpv) *]
			xret := "getOwnProperty"(l, prop) with elab;
			[* fold Pi(#l, #prop, #d, #ls, #lcls, #lpv) *]
	op:		goto [(xret = undefined)] nop odesc;
	odesc:		d := l-nth(xret, 0.);
			goto [(d = "d")] odd nop;
	odd:		xret := l-nth(xret, 2.);
			goto rlab;
	nop:		m := metadata (l);
			e := [m, "@extensible"];
			xret := "getProperty"(l, prop) with elab;
			goto [(xret = undefined)] ext desc;
	desc:		d := l-nth(xret, 0.);
			v := l-nth(xret, 2.);
			goto [(d = "d")] dd ad;
	dd:		goto [e] wr ext;
	wr:		xret := v;
			goto rlab;
	ad:		xret := (not (v = undefined));
			goto rlab;
	ext:		xret := e;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec setupInitialHeap()
[[ types() * Extensible ($lbool_proto, true) * MetaData ($lbool_proto, _$l__lvar_810) * empty_fields($lbool_proto : -{  }-) * Extensible (_$l__lvar_811, true) * MetaData (_$l__lvar_811, null) * empty_fields(_$l__lvar_811 : -{  }-) * Extensible (_$l__lvar_813, true) * MetaData (_$l__lvar_813, null) * empty_fields(_$l__lvar_813 : -{  }-) * Extensible (_$l__lvar_810, true) * MetaData (_$l__lvar_810, null) * empty_fields(_$l__lvar_810 : -{  }-) * Extensible (_$l__lvar_808, true) * MetaData (_$l__lvar_808, null) * empty_fields(_$l__lvar_808 : -{  }-) * Extensible ($lnum_proto, true) * MetaData ($lnum_proto, _$l__lvar_809) * empty_fields($lnum_proto : -{  }-) * Extensible ($lerr_proto, true) * MetaData ($lerr_proto, _$l__lvar_807) * empty_fields($lerr_proto : -{  }-) * Extensible ($lobj_proto, true) * MetaData ($lobj_proto, _$l__lvar_812) * empty_fields($lobj_proto : -{  }-) * Extensible ($lop_hasOwnProperty, true) * MetaData ($lop_hasOwnProperty, _$l__lvar_806) * empty_fields($lop_hasOwnProperty : -{  }-) * Extensible (_$l__lvar_809, true) * MetaData (_$l__lvar_809, null) * empty_fields(_$l__lvar_809 : -{  }-) * Extensible ($lg, true) * MetaData ($lg, _$l__lvar_813) * empty_fields($lg : -{  }-) * Extensible ($lerr, true) * MetaData ($lerr, _$l__lvar_808) * empty_fields($lerr : -{  }-) * Extensible (_$l__lvar_806, true) * MetaData (_$l__lvar_806, null) * empty_fields(_$l__lvar_806 : -{  }-) * Extensible (_$l__lvar_812, true) * MetaData (_$l__lvar_812, null) * empty_fields(_$l__lvar_812 : -{  }-) * Extensible ($lfun_proto, true) * MetaData ($lfun_proto, _$l__lvar_811) * empty_fields($lfun_proto : -{  }-) * Extensible (_$l__lvar_807, true) * MetaData (_$l__lvar_807, null) * empty_fields(_$l__lvar_807 : -{  }-) ]]
[[ types() * (xret == empty) * Extensible ($lbool_proto, true) * MetaData ($lbool_proto, _$l__lvar_818) * empty_fields($lbool_proto : -{ "constructor" }-) * (($lbool_proto, "constructor") ->@d {{ "d", $lbool, true, false, true }}) * Extensible (_$l__lvar_822, true) * MetaData (_$l__lvar_822, null) * empty_fields(_$l__lvar_822 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_822, "@proto") ->@d null) * ((_$l__lvar_822, "@extensible") ->@d true) * ((_$l__lvar_822, "@class") ->@d "Object") * Extensible (_$l__lvar_823, true) * MetaData (_$l__lvar_823, null) * empty_fields(_$l__lvar_823 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_823, "@proto") ->@d $lobj_proto) * ((_$l__lvar_823, "@extensible") ->@d true) * ((_$l__lvar_823, "@class") ->@d "Object") * Extensible ($lnum_proto, true) * MetaData ($lnum_proto, _$l__lvar_817) * empty_fields($lnum_proto : -{ "constructor" }-) * (($lnum_proto, "constructor") ->@d {{ "d", $lnum, true, false, true }}) * Extensible (_$l__lvar_818, true) * MetaData (_$l__lvar_818, null) * empty_fields(_$l__lvar_818 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_818, "@proto") ->@d $lobj_proto) * ((_$l__lvar_818, "@primitiveValue") ->@d false) * ((_$l__lvar_818, "@extensible") ->@d true) * ((_$l__lvar_818, "@class") ->@d "Boolean") * Extensible ($lerr_proto, true) * MetaData ($lerr_proto, _$l__lvar_814) * empty_fields($lerr_proto : -{ "message" }-) * (($lerr_proto, "message") ->@d {{ "d", "", true, false, true }}) * Extensible ($lobj_proto, true) * MetaData ($lobj_proto, _$l__lvar_822) * empty_fields($lobj_proto : -{ "hasOwnProperty" }-) * (($lobj_proto, "hasOwnProperty") ->@d {{ "d", $lop_hasOwnProperty, true, false, true }}) * Extensible ($lop_hasOwnProperty, true) * MetaData ($lop_hasOwnProperty, _$l__lvar_821) * empty_fields($lop_hasOwnProperty : -{ "length" }-) * (($lop_hasOwnProperty, "length") ->@d {{ "d", 1., false, false, false }}) * Extensible (_$l__lvar_814, true) * MetaData (_$l__lvar_814, null) * empty_fields(_$l__lvar_814 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_814, "@proto") ->@d $lobj_proto) * ((_$l__lvar_814, "@extensible") ->@d true) * ((_$l__lvar_814, "@class") ->@d "Error") * Extensible ($lg, true) * MetaData ($lg, _$l__lvar_823) * empty_fields($lg : -u- (-{  }-, -{ "Error" }-)) * (($lg, "Error") ->@d {{ "d", $lerr, true, false, true }}) * Extensible ($lerr, true) * MetaData ($lerr, _$l__lvar_816) * empty_fields($lerr : -{ "length", "prototype" }-) * (($lerr, "prototype") ->@d {{ "d", $lerr_proto, false, false, false }}) * (($lerr, "length") ->@d {{ "d", 1., false, false, false }}) * Extensible (_$l__lvar_817, true) * MetaData (_$l__lvar_817, null) * empty_fields(_$l__lvar_817 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_817, "@proto") ->@d $lobj_proto) * ((_$l__lvar_817, "@primitiveValue") ->@d 0.) * ((_$l__lvar_817, "@extensible") ->@d true) * ((_$l__lvar_817, "@class") ->@d "Number") * Extensible (_$l__lvar_816, true) * MetaData (_$l__lvar_816, null) * empty_fields(_$l__lvar_816 : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope" }-) * ((_$l__lvar_816, "@scope") ->@d empty) * ((_$l__lvar_816, "@proto") ->@d $lfun_proto) * ((_$l__lvar_816, "@extensible") ->@d true) * ((_$l__lvar_816, "@construct") ->@d "Error_construct") * ((_$l__lvar_816, "@class") ->@d "Function") * ((_$l__lvar_816, "@call") ->@d "Error_call") * Extensible (_$l__lvar_820, true) * MetaData (_$l__lvar_820, null) * empty_fields(_$l__lvar_820 : -{ "@call", "@class", "@extensible", "@proto", "@scope" }-) * ((_$l__lvar_820, "@scope") ->@d empty) * ((_$l__lvar_820, "@proto") ->@d $lobj_proto) * ((_$l__lvar_820, "@extensible") ->@d true) * ((_$l__lvar_820, "@class") ->@d "Function") * ((_$l__lvar_820, "@call") ->@d "FP_default") * Extensible ($lfun_proto, true) * MetaData ($lfun_proto, _$l__lvar_820) * empty_fields($lfun_proto : -{ "length" }-) * (($lfun_proto, "length") ->@d {{ "d", 0., false, false, false }}) * Extensible (_$l__lvar_821, true) * MetaData (_$l__lvar_821, null) * empty_fields(_$l__lvar_821 : -{ "@call", "@class", "@extensible", "@proto", "@scope" }-) * ((_$l__lvar_821, "@scope") ->@d empty) * ((_$l__lvar_821, "@proto") ->@d $lfun_proto) * ((_$l__lvar_821, "@extensible") ->@d true) * ((_$l__lvar_821, "@class") ->@d "Function") * ((_$l__lvar_821, "@call") ->@d "OP_hasOwnProperty") ]]
normal

proc setupInitialHeap () {
			xret := "create_default_object"($lg, $lobj_proto, "Object", true);
			xret := "create_default_object"($lobj_proto, null, "Object", true);
			[$lobj_proto, "hasOwnProperty"] := {{ "d", $lop_hasOwnProperty, true, false, true }};
			xret := "create_object_with_call_construct"($lop_hasOwnProperty, "OP_hasOwnProperty", empty, 1.);
			xret := "create_object_with_call_construct"($lfun_proto, "FP_default", empty, 0.);
			m := metadata ($lfun_proto);
			[m, "@proto"] := $lobj_proto;
			xret := "create_default_object"($lbool_proto, $lobj_proto, "Boolean", true);
			m := metadata ($lbool_proto);
			[m, "@primitiveValue"] := false;
			[$lbool_proto, "constructor"] := {{ "d", $lbool, true, false, true }};
			xret := "create_default_object"($lnum_proto, $lobj_proto, "Number", true);
			m := metadata ($lnum_proto);
			[m, "@primitiveValue"] := 0.;
			[$lnum_proto, "constructor"] := {{ "d", $lnum, true, false, true }};
			xret := "create_object_with_call_construct"($lerr, "Error_call", "Error_construct", 1.);
			[$lg, "Error"] := {{ "d", $lerr, true, false, true }};
			[$lerr, "prototype"] := {{ "d", $lerr_proto, false, false, false }};
			xret := "create_default_object"($lerr_proto, $lobj_proto, "Error", true);
			[$lerr_proto, "message"] := {{ "d", "", true, false, true }};
	rlab:		xret := empty
} with {
	ret: xret, rlab;
};


spec i__typeOf(v)
[[ types(#v : Undefined) * (#v == undefined) * (v == undefined) ]]
[[ types(#v : Undefined) * (#v == undefined) * (xret == "undefined") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Null) * (#v == null) * (v == null) ]]
[[ types(#v : Null) * (#v == null) * (xret == "object") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Bool) * (v == #v) ]]
[[ types(#v : Bool) * (xret == "boolean") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == "number") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str) * (xret == "string") * (v == _lvar_v) ]]
normal

proc i__typeOf (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := "undefined";
			goto rlab;
	in:		goto [(v = null)] nll ib;
	nll:		xret := "object";
			goto rlab;
	ib:		goto [((typeOf v) = Bool)] bool inum;
	bool:		xret := "boolean";
			goto rlab;
	inum:		goto [((typeOf v) = Num)] num is;
	num:		xret := "number";
			goto rlab;
	is:		goto [((typeOf v) = Str)] str io;
	str:		xret := "string";
			goto rlab;
	io:		goto [((typeOf v) = Obj)] obj oops;
	obj:		m := metadata (v);
			xret := hasField(m,"@call");
			goto [xret] isfun isobj;
	isobj:		xret := "object";
			goto rlab;
	isfun:		xret := "function";
			goto rlab;
	oops:		xret := "typeOf: This should not happen.";
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec s__getOwnProperty(l, prop)
[[ types(#dx : List, _lvar_660 : Bool, _lvar_662 : Bool, #prop : Str, _lvar_661 : Bool) * (#dx == {{ "d", _lvar_659, _lvar_660, _lvar_661, _lvar_662 }}) * (! (_lvar_659 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_659, _lvar_660, _lvar_661, _lvar_662 }}) ]]
[[ types(#dx : List, _lvar_668 : Bool, #prop : Str, _lvar_670 : Bool, _lvar_669 : Bool) * (#dx == {{ "d", _lvar_667, _lvar_668, _lvar_669, _lvar_670 }}) * (! (_lvar_667 == empty)) * (xret == {{ "d", _lvar_667, _lvar_668, _lvar_669, _lvar_670 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_667, _lvar_668, _lvar_669, _lvar_670 }}) ]]
normal;

 [[ types(#dx : List, _lvar_666 : Bool, #prop : Str, _lvar_665 : Bool) * (#dx == {{ "a", _lvar_664, _lvar_663, _lvar_665, _lvar_666 }}) * (! (_lvar_664 == empty)) * (! (_lvar_663 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_664, _lvar_663, _lvar_665, _lvar_666 }}) ]]
[[ types(#dx : List, _lvar_673 : Bool, #prop : Str, _lvar_674 : Bool) * (#dx == {{ "a", _lvar_672, _lvar_671, _lvar_673, _lvar_674 }}) * (! (_lvar_672 == empty)) * (! (_lvar_671 == empty)) * (xret == {{ "a", _lvar_672, _lvar_671, _lvar_673, _lvar_674 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_672, _lvar_671, _lvar_673, _lvar_674 }}) ]]
normal

proc s__getOwnProperty (l, prop) {
			xret := "o__getOwnProperty"(l, prop);
			goto [(xret = undefined)] str rlab;
	str:		idx := "i__toInteger"(prop) with elab;
			goto [(idx < 0.)] rlab next;
	next:		sidx := "i__toString"(idx);
			goto [(sidx = prop)] index rlab;
	index:		m := metadata (l);
			str := [m, "@primitiveValue"];
			len := (s-len str);
			goto [(len <= idx)] rlab return;
	return:		rstr := s-nth(str, idx);
			xret := {{ "d", rstr, false, true, false }};
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec create_function_object(xsc, call, construct, params)
[[ types(#xsc : List, #construct : Str, #params : List, #call : Str) * (#call == #construct) * (xsc == #xsc) * (construct == #construct) * (params == #params) * (call == #construct) ]]
[[ types(#xsc : List, #construct : Str, #params : List, #call : Str) * (xret == _$l_xret) * (xsc == _lvar_xsc) * (construct == _lvar_construct) * (params == _lvar_params) * (call == _lvar_call) * Extensible (_$l_#prototype, true) * MetaData (_$l_#prototype, _$l__lvar_646) * empty_fields(_$l_#prototype : -{ "constructor" }-) * ((_$l_#prototype, "constructor") ->@d {{ "d", _$l_xret, true, false, true }}) * Extensible (_$l__lvar_647, true) * MetaData (_$l__lvar_647, null) * empty_fields(_$l__lvar_647 : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope" }-) * ((_$l__lvar_647, "@scope") ->@d #xsc) * ((_$l__lvar_647, "@proto") ->@d $lfun_proto) * ((_$l__lvar_647, "@extensible") ->@d true) * ((_$l__lvar_647, "@construct") ->@d #call) * ((_$l__lvar_647, "@class") ->@d "Function") * ((_$l__lvar_647, "@call") ->@d #call) * Extensible (_$l__lvar_646, true) * MetaData (_$l__lvar_646, null) * empty_fields(_$l__lvar_646 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_646, "@proto") ->@d $lobj_proto) * ((_$l__lvar_646, "@extensible") ->@d true) * ((_$l__lvar_646, "@class") ->@d "Object") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_647) * empty_fields(_$l_xret : -{ "arguments", "caller", "length", "prototype" }-) * ((_$l_xret, "prototype") ->@d {{ "d", _$l_#prototype, true, false, false }}) * ((_$l_xret, "length") ->@d {{ "d", (l-len #params), false, false, false }}) * ((_$l_xret, "caller") ->@d {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }}) * ((_$l_xret, "arguments") ->@d {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }}) ]]
normal

proc create_function_object (xsc, call, construct, params) {
			len := (l-len params);
			m := new(null);
			l := new(m);
			l := "create_object_with_call_construct"(l, call, construct, len);
			[m, "@scope"] := xsc;
			prototype := "Object_construct"();
			[prototype, "constructor"] := {{ "d", l, true, false, true }};
			[l, "prototype"] := {{ "d", prototype, true, false, false }};
			[l, "caller"] := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};
			[l, "arguments"] := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};
			xret := l;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__abstractComparison(v1, v2, leftFirst)
[[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (#v1 <# #v2) * (leftFirst == #leftFirst) * (v2 == #v2) * (v1 == #v1) ]]
[[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (xret == true) * (leftFirst == _lvar_leftFirst) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (#v1 == #v2) * (leftFirst == #leftFirst) * (v2 == #v2) * (v1 == #v2) ]]
[[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (xret == false) * (leftFirst == _lvar_leftFirst) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (#v2 <# #v1) * (leftFirst == #leftFirst) * (v2 == #v2) * (v1 == #v1) ]]
[[ types(#leftFirst : Bool, #v2 : Num, #v1 : Num) * (xret == false) * (leftFirst == _lvar_leftFirst) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal

proc i__abstractComparison (v1, v2, leftFirst) {
			goto [((leftFirst = empty) or (leftFirst = true))] eleft eright;
	eleft:		xret := "i__toPrimitive"(v1, "Number") with elab;
			px := xret;
			xret := "i__toPrimitive"(v2, "Number") with elab;
			py := xret;
			goto is_str;
	eright:		xret := "i__toPrimitive"(v2, "Number") with elab;
			py := xret;
			xret := "i__toPrimitive"(v1, "Number") with elab;
			px := xret;
	is_str:		goto [(((typeOf px) = Str) and ((typeOf py) = Str))] str num;
	str:		xret := (px <s py);
			goto rlab;
	num:		xret := "i__toNumber"(px) with elab;
			nx := xret;
			xret := "i__toNumber"(py) with elab;
			ny := xret;
			goto [((not (nx = nx)) or (not (ny = ny)))] ru eq;
	eq:		goto [(nx = ny)] rf sl;
	sl:		xret := (nx < ny);
			goto rlab;
	ru:		xret := undefined;
			goto rlab;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec Boolean_construct(xsc, vthis, v)
[[ types(#v : Bool) * (v == #v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) ]]
[[ types(#v : Bool) * (xret == _$l_xret) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * Extensible (_$l__lvar_358, true) * MetaData (_$l__lvar_358, null) * empty_fields(_$l__lvar_358 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_358, "@proto") ->@d $lbool_proto) * ((_$l__lvar_358, "@primitiveValue") ->@d #v) * ((_$l__lvar_358, "@extensible") ->@d true) * ((_$l__lvar_358, "@class") ->@d "Boolean") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_358) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc Boolean_construct (xsc, vthis, v) {
			pv := "i__toBoolean"(v);
			xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lbool_proto, "Boolean", true);
			m := metadata (xret);
			[m, "@primitiveValue"] := pv;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__toNumber(v)
[[ types() * (v == null) ]]
[[ types() * (xret == 0.) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == true) ]]
[[ types() * (xret == 1.) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == false) ]]
[[ types() * (xret == 0.) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str) * (xret == (string_to_num #v)) * (v == _lvar_v) ]]
normal

proc i__toNumber (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := nan;
			goto rlab;
	in:		goto [(v = null)] nul ib;
	nul:		xret := 0.;
			goto rlab;
	ib:		goto [((typeOf v) = Bool)] bool inum;
	bool:		goto [(v = true)] is_t is_f;
	is_t:		xret := 1.;
			goto rlab;
	is_f:		xret := 0.;
			goto rlab;
	inum:		goto [((typeOf v) = Num)] num is;
	num:		xret := v;
			goto rlab;
	is:		goto [((typeOf v) = Str)] str io;
	str:		xret := (string_to_num v);
			goto rlab;
	io:		goto [((typeOf v) = Obj)] obj oops;
	obj:		xret := "i__toPrimitive"(v, "Number") with elab;
			xret := "i__toNumber"(xret);
			goto rlab;
	oops:		xret := "TypeError"("ToNumber: This should not happen.");
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec ReferenceError(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_349, true) * MetaData (_$l__lvar_349, null) * empty_fields(_$l__lvar_349 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_349, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_349, "@extensible") ->@d true) * ((_$l__lvar_349, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_349) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc ReferenceError (v) {
			xret := "ReferenceError_call"(undefined, undefined, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec create_default_object(l, pr, cl, ext)
[[ types(#l : Obj) * (#l == _$l_l) * (pr == #pr) * (ext == undefined) * (l == _$l_l) * (cl == undefined) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@proto") ->@d #lvar_0) * ((_$l_#md, "@extensible") ->@d #lvar_2) * ((_$l_#md, "@class") ->@d #lvar_1) * Extensible (_$l_l, true) * MetaData (_$l_l, _$l_#md) ]]
[[ types(#l : Obj) * (xret == #l) * (pr == _lvar_pr) * (ext == _lvar_ext) * (l == _$l_l) * (cl == _lvar_cl) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@proto") ->@d #pr) * ((_$l_#md, "@extensible") ->@d true) * ((_$l_#md, "@class") ->@d "Object") * Extensible (_$l_l, true) * MetaData (_$l_l, _$l_#md) ]]
normal;

 [[ types(#l : Obj, #cl : Str, #ext : Bool) * (#l == _$l_l) * (pr == #pr) * (ext == #ext) * (l == _$l_l) * (cl == #cl) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@proto") ->@d #lvar_3) * ((_$l_#md, "@extensible") ->@d #lvar_5) * ((_$l_#md, "@class") ->@d #lvar_4) * Extensible (_$l_l, true) * MetaData (_$l_l, _$l_#md) ]]
[[ types(#l : Obj, #cl : Str, #ext : Bool) * (xret == #l) * (pr == _lvar_pr) * (ext == _lvar_ext) * (l == _$l_l) * (cl == _lvar_cl) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@proto") ->@d #pr) * ((_$l_#md, "@extensible") ->@d #ext) * ((_$l_#md, "@class") ->@d #cl) * Extensible (_$l_l, true) * MetaData (_$l_l, _$l_#md) ]]
normal

proc create_default_object (l, pr, cl, ext) {
			goto [(cl = undefined)] scl text;
	scl:		cl := "Object";
	text:		goto [(ext = undefined)] sext setall;
	sext:		ext := true;
	setall:		m := metadata (l);
			[m, "@proto"] := pr;
			[m, "@class"] := cl;
			[m, "@extensible"] := ext;
	rlab:		xret := l
} with {
	ret: xret, rlab;
};


spec i__toPrimitive(v, hint)
[[ types() * (v == undefined) * (hint == _lvar_hint) ]]
[[ types() * (xret == undefined) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types() * (v == null) * (hint == _lvar_hint) ]]
[[ types() * (xret == null) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types(#v : Num) * (v == #v) * (hint == _lvar_hint) ]]
[[ types(#v : Num) * (xret == #v) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types(#v : Bool) * (v == #v) * (hint == _lvar_hint) ]]
[[ types(#v : Bool) * (xret == #v) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal;

 [[ types(#v : Str) * (v == #v) * (hint == _lvar_hint) ]]
[[ types(#v : Str) * (xret == #v) * (v == _lvar_v) * (hint == _lvar_hint) ]]
normal

proc i__toPrimitive (v, hint) {
			xret := v;
			tv := (typeOf v);
	iu:		goto [(((((v = undefined) or (v = null)) or ((typeOf v) = Bool)) or ((typeOf v) = Num)) or ((typeOf v) = Str))] rlab is_obj;
	is_obj:		goto [((typeOf v) = Obj)] obj oops;
	obj:		xret := "defaultValue"(v, hint) with elab;
			goto rlab;
	oops:		xret := "ToPrimitive: This should not happen.";
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec o__getOwnProperty(l, prop)
[[ types(#prop : Str) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#prop : Str) * (xret == undefined) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(#dx : List, _lvar_131 : Bool, _lvar_129 : Bool, #prop : Str, _lvar_130 : Bool) * (#dx == {{ "d", _lvar_128, _lvar_129, _lvar_130, _lvar_131 }}) * (! (_lvar_128 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_128, _lvar_129, _lvar_130, _lvar_131 }}) ]]
[[ types(#dx : List, _lvar_138 : Bool, #prop : Str, _lvar_137 : Bool, _lvar_139 : Bool) * (#dx == {{ "d", _lvar_136, _lvar_137, _lvar_138, _lvar_139 }}) * (! (_lvar_136 == empty)) * (xret == {{ "d", _lvar_136, _lvar_137, _lvar_138, _lvar_139 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_136, _lvar_137, _lvar_138, _lvar_139 }}) ]]
normal;

 [[ types(#dx : List, _lvar_134 : Bool, #prop : Str, _lvar_135 : Bool) * (#dx == {{ "a", _lvar_133, _lvar_132, _lvar_134, _lvar_135 }}) * (! (_lvar_133 == empty)) * (! (_lvar_132 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_133, _lvar_132, _lvar_134, _lvar_135 }}) ]]
[[ types(#dx : List, _lvar_143 : Bool, #prop : Str, _lvar_142 : Bool) * (#dx == {{ "a", _lvar_141, _lvar_140, _lvar_142, _lvar_143 }}) * (! (_lvar_141 == empty)) * (! (_lvar_140 == empty)) * (xret == {{ "a", _lvar_141, _lvar_140, _lvar_142, _lvar_143 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_141, _lvar_140, _lvar_142, _lvar_143 }}) ]]
normal

proc o__getOwnProperty (l, prop) {
			x := hasField(l,prop);
			goto [x] hp nhp;
	nhp:		xret := undefined;
			goto rlab;
	hp:		xret := [l, prop];
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec deleteProperty(l, prop, throw)
[[ types(#cls : Str, #prop : Str) * (! (#cls == "String")) * (throw == _lvar_throw) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#cls : Str, #prop : Str) * (throw == _lvar_throw) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(#cls : Str, _lvar_741 : Bool, #prop : Str, _lvar_742 : Bool, #d : List) * (#d == {{ "d", _lvar_740, _lvar_741, _lvar_742, true }}) * (! (_lvar_740 == empty)) * (! (#cls == "String")) * (throw == _lvar_throw) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_740, _lvar_741, _lvar_742, true }}) ]]
[[ types(#cls : Str, #prop : Str, #d : List) * (throw == _lvar_throw) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(#cls : Str, _lvar_746 : Bool, #prop : Str, #d : List) * (#d == {{ "a", _lvar_745, _lvar_744, _lvar_746, true }}) * (! (_lvar_745 == empty)) * (! (_lvar_744 == empty)) * (! (#cls == "String")) * (throw == _lvar_throw) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_745, _lvar_744, _lvar_746, true }}) ]]
[[ types(#cls : Str, #prop : Str, #d : List) * (throw == _lvar_throw) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(_lvar_766 : Bool, #cls : Str, #prop : Str, _lvar_765 : Bool, #d : List) * (#d == {{ "d", _lvar_764, _lvar_765, _lvar_766, false }}) * (! (_lvar_764 == empty)) * (! (#cls == "String")) * (throw == false) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_764, _lvar_765, _lvar_766, false }}) ]]
[[ types(_lvar_773 : Bool, #cls : Str, _lvar_775 : Bool, #prop : Str, _lvar_774 : Bool, #d : List) * (#d == {{ "d", _lvar_772, _lvar_773, _lvar_774, _lvar_775 }}) * (! (_lvar_772 == empty)) * (throw == _lvar_throw) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_772, _lvar_773, _lvar_774, _lvar_775 }}) ]]
normal;

 [[ types(_lvar_770 : Bool, #cls : Str, #prop : Str, #d : List) * (#d == {{ "a", _lvar_769, _lvar_768, _lvar_770, false }}) * (! (_lvar_769 == empty)) * (! (_lvar_768 == empty)) * (! (#cls == "String")) * (throw == false) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_769, _lvar_768, _lvar_770, false }}) ]]
[[ types(#cls : Str, _lvar_779 : Bool, _lvar_778 : Bool, #prop : Str, #d : List) * (#d == {{ "a", _lvar_777, _lvar_776, _lvar_778, _lvar_779 }}) * (! (_lvar_777 == empty)) * (! (_lvar_776 == empty)) * (throw == _lvar_throw) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_777, _lvar_776, _lvar_778, _lvar_779 }}) ]]
normal;

 [[ types(#cls : Str, _lvar_789 : Bool, #prop : Str, #d : List, _lvar_790 : Bool) * (#d == {{ "d", _lvar_788, _lvar_789, _lvar_790, false }}) * (! (_lvar_788 == empty)) * (! (#cls == "String")) * (throw == true) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_788, _lvar_789, _lvar_790, false }}) ]]
[[ types(#cls : Str, _lvar_800 : Bool, #prop : Str, _lvar_798 : Bool, #d : List, _lvar_799 : Bool) * (#d == {{ "d", _lvar_797, _lvar_798, _lvar_799, _lvar_800 }}) * (! (_lvar_797 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_797, _lvar_798, _lvar_799, _lvar_800 }}) * Extensible (_$l__lvar_796, true) * MetaData (_$l__lvar_796, null) * empty_fields(_$l__lvar_796 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_796, "@proto") ->@d $lterr_proto) * ((_$l__lvar_796, "@extensible") ->@d true) * ((_$l__lvar_796, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_796) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#cls : Str, #prop : Str, _lvar_794 : Bool, #d : List) * (#d == {{ "a", _lvar_793, _lvar_792, _lvar_794, false }}) * (! (_lvar_793 == empty)) * (! (_lvar_792 == empty)) * (! (#cls == "String")) * (throw == true) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_793, _lvar_792, _lvar_794, false }}) ]]
[[ types(#cls : Str, _lvar_804 : Bool, _lvar_803 : Bool, #prop : Str, #d : List) * (#d == {{ "a", _lvar_802, _lvar_801, _lvar_803, _lvar_804 }}) * (! (_lvar_802 == empty)) * (! (_lvar_801 == empty)) * (throw == _lvar_throw) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_802, _lvar_801, _lvar_803, _lvar_804 }}) * Extensible (_$l__lvar_796, true) * MetaData (_$l__lvar_796, null) * empty_fields(_$l__lvar_796 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_796, "@proto") ->@d $lterr_proto) * ((_$l__lvar_796, "@extensible") ->@d true) * ((_$l__lvar_796, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_796) * empty_fields(_$l_xret : -{  }-) ]]
error

proc deleteProperty (l, prop, throw) {
			xret := "getOwnProperty"(l, prop) with elab;
			goto [(xret = undefined)] dt cont;
	cont:		c := l-nth(xret, 4.);
			goto [c] del reject;
	del:		delete (l,prop);
	dt:		xret := true;
			goto rlab;
	df:		xret := false;
	rlab:		skip;
	reject:		goto [throw] tt df;
	tt:		xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec getOwnProperty(l, prop)
[[ types(#cls : Str, #prop : Str) * (! (#cls == "String")) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#cls : Str, #prop : Str) * (xret == undefined) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal;

 [[ types(#dx : List, #prop : Str, _lvar_702 : Bool, _lvar_701 : Bool, _lvar_700 : Bool) * (#dx == {{ "d", _lvar_699, _lvar_700, _lvar_701, _lvar_702 }}) * (! (_lvar_699 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_699, _lvar_700, _lvar_701, _lvar_702 }}) ]]
[[ types(#dx : List, _lvar_708 : Bool, _lvar_709 : Bool, #prop : Str, _lvar_710 : Bool) * (#dx == {{ "d", _lvar_707, _lvar_708, _lvar_709, _lvar_710 }}) * (! (_lvar_707 == empty)) * (xret == {{ "d", _lvar_707, _lvar_708, _lvar_709, _lvar_710 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", _lvar_707, _lvar_708, _lvar_709, _lvar_710 }}) ]]
normal;

 [[ types(#dx : List, _lvar_705 : Bool, #prop : Str, _lvar_706 : Bool) * (#dx == {{ "a", _lvar_704, _lvar_703, _lvar_705, _lvar_706 }}) * (! (_lvar_704 == empty)) * (! (_lvar_703 == empty)) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_704, _lvar_703, _lvar_705, _lvar_706 }}) ]]
[[ types(#dx : List, _lvar_713 : Bool, #prop : Str, _lvar_714 : Bool) * (#dx == {{ "a", _lvar_712, _lvar_711, _lvar_713, _lvar_714 }}) * (! (_lvar_712 == empty)) * (! (_lvar_711 == empty)) * (xret == {{ "a", _lvar_712, _lvar_711, _lvar_713, _lvar_714 }}) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@class") ->@d #cls) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "a", _lvar_712, _lvar_711, _lvar_713, _lvar_714 }}) ]]
normal

proc getOwnProperty (l, prop) {
			m := metadata (l);
			class := [m, "@class"];
			goto [(class = "String")] sgop ogop;
	sgop:		xret := "s__getOwnProperty"(l, prop) with elab;
			goto rlab;
	ogop:		xret := "o__getOwnProperty"(l, prop) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__toString(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == "undefined") * (v == _lvar_v) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == "null") * (v == _lvar_v) ]]
normal;

 [[ types() * (v == true) ]]
[[ types() * (xret == "true") * (v == _lvar_v) ]]
normal;

 [[ types() * (v == false) ]]
[[ types() * (xret == "false") * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == (num_to_string #v)) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str) * (xret == #v) * (v == _lvar_v) ]]
normal

proc i__toString (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := "undefined";
			goto rlab;
	in:		goto [(v = null)] nul ib;
	nul:		xret := "null";
			goto rlab;
	ib:		goto [((typeOf v) = Bool)] bool inum;
	bool:		goto [(v = true)] is_t is_f;
	is_t:		xret := "true";
			goto rlab;
	is_f:		xret := "false";
			goto rlab;
	inum:		goto [((typeOf v) = Num)] num is;
	num:		xret := (num_to_string v);
			goto rlab;
	is:		goto [((typeOf v) = Str)] str io;
	str:		xret := v;
			goto rlab;
	io:		goto [((typeOf v) = Obj)] obj oops;
	obj:		xret := "i__toPrimitive"(v, "String") with elab;
			xret := "i__toString"(xret) with elab;
			goto rlab;
	oops:		xret := "TypeError"("ToString: This should not happen.");
			goto elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__checkAssignmentErrors(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_350 : Num) * (v == _lvar_350) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_351 : Bool) * (v == _lvar_351) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_352 : Str) * (v == _lvar_352) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_353 : Obj) * (v == _lvar_353) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(#l : Obj, #prop : Str, #v : List) * (#v == {{ "v", #l, #prop }}) * (! (#prop == "eval")) * (! (#prop == "arguments")) * (v == {{ "v", #l, #prop }}) ]]
[[ types(#l : Obj, #prop : Str, #v : List) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(#l : Obj, #v : List) * (#v == {{ "v", #l, "eval" }}) * (v == {{ "v", #l, "eval" }}) ]]
[[ types(#l : Obj, #v : List) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_354, true) * MetaData (_$l__lvar_354, null) * empty_fields(_$l__lvar_354 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_354, "@proto") ->@d $lserr_proto) * ((_$l__lvar_354, "@extensible") ->@d true) * ((_$l__lvar_354, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_354) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#l : Obj, #v : List) * (#v == {{ "v", #l, "arguments" }}) * (v == {{ "v", #l, "arguments" }}) ]]
[[ types(#l : Obj, #v : List) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_355, true) * MetaData (_$l__lvar_355, null) * empty_fields(_$l__lvar_355 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_355, "@proto") ->@d $lserr_proto) * ((_$l__lvar_355, "@extensible") ->@d true) * ((_$l__lvar_355, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_355) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#field : Str, #v : List, #base : Obj) * (#v == {{ "o", #base, #field }}) * (v == {{ "o", #base, #field }}) ]]
[[ types(#field : Str, #v : List, #base : Obj) * (xret == true) * (v == _lvar_v) ]]
normal

proc i__checkAssignmentErrors (v) {
			tv := (typeOf v);
			goto [((tv = List) and ((l-nth(v, 0.) = "v") or (l-nth(v, 0.) = "o")))] prep rlab;
	prep:		fv := l-nth(v, 2.);
	csyn:		goto [((l-nth(v, 0.) = "v") and ((fv = "eval") or (fv = "arguments")))] se rlab;
	rlab:		xret := true;
	se:		xret := "SyntaxError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec put(l, prop, value, throw)
[[ Pi(_$l_#l, #prop, undefined, (_$l_#l :: (#lp :: #lllp)), (#cls :: (#ccls :: #llcls)), ("" :: (#pv :: #llpv))) * types(#cls : Str, #throw : Bool, #ccls : Str, #llpv : List, #prop : Str, #lllp : List, #lp : Obj, #pv : Str, #llcls : List) * (! (#value == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #value, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, undefined, (#lp :: #lllp), (#ccls :: #llcls), (#pv :: #llpv)) * types(#cls : Str, #throw : Bool, #ccls : Str, #llpv : List, #prop : Str, #lllp : List, #lp : Obj, #pv : Str, #llcls : List) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == empty) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", #dval, true, #denum, #dconf }}, {{ _$l_#l }}, {{ #cls }}, #lpv) * types(#cls : Str, #throw : Bool, #dconf : Bool, #lpv : List, #denum : Bool, #prop : Str, #ext : Bool) * (! (#value == empty)) * (! (#dval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #value, true, #denum, #dconf }}, {{ _$l_#l }}, {{ #cls }}, #lpv) * types(#cls : Str, #throw : Bool, #dconf : Bool, #lpv : List, #denum : Bool, #prop : Str, #ext : Bool) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == empty) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, (_$l_#l :: (#lp :: #lllp)), (#cls :: (#pcls :: #ocls)), ("" :: (#pv :: #llpv))) * types(#cls : Str, #throw : Bool, #dcconf : Bool, #llpv : List, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (! (#value == empty)) * (! (#dcval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #value, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, (#lp :: #lllp), (#pcls :: #ocls), (#pv :: #llpv)) * types(#cls : Str, #throw : Bool, #dcconf : Bool, #llpv : List, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == empty) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, undefined, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #throw : Bool, #prop : Str) * (! (#value == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (throw == #throw) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #value, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #throw : Bool, #prop : Str) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == empty) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@proto") ->@d null) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str) * (throw == true) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_331) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_331, true) * MetaData (_$l__lvar_331, null) * empty_fields(_$l__lvar_331 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_331, "@proto") ->@d $lterr_proto) * ((_$l__lvar_331, "@extensible") ->@d true) * ((_$l__lvar_331, "@class") ->@d "Error") ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_332, false, _lvar_334, _lvar_335 }}, {{ _$l_#l }}, #lcls, #lpv) * types(_lvar_334 : Bool, #lpv : List, #lcls : List, #prop : Str, #ext : Bool, _lvar_335 : Bool, #d : List) * (#d == {{ "d", _lvar_332, false, _lvar_334, _lvar_335 }}) * (! (_lvar_332 == empty)) * (throw == true) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, {{ _$l_#l }}, #lcls, #lpv) * types(#lpv : List, #lcls : List, #prop : Str, #ext : Bool, #d : List) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * Extensible (_$l__lvar_336, true) * MetaData (_$l__lvar_336, null) * empty_fields(_$l__lvar_336 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_336, "@proto") ->@d $lterr_proto) * ((_$l__lvar_336, "@extensible") ->@d true) * ((_$l__lvar_336, "@class") ->@d "Error") * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_336) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_339, _lvar_340, _lvar_341, _lvar_342 }}, (_$l_#l :: (#lp :: #other)), #lcls, #lpv) * types(_lvar_340 : Bool, #lpv : List, #lcls : List, #ls : List, #prop : Str, #lp : Obj, #other : List, _lvar_341 : Bool, #d : List, _lvar_342 : Bool) * (#ls == (_$l_#l :: (#lp :: #other))) * (#d == {{ "d", _lvar_339, _lvar_340, _lvar_341, _lvar_342 }}) * (! (_lvar_339 == empty)) * (throw == true) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str, #lp : Obj, #other : List, #d : List) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_343) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_343, true) * MetaData (_$l__lvar_343, null) * empty_fields(_$l__lvar_343 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_343, "@proto") ->@d $lterr_proto) * ((_$l__lvar_343, "@extensible") ->@d true) * ((_$l__lvar_343, "@class") ->@d "Error") ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_344, false, _lvar_346, _lvar_347 }}, (_$l_#l :: (#lp :: #other)), #lcls, #lpv) * types(_lvar_347 : Bool, #lpv : List, #lcls : List, _lvar_346 : Bool, #ls : List, #prop : Str, #lp : Obj, #other : List, #d : List) * (#ls == (_$l_#l :: (#lp :: #other))) * (#d == {{ "d", _lvar_344, false, _lvar_346, _lvar_347 }}) * (! (_lvar_344 == empty)) * (throw == true) * (value == #value) * (prop == #prop) * (l == _$l_#l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str, #lp : Obj, #other : List, #d : List) * (throw == _lvar_throw) * (value == _lvar_value) * (xret == _$l_xret) * (prop == _lvar_prop) * (l == _lvar_l) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l__lvar_348, true) * MetaData (_$l__lvar_348, null) * empty_fields(_$l__lvar_348 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_348, "@proto") ->@d $lterr_proto) * ((_$l__lvar_348, "@extensible") ->@d true) * ((_$l__lvar_348, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_348) * empty_fields(_$l_xret : -{  }-) ]]
error

proc put (l, prop, value, throw) {
			xret := "canPut"(l, prop) with elab;
			goto [xret] cp reject;
			[* unfold Pi(#l, #prop, #d, #ls, #lcls, #lpv) *]
	cp:		xret := "getOwnProperty"(l, prop) with elab;
			dd := "i__isDataDescriptor"(xret);
			goto [dd] dd gp;
	dd:		desc := {{ "g", empty, empty, value, empty, empty, empty }};
			xret := "defineOwnProperty"(l, prop, desc, throw) with elab;
			[* fold Pi(#l, #prop, {{ "d", #value, true, #denum, #dconf }}, {{ #l }}, #lvar_19, #lvar_20) *]
			goto remp;
			[* fold Pi(#l, #prop, #d, #ls, #lcls, #lpv) *]
	gp:		xret := "getProperty"(l, prop) with elab;
			ad := "i__isAccessorDescriptor"(xret);
			goto [ad] ad def;
	ad:		s := l-nth(xret, 2.);
			xsc := [s, "@scope"];
			fun := [s, "@call"];
			xret := fun(xsc, l, value) with elab;
			goto remp;
	def:		desc := {{ "d", value, true, true, true }};
			[* unfold Pi(#l, #prop, #d, #ls, #lcls, #lpv) *]
			xret := "defineOwnProperty"(l, prop, desc, throw) with elab;
			[* fold Pi(#l, #prop, {{ "d", #value, true, true, true }}, {{ #l }}, #lvar_21, #lvar_22) *]
			skip;
	remp:		xret := empty;
	rlab:		skip;
	reject:		xret := empty;
			goto [throw] tt rlab;
	tt:		xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__putValue(v, w)
[[ types() * (v == undefined) * (w == _lvar_w) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * Extensible (_$l__lvar_218, true) * MetaData (_$l__lvar_218, null) * empty_fields(_$l__lvar_218 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_218, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_218, "@extensible") ->@d true) * ((_$l__lvar_218, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_218) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types() * (v == null) * (w == _lvar_w) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * Extensible (_$l__lvar_219, true) * MetaData (_$l__lvar_219, null) * empty_fields(_$l__lvar_219 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_219, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_219, "@extensible") ->@d true) * ((_$l__lvar_219, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_219) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(_lvar_221 : Num) * (v == _lvar_221) * (w == _lvar_w) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * Extensible (_$l__lvar_220, true) * MetaData (_$l__lvar_220, null) * empty_fields(_$l__lvar_220 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_220, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_220, "@extensible") ->@d true) * ((_$l__lvar_220, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_220) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(_lvar_223 : Bool) * (v == _lvar_223) * (w == _lvar_w) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * Extensible (_$l__lvar_222, true) * MetaData (_$l__lvar_222, null) * empty_fields(_$l__lvar_222 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_222, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_222, "@extensible") ->@d true) * ((_$l__lvar_222, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_222) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(_lvar_225 : Str) * (v == _lvar_225) * (w == _lvar_w) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * Extensible (_$l__lvar_224, true) * MetaData (_$l__lvar_224, null) * empty_fields(_$l__lvar_224 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_224, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_224, "@extensible") ->@d true) * ((_$l__lvar_224, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_224) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(_lvar_227 : Obj) * (v == _lvar_227) * (w == _lvar_w) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_226) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_226, true) * MetaData (_$l__lvar_226, null) * empty_fields(_$l__lvar_226 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_226, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_226, "@extensible") ->@d true) * ((_$l__lvar_226, "@class") ->@d "Error") ]]
error;

 [[ types() * (! (#w == empty)) * (v == {{ "v", _$l_#obj, #field }}) * (w == #w) * ((_$l_#obj, #field) ->@d #lvar_23) ]]
[[ types() * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#obj, #field) ->@d #w) ]]
normal;

 [[ Pi(_$l_#l, #prop, undefined, (_$l_#l :: (#lp :: #lllp)), (#cls :: (#pcls :: #ocls)), ("" :: (#pv :: #llpv))) * types(#cls : Str, #llpv : List, #pcls : Str, #ocls : List, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (! (#w == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #w, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, undefined, (#lp :: #lllp), (#pcls :: #ocls), (#pv :: #llpv)) * types(#cls : Str, #llpv : List, #pcls : Str, #ocls : List, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi($lg, #prop, undefined, ($lg :: (#lp :: #lllp)), (#cls :: (#pcls :: #ocls)), ("" :: (#pv :: #llpv))) * types(#cls : Str, #llpv : List, #pcls : Str, #ocls : List, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (! (#w == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "v", $lg, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d true) * MetaData ($lg, _$l_#md) ]]
[[ Pi($lg, #prop, {{ "d", #w, true, true, true }}, {{ $lg }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, undefined, (#lp :: #lllp), (#pcls :: #ocls), (#pv :: #llpv)) * types(#cls : Str, #llpv : List, #pcls : Str, #ocls : List, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData ($lg, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", #dval, true, #denum, #dconf }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #dconf : Bool, #denum : Bool, #prop : Str, #ext : Bool) * (! (#w == empty)) * (! (#dval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #w, true, #denum, #dconf }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #dconf : Bool, #denum : Bool, #prop : Str, #ext : Bool) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi($lg, #prop, {{ "d", #dval, true, #denum, #dconf }}, {{ $lg }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #dconf : Bool, #denum : Bool, #prop : Str, #ext : Bool) * (! (#w == empty)) * (! (#dval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "v", $lg, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData ($lg, _$l_#md) ]]
[[ Pi($lg, #prop, {{ "d", #w, true, #denum, #dconf }}, {{ $lg }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #dconf : Bool, #denum : Bool, #prop : Str, #ext : Bool) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData ($lg, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, (_$l_#l :: (#lp :: #lllp)), (#cls :: (#pcls :: #ocls)), ("" :: (#pv :: #llpv))) * types(#cls : Str, #dcconf : Bool, #llpv : List, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (! (#w == empty)) * (! (#dcval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #w, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, (#lp :: #lllp), (#pcls :: #ocls), (#pv :: #llpv)) * types(#cls : Str, #dcconf : Bool, #llpv : List, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi($lg, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, ($lg :: (#lp :: #lllp)), (#cls :: (#pcls :: #ocls)), ("" :: (#pv :: #llpv))) * types(#cls : Str, #dcconf : Bool, #llpv : List, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (! (#w == empty)) * (! (#dcval == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "v", $lg, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d true) * MetaData ($lg, _$l_#md) ]]
[[ Pi($lg, #prop, {{ "d", #w, true, true, true }}, {{ $lg }}, {{ #cls }}, {{ "" }}) * Pi(#lp, #prop, {{ "d", #dcval, true, #dcenum, #dcconf }}, (#lp :: #lllp), (#pcls :: #ocls), (#pv :: #llpv)) * types(#cls : Str, #dcconf : Bool, #llpv : List, #pcls : Str, #ocls : List, #dcenum : Bool, #prop : Str, #lllp : List, #lp : Obj, #pv : Str) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@proto") ->@d #lp) * ((_$l_#md, "@extensible") ->@d true) * MetaData ($lg, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, undefined, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #prop : Str) * (! (#w == empty)) * (! (#cls == "String")) * (! (#cls == "Array")) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, {{ "d", #w, true, true, true }}, {{ _$l_#l }}, {{ #cls }}, {{ "" }}) * types(#cls : Str, #prop : Str) * (xret == empty) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@proto") ->@d null) * ((_$l_#md, "@extensible") ->@d true) * MetaData (_$l_#l, _$l_#md) ]]
normal;

 [[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * Extensible (_$l__lvar_281, true) * MetaData (_$l__lvar_281, null) * empty_fields(_$l__lvar_281 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_281, "@proto") ->@d $lterr_proto) * ((_$l__lvar_281, "@extensible") ->@d true) * ((_$l__lvar_281, "@class") ->@d "Error") * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_281) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_282, false, _lvar_284, _lvar_285 }}, {{ _$l_#l }}, #lcls, #lpv) * types(_lvar_285 : Bool, _lvar_284 : Bool, #lpv : List, #lcls : List, #prop : Str, #ext : Bool, #d : List) * (#d == {{ "d", _lvar_282, false, _lvar_284, _lvar_285 }}) * (! (_lvar_282 == empty)) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, {{ _$l_#l }}, #lcls, #lpv) * types(#lpv : List, #lcls : List, #prop : Str, #ext : Bool, #d : List) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * Extensible (_$l__lvar_286, true) * MetaData (_$l__lvar_286, null) * empty_fields(_$l__lvar_286 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_286, "@proto") ->@d $lterr_proto) * ((_$l__lvar_286, "@extensible") ->@d true) * ((_$l__lvar_286, "@class") ->@d "Error") * ((_$l_#md, "@extensible") ->@d #ext) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_286) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_289, _lvar_290, _lvar_291, _lvar_292 }}, (_$l_#l :: (#lp :: #other)), #cls, #lpv) * types(#cls : List, _lvar_292 : Bool, #lpv : List, _lvar_290 : Bool, #ls : List, _lvar_291 : Bool, #prop : Str, #lp : Obj, #other : List, #d : List) * (#ls == (_$l_#l :: (#lp :: #other))) * (#d == {{ "d", _lvar_289, _lvar_290, _lvar_291, _lvar_292 }}) * (! (_lvar_289 == empty)) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #cls, #lpv) * types(#cls : List, #lpv : List, #ls : List, #prop : Str, #lp : Obj, #other : List, #d : List) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) * Extensible (_$l__lvar_293, true) * MetaData (_$l__lvar_293, null) * empty_fields(_$l__lvar_293 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_293, "@proto") ->@d $lterr_proto) * ((_$l__lvar_293, "@extensible") ->@d true) * ((_$l__lvar_293, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_293) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi(_$l_#l, #prop, {{ "d", _lvar_294, false, _lvar_296, _lvar_297 }}, (_$l_#l :: (#lp :: #other)), #lcls, #lpv) * types(_lvar_296 : Bool, _lvar_297 : Bool, #lpv : List, #lcls : List, #ls : List, #prop : Str, #lp : Obj, #other : List, #d : List) * (#ls == (_$l_#l :: (#lp :: #other))) * (#d == {{ "d", _lvar_294, false, _lvar_296, _lvar_297 }}) * (! (_lvar_294 == empty)) * (v == {{ "o", _$l_#l, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d false) * MetaData (_$l_#l, _$l_#md) ]]
[[ Pi(_$l_#l, #prop, #d, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str, #lp : Obj, #other : List, #d : List) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * ((_$l_#md, "@extensible") ->@d false) * Extensible (_$l__lvar_298, true) * MetaData (_$l__lvar_298, null) * empty_fields(_$l__lvar_298 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_298, "@proto") ->@d $lterr_proto) * ((_$l__lvar_298, "@extensible") ->@d true) * ((_$l__lvar_298, "@class") ->@d "Error") * MetaData (_$l_#l, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_298) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi($lg, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str) * (v == {{ "v", $lg, #prop }}) * (w == #w) * ((_$l_#md, "@extensible") ->@d false) * MetaData ($lg, _$l_#md) ]]
[[ Pi($lg, #prop, undefined, #ls, #lcls, #lpv) * types(#lpv : List, #lcls : List, #ls : List, #prop : Str) * (xret == _$l_xret) * (v == _lvar_v) * (w == _lvar_w) * Extensible (_$l__lvar_299, true) * MetaData (_$l__lvar_299, null) * empty_fields(_$l__lvar_299 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_299, "@proto") ->@d $lterr_proto) * ((_$l__lvar_299, "@extensible") ->@d true) * ((_$l__lvar_299, "@class") ->@d "Error") * ((_$l_#md, "@extensible") ->@d false) * MetaData ($lg, _$l_#md) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_299) * empty_fields(_$l_xret : -{  }-) ]]
error

proc i__putValue (v, w) {
			goto [(((typeOf v) = List) and ((l-nth(v, 0.) = "v") or (l-nth(v, 0.) = "o")))] init throw;
	init:		rbase := l-nth(v, 1.);
			rfield := l-nth(v, 2.);
			goto [(rbase = undefined)] throw prim;
	prim:		prim := "i__isPrimitive"(rbase);
			goto [prim] is_pr refr;
	refr:		goto [(((typeOf v) = List) and (l-nth(v, 0.) = "o"))] oref vref;
	oref:		xret := "put"(rbase, rfield, w, true) with elab;
			goto dflt;
	vref:		goto [(rbase = $lg)] lg er;
	lg:		xret := "put"(rbase, rfield, w, true) with elab;
			goto dflt;
	er:		[rbase, rfield] := w;
	dflt:		xret := empty;
	rlab:		skip;
	throw:		xret := "ReferenceError"();
	elab:		skip;
	is_pr:		xret := "i__toObject"(rbase) with elab;
			l := xret;
			xret := "canPut"(l, rfield) with elab;
			goto [xret] cp reject;
	cp:		xret := "getProperty"(l, rfield) with elab;
			dd := "i__isDataDescriptor"(xret);
			goto [dd] reject is_ad;
	is_ad:		ad := "i__isAccessorDescriptor"(xret);
			goto [ad] ad reject;
	ad:		s := l-nth(xret, 2.);
			m := metadata (s);
			xsc := [m, "@scope"];
			fun := [m, "@call"];
			xret := fun(xsc, rbase, w) with elab;
			goto dflt;
	reject:		xret := "TypeError"();
			goto elab
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec OP_hasOwnProperty(xsc, vthis, v)
[[ types(#en : Bool, #wr : Bool, #co : Bool, #prop : Str) * (! (#v == empty)) * (v == #prop) * (xsc == _lvar_xsc) * (vthis == _$l_#l) * ((_$l_#md, "@class") ->@d "Object") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", #v, #wr, #en, #co }}) ]]
[[ types(#en : Bool, #wr : Bool, #co : Bool, #prop : Str) * (! (#v == empty)) * (xret == true) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * ((_$l_#md, "@class") ->@d "Object") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d {{ "d", #v, #wr, #en, #co }}) ]]
normal;

 [[ types(#prop : Str) * (v == #prop) * (xsc == _lvar_xsc) * (vthis == _$l_#l) * ((_$l_#md, "@class") ->@d "Object") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
[[ types(#prop : Str) * (xret == false) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * ((_$l_#md, "@class") ->@d "Object") * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, #prop) ->@d none) ]]
normal

proc OP_hasOwnProperty (xsc, vthis, v) {
			xret := "i__toString"(v) with elab;
			p := xret;
			xret := "i__toObject"(vthis) with elab;
			xret := "getOwnProperty"(xret, p) with elab;
			xret := (not (xret = undefined));
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec hasProperty(l, prop)
[[ Pi(#l, #prop, undefined, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, undefined, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List) * (xret == false) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal;

 [[ Pi(#l, #prop, {{ "d", _lvar_168, _lvar_169, _lvar_170, _lvar_171 }}, #ls, #cls, #pv) * types(#cls : List, #l : Obj, _lvar_171 : Bool, _lvar_169 : Bool, #ls : List, #prop : Str, #pv : List, _lvar_170 : Bool, #d : List) * (#d == {{ "d", _lvar_168, _lvar_169, _lvar_170, _lvar_171 }}) * (! (_lvar_168 == empty)) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #d, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List, #d : List) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal;

 [[ Pi(#l, #prop, {{ "a", _lvar_173, _lvar_172, _lvar_174, _lvar_175 }}, #ls, #cls, #pv) * types(#cls : List, #l : Obj, _lvar_174 : Bool, #ls : List, #prop : Str, _lvar_175 : Bool, #pv : List, #d : List) * (#d == {{ "a", _lvar_173, _lvar_172, _lvar_174, _lvar_175 }}) * (! (_lvar_173 == empty)) * (! (_lvar_172 == empty)) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #d, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List, #d : List) * (xret == true) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal

proc hasProperty (l, prop) {
			xret := "getProperty"(l, prop) with elab;
	rlab:		xret := (not (xret = undefined));
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec create_object_with_call_construct(l, call, construct, len)
[[ types(#len : Num, #call : Str) * (l == _$l_#l) * (construct == empty) * (len == #len) * (call == #call) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@scope") ->@d #lvar_10) * ((_$l_#md, "@proto") ->@d #lvar_7) * ((_$l_#md, "@extensible") ->@d #lvar_9) * ((_$l_#md, "@class") ->@d #lvar_8) * ((_$l_#md, "@call") ->@d #lvar_11) * Extensible (_$l_#l, true) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, "length") ->@d #lvar_6) ]]
[[ types(#len : Num, #call : Str) * (xret == _$l_#l) * (l == _lvar_l) * (construct == _lvar_construct) * (len == _lvar_len) * (call == _lvar_call) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@scope") ->@d empty) * ((_$l_#md, "@proto") ->@d $lfun_proto) * ((_$l_#md, "@extensible") ->@d true) * ((_$l_#md, "@class") ->@d "Function") * ((_$l_#md, "@call") ->@d #call) * Extensible (_$l_#l, true) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, "length") ->@d {{ "d", #len, false, false, false }}) ]]
normal;

 [[ types(#construct : Str, #len : Num, #call : Str) * (l == _$l_#l) * (construct == #construct) * (len == #len) * (call == #call) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@scope") ->@d #lvar_16) * ((_$l_#md, "@proto") ->@d #lvar_13) * ((_$l_#md, "@extensible") ->@d #lvar_15) * ((_$l_#md, "@construct") ->@d #lvar_18) * ((_$l_#md, "@class") ->@d #lvar_14) * ((_$l_#md, "@call") ->@d #lvar_17) * Extensible (_$l_#l, true) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, "length") ->@d #lvar_12) ]]
[[ types(#construct : Str, #len : Num, #call : Str) * (xret == _$l_#l) * (l == _lvar_l) * (construct == _lvar_construct) * (len == _lvar_len) * (call == _lvar_call) * Extensible (_$l_#md, true) * MetaData (_$l_#md, null) * ((_$l_#md, "@scope") ->@d empty) * ((_$l_#md, "@proto") ->@d $lfun_proto) * ((_$l_#md, "@extensible") ->@d true) * ((_$l_#md, "@construct") ->@d #construct) * ((_$l_#md, "@class") ->@d "Function") * ((_$l_#md, "@call") ->@d #call) * Extensible (_$l_#l, true) * MetaData (_$l_#l, _$l_#md) * ((_$l_#l, "length") ->@d {{ "d", #len, false, false, false }}) ]]
normal

proc create_object_with_call_construct (l, call, construct, len) {
			xret := "create_default_object"(l, $lfun_proto, "Function", true);
			[xret, "length"] := {{ "d", len, false, false, false }};
			m := metadata (xret);
			[m, "@scope"] := empty;
			[m, "@call"] := call;
			goto [(construct = empty)] rlab cstr;
	cstr:		[m, "@construct"] := construct;
	rlab:		xret := l
} with {
	ret: xret, rlab;
};


spec i__isPrimitive(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_85 : Num) * (v == _lvar_85) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_86 : Bool) * (v == _lvar_86) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_87 : Str) * (v == _lvar_87) ]]
[[ types() * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_88 : Obj) * (v == _lvar_88) ]]
[[ types() * (xret == false) * (v == _lvar_v) ]]
normal

proc i__isPrimitive (v) {
			tv := (typeOf v);
	iu:		goto [(((((v = undefined) or (v = null)) or ((typeOf v) = Bool)) or ((typeOf v) = Num)) or ((typeOf v) = Str))] rt rf;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec Object_construct(xsc, vthis, l)
[[ types(#l : Undefined) * (#l == undefined) * (l == undefined) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) ]]
[[ types(#l : Undefined) * (#l == undefined) * (xret == _$l_xret) * (l == _lvar_l) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * Extensible (_$l__lvar_84, true) * MetaData (_$l__lvar_84, null) * empty_fields(_$l__lvar_84 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_84, "@proto") ->@d $lobj_proto) * ((_$l__lvar_84, "@extensible") ->@d true) * ((_$l__lvar_84, "@class") ->@d "Object") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_84) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc Object_construct (xsc, vthis, l) {
			goto [((typeOf l) = Obj)] obj l1b;
	obj:		xret := l;
			goto rlab;
	l1b:		goto [((((typeOf l) = Bool) or ((typeOf l) = Num)) or ((typeOf l) = Str))] to_obj norm;
	to_obj:		xret := "i__toObject"(l);
			goto rlab;
	norm:		xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lobj_proto, "Object", true);
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__sameValue(v1, v2)
[[ types() * (v2 == 0.) * (v1 == 0.) ]]
[[ types() * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (v2 == -0.) * (v1 == -0.) ]]
[[ types() * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (v2 == 0.) * (v1 == -0.) ]]
[[ types() * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (v2 == -0.) * (v1 == 0.) ]]
[[ types() * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (v2 == _lvar_650) * (v1 == _lvar_650) ]]
[[ types() * (xret == true) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal;

 [[ types() * (! (_lvar_v1 == _lvar_v2)) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
[[ types() * (xret == false) * (v2 == _lvar_v2) * (v1 == _lvar_v1) ]]
normal

proc i__sameValue (v1, v2) {
			goto [((typeOf v1) = Num)] test2 nonum;
	test2:		goto [((typeOf v2) = Num)] inan1 nonum;
	inan1:		goto [(not (v1 = v1))] inan2 zero1;
	inan2:		goto [(not (v2 = v2))] rt zero1;
	zero1:		goto [(v1 = 0.)] zero2 nonum;
	zero2:		goto [(v2 = 0.)] fix nonum;
	fix:		sv1 := (m_sgn v1);
			sv2 := (m_sgn v2);
			goto [(sv1 = sv2)] rt rf;
			goto rlab;
	nonum:		goto [(v1 = v2)] rt rf;
	rt:		xret := true;
			goto rlab;
	rf:		xret := false;
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec i__toObject(v)
[[ types(#v : Obj) * (v == #v) ]]
[[ types(#v : Obj) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Bool) * (v == #v) ]]
[[ types(#v : Bool) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_648, true) * MetaData (_$l__lvar_648, null) * empty_fields(_$l__lvar_648 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_648, "@proto") ->@d $lbool_proto) * ((_$l__lvar_648, "@primitiveValue") ->@d #v) * ((_$l__lvar_648, "@extensible") ->@d true) * ((_$l__lvar_648, "@class") ->@d "Boolean") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_648) * empty_fields(_$l_xret : -{  }-) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_649, true) * MetaData (_$l__lvar_649, null) * empty_fields(_$l__lvar_649 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_649, "@proto") ->@d $lnum_proto) * ((_$l__lvar_649, "@primitiveValue") ->@d #v) * ((_$l__lvar_649, "@extensible") ->@d true) * ((_$l__lvar_649, "@class") ->@d "Number") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_649) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc i__toObject (v) {
	iu:		goto [(v = undefined)] throw in;
	in:		goto [(v = null)] throw ib;
	ib:		goto [((typeOf v) = Bool)] bool inum;
	bool:		xret := "Boolean_construct"(undefined, undefined, v);
			goto rlab;
	inum:		goto [((typeOf v) = Num)] num is;
	num:		xret := "Number_construct"(undefined, undefined, v);
			goto rlab;
	is:		goto [((typeOf v) = Str)] str io;
	str:		xret := "String_construct"(undefined, undefined, v);
			goto rlab;
	io:		goto [((typeOf v) = Obj)] obj oops;
	obj:		xret := v;
			goto rlab;
	oops:		xret := "ToObject: This should not happen.";
	rlab:		skip;
	throw:		xret := "Here!";
			xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__toBoolean(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == false) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == false) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Bool) * (v == #v) ]]
[[ types(#v : Bool) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == 0.) ]]
[[ types() * (xret == false) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (! (#v == 0.)) * (v == #v) ]]
[[ types(#v : Num) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == "") ]]
[[ types() * (xret == false) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (! (#v == "")) * (v == #v) ]]
[[ types(#v : Str) * (xret == true) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Obj) * (v == #v) ]]
[[ types(#v : Obj) * (xret == true) * (v == _lvar_v) ]]
normal

proc i__toBoolean (v) {
	iu:		goto [(v = undefined)] undef in;
	undef:		xret := false;
			goto rlab;
	in:		goto [(v = null)] nul ib;
	nul:		xret := false;
			goto rlab;
	ib:		goto [((typeOf v) = Bool)] bool inum;
	bool:		xret := v;
			goto rlab;
	inum:		goto [((typeOf v) = Num)] num is;
	num:		goto [((v = 0.) or (not (v = v)))] is_f is_t;
	is:		goto [((typeOf v) = Str)] str io;
	str:		goto [(v = "")] is_f is_t;
			goto rlab;
	io:		goto [((typeOf v) = Obj)] obj oops;
	obj:		xret := true;
			goto rlab;
	is_t:		xret := true;
			goto rlab;
	is_f:		xret := false;
			goto rlab;
	oops:		xret := "ToBoolean: This should not happen.";
	rlab:		skip
} with {
	ret: xret, rlab;
};


spec getProperty(l, prop)
[[ Pi(#l, #prop, #d, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #d, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List) * (xret == #d) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal

proc getProperty (l, prop) {
			[* unfold Pi(#l, #prop, #d, #ls, #cls, #pv) *]
			xret := "getOwnProperty"(l, prop) with elab;
			goto [(xret = undefined)] next rlab;
	next:		m := metadata (l);
			proto := [m, "@proto"];
			goto [(proto = null)] rlab call;
	call:		xret := "getProperty"(proto, prop) with elab;
			[* fold Pi(#l, #prop, #d, #ls, #cls, #pv) *]
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec Number_construct(xsc, vthis, v)
[[ types(#v : Num) * (v == #v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) ]]
[[ types(#v : Num) * (xret == _$l_xret) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * Extensible (_$l__lvar_356, true) * MetaData (_$l__lvar_356, null) * empty_fields(_$l__lvar_356 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_356, "@proto") ->@d $lnum_proto) * ((_$l__lvar_356, "@primitiveValue") ->@d #v) * ((_$l__lvar_356, "@extensible") ->@d true) * ((_$l__lvar_356, "@class") ->@d "Number") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_356) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc Number_construct (xsc, vthis, v) {
	init:		pv := "i__toNumber"(v) with elab;
			xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lnum_proto, "Number", true);
			m := metadata (xret);
			[m, "@primitiveValue"] := pv;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: pv, elab;
};


spec get(l, prop)
[[ Pi(#l, #prop, undefined, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List, #d : Undefined) * (#d == undefined) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, undefined, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List, #d : Undefined) * (#d == undefined) * (xret == undefined) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal;

 [[ Pi(#l, #prop, {{ "d", _lvar_214, _lvar_215, _lvar_216, _lvar_217 }}, #ls, #cls, #pv) * types(#cls : List, #l : Obj, _lvar_215 : Bool, _lvar_216 : Bool, #ls : List, _lvar_217 : Bool, #prop : Str, #pv : List, #d : List) * (#d == {{ "d", _lvar_214, _lvar_215, _lvar_216, _lvar_217 }}) * (! (_lvar_214 == empty)) * (prop == #prop) * (l == #l) ]]
[[ Pi(#l, #prop, #d, #ls, #cls, #pv) * types(#cls : List, #l : Obj, #ls : List, #prop : Str, #pv : List, #d : List) * (xret == l-nth(#d, 1.)) * (prop == _lvar_prop) * (l == _lvar_l) ]]
normal

proc get (l, prop) {
			xret := "getProperty"(l, prop) with elab;
			goto [(xret = undefined)] rlab def;
	def:		d := l-nth(xret, 0.);
			xret := l-nth(xret, 1.);
			goto [(d = "d")] rlab acc;
	acc:		goto [(xret = undefined)] rlab get;
	get:		m := metadata (xret);
			xsc := [m, "@scope"];
			fun := [m, "@call"];
			xret := fun(xsc, l) with elab;
			goto [(xret = empty)] undef rlab;
	undef:		xret := undefined;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__checkObjectCoercible(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_176, true) * MetaData (_$l__lvar_176, null) * empty_fields(_$l__lvar_176 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_176, "@proto") ->@d $lterr_proto) * ((_$l__lvar_176, "@extensible") ->@d true) * ((_$l__lvar_176, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_176) * empty_fields(_$l_xret : -{  }-) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_177) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_177, true) * MetaData (_$l__lvar_177, null) * empty_fields(_$l__lvar_177 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_177, "@proto") ->@d $lterr_proto) * ((_$l__lvar_177, "@extensible") ->@d true) * ((_$l__lvar_177, "@class") ->@d "Error") ]]
normal;

 [[ types(_lvar_178 : Num) * (v == _lvar_178) ]]
[[ types() * (xret == empty) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_179 : Bool) * (v == _lvar_179) ]]
[[ types() * (xret == empty) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_180 : Str) * (v == _lvar_180) ]]
[[ types() * (xret == empty) * (v == _lvar_v) ]]
normal;

 [[ types(_lvar_181 : Obj) * (v == _lvar_181) ]]
[[ types() * (xret == empty) * (v == _lvar_v) ]]
normal

proc i__checkObjectCoercible (v) {
			xret := empty;
	iu:		goto [(v = undefined)] throw in;
	in:		goto [(v = null)] throw other;
	other:		goto [(((((typeOf v) = Bool) or ((typeOf v) = Num)) or ((typeOf v) = Str)) or ((typeOf v) = Obj))] rlab oops;
	oops:		xret := "CheckObjectCoercible: This should not happen.";
	rlab:		skip;
	throw:		xret := "TypeError"();
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec SyntaxError_call(xsc, vthis, v)
[[ types() * (v == undefined) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * Extensible (_$l__lvar_167, true) * MetaData (_$l__lvar_167, null) * empty_fields(_$l__lvar_167 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_167, "@proto") ->@d $lserr_proto) * ((_$l__lvar_167, "@extensible") ->@d true) * ((_$l__lvar_167, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_167) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc SyntaxError_call (xsc, vthis, v) {
			xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lserr_proto, "Error", true);
			xret := "Error_construct"(undefined, xret, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec i__getValue(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == undefined) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == null) ]]
[[ types() * (xret == null) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Obj) * (v == #v) ]]
[[ types(#v : Obj) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Num) * (v == #v) ]]
[[ types(#v : Num) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Bool) * (v == #v) ]]
[[ types(#v : Bool) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ types(#v : Str) * (v == #v) ]]
[[ types(#v : Str) * (xret == #v) * (v == _lvar_v) ]]
normal;

 [[ Pi(#obj, #field, undefined, #ls, #lcls, #lpv) * types(#field : Str, #lpv : List, #lcls : List, #obj : Obj, #ls : List, #d : Undefined) * (#d == undefined) * (v == {{ "o", #obj, #field }}) ]]
[[ Pi(#obj, #field, undefined, #ls, #lcls, #lpv) * types(#field : Str, #lpv : List, #lcls : List, #obj : Obj, #ls : List, #d : Undefined) * (#d == undefined) * (xret == undefined) * (v == _lvar_v) ]]
normal;

 [[ Pi(#obj, #field, {{ "d", _lvar_145, _lvar_146, _lvar_147, _lvar_148 }}, #ls, #lcls, #lpv) * types(_lvar_146 : Bool, _lvar_147 : Bool, #field : Str, #lpv : List, #lcls : List, #obj : Obj, #ls : List, _lvar_148 : Bool, #d : List) * (#d == {{ "d", _lvar_145, _lvar_146, _lvar_147, _lvar_148 }}) * (! (_lvar_145 == empty)) * (v == {{ "o", #obj, #field }}) ]]
[[ Pi(#obj, #field, #d, #ls, #lcls, #lpv) * types(#field : Str, #lpv : List, #lcls : List, #obj : Obj, #ls : List, #d : List) * (xret == l-nth(#d, 1.)) * (v == _lvar_v) ]]
normal;

 [[ Pi($lg, #field, undefined, #ls, #lcls, #lpv) * types(#field : Str, #lpv : List, #lcls : List, #ls : List, #d : Undefined) * (#d == undefined) * (v == {{ "v", $lg, #field }}) ]]
[[ Pi($lg, #field, undefined, #ls, #lcls, #lpv) * types(#field : Str, #lpv : List, #lcls : List, #ls : List, #d : Undefined) * (#d == undefined) * (xret == undefined) * (v == _lvar_v) ]]
normal;

 [[ Pi($lg, #field, {{ "d", _lvar_149, _lvar_150, _lvar_151, _lvar_152 }}, #ls, #lcls, #lpv) * types(_lvar_150 : Bool, _lvar_152 : Bool, #field : Str, _lvar_151 : Bool, #lpv : List, #lcls : List, #ls : List, #d : List) * (#d == {{ "d", _lvar_149, _lvar_150, _lvar_151, _lvar_152 }}) * (! (_lvar_149 == empty)) * (v == {{ "v", $lg, #field }}) ]]
[[ Pi($lg, #field, #d, #ls, #lcls, #lpv) * types(#field : Str, #lpv : List, #lcls : List, #ls : List, #d : List) * (xret == l-nth(#d, 1.)) * (v == _lvar_v) ]]
normal;

 [[ types() * (v == {{ "v", _$l_#obj, #field }}) * ((_$l_#obj, #field) ->@d #value) ]]
[[ types() * (xret == #value) * (v == _lvar_v) * ((_$l_#obj, #field) ->@d #value) ]]
normal;

 [[ types(#field : Str) * (v == {{ "v", undefined, #field }}) ]]
[[ types(#field : Str) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_153, true) * MetaData (_$l__lvar_153, null) * empty_fields(_$l__lvar_153 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_153, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_153, "@extensible") ->@d true) * ((_$l__lvar_153, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_153) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ types(#field : Str) * (v == {{ "o", undefined, #field }}) ]]
[[ types(#field : Str) * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_154, true) * MetaData (_$l__lvar_154, null) * empty_fields(_$l__lvar_154 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_154, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_154, "@extensible") ->@d true) * ((_$l__lvar_154, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_154) * empty_fields(_$l_xret : -{  }-) ]]
error;

 [[ Pi($lbool_proto, #field, undefined, #pls, #plcls, #plpv) * types(#field : Str, #pls : List, #b : Bool, #plpv : List, #plcls : List, #d : Undefined) * (#d == undefined) * (v == {{ "o", #b, #field }}) ]]
[[ Pi($lbool_proto, #field, undefined, #pls, #plcls, #plpv) * types(#pls : List, #field : Str, #b : Bool, #plpv : List, #plcls : List, #d : Undefined) * (#d == undefined) * (xret == undefined) * (v == _lvar_v) * (xobj == _$l_#o) * Extensible (_$l_#o, true) * MetaData (_$l_#o, _$l__lvar_155) * empty_fields(_$l_#o : -{  }-) * Extensible (_$l__lvar_155, true) * MetaData (_$l__lvar_155, null) * empty_fields(_$l__lvar_155 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_155, "@proto") ->@d $lbool_proto) * ((_$l__lvar_155, "@primitiveValue") ->@d #b) * ((_$l__lvar_155, "@extensible") ->@d true) * ((_$l__lvar_155, "@class") ->@d "Boolean") ]]
normal;

 [[ Pi($lbool_proto, #field, {{ "d", _lvar_156, _lvar_157, _lvar_158, _lvar_159 }}, #pls, #plcls, #plpv) * types(_lvar_158 : Bool, #pls : List, #field : Str, #b : Bool, #plpv : List, _lvar_159 : Bool, #plcls : List, _lvar_157 : Bool, #d : List) * (#d == {{ "d", _lvar_156, _lvar_157, _lvar_158, _lvar_159 }}) * (! (_lvar_156 == empty)) * (v == {{ "o", #b, #field }}) ]]
[[ Pi($lbool_proto, #field, #d, #pls, #plcls, #plpv) * types(#field : Str, #pls : List, #b : Bool, #plpv : List, #plcls : List, #d : List) * (xret == l-nth(#d, 1.)) * (v == _lvar_v) * (xobj == _$l_#o) * Extensible (_$l_#o, true) * MetaData (_$l_#o, _$l__lvar_160) * empty_fields(_$l_#o : -{  }-) * Extensible (_$l__lvar_160, true) * MetaData (_$l__lvar_160, null) * empty_fields(_$l__lvar_160 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_160, "@proto") ->@d $lbool_proto) * ((_$l__lvar_160, "@primitiveValue") ->@d #b) * ((_$l__lvar_160, "@extensible") ->@d true) * ((_$l__lvar_160, "@class") ->@d "Boolean") ]]
normal;

 [[ Pi($lnum_proto, #field, undefined, #pls, #plcls, #plpv) * types(#field : Str, #pls : List, #plpv : List, #n : Num, #plcls : List, #d : Undefined) * (#d == undefined) * (v == {{ "o", #n, #field }}) ]]
[[ Pi($lnum_proto, #field, undefined, #pls, #plcls, #plpv) * types(#pls : List, #field : Str, #plpv : List, #n : Num, #plcls : List, #d : Undefined) * (#d == undefined) * (xret == undefined) * (v == _lvar_v) * (xobj == _$l_#o) * Extensible (_$l_#o, true) * MetaData (_$l_#o, _$l__lvar_161) * empty_fields(_$l_#o : -{  }-) * Extensible (_$l__lvar_161, true) * MetaData (_$l__lvar_161, null) * empty_fields(_$l__lvar_161 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_161, "@proto") ->@d $lnum_proto) * ((_$l__lvar_161, "@primitiveValue") ->@d #n) * ((_$l__lvar_161, "@extensible") ->@d true) * ((_$l__lvar_161, "@class") ->@d "Number") ]]
normal;

 [[ Pi($lnum_proto, #field, {{ "d", _lvar_162, _lvar_163, _lvar_164, _lvar_165 }}, #pls, #plcls, #plpv) * types(#pls : List, #field : Str, _lvar_163 : Bool, _lvar_164 : Bool, #plpv : List, #n : Num, #plcls : List, _lvar_165 : Bool, #d : List) * (#d == {{ "d", _lvar_162, _lvar_163, _lvar_164, _lvar_165 }}) * (! (_lvar_162 == empty)) * (v == {{ "o", #n, #field }}) ]]
[[ Pi($lnum_proto, #field, #d, #pls, #plcls, #plpv) * types(#field : Str, #pls : List, #plpv : List, #n : Num, #plcls : List, #d : List) * (xret == l-nth(#d, 1.)) * (v == _lvar_v) * (xobj == _$l_#o) * Extensible (_$l_#o, true) * MetaData (_$l_#o, _$l__lvar_166) * empty_fields(_$l_#o : -{  }-) * Extensible (_$l__lvar_166, true) * MetaData (_$l__lvar_166, null) * empty_fields(_$l__lvar_166 : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-) * ((_$l__lvar_166, "@proto") ->@d $lnum_proto) * ((_$l__lvar_166, "@primitiveValue") ->@d #n) * ((_$l__lvar_166, "@extensible") ->@d true) * ((_$l__lvar_166, "@class") ->@d "Number") ]]
normal

proc i__getValue (v) {
			goto [((typeOf v) = List)] rcand dflt;
	rcand:		rtype := l-nth(v, 0.);
			goto [((rtype = "v") or (rtype = "o"))] init dflt;
	init:		rbase := l-nth(v, 1.);
			rfield := l-nth(v, 2.);
			goto [(rbase = undefined)] throw prim;
	prim:		prim := "i__isPrimitive"(rbase);
			goto [prim] is_pr ref;
	is_pr:		xobj := "i__toObject"(rbase) with pelab;
			[* fold Pi(xobj, #field, #d, #ls, #lcls, #lpv) *]
			xret := "getProperty"(xobj, rfield) with pelab;
			[* unfold Pi(xobj, #field, #d, #ls, #lcls, #lpv) *]
			goto [(xret = undefined)] rlab def;
	def:		d := l-nth(xret, 0.);
			xret := l-nth(xret, 1.);
			goto [(d = "d")] rlab acc;
	acc:		goto [(xret = undefined)] rlab get;
	get:		m := metadata (xret);
			xsc := [m, "@scope"];
			fun := [m, "@call"];
			xret := fun(xsc, rbase) with pelab;
			goto [(xret = empty)] undef rlab;
	undef:		xret := undefined;
	ref:		goto [(((typeOf v) = List) and (l-nth(v, 0.) = "o"))] oref vref;
	oref:		xret := "get"(rbase, rfield) with pelab;
			goto rlab;
	vref:		goto [(rbase = $lg)] lg er;
	lg:		xret := "get"(rbase, rfield) with pelab;
			goto rlab;
	er:		xret := [rbase, rfield];
			goto rlab;
	dflt:		xret := v;
	rlab:		skip;
	throw:		xret := "ReferenceError"();
	pelab:		xret := PHI(xobj, xret, xret, xret, xret, xret);
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec ReferenceError_call(xsc, vthis, v)
[[ types() * (v == undefined) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * (xsc == _lvar_xsc) * (vthis == _lvar_vthis) * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_144) * empty_fields(_$l_xret : -{  }-) * Extensible (_$l__lvar_144, true) * MetaData (_$l__lvar_144, null) * empty_fields(_$l__lvar_144 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_144, "@proto") ->@d $lrferr_proto) * ((_$l__lvar_144, "@extensible") ->@d true) * ((_$l__lvar_144, "@class") ->@d "Error") ]]
normal

proc ReferenceError_call (xsc, vthis, v) {
			xmet := new();
			xret := new(xmet);
			xret := "create_default_object"(xret, $lrferr_proto, "Error", true);
			xret := "Error_construct"(undefined, xret, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};


spec SyntaxError(v)
[[ types() * (v == undefined) ]]
[[ types() * (xret == _$l_xret) * (v == _lvar_v) * Extensible (_$l__lvar_103, true) * MetaData (_$l__lvar_103, null) * empty_fields(_$l__lvar_103 : -{ "@class", "@extensible", "@proto" }-) * ((_$l__lvar_103, "@proto") ->@d $lserr_proto) * ((_$l__lvar_103, "@extensible") ->@d true) * ((_$l__lvar_103, "@class") ->@d "Error") * Extensible (_$l_xret, true) * MetaData (_$l_xret, _$l__lvar_103) * empty_fields(_$l_xret : -{  }-) ]]
normal

proc SyntaxError (v) {
			xret := "SyntaxError_call"(undefined, undefined, v) with elab;
	rlab:		skip;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xret, elab;
};



