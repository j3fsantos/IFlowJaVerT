(*************************
 **** GENERAL OBJECTS ****
 *************************)

pred JSObject (l:Obj) :
    MetaData(l, #md) * Extensible(l, true) *
	((#md, "@proto")      -> $lobj_proto) *
	((#md, "@class")      -> "Object") *
	((#md, "@extensible") -> true) *
	MetaData(#md, null) * Extensible(#md, true);

pred JSObjWithProto (l:Obj, proto) :
    MetaData(l, #md) * Extensible(l, true) *
	((#md, "@proto")      -> proto) *
	((#md, "@class")      -> "Object") *
	((#md, "@extensible") -> true) *
	MetaData(#md, null) * Extensible(#md, true);
	
pred JSObjGeneral (l:Obj, proto, class:Str, ext:Bool) :
    MetaData(l, #md) * Extensible(l, true) *
	((#md, "@proto")      -> proto) *
	((#md, "@class")      -> class) *
	((#md, "@extensible") -> ext) *
	MetaData(#md, null) * Extensible(#md, true);
	
pred JSObjGeneralWeak (l:Obj, proto, class, ext) :
    MetaData(l, #md) * Extensible(l, true) *
	((#md, "@proto")      -> proto) *
	((#md, "@class")      -> class) *
	((#md, "@extensible") -> ext) *
	MetaData(#md, null) * Extensible(#md, true);
	
pred EmptyExtensibleObject(l:Obj) :
	empty_fields(l   : -{}-) * MetaData(l,  #md)   * Extensible(l, true) *
	empty_fields(#md : -{}-) * MetaData(#md, null) * Extensible(#md, true);

(************************
 ***** INITIAL HEAP *****
 ************************)

pred initialHeapPre () :
    EmptyExtensibleObject ($lg) *
    EmptyExtensibleObject ($lobj_proto) * 
    EmptyExtensibleObject ($lfun_proto) * 
    EmptyExtensibleObject ($lerr) *
    EmptyExtensibleObject ($lerr_proto) * 
    EmptyExtensibleObject ($lop_hasOwnProperty);
    
pred initialHeapPost (globals) :
	types(globals:Set) *
	
	JSObject ($lg) *
	(($lg, "Error") -> {{ "d", $lerr, true, false, true }}) *
    empty_fields ($lg    : -u- (-{ "Error" }-, globals) ) *
    MetaData($lg, #mlg) * empty_fields (#mlg : -{ "@class", "@proto", "@extensible" }-) *
    
    JSObjWithProto ($lobj_proto, null) *
    (($lobj_proto, "hasOwnProperty") -> {{ "d", $lop_hasOwnProperty, true, false, true }}) *
    empty_fields ($lobj_proto    : -{ "hasOwnProperty" }-) *
    MetaData($lobj_proto, #mlop) * empty_fields (#mlop : -{ "@class", "@proto", "@extensible" }-) *

    JSObjGeneral ($lop_hasOwnProperty, $lfun_proto, "Function", true) *
    (($lop_hasOwnProperty, "length") -> {{ "d", 1, false, false, false }}) *
    empty_fields($lop_hasOwnProperty : -{ "length" }-) *
    MetaData($lop_hasOwnProperty, #mlophOP) *
    ((#mlophOP, "@scope") -> empty) * ((#mlophOP, "@call") -> "OP_hasOwnProperty") *
    empty_fields(#mlophOP : -{ "@proto", "@class", "@extensible", "@scope", "@call" }-) *
    
    JSObjGeneral ($lfun_proto, $lobj_proto, "Function", true) *
    (($lfun_proto, "length") -> {{ "d", 0, false, false, false }}) *
    empty_fields($lfun_proto : -{ "length" }-) *
    MetaData($lfun_proto, #mfp) *
    ((#mfp, "@scope") -> empty) * ((#mfp, "@call") -> "FP_default") *
    empty_fields(#mfp : -{ "@proto", "@class", "@extensible", "@scope", "@call" }-) *
      
    JSObjGeneral ($lerr, $lfun_proto, "Function", true) *
    (($lerr, "length") -> {{ "d", 1, false, false, false }}) *
    (($lerr, "prototype") -> {{ "d", $lerr_proto, false, false, false }}) *
    empty_fields($lerr : -{ "length", "prototype" }-) *
    MetaData($lerr, #mlerr) *
    ((#mlerr, "@scope") -> empty) * ((#mlerr, "@call") -> "Error_call") * ((#mlerr, "@construct") -> "Error_construct") *
    empty_fields(#mlerr : -{ "@proto", "@class", "@extensible", "@scope", "@call", "@construct" }-) *
    
    JSObjGeneral ($lerr_proto, $lobj_proto, "Error", true) * 
    (($lerr_proto, "message") -> {{ "d", "", true, false, true }}) *
    empty_fields($lerr_proto : -{ "message" }-) *
    MetaData($lerr_proto, #mlerrp) * empty_fields(#mlerrp : -{ "@proto", "@class", "@extensible" }-);

(**************************
 **** FUNCTION OBJECTS ****
 **************************)

pred FunctionObject (l:Obj, fid:Str, sc:List, len:Num, proto:Obj) : 
	((l, "length")     -> {{ "d", len, false, false, false }}) *
	((l, "arguments")  -> {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }}) *
	((l, "caller")     -> {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }}) *
	((l, "prototype")  -> {{ "d", proto, true, false, false }}) *
	MetaData(l, #md) * Extensible (l, true) *
	((#md, "@proto")      -> $lfun_proto) * 
	((#md, "@class")      -> "Function") *
	((#md, "@extensible") -> true) * 
	((#md, "@call")       -> fid) * 
	((#md, "@construct")  -> fid) *
	((#md, "@scope")      -> sc) *
	MetaData(#md, null) * Extensible(#md, true);

(***********************
 **** ERROR OBJECTS ****
 ***********************)
 
pred ErrorObject (l : Obj, pr : Obj) :
	JSObjGeneral(l, pr, "Error", true);

pred ErrorObjectWithMessage (l : Obj, m : Str) :
  MetaData(l, #md) * Extensible(l, true) *
  ((#md, "@proto") -> $lerr_proto) * ((#md, "@class") -> "Error") * ((#md, "@extensible") -> true) *
  ((#md, "message") -> {{"d", m, true, false, true}}) * 
  MetaData(#md, null) * Extensible(#md, true);

pred isTypeError(l : Obj) :
    ErrorObject (l, $lterr_proto);

pred isSyntaxError(l : Obj) :
    ErrorObject (l, $lserr_proto);

pred isReferenceError(l : Obj) :
    ErrorObject (l, $lrferr_proto);

(********************
 **** PROPERTIES ****
 ********************)

pred DataProp (l : Obj, prop : Str, v) :
	((l, prop) -> {{ "d", v, true, true, true }}) *
	(! (v == empty));
	
pred DataPropGen (l : Obj, prop : Str, v, writ : Bool, enum : Bool, conf : Bool) : 
	((l, prop) -> {{ "d", v, writ, enum, conf }}) *
	(! (v == empty));
	
pred DataPropConst (l : Obj, prop : Str, v) :
	((l, prop) -> {{ "d", v, false, #e, false }}) *
	types(#e:Bool) * (! (v == empty));

(*********************
 **** DESCRIPTORS ****
 *********************)
 
 (*
 * Predicate: DataDescriptor
 *
 * Resource: none
 *
 *)
pred DataDescriptor (d:List) :
	(d == {{ "d", #dval, #dwrit, #denum, #dconf }}) *
	types (#dwrit:Bool, #denum:Bool, #dconf:Bool) * 
	(! (#dval == empty));

 (*
 * Predicate: AccessorDescriptor
 *
 * Resource: none
 *
 *)
pred AccessorDescriptor (d:List) :
	(d == {{ "a", #dget, #dset, #denum, #dconf }}) *
	types (#denum:Bool, #dconf:Bool) * 
	(! (#dget == empty)) * (! (#dset == empty));
	
 (*
 * Predicate: Descriptor
 *
 * Resource: none
 *
 *)
pred Descriptor (d:List) :
	DataDescriptor(d),
	AccessorDescriptor(d);

(*
 * Predicate: GenericDescriptor
 *
 * Resource: none
 *
 *)
pred GenericDescriptor (d:List) :
	(d == {{ "g", #genum, #gconf, #gval, #gwrit, #gget, #gset }});

(*
 * Predicate: Projection functions for descriptors
 *
 * Resource: none
 *
 *)
pred desc_val (d:List, v) :
    v == l-nth(d, 1);

pred desc_writ (d:List, v) :
    v == l-nth(d, 2);

pred desc_get (d:List, v) :
    v == l-nth(d, 1);

pred desc_set (d:List, v) :
    v == l-nth(d, 2);

pred desc_enum (d:List, v) :
    v == l-nth(d, 3);

pred desc_conf (d:List, v) :
    v == l-nth(d, 4);
    
(*********************
 **** OBJECT CELL ****
 *********************) 

(*
 * Predicate: Cell_o(l, prop, X)
 *
 * Resource:
 *      (l, prop)
 *
 *)
pred Cell_o (l:Obj, prop:Str, d) :
    ((l, prop) -> d) * (d == none),
    ((l, prop) -> d) * DataDescriptor(d),
    ((l, prop) -> d) * AccessorDescriptor(d);
    
(***************************
 **** TODO: STRING CELL ****
 ***************************) 
 
(**************************
 **** CLASS CLASSIFIERS ***
 **************************)	
 
(*
 * Predicate: isClass(c, X)
 *
 * Resource:
 *      (l, "@class")
 *
 *)
pred isClass (c:Str, case:Str) :
	(case == "Array")      * (c == "Array"),
	(case == "String")     * (c == "String"),
	(case == "Non-Array")  * (! (c == "Array")),
	(case == "Non-String") * (! (c == "String"));	

(**********************************
 **** PI: PROTOTYPE INHERITANCE ***
 **********************************)

pred Pi (l:Obj, prop:Str, d, ls:List, lcls:List, lpv:List) :

    (* Non-string object, cell exists in the heap *)
    Cell_o (l, prop, d) * Descriptor(d) *
	MetaData(l, #md) * ((#md, "@class") -> #cls) * isClass (#cls, "Non-String") *
    (ls == {{ l }}) * (lcls == {{ #cls }}) * (lpv == {{ "" }}),

	(* Non-string object, cell does not exist in the heap, down the prototype chain *)
    Cell_o (l, prop, none) *
	MetaData(l, #md) * ((#md, "@class") -> #cls) * isClass (#cls, "Non-String") * ((#md, "@proto") -> #lp) *
	(ls == l :: #lls) * (lcls == #cls :: #lcls) * (lpv == "" :: #lpv) *
	types(#cls:Str) *
	(#lls == #lp :: #ols) * (#lcls == #pcls :: #ocls) * (#lpv == #ppv :: #otv) *
	types(#lp:Obj, #pcls:Str, #ppv:Str) *
	Pi (#lp, prop, d, #lls, #lcls, #lpv),
	
	(* Non-string object, cell does not exist in the heap, end of prototype chain *)
    Cell_o (l, prop, none) * (d == undefined) *
    MetaData(l, #md) * ((#md, "@class") -> #cls) * isClass (#cls, "Non-String") *  ((#md, "@proto") -> null) * 
    (ls == {{ l }}) * (lcls == {{ #cls }}) * (lpv == {{ "" }});
    