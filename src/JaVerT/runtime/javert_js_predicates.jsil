(*************************
 **** GENERAL OBJECTS ****
 *************************)

pred JSObject (l:Obj) :
    MetaData(l, #md) * Extensible(l, true) *
	((#md, "@proto")      -> $lobj_proto) *
	((#md, "@class")      -> "Object") *
	((#md, "@extensible") -> true) *
	MetaData(#md, null) * Extensible(#md, true) *
	empty_fields (#md : -{ "@class", "@extensible", "@proto" }-);

pred JSObjWithProto (+l:Obj, proto) :
    MetaData(l, #md) * Extensible(l, true) *
	((#md, "@proto")      -> proto) *
	((#md, "@class")      -> "Object") *
	((#md, "@extensible") -> true) *
	MetaData(#md, null) * Extensible(#md, true) *
	empty_fields (#md : -{ "@class", "@extensible", "@proto" }-);
	
pred JSObjGeneral (+l:Obj, proto, class:Str, ext:Bool) :
    MetaData(l, #md) * Extensible(l, true) *
	((#md, "@proto")      -> proto) *
	((#md, "@class")      -> class) *
	((#md, "@extensible") -> ext) *
	MetaData(#md, null) * Extensible(#md, true) *
	empty_fields (#md : -{ "@class", "@extensible", "@proto" }-);
	
pred EmptyExtensibleObject(l:Obj) :
	empty_fields(l   : -{}-) * MetaData(l,  #md)   * Extensible(l, true) *
	empty_fields(#md : -{}-) * MetaData(#md, null) * Extensible(#md, true);

(**************************
 **** FUNCTION OBJECTS ****
 **************************)

pred JSFunctionObject (+l:Obj, fid:Str, sc:List, len:Num, proto:Obj) : 
	((l, "length")     -> {{ "d", len, false, false, false }}) *
	((l, "arguments")  -> {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }}) *
	((l, "caller")     -> {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }}) *
	((l, "prototype")  -> {{ "d", proto, true, false, false }}) *
	MetaData(l, #md) * Extensible (l, true) *
	((#md, "@proto")      -> $lfun_proto) * 
	((#md, "@class")      -> "Function") *
	((#md, "@extensible") -> true) * 
	((#md, "@call")       -> fid) * 
	((#md, "@construct")  -> fid) *
	((#md, "@scope")      -> sc) *
	empty_fields(#md : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope" }-) *
	MetaData(#md, null) * Extensible(#md, true);

pred JSBIFunction (+l:Obj, fid:Str, len:Num) : 
	((l, "length")     -> {{ "d", len, false, false, false }}) *
	MetaData(l, #md) * Extensible (l, true) *
	((#md, "@proto")      -> $lfun_proto) * 
	((#md, "@class")      -> "Function") *
	((#md, "@extensible") -> true) * 
	((#md, "@call")       -> fid) * 
	((#md, "@scope")      -> empty) *
	empty_fields(#md : -{ "@call", "@class", "@extensible", "@proto", "@scope" }-) *
	MetaData(#md, null) * Extensible(#md, true);

pred BIFunctionObject (+l:Obj, len:Num, proto:Obj) : 
	((l, "length")     -> {{ "d", len, false, false, false }}) *
	((l, "prototype")  -> {{ "d", proto, false, false, false }}) *
	MetaData(l, #md) * Extensible (l, true) *
	((#md, "@proto")      -> $lfun_proto) * 
	((#md, "@class")      -> "Function") *
	((#md, "@extensible") -> true) * 
	((#md, "@scope")      -> empty) *
	empty_fields(#md : -{ "@call", "@class", "@construct", "@extensible", "@proto", "@scope" }-) *
	MetaData(#md, null) * Extensible(#md, true);

(**************************
 **** BUILT-IN OBJECTS ****
 **************************)

pred BooleanObject (+l:Obj, b:Bool) :
    MetaData(l, #md) * Extensible(l, true) *
	((#md, "@proto")      -> $lbool_proto) *
	((#md, "@class")      -> "Boolean") *
	((#md, "@extensible") -> true) *
	((#md, "@primitiveValue") -> b) *
	MetaData(#md, null) * Extensible(#md, true) *
	empty_fields (#md : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-);
	
pred NumberObject (+l:Obj, n:Num) :
    MetaData(l, #md) * Extensible(l, true) *
	((#md, "@proto")      -> $lnum_proto) *
	((#md, "@class")      -> "Number") *
	((#md, "@extensible") -> true) *
	((#md, "@primitiveValue") -> n) *
	MetaData(#md, null) * Extensible(#md, true) *
	empty_fields (#md : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-);

pred BooleanPrototype () :
    (($lbool_proto, "constructor") -> {{ "d", $lbool, true, false, true }}) *
    MetaData($lbool_proto, #bpmd) * Extensible($lbool_proto, true) *
	((#bpmd, "@proto")          -> $lobj_proto) *
	((#bpmd, "@class")          -> "Boolean") *
	((#bpmd, "@extensible")     -> true) *
	((#bpmd, "@primitiveValue") -> false) *
	MetaData(#bpmd, null) * Extensible(#bpmd, true) *
	empty_fields (#bpmd : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-);
	
pred NumberPrototype () :
    (($lnum_proto, "constructor")    -> {{ "d", $lnum, true, false, true }}) *
    MetaData($lnum_proto, #npmd) * Extensible($lnum_proto, true) *
	((#npmd, "@proto")          -> $lobj_proto) *
	((#npmd, "@class")          -> "Number") *
	((#npmd, "@extensible")     -> true) *
	((#npmd, "@primitiveValue") -> 0) *
	MetaData(#npmd, null) * Extensible(#npmd, true) *
	empty_fields (#npmd : -{ "@class", "@extensible", "@primitiveValue", "@proto" }-);

pred GlobalObject () :
	JSObject ($lg) *
	(($lg, "Error") -> {{ "d", $lerr, true, false, true }});
    
pred ObjectPrototype () :
	JSObjWithProto ($lobj_proto, null) *
    (($lobj_proto, "hasOwnProperty") -> {{ "d", $lop_hasOwnProperty, true, false, true }}) *
    empty_fields ($lobj_proto : -{ "hasOwnProperty" }-);

pred BI_ErrorObject () :
	BIFunctionObject ($lerr, 1, $lerr_proto) *
    MetaData($lerr, #mlerr) * ((#mlerr, "@call") -> "Error_call") * ((#mlerr, "@construct") -> "Error_construct");
 

(************************
 ***** INITIAL HEAP *****
 ************************)
 
(* The abstractions for the initial heap are a bit off *)

pred initialHeapPre () :
    EmptyExtensibleObject ($lg) *
    EmptyExtensibleObject ($lobj_proto) *
    EmptyExtensibleObject ($lfun_proto) *
    EmptyExtensibleObject ($lbool_proto) *
    EmptyExtensibleObject ($lnum_proto) *
    EmptyExtensibleObject ($lerr) *
    EmptyExtensibleObject ($lerr_proto) *
    EmptyExtensibleObject ($lop_hasOwnProperty);
    
pred initialHeapPost (globals) :
	types(globals:Set) *
	
	JSObject ($lg) *
	(($lg, "Error") -> {{ "d", $lerr, true, false, true }}) *
    empty_fields ($lg : -u- (-{ "Error" }-, globals) ) *
    
    ObjectPrototype () *

	JSBIFunction($lop_hasOwnProperty, "OP_hasOwnProperty", 1) * empty_fields($lop_hasOwnProperty : -{ "length" }-) *
    
    JSObjGeneral ($lfun_proto, $lobj_proto, "Function", true) *
    (($lfun_proto, "length") -> {{ "d", 0, false, false, false }}) *
    empty_fields($lfun_proto : -{ "length" }-) *
    MetaData($lfun_proto, #mfp) *
    ((#mfp, "@scope") -> empty) * ((#mfp, "@call") -> "FP_default") *
    empty_fields(#mfp : -{ "@proto", "@class", "@extensible", "@scope", "@call" }-) *
    
    BooleanPrototype () *
    empty_fields ($lbool_proto : -{ "constructor" }-) *

    NumberPrototype () *
    empty_fields ($lnum_proto : -{ "constructor" }-) *
    
    BI_ErrorObject () * empty_fields($lerr : -{ "length", "prototype" }-) *
     
    JSObjGeneral ($lerr_proto, $lobj_proto, "Error", true) * 
    (($lerr_proto, "message") -> {{ "d", "", true, false, true }}) *
    empty_fields($lerr_proto : -{ "message" }-);

pred initialHeapPostWeak ( ) :
	JSObject ($lg) *
	(($lg, "Error") -> {{ "d", $lerr, true, false, true }}) *

    JSObjWithProto ($lobj_proto, null) *
    (($lobj_proto, "hasOwnProperty") -> {{ "d", $lop_hasOwnProperty, true, false, true }}) *
    empty_fields ($lobj_proto : -{ "hasOwnProperty" }-) *

	JSBIFunction($lop_hasOwnProperty, "OP_hasOwnProperty", 1) * empty_fields($lop_hasOwnProperty : -{ "length" }-) *
    
    JSObjGeneral ($lfun_proto, $lobj_proto, "Function", true) *
    (($lfun_proto, "length") -> {{ "d", 0, false, false, false }}) *
    empty_fields($lfun_proto : -{ "length" }-) *
    MetaData($lfun_proto, #mfp) *
    ((#mfp, "@scope") -> empty) * ((#mfp, "@call") -> "FP_default") *
    empty_fields(#mfp : -{ "@proto", "@class", "@extensible", "@scope", "@call" }-) *
    
    BooleanPrototype () *
    empty_fields ($lbool_proto : -{ "constructor" }-) *

    NumberPrototype () *
    empty_fields ($lnum_proto : -{ "constructor" }-) *
    
    BI_ErrorObject () * empty_fields($lerr : -{ "length", "prototype" }-) *
    
    JSObjGeneral ($lerr_proto, $lobj_proto, "Error", true) * 
    (($lerr_proto, "message") -> {{ "d", "", true, false, true }}) *
    empty_fields($lerr_proto : -{ "message" }-);

(***********************
 **** ERROR OBJECTS ****
 ***********************)
 
pred ErrorObject (+l:Obj, pr:Obj) :
	JSObjGeneral(l, pr, "Error", true);

pred ErrorObjectWithMessage (+l:Obj, m:Str) :
	MetaData(l, #md) * Extensible(l, true) *
	((l, "message") -> {{"d", m, true, false, true}}) *
	((#md, "@proto") -> $lerr_proto) * ((#md, "@class") -> "Error") * ((#md, "@extensible") -> true) *
	MetaData(#md, null) * Extensible(#md, true);

pred isTypeError(l:Obj) :
    ErrorObject (l, $lterr_proto) * empty_fields(l : -{ }-);

pred isSyntaxError(l:Obj) :
    ErrorObject (l, $lserr_proto);

pred isReferenceError(l:Obj) :
    ErrorObject (l, $lrferr_proto) * empty_fields(l : -{ }-);

(********************
 **** PROPERTIES ****
 ********************)

pred DataProp (+l:Obj, +prop:Str, v) :
	((l, prop) -> {{ "d", v, true, true, true }}) *
	(! (v == empty));
	
pred DataPropGen (+l:Obj, +prop:Str, v, writ:Bool, enum:Bool, conf:Bool) : 
	((l, prop) -> {{ "d", v, writ, enum, conf }}) *
	(! (v == empty));
	
pred DataPropConst (+l:Obj, +prop:Str, v) :
	((l, prop) -> {{ "d", v, false, #e, false }}) *
	types(#e:Bool) * (! (v == empty));

(*********************
 **** DESCRIPTORS ****
 *********************)
 
 (*
 * Predicate: DataDescriptor
 *
 * Resource: none
 *
 *)
pred DataDescriptor (d:List) :
	(d == {{ "d", #dval, #dwrit, #denum, #dconf }}) *
	types (#dwrit:Bool, #denum:Bool, #dconf:Bool) * 
	(! (#dval == empty));

 (*
 * Predicate: AccessorDescriptor
 *
 * Resource: none
 *
 *)
pred AccessorDescriptor (d:List) :
	(d == {{ "a", #dget, #dset, #denum, #dconf }}) *
	types (#denum:Bool, #dconf:Bool) * 
	(! (#dget == empty)) * (! (#dset == empty));
	
 (*
 * Predicate: Descriptor
 *
 * Resource: none
 *
 *)
pred Descriptor (d:List) :
	DataDescriptor(d),
	AccessorDescriptor(d);

(*
 * Predicate: GenericDescriptor
 *
 * Resource: none
 *
 *)
pred GenericDescriptor (d:List) :
	(d == {{ "g", #genum, #gconf, #gval, #gwrit, #gget, #gset }});

(*
 * Predicate: Projection functions for descriptors
 *
 * Resource: none
 *
 *)
pred desc_val (d:List, v) :
    v == l-nth(d, 1);

pred desc_writ (d:List, v) :
    v == l-nth(d, 2);

pred desc_get (d:List, v) :
    v == l-nth(d, 1);

pred desc_set (d:List, v) :
    v == l-nth(d, 2);

pred desc_enum (d:List, v) :
    v == l-nth(d, 3);

pred desc_conf (d:List, v) :
    v == l-nth(d, 4);
    
(*********************
 **** OBJECT CELL ****
 *********************) 

(*
 * Predicate: Cell_o(l, prop, X)
 *
 * Resource:
 *      (l, prop)
 *
 *)
pred Cell_o (+l:Obj, +prop:Str, d) :
    ((l, prop) -> d) * (d == none),
    ((l, prop) -> d) * DataDescriptor(d);
    
(***************************
 **** TODO: STRING CELL ****
 ***************************) 
 
 (*
 * Predicate: Cell_s(l, prop, X)
 *
 * Resource:
 *      (l, prop)
 *
 *)
pred Cell_s (+l:Obj, +prop:Str, d) :
    ((l, prop) -> d) * DataDescriptor(d),
    ((l, prop) -> d) * AccessorDescriptor(d);
 
(**************************
 **** CLASS CLASSIFIERS ***
 **************************)	
 
(*
 * Predicate: isClass(c, X)
 *
 * Resource:
 *      (l, "@class")
 *
 *)
pred isClass (c:Str, case:Str) :
	(case == "Array")      * (c == "Array"),
	(case == "String")     * (c == "String"),
	(case == "Non-Array")  * (! (c == "Array")),
	(case == "Non-String") * (! (c == "String"));	

(**********************************
 **** PI: PROTOTYPE INHERITANCE ***
 **********************************)

pred Pi (+l:Obj, +prop:Str, d, ls:List, lcls:List, lpv:List) :

    (* Any object, cell exists in the heap *)
    Cell_o (l, prop, d) * DataDescriptor(d) *
	MetaData(l, #md) * ((#md, "@class") -> #cls) * types(#cls:Str) *
    (ls == {{ l }}) * (lcls == {{ #cls }}) * (lpv == {{ "" }}),

	(* Non-string object, cell does not exist in the heap, down the prototype chain *)
    Cell_o (l, prop, none) *
	MetaData(l, #md) * ((#md, "@class") -> #cls) * isClass (#cls, "Non-String") * ((#md, "@proto") -> #lp) *
	(ls == l :: #lls) * (lcls == #cls :: #lcls) * (lpv == "" :: #lpv) * types(#cls:Str) *
	(#lls == #lp :: #ols) * (#lcls == #pcls :: #ocls) * (#lpv == #ppv :: #otv) *
	types(#lp:Obj, #pcls:Str, #ppv:Str) *
	Pi (#lp, prop, d, #lls, #lcls, #lpv),
	
	(* Non-string object, cell does not exist in the heap, end of prototype chain *)
    Cell_o (l, prop, none) * (d == undefined) *
    MetaData(l, #md) * ((#md, "@class") -> #cls) * isClass (#cls, "Non-String") *  ((#md, "@proto") -> null) * 
    (ls == {{ l }}) * (lcls == {{ #cls }}) * (lpv == {{ "" }});
    