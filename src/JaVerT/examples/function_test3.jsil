import javert_internal_functions, javert_logic_macros, javert_js_predicates;

pred counter (c, c_val) : function_object(c, {{ #fid_1_f1, $lg }}, "fcounter", "fcounter", 0., #c_proto) * (#c_sc == {{ #fid_1_f1, $lg }}) * types(#fid_1_f1 : $$object_type) * ((#c_proto, "constructor") -> {{ "d", c, $$t, $$f, $$t }}) * ((#fid_0_f1, "x") -> c_val) * (#c_sc == {{ #fid_0_f1, $lg }}) * types(c_val : $$number_type);

spec fcounter (x__scope, x__this)
 	[[ (x__this == #this) * (! (#fid_f1 == $lg)) * types(#fid_f1 : $$object_type) * (x__scope == {{ #fid_f1, $lg }}) * initialHeapPost() * ((#fid_f1, "x") -> #x) * types(#x : $$number_type) ]]
	[[ (x__this == #this) * initialHeapPost() * ((#fid_f1, "x") -> (#x + 1.)) * (ret == #) ]]
	normal

proc fcounter (x__scope, x__this) {
			x__er := new();
			[x__er, "@er"] := $$t;
			x_sc_0 := (x__er :: x__scope);
			x__te := "TypeError"();
			x__se := "SyntaxError"();
			x_0 := l-nth(x_sc_0, 1.);
			x_1 := {{ "v", x_0, "x" }};
			goto [(((typeOf(x_1) = $$list_type) and (l-nth(x_1, 0.) = "v")) and ((l-nth(x_1, 2.) = "eval") or (l-nth(x_1, 2.) = "arguments")))] pre_elab lab_0;
			[* GPVFold(x_1, #x4, #x3, #x2, #x1, #x0) *]
	lab_0:		x_1_v := "i__getValue"(x_1) with pre_elab
			[+ GPVUnfold(x_1) +];
			x_1_n := "i__toNumber"(x_1_v) with pre_elab;
			x_2 := (x_1_n + 1.);
			[* GPVFold(x_1, #x9, #x8, #x7, #x6, #x5) *]
			x_3 := "i__putValue"(x_1, x_2) with pre_elab
			[+ GPVUnfold(x_1) +];
			[* GPVFold(x_1_n, #x14, #x13, #x12, #x11, #x10) *]
			x_1_n_v := "i__getValue"(x_1_n) with pre_elab
			[+ GPVUnfold(x_1_n) +];
			goto pre_rlab;
			x_4 := $$empty;
	pre_rlab:	xret := PHI(x_1_n_v, x_4);
			deleteObject (x__te);
			deleteObject (x__se);
	rlab:		skip;
	pre_elab:	xerr := PHI(x__se, x_1_v, x_1_n, x_3, x_1_n_v);
	elab:		skip
} with {
	ret: xret, rlab;
	err: xerr, elab;
};

proc main () {
			x_5 := "setupInitialHeap"();
			x_sc_1 := {{ $lg }};
			x__this := $lg;
			[$lg, "f1"] := {{ "d", $$undefined, $$t, $$t, $$f }};
			x__te := "TypeError"();
			x__se := "SyntaxError"();
			x_f_0 := "create_function_object"(x_sc_1, "f1", "f1", {{ "x" }});
			[* GPVFold(x_f_0, #x19, #x18, #x17, #x16, #x15) *]
			x_f_0_v := "i__getValue"(x_f_0) with elab
			[+ GPVUnfold(x_f_0) +];
			x_6 := l-nth(x_sc_1, 0.);
			x_7 := {{ "v", x_6, "f1" }};
			x_8 := "i__checkAssignmentErrors"(x_7) with elab;
			[* GPVFold(x_7, #x24, #x23, #x22, #x21, #x20) *]
			x_9 := "i__putValue"(x_7, x_f_0_v) with elab
			[+ GPVUnfold(x_7) +];
			x_10 := $$empty;
			xret := x_10;
			deleteObject (x__te);
			deleteObject (x__se);
	rlab:		skip;
	elab:		xerr := PHI(x_f_0_v, x_8, x_9)
} with {
	ret: xret, rlab;
	err: xerr, elab;
};

spec f1 (x__scope, x__this, x)
 	[[ (x__this == #this) * (x__scope == {{ $lg }}) * initialHeapPost() * emp * (x == #x) * types(#x : $$number_type) ]]
	[[ (x__this == #this) * initialHeapPost() * counter(ret, #x) ]]
	normal

proc f1 (x__scope, x__this, x) {
			x__er := new();
			[x__er, "@er"] := $$t;
			[x__er, "x"] := x;
			x_sc_2 := (x__er :: x__scope);
			x__te := "TypeError"();
			x__se := "SyntaxError"();
			x_f_1 := "create_function_object"(x_sc_2, "fcounter", "fcounter", $$nil);
			[* GPVFold(x_f_1, #x29, #x28, #x27, #x26, #x25) *]
			x_f_1_v := "i__getValue"(x_f_1) with pre_elab
			[+ GPVUnfold(x_f_1) +];
			goto pre_rlab;
			x_11 := $$empty;
	pre_rlab:	xret := PHI(x_f_1_v, x_11);
			deleteObject (x__te);
			deleteObject (x__se);
	rlab:		skip;
	pre_elab:	xerr := x_f_1_v;
	elab:		skip
} with {
	ret: xret, rlab;
	err: xerr, elab;
};
