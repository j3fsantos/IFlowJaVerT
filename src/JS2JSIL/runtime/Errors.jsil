import Internals.jsil, Init.jsil;

(* ***************** *)
(* THE ERROR LIBRARY *)
(* ***************** *)

proc Error_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lerr_proto, "Error", $$t);

			xret := "Error_construct" ($$undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

proc Error_construct (xsc, vthis, v) {
			xret := vthis;

			[vthis, "@class"] := "Error";
			[vthis, "@extensible"] := $$t;

			goto [v = $$undefined] rlab mess;

	mess:	xerr := "i__toString" (v) with elab;
			[xret, "message"] := {{ "d", xerr, $$t, $$f, $$t }};

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xerr, elab;
};

proc Error (v) {
			xret := "Error_call" ($$undefined, $$undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};


(* *** TOSTRING *** *)

proc EP_toString(xsc, vthis) {
			goto [typeOf(vthis) = $$object_type] init throw;

	init:	name := "";
			xret := "get" (vthis, "name") with elab;
			goto [xret = $$undefined] msg ndef;

	ndef:	xret := "i__toString" (xret) with elab;
			name := xret;

	msg:	msg := "";
			xret := "get" (vthis, "message") with elab;
			goto [xret = $$undefined] ccat mdef;

	mdef:	xret := "i__toString" (xret) with elab;
			msg := xret;

	ccat:	goto [name = ""] nemp cmsg;

	nemp:	xret := msg;
			goto rlab;

	cmsg:	goto [msg = ""] memp cc;

	memp:	xret := name;
			goto rlab;

	cc:		xret := name ++ ": " ++ msg;

	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* ***************** *)
(* THE NATIVE ERRORS *)
(* ***************** *)

(* *** EVALERROR *** *)

proc EvalError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $leerr_proto, "Error", $$t);

			xret := "Error_construct" ($$undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

proc EvalError (v) {
			xret := "EvalError_call" ($$undefined, $$undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** RANGEERROR *** *)

proc RangeError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lrgerr_proto, "Error", $$t);

			xret := "Error_construct" ($$undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

proc RangeError (v) {
			xret := "RangeError_call" ($$undefined, $$undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** REFERENCEERROR *** *)

proc ReferenceError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lrferr_proto, "Error", $$t);

			xret := "Error_construct" ($$undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

proc ReferenceError (v) {
			xret := "ReferenceError_call" ($$undefined, $$undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** SYNTAXERROR *** *)

proc SyntaxError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lserr_proto, "Error", $$t);

			xret := "Error_construct" ($$undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

proc SyntaxError (v) {
			xret := "SyntaxError_call" ($$undefined, $$undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** TYPEERROR *** *)

proc TypeError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $lterr_proto, "Error", $$t);

			xret := "Error_construct" ($$undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

proc TypeError (v) {
			xret := "TypeError_call" ($$undefined, $$undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};



(* *** URIERROR *** *)

proc URIError_call (xsc, vthis, v) {
			xret := new ();
			xret := "create_default_object" (xret, $luerr_proto, "Error", $$t);

			xret := "Error_construct" ($$undefined, xret, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

proc URIError (v) {
			xret := "URIError_call" ($$undefined, $$undefined, v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* 13.2.3.8 [[ThrowTypeError]] *)
proc ThrowTypeError (xsc, vthis) {
		xerr := "TypeError_call" ($$undefined, $$undefined, "Attempt to access function `caller` or `arguments`");
	elab:	skip
}
with
{
	err: xerr, elab;
};
