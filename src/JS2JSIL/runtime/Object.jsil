import Internals.jsil;

(* ****************** *)
(* THE OBJECT LIBRARY *)
(* ****************** *)

(*  
	Procedure: i__getFields

	Returns the list of properties of 
		object at a given location l
	
	The list doesn't include internals
		
	If the object is a string object,
		then it has additional properties
*)
proc i__getFields (l) {
			xret := getFields (l);

			m := metadata(l);
			class := [m, "@class"];
			goto [class = "String"] add rlab;

	add:	str := [m, "@primitiveValue"];
			len := s-len (str);

			n := len - 1;

	loop:	goto [n < 0] rlab head;
	head:	sn := num_to_string n;
			xret := sn :: xret;
			n := n - 1;
			goto loop;

	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* *** GETENUMERABLEFIELDS *** *)

proc i__getEnumerableFields (l) {
			prop_list := "i__getFields" (l);
			xret := "i__getEnumerableFieldsIter" (l, prop_list);

	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* *** GETENUMERABLEFIELDSITER *** *)

proc i__getEnumerableFieldsIter (l, prop_list) {
			goto [prop_list = nil] nill init;

	nill:	xret := nil;
			goto rlab;

	init:	xh := car prop_list;
			xt := cdr prop_list;

			prop := "getOwnProperty" (l, xh);
			goto [l-nth (prop, 3) = true] yes no;

	no:		fh := nil;
			goto rcall;

	yes:	fh := xh;

	rcall:	ft := "i__getEnumerableFieldsIter" (l, xt);

			xret := fh :: ft;
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* *** GETENUMERABLEFIELDSWITHVALUES *** *)

proc i__getEnumerableFieldsWithValues (l) {
			prop_list := "i__getEnumerableFields" (l);
			xret := "i__getEnumerableFieldsWithValuesIter" (l, prop_list) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** GETENUMERABLEFIELDSWITHVALUESITER *** *)

proc i__getEnumerableFieldsWithValuesIter (l, prop_list, g) {
			goto [prop_list = nil] nill init;

	nill:	xret := {{ nil, nil }};
			goto rlab;

	init:	xh := car prop_list;
			xt := cdr prop_list;

			xret := "get" (l, xh) with elab;
			xret := "i__toPropertyDescriptor" (xret) with elab;

			fh := xret;

	rcall:	xret := "i__getEnumerableFieldsWithValuesIter" (l, xt) with elab;

			xret := {{ prop_list , (fh :: l-nth (xret, 1)) }};

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** GETALLENUMERABLEFIELDS *** *)

proc i__getAllEnumerableFields (l) {
			props := new ();
			xret := "i__getAllEnumerableFieldsIter" (l, props, l);
	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* *** GETALLENUMERABLEFIELDSITER *** *)

proc i__getAllEnumerableFieldsIter (l, props, b) {

			enums := "i__getEnumerableFields" (l);

			len := l-len (enums);
			n := 0;
	loop:	goto [n < len] head next;

	head:	hf := hasField (props, l-nth (enums, n));
			goto [hf] inc test;
	test:	goto [l = b] add bf;
	bf:		hf := hasField (b, l-nth (enums, n));
			goto [hf] inc add;
	add:	[props, l-nth (enums, n)] := {{ "d", l, false, false, false }};
	inc:	n := n + 1;
			goto loop;

	next:	m := metadata(l);
			l := [m, "@proto"];
			goto [l = null] end deeper;

	deeper:	xret := "i__getAllEnumerableFieldsIter" (l, props, b);

	end:	xret := props;

	rlab:	skip
}
with
{
	ret:	xret, rlab;
};

(* *** CALL *** *)

proc Object_call (xsc, vthis, v) {
			goto [(v = undefined) or (v = null) or (v = empty)] cns to_obj;

	cns:	xret := "Object_construct" (xsc, vthis, v);
			goto rlab;

	to_obj:	xret := "i__toObject" (v) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* *** CONSTRUCT *** *)

proc Object_construct (xsc, vthis, l) {
			l := l;

			goto [typeOf l = Obj] obj l1b;
	obj:	xret := l;
			goto rlab;

	l1b:	goto [(typeOf l = Bool) or (typeOf l = Num) or (typeOf l = Str)] to_obj norm;
	to_obj:	xret := "i__toObject" (l);
			goto rlab;

	norm:	xmet := new ();
			xret := new (xmet);
			xret := "create_default_object" (xret, $lobj_proto, "Object", true);
	rlab:	skip
}
with
{
	ret: xret, rlab;
};

(* *** GETPROTOTYPEOF *** *)

proc Object_getPrototypeOf (xsc, vthis, o) {
			goto [typeOf o = Obj] proto throw;

	proto:	m := metadata(o);
			xret := [m, "@proto"];

	rlab:	skip;

	throw:	xerr := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xerr, elab;
};

(* *** GETOWNPROPERTYDESCRIPTOR *** *)

proc Object_getOwnPropertyDescriptor (xsc, vthis, o, prop) {
			goto [typeOf o = Obj] start throw;

	start:	xret := "i__toString" (prop) with elab;
			xret := "getOwnProperty" (o, xret) with elab;

			xret := "i__fromPropertyDescriptor" (xret) with elab;

	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** GETOWNPROPERTYNAMES *** *)

proc Object_getOwnPropertyNames (xsc, vthis, o) {
			goto [not (typeOf o = Obj)] throw start;

	start:	xret := "Array_construct" (xsc, vthis) with elab;

			n := 0;
			l := xret;
			props := "i__getFields" (o);
			len := l-len (props);

	loop:	goto [n < len] head end;
	head:	xret := "defineOwnProperty" (l, num_to_string n, {{ "d", l-nth (props, n), true, true, true }}, false) with elab;
			n := n + 1;
			goto loop;

	end:	xret := l;
	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** CREATE *** *)

proc Object_create (xsc, vthis, o, props) {
			goto [(typeOf o = Obj) or (o = null)] main throw;

	main:	xret := "Object_construct" () with elab;
			m := metadata(xret);
			[m, "@proto"] := o;

			goto [props = undefined] rlab props;

	props:	xret := "Object_defineProperties" (xsc, vthis, xret, props) with elab;

	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** DEFINEPROPERTY *** *)

proc Object_defineProperty (xsc, vthis, o, prop, attr) {
			goto [typeOf o = Obj] main throw;

	main:	xret := "i__toString" (prop) with elab;
			prop := xret;

			xret := "i__toPropertyDescriptor" (attr) with elab;

			xret := "defineOwnProperty" (o, prop, xret, true) with elab;

	end:	xret := o;
	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** DEFINEPROPERTIES *** *)

proc Object_defineProperties (xsc, vthis, o, props) {
			goto [not (typeOf o = Obj)] throw start;

	start:	xret := "i__toObject" (props) with elab;
			props := xret;

			xret := "i__getEnumerableFieldsWithValues" (props) with elab;

			props := l-nth (xret, 0);
			descs := l-nth (xret, 1);

			n := 0;
			len := l-len (props);

	loop:	goto [n < len] head end;
	head:	xret := "defineOwnProperty" (o, l-nth (props, n), l-nth (descs, n), true) with elab;
			n := n + 1;
			goto loop;

	end:	xret := o;
	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** PREVENTEXTENSIONS *** *)

proc Object_preventExtensions (xsc, vthis, o) {
			goto [typeOf o = Obj] start throw;

	start:	m := metadata(o);
			[m, "@extensible"] := false;
			xret := o;

	rlab: 	skip;

	throw:	xerr := "TypeError" ();
	elab: 	skip
}
with
{
	ret: 	xret, rlab;
	err:	xerr, elab;
};

(* *** SEAL *** *)

proc Object_seal (xsc, vthis, o) {
			goto [typeOf o = Obj] start throw;

	start:	props := "i__getFields" (o);

			n := 0;
			len := l-len (props);

	loop:	goto [n < len] head ext;
	head:	xret := "getOwnProperty" (o, l-nth (props, n)) with elab;
			xret := "defineOwnProperty" (o, l-nth (props, n), {{ l-nth (xret, 0), l-nth (xret, 1), l-nth (xret, 2), l-nth (xret, 3), false }}, true) with elab;
	next:	n := n + 1;
			goto loop;

	ext:	m := metadata(o);
			[m, "@extensible"] := false;
			xret := o;

	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab: 	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** ISSEALED *** *)

proc Object_isSealed (xsc, vthis, o) {
			goto [typeOf o = Obj] start throw;

	start:	props := "i__getFields" (o);

			n := 0;
			len := l-len (props);

	loop:	goto [n < len] head ext;
	head:	xret := "getOwnProperty" (o, l-nth (props, n)) with elab;
			goto [l-nth (xret, 4) = true] r_f next;
	next:	n := n + 1;
			goto loop;

	ext:	m := metadata(o);
			xret := [m, "@extensible"];
			goto [xret] r_f r_t;

	r_t:	xret := true;
			goto rlab;

	r_f:	xret := false;

	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab: 	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** FREEZE *** *)

proc Object_freeze (xsc, vthis, o) {
			goto [typeOf o = Obj] start throw;

	start:	props := "i__getFields" (o);

			n := 0;
			len := l-len (props);

	loop:	goto [n < len] head ext;
	head:	xret := "getOwnProperty" (o, l-nth (props, n)) with elab;
			ws := l-nth (xret, 2);
			goto [ws = true] set_w cf;
	set_w:	ws := false;
	cf:		xret := "defineOwnProperty" (o, l-nth (props, n), {{ l-nth (xret, 0), l-nth (xret, 1), ws, l-nth (xret, 3), false }}, true) with elab;
	next:	n := n + 1;
			goto loop;

	ext:	m := metadata(o);
			[m, "@extensible"] := false;
			xret := o;

	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab: 	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** ISFROZEN *** *)

proc Object_isFrozen (xsc, vthis, o) {
			goto [typeOf o = Obj] start throw;

	start:	props := "i__getFields" (o);

			n := 0;
			len := l-len (props);

	loop:	goto [n < len] head ext;
	head:	xret := "getOwnProperty" (o, l-nth (props, n)) with elab;
			goto [l-nth (xret, 2) = true] r_f cf;
	cf:		goto [l-nth (xret, 4) = true] r_f next;
	next:	n := n + 1;
			goto loop;

	ext:	m := metadata(o);
			xret := [m, "@extensible"];
			goto [xret] r_f r_t;

	r_t:	xret := true;
			goto rlab;

	r_f:	xret := false;

	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab: 	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** ISEXTENSIBLE *** *)

proc Object_isExtensible (xsc, vthis, o) {
			goto [typeOf o = Obj] start throw;

	start: 	m := metadata(o);
			xret := [m, "@extensible"];
	rlab:	skip;

	throw:	xerr := "TypeError" ();
	elab: 	skip
}
with
{
	ret: 	xret, rlab;
	err:	xerr, elab;
};

(* *** KEYS *** *)

proc Object_keys (xsc, vthis, o) {
			goto [not (typeOf o = Obj)] throw start;

	start:	xret := "Array_construct" () with elab;

			n := 0;
			l := xret;
			props := "i__getEnumerableFields" (o);
			len := l-len (props);

	loop:	goto [n < len] head end;
	head:	xret := "defineOwnProperty" (l, num_to_string n, {{ "d", l-nth (props, n), true, true, true }}, false) with elab;
			n := n + 1;
			goto loop;

	end:	xret := l;
	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* **************** *)
(* OBJECT.PROTOTYPE *)
(* **************** *)

(* *** TOSTRING*** *)

proc OP_toString(xsc, vthis) {
			goto [vthis = undefined] undef def;

	undef: 	xret := "[object Undefined]";
			goto rlab;

	def:	goto [vthis = null] nul nnull;

	nul:	xret := "[object Null]";
			goto rlab;

	nnull:	xret := "i__toObject" (vthis) with elab;
			m := metadata(xret);
			c := [m, "@class"];
			xret := "[object " ++ c ++ "]";

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err: 	xret, elab;
};

(* *** TOLOCALESTRING *** *)

proc OP_toLocaleString(xsc, vthis) {
			xret := "i__toObject" (vthis) with elab;
			o := xret;

			xret := "get" (o, "toString") with elab;
			c := "i__isCallable" (xret);
            goto [c] call throw;

	call:	m := metadata(xret);
			scp := [m, "@scope"];
			fun := [m, "@call"];
			xret := fun (scp, vthis) with elab;

	rlab:	skip;

	throw: 	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err: 	xret, elab;
};

(* *** VALUEOF *** *)

proc OP_valueOf(xsc, vthis) {
			xret := "i__toObject" (vthis) with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};


(* *** HASOWNPROPERTY*** *)

proc OP_hasOwnProperty(xsc, vthis, v) {
			xret := "i__toString" (v) with elab;
			p := xret;

			xret := "i__toObject" (vthis) with elab;
			xret := "getOwnProperty" (xret, p) with elab;

			goto [xret = undefined] undef def;

	undef:  xret := false;
			goto rlab;

	def:	xret := true;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};


(* *** ISPROTOTYPEOF *** *)

proc OP_isPrototypeOf(xsc, vthis, v) {
			goto [typeOf v = Obj] obj fret;

	obj:	xret := "i__toObject" (vthis) with elab;

	rep:	m := metadata(v);
			v := [m, "@proto"];
			goto [v = null] fret nnull;

	nnull:  goto [v = xret] tret rep;

	tret: 	xret := true;
			goto rlab;

	fret: 	xret := false;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** PROPERTYISENUMERABLE *** *)

proc OP_propertyIsEnumerable(xsc, vthis, v) {
			xret := "i__toString" (v) with elab;
			p := xret;

			xret := "i__toObject" (vthis) with elab;
			xret := "getOwnProperty" (xret, p) with elab;

			goto [xret = undefined] undef def;

	undef:  xret := false;
			goto rlab;

	def:	xret := l-nth (xret, 3);

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};
