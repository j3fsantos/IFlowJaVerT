import Object.jsil;

(*  
	Procedure: create_default_object

	Creates an object at a given location l, 
		with prototype pr, 
		     class cl, and 
		     extensibility ext 
		     
	Doesn't throw an error
*)
proc create_default_object (l, pr, cl, ext) {

			goto [cl = undefined] scl text;
	scl:	cl := "Object";
	text:	goto [ext = undefined] sext setall;
	sext:	ext := true;

			(* Get the metadata, creating the object in the process *)
	setall:	m := metadata(l);
	
			(* ASSERT: m is an empty object with metadata null *)
			
			(* Set the internal properties in the metadata *)
			[m, "@proto"] := pr;
			[m, "@class"] := cl;
			[m, "@extensible"] := ext;

	rlab:	xret := l
}
with
{
	ret:	xret, rlab;
};


(*  
	Procedure: create_object_with_call_construct

	Creates an object at location l 
		with caller call,
		     constructor construct, and
		     length len 
		     
	Doesn't throw an error
*)
proc create_object_with_call_construct (l, call, construct, len) {

			xret := "create_default_object" (l, $lfun_proto, "Function", true);

			[xret, "length"] := {{ "d", len, false, false, false }};

			(* Get the metadata *)
			m := metadata(xret);
			
			(* Set the internal scope, call and construct properties *)
			[m, "@scope"] := empty;
			[m, "@call"] := call;
			
			goto [construct = empty] rlab cstr;

	cstr:	[m, "@construct"] := construct;

	rlab:	xret := l
}
with
{
	ret:	xret, rlab;
};


(*  
	Procedure: create_function_object

	Creates an new function object 
		with scope chain xsc,
		     caller call,
		     constructor construct, and
		     parameters params 
		     
	Doesn't throw an error
*)
proc create_function_object (xsc, call, construct, params) {
			len := l-len (params);
			m := new (null);
			l := new (m);
			l := "create_object_with_call_construct" (l, call, construct, len);

			[m, "@scope"] := xsc;

			prototype := "Object_construct" ();
			[prototype, "constructor"] := {{ "d", l, true, false, true }};
			[l, "prototype"]           := {{ "d", prototype, true, false, false }};

			(* Strict mode only *)
			[l, "caller"]    := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};
			[l, "arguments"] := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};

			xret := l;

	rlab:	skip
}
with
{
	ret:	xret, rlab;
};


(*  
	Procedure: setupInitialHeap

	Creates the JavaScript initial heap
			     
	Doesn't throw an error
*)
proc setupInitialHeap () {

  			(* Function object *)

  			xret := "create_object_with_call_construct" ($lfun, "Function_call", "Function_construct", 1);

  			[$lfun, "prototype"] := {{ "d", $lfun_proto, false, false, false }};

  			(* Function.prototype *)

   			xret := "create_object_with_call_construct" ($lfun_proto, "FP_default", empty, 0);
   			m := metadata($lfun_proto); 
   			[m, "@proto"] := $lobj_proto;

  			[$lfun_proto, "constructor"] := {{ "d", $lfun, true, false, true }};
  			[$lfun_proto, "toString"]    := {{ "d", $lfp_toString, true, false, true }};
  			[$lfun_proto, "call"]        := {{ "d", $lfp_call, true, false, true }};
  			[$lfun_proto, "apply"]       := {{ "d", $lfp_apply, true, false, true }};
  			[$lfun_proto, "bind"]        := {{ "d", $lfp_bind, true, false, true }};

			xret := "create_object_with_call_construct" ($lfp_toString, "FP_toString", empty, 0);
  			xret := "create_object_with_call_construct" ($lfp_call, "FP_call", empty, 1);
 			xret := "create_object_with_call_construct" ($lfp_apply, "FP_apply", empty, 2);
  			xret := "create_object_with_call_construct" ($lfp_bind, "FP_bind", empty, 1);


			(* Boolean object *)

			xret := "create_object_with_call_construct" ($lbool, "Boolean_call", "Boolean_construct", 1);

			[$lbool, "prototype"] := {{ "d", $lbool_proto, false, false, false }};

			(* Boolean.prototype *)

			xret := "create_default_object" ($lbool_proto, $lobj_proto, "Boolean", true);
			
			m := metadata($lbool_proto); 
			[m, "@primitiveValue"] := false;

			[$lbool_proto, "constructor"] := {{ "d", $lbool, true, false, true }};
			[$lbool_proto, "toString"]    := {{ "d", $lbp_toString, true, false, true }};
			[$lbool_proto, "valueOf"]     := {{ "d", $lbp_valueOf, true, false, true }};

			xret := "create_object_with_call_construct" ($lbp_toString, "BP_toString", empty, 0);
			xret := "create_object_with_call_construct" ($lbp_valueOf, "BP_valueOf", empty, 0);

			(* Number object *)

			xret := "create_object_with_call_construct" ($lnum, "Number_call", "Number_construct", 1);

			[$lnum, "prototype"]         := {{ "d", $lnum_proto, false, false, false }};
			[$lnum, "MAX_VALUE"]         := {{ "d", $$max_float, false, false, false }};
			[$lnum, "MIN_VALUE"]         := {{ "d", $$min_float, false, false, false }};
			[$lnum, "NaN"]               := {{ "d", nan, false, false, false }};
			[$lnum, "POSITIVE_INFINITY"] := {{ "d", inf, false, false, false }};
			[$lnum, "NEGATIVE_INFINITY"] := {{ "d", -inf, false, false, false }};

			(* Number.prototype *)

			xret := "create_default_object" ($lnum_proto, $lobj_proto, "Number", true);

			m := metadata($lnum_proto);
			[m,           "@primitiveValue"]      := 0;
			[$lnum_proto, "constructor"]          := {{ "d", $lnum, true, false, true }};
			[$lnum_proto, "toString"]             := {{ "d", $lnp_toString, true, false, true }};
			[$lnum_proto, "valueOf"]              := {{ "d", $lnp_valueOf, true, false, true }};

			xret := "create_object_with_call_construct" ($lnp_toString, "NP_toString", empty, 1);
			xret := "create_object_with_call_construct" ($lnp_valueOf, "NP_valueOf", empty, 0);

			(* Math object *)

			xret := "create_default_object" ($lmath, $lobj_proto, "Math", true);

			[$lmath, "E"]       := {{ "d", $$e,       false, false, false }};
			[$lmath, "LN10"]    := {{ "d", $$ln10,    false, false, false }};
			[$lmath, "LN2"]     := {{ "d", $$ln2,     false, false, false }};
			[$lmath, "LOG2E"]   := {{ "d", $$log2e,   false, false, false }};
			[$lmath, "LOG10E"]  := {{ "d", $$log10e,  false, false, false }};
			[$lmath, "PI"]      := {{ "d", $$pi,      false, false, false }};
			[$lmath, "SQRT1_2"] := {{ "d", $$sqrt1_2, false, false, false }};
			[$lmath, "SQRT2"]   := {{ "d", $$sqrt2,   false, false, false }};

			[$lmath, "ceil"]   := {{ "d", $lmath_ceil, true, false, true }};
			[$lmath, "floor"]  := {{ "d", $lmath_floor, true, false, true }};
			[$lmath, "max"]    := {{ "d", $lmath_max, true, false, true }};

			xret := "create_object_with_call_construct" ($lmath_ceil, "M_ceil", empty, 1);
			xret := "create_object_with_call_construct" ($lmath_floor, "M_floor", empty, 1);
			xret := "create_object_with_call_construct" ($lmath_max, "M_max", empty, 2);

			(* Error object *)

			xret := "create_object_with_call_construct" ($lerr, "Error_call", "Error_construct", 1);

			[$lerr, "prototype"]         := {{ "d", $lerr_proto, false, false, false }};

			(* Error.prototype *)

			xret := "create_default_object" ($lerr_proto, $lobj_proto, "Error", true);

			[$lerr_proto, "constructor"] := {{ "d", $lerr, true, false, true }};
			[$lerr_proto, "name"]        := {{ "d", "Error", true, false, true }};
			[$lerr_proto, "message"]     := {{ "d", "", true, false, true }};
			[$lerr_proto, "toString"]    := {{ "d", $lep_toString, true, false, true }};

			xret := "create_object_with_call_construct" ($lep_toString, "EP_toString", empty, 0);

			(* Native errors *)

			xret := "create_object_with_call_construct" ($lrgerr, "RangeError_call",     "Error_construct", 1);
			xret := "create_object_with_call_construct" ($lrferr, "ReferenceError_call", "Error_construct", 1);
			xret := "create_object_with_call_construct" ($lserr,  "SyntaxError_call",    "Error_construct", 1);
			xret := "create_object_with_call_construct" ($lterr,  "TypeError_call",      "Error_construct", 1);

			[$lrgerr, "prototype"] := {{ "d", $lrgerr_proto, false, false, false }};
			[$lrferr, "prototype"] := {{ "d", $lrferr_proto, false, false, false }};
			[$lserr,  "prototype"] := {{ "d", $lserr_proto, false, false, false }};
			[$lterr,  "prototype"] := {{ "d", $lterr_proto, false, false, false }};

			[$lrgerr, "name"] := {{ "d", "RangeError", true, false, true }};
			[$lrferr, "name"] := {{ "d", "ReferenceError", true, false, true }};
			[$lserr,  "name"] := {{ "d", "SyntaxError", true, false, true }};
			[$lterr,  "name"] := {{ "d", "TypeError", true, false, true }};

			(* Native error prototypes *)

			xret := "create_default_object" ($lrgerr_proto, $lerr_proto, "Error", true);
			xret := "create_default_object" ($lrferr_proto, $lerr_proto, "Error", true);
			xret := "create_default_object" ($lserr_proto,  $lerr_proto, "Error", true);
			xret := "create_default_object" ($lterr_proto,  $lerr_proto, "Error", true);

			[$lrgerr_proto, "constructor"]    := {{ "d", $lrgerr, true, false, true }};
			[$lrferr_proto, "constructor"]    := {{ "d", $lrferr, true, false, true }};
			[$lserr_proto,  "constructor"]    := {{ "d", $lserr, true, false, true }};
			[$lterr_proto,  "constructor"]    := {{ "d", $lterr, true, false, true }};

			[$lrgerr_proto, "name"]    := {{ "d", "RangeError", true, false, true }};
			[$lrferr_proto, "name"]    := {{ "d", "ReferenceError", true, false, true }};
			[$lserr_proto,  "name"]    := {{ "d", "SyntaxError", true, false, true }};
			[$lterr_proto,  "name"]    := {{ "d", "TypeError", true, false, true }};

			[$lrgerr_proto, "message"]    := {{ "d", "", true, false, true }};
			[$lrferr_proto, "message"]    := {{ "d", "", true, false, true }};
			[$lserr_proto,  "message"]    := {{ "d", "", true, false, true }};
			[$lterr_proto,  "message"]    := {{ "d", "", true, false, true }};

			(* 13.2.3 The [[ThrowTypeError]] Function Object *)
			(* Note, this object doesn't follow the standard Function object construction *)
			xret := "create_default_object" ($lthrow_type_error, $lfun_proto, "Function", false);
			
			m := metadata(xret);
			[m, "@scope"] := empty;
			[m, "@formalParameters"] := {{ }};
			[m, "@call"] := "ThrowTypeError";
			[xret, "length"] := {{ "d", 0, false, false, false }};		

  			(* Array object *)

  			xret := "create_object_with_call_construct" ($larr, "Array_call", "Array_construct", 1);

  			[$larr, "prototype"] := {{ "d", $larr_proto, false, false, false }};
  			[$larr, "isArray"]   := {{ "d", $larr_isArray, true, false, true }};

			xret := "create_object_with_call_construct" ($larr_isArray, "Array_isArray", empty, 1);

			(* Array.prototype *)

			xret := "create_default_object" ($larr_proto, $lobj_proto, "Array", true);

			[$larr_proto, "length"]         := {{ "d", 0, true, false, false }};
			[$larr_proto, "constructor"]    := {{ "d", $larr, true, false, true }};
			[$larr_proto, "toString"]       := {{ "d", $lap_toString, true, false, true }};
			[$larr_proto, "concat"]         := {{ "d", $lap_concat, true, false, true }};
			[$larr_proto, "pop"]            := {{ "d", $lap_pop, true, false, true }};
			[$larr_proto, "push"]           := {{ "d", $lap_push, true, false, true }};
			[$larr_proto, "reverse"]        := {{ "d", $lap_reverse, true, false, true }};
			[$larr_proto, "sort"]           := {{ "d", $lap_sort, true, false, true }};
			[$larr_proto, "splice"]         := {{ "d", $lap_splice, true, false, true }};
			[$larr_proto, "indexOf"]        := {{ "d", $lap_indexOf, true, false, true }};
			[$larr_proto, "lastIndexOf"]    := {{ "d", $lap_lastIndexOf, true, false, true }};
			[$larr_proto, "forEach"]        := {{ "d", $lap_forEach, true, false, true }};
			[$larr_proto, "map"]            := {{ "d", $lap_map, true, false, true }};

			xret := "create_object_with_call_construct" ($lap_toString, "AP_toString", empty, 0);
			xret := "create_object_with_call_construct" ($lap_concat, "AP_concat", empty, 1);
			xret := "create_object_with_call_construct" ($lap_pop, "AP_pop", empty, 0);
			xret := "create_object_with_call_construct" ($lap_push, "AP_push", empty, 1);
			xret := "create_object_with_call_construct" ($lap_reverse, "AP_reverse", empty, 0);
			xret := "create_object_with_call_construct" ($lap_sort, "AP_sort", empty, 1);
			xret := "create_object_with_call_construct" ($lap_splice, "AP_splice", empty, 2);
			xret := "create_object_with_call_construct" ($lap_indexOf, "AP_indexOf", empty, 1);
			xret := "create_object_with_call_construct" ($lap_lastIndexOf, "AP_lastIndexOf", empty, 1);
			xret := "create_object_with_call_construct" ($lap_forEach, "AP_forEach", empty, 1);
			xret := "create_object_with_call_construct" ($lap_map, "AP_map", empty, 1);

			(* String object *)

			xret := "create_object_with_call_construct" ($lstr, "String_call", "String_construct", 1);

			[$lstr, "prototype"]    := {{ "d", $lstr_proto, false, false, false }};

			(* String.prototype *)

			xret := "create_default_object" ($lstr_proto, $lobj_proto, "String", true);

			m := metadata($lstr_proto);
			[m, "@primitiveValue"]             := "";
			[$lstr_proto, "length"]            := {{ "d", 0, false, false, false }};
			[$lstr_proto, "constructor"]       := {{ "d", $lstr, true, false, true }};
			[$lstr_proto, "toString"]          := {{ "d", $lsp_toString, true, false, true }};
			[$lstr_proto, "valueOf"]           := {{ "d", $lsp_valueOf, true, false, true }};
			[$lstr_proto, "charAt"]            := {{ "d", $lsp_charAt, true, false, true }};
			[$lstr_proto, "concat"]            := {{ "d", $lsp_concat, true, false, true }};
			[$lstr_proto, "indexOf"]           := {{ "d", $lsp_indexOf, true, false, true }};
			[$lstr_proto, "lastIndexOf"]       := {{ "d", $lsp_lastIndexOf, true, false, true }};
			[$lstr_proto, "replace"]           := {{ "d", $lsp_replace, true, false, true }};
			[$lstr_proto, "substring"]         := {{ "d", $lsp_substring, true, false, true }};

			xret := "create_object_with_call_construct" ($lsp_toString, "SP_toString", empty, 0);
			xret := "create_object_with_call_construct" ($lsp_valueOf, "SP_valueOf", empty, 0);
			xret := "create_object_with_call_construct" ($lsp_charAt, "SP_charAt", empty, 1);
			xret := "create_object_with_call_construct" ($lsp_concat, "SP_concat", empty, 1);
			xret := "create_object_with_call_construct" ($lsp_indexOf, "SP_indexOf", empty, 1);
			xret := "create_object_with_call_construct" ($lsp_lastIndexOf, "SP_lastIndexOf", empty, 1);
			xret := "create_object_with_call_construct" ($lsp_replace, "SP_replace", empty, 2);
			xret := "create_object_with_call_construct" ($lsp_substring, "SP_substring", empty, 2);

  			(* Object object *)

  			xret := "create_object_with_call_construct" ($lobj, "Object_call", "Object_construct", 1);

  			[$lobj, "prototype"]                := {{ "d", $lobj_proto, false, false, false }};
			[$lobj, "create"]                   := {{ "d", $lobj_create, true, false, true }};
			[$lobj, "keys"]                     := {{ "d", $lobj_keys, true, false, true }};

			xret := "create_object_with_call_construct" ($lobj_create, "Object_create", empty, 2);
  			xret := "create_object_with_call_construct" ($lobj_keys, "Object_keys", empty, 1);

			(* Object.prototype *)

			xret := "create_default_object" ($lobj_proto, null, "Object", true);

			[$lobj_proto, "constructor"]          := {{ "d", $lobj, true, false, true }};
			[$lobj_proto, "toString"]             := {{ "d", $lop_toString, true, false, true }};
			[$lobj_proto, "valueOf"]              := {{ "d", $lop_valueOf, true, false, true }};
			[$lobj_proto, "hasOwnProperty"]       := {{ "d", $lop_hasOwnProperty, true, false, true }};

			xret := "create_object_with_call_construct" ($lop_toString, "OP_toString", empty, 0);
			xret := "create_object_with_call_construct" ($lop_valueOf, "OP_valueOf", empty, 0);
  			xret := "create_object_with_call_construct" ($lop_hasOwnProperty, "OP_hasOwnProperty", empty, 1);

			(* Global object *)

			xret := "create_default_object" ($lg, $lobj_proto, "Object", true);

  			[$lg, "NaN"]                := {{ "d", nan, false, false, false }};
  			[$lg, "Infinity"]           := {{ "d", inf, false, false, false }};
  			[$lg, "undefined"]          := {{ "d", undefined, false, false, false }};

  			[$lg, "isNaN"]              := {{ "d", $lg_isNan, true, false, true }};
  			[$lg, "isFinite"]           := {{ "d", $lg_isFinite, true, false, true }};
  			[$lg, "Object"]             := {{ "d", $lobj, true, false, true }};
  			[$lg, "Function"]           := {{ "d", $lfun, true, false, true }};
 			[$lg, "Array"]              := {{ "d", $larr, true, false, true }};
  			[$lg, "String"]             := {{ "d", $lstr, true, false, true }};
  			[$lg, "Boolean"]            := {{ "d", $lbool, true, false, true }};
  			[$lg, "Number"]             := {{ "d", $lnum, true, false, true }};
  			[$lg, "Math"]               := {{ "d", $lmath, true, false, true }};
  			[$lg, "Error"]              := {{ "d", $lerr, true, false, true }};
  			[$lg, "RangeError"]         := {{ "d", $lrgerr, true, false, true }};
  			[$lg, "ReferenceError"]     := {{ "d", $lrferr, true, false, true }};
  			[$lg, "SyntaxError"]        := {{ "d", $lserr, true, false, true }};
  			[$lg, "TypeError"]          := {{ "d", $lterr, true, false, true }};

  			xret := "create_object_with_call_construct" ($lg_isNan, "Object_isNan", empty, 1);
  			xret := "create_object_with_call_construct" ($lg_isFinite, "Object_isFinite", empty, 1);

	rlab:	xret := empty
}
with
{
	ret:	xret, rlab;
};


(*  
	Procedure: create_arguments_object

	Creates a JavaScript arguments object with arguments list argList
		     
	Doesn't throw an error
*)
proc create_arguments_object (argList) {

			len := l-len (argList);

			(* Create the arguments object *)
			m := new ();
			xret := new (m);
			xret := "create_default_object" (xret, $lobj_proto, "Arguments", true);
			obj  := xret;

			(* Define length *)
			xret := "defineOwnProperty" (obj, "length", {{ "d", len, true, false, true }}, false) with elab;

			(* Loop through values *)
			indx := len - 1;

	loop:	goto [0 <= indx] head call;
	head:	xret := "i__toString" (indx) with elab;
			xret := "defineOwnProperty" (obj, xret, {{ "d", l-nth (argList, indx), true, true, true }}, false) with elab;
			indx := indx - 1;
			goto loop;

			(* Set caller and callee *)
	call:	[obj, "caller"] := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};
			[obj, "callee"] := {{ "a", $lthrow_type_error, $lthrow_type_error, false, false }};

	rlab:	xret := obj;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};
