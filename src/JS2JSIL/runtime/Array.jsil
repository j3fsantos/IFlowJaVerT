import Internals.jsil;

(* ***************** *)
(* THE ARRAY LIBRARY *)
(* ***************** *)

(* *** CONSTRUCT *** *)

proc Array_call () {
			xret := "Array_construct" ("args") with elab;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};

proc Array_construct () {

			la := args;
			len := l-len (la);

			xret := new ();
			xret := "create_default_object" (xret, $larr_proto, "Array", true);

			[xret, "length"] := {{ "d", 0, true, false, true }};
			array := xret;

			goto [len < 3] rtrn ltest;

	ltest:	goto [len = 3] len3 other;

	len3:	len := l-nth (la, 2);
			goto [typeOf(len) = Num] len0 setl;
	len0:	xret := "i__toUint32" (len) with elab;
			goto [len = xret] dop re;
	dop:	prop := "length";
			conf := false;
			goto set;

	setl:	prop := "0";
			conf := true;
	set:	xret := "a__defineOwnProperty" (array, prop, {{ "d", len, true, conf, true }}, true) with elab;
			goto rtrn;

	other:	n := 2;
	loop:	goto [n < len] head rtrn;
	head:	prop := "i__toString" (n - 2) with elab;
			xret := "a__defineOwnProperty" (array, prop, {{ "d", l-nth (la, n), true, true, true }}, true) with elab;
			n := n + 1;
			goto loop;

	rtrn:	xret := array;
	rlab:	skip;

	re:		xret := "RangeError" ();
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err:	xret, elab;
};

(* *** ISIDX *** *)

proc a__isIdx (s) {
			xret := "i__toUint32" (s) with elab;
			xret := "i__toString" (xret) with elab;

			goto [xret = s] check ret_f;

	check:	xret := not (xret = "4294967295");
			goto rlab;

	ret_f:	xret := false;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** DEFINEOWNPROPERTY *** *)

proc a__defineOwnProperty (l, prop, desc, throw) {

			oldLenDesc := "getOwnProperty" (l, "length");
			oldLen := l-nth (oldLenDesc, 1);
			xret := "i__toUint32" (oldLen) with elab;
			oldLenNum := xret;

			goto [prop = "length"] getall is_idx;

	is_idx:	idxp := "a__isIdx" (prop);
			goto [idxp] idx norm;

	idx:	index := "i__toUint32" (prop);
			index := index;
			oldLen := oldLen;
			xret := l-nth (oldLenDesc, 2);
			goto [(not (index < oldLenNum)) and (not (l-nth (oldLenDesc, 2)))] reject idop;
	idop:	xret := "o__defineOwnProperty" (l, prop, desc, false) with elab;
			goto [xret = false] reject ilen;
	ilen:	goto [not (index < oldLenNum)] setl rlab;
	setl:	xret := "o__defineOwnProperty" (l, "length", {{ "d", (index + 1), l-nth (oldLenDesc, 2), l-nth (oldLenDesc, 3), l-nth (oldLenDesc, 4) }}, false);
			goto rlab;

	norm:	xret := "o__defineOwnProperty" (l, prop, desc, throw) with elab;
			goto rlab;

	getall:	goto [l-nth (desc, 0) = "d"] ddd odd;

			(* Data *)
	ddd:	de := l-nth (desc, 3);
			dc := l-nth (desc, 4);
			dv := l-nth (desc, 1);
			dw := l-nth (desc, 2);
			dg := empty;
			ds := empty;
			goto sla;

	odd:	goto [l-nth (desc, 0) = "a"] add gdd;

			(* Accessor *)
	add:	de := l-nth (desc, 3);
			dc := l-nth (desc, 4);
			dv := empty;
			dw := empty;
			dg := l-nth (desc, 1);
			ds := l-nth (desc, 2);
			goto sla;

			(* Generic *)
	gdd:	de := l-nth (desc, 1);
			dc := l-nth (desc, 2);
			dv := l-nth (desc, 3);
			dw := l-nth (desc, 4);
			dg := l-nth (desc, 5);
			ds := l-nth (desc, 6);

	sla:	goto [dv = empty] slai slb;

	slai:	xret := "o__defineOwnProperty" (l, "length", desc, throw) with elab;
			goto rlab;

	slb:	xret := "i__toUint32" (dv) with elab;
			newLen := xret;
			xret := "i__toNumber" (dv) with elab;
			goto [not (newLen = xret)] rgerr sle;

	sle:	dv := newLen;
			goto [not (newLen < oldLenNum)] slfi slg;

	slfi:	xret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, throw) with elab;
			goto rlab;

	slg:	goto [l-nth (oldLenDesc, 2) = false] reject slh;

	slh:	goto [dw = false] sli slh1;

	slh1:	newWritable := true;
			goto slj;

	sli:	newWritable := false;
			dw := true;

	slj:	xret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, throw) with elab;
			goto [xret = false] tf loop;

	loop:	goto [newLen < oldLen] head slm;
	head:	oldLen := oldLen - 1;
			xret := "i__toString" (oldLen) with elab;
			xret := "deleteProperty" (l, xret, false) with elab;
			goto [xret = false] fix next;

	fix:	dv := oldLen + 1;
			goto [newWritable = false] setwr defl;
	setwr:	dw := false;
	defl:	xret := "o__defineOwnProperty" (l, "length", {{ "g", de, dc, dv, dw, dg, ds }}, throw) with elab;
			goto reject;

	next:	goto loop;

	slm:	goto [newWritable = false] slmi sln;

	slmi:	xret := "o__defineOwnProperty" (l, "length", {{ "g", empty, empty, empty, false, empty, empty }}, false) with elab;

	sln:	xret := true;
	rlab:	skip;

	rgerr:	xret := "RangeError" ();
			goto elab;

	reject:	goto [throw] tt tf;

	tt:		xret := "TypeError" ();
	elab:	skip;

	tf:		xret := false;
			goto rlab
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** ISARRAY *** *)

proc Array_isArray (xsc, vthis, array) {
			xret := false;

			goto [typeOf (array) = Obj] cls rlab;
	cls:	class := [array, "@class"];
			goto [class = "Array"] rt rlab;

	rt:		xret := true;

	rlab:	skip;
	elab:	skip
}
with
{
	ret:	xret, rlab;
	err:	xret, elab;
};

(* *** TOSTRING *** *)

proc AP_toString (xsc, vthis) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "join") with elab;
			func := xret;

			xret := "i__isCallable" (func);
			goto [xret] norm setfun;

	setfun:	func := $lop_toString;

	norm:	xsc := [func, "@scope"];
			fun := [func, "@call"];
			xret := fun (xsc, vthis) with elab;
			goto [xret = empty] undef rlab;
	undef:	xret := undefined;

	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* *** JOIN *** *)

proc AP_join (xsc, vthis, sep) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			goto [sep = undefined] ssep sssep;
	ssep:	sep := ",";
			goto len0;

	sssep:	xret := "i__toString" (sep) with elab;
			sep := xret;

	len0:	goto [len = 0] xemp non0;

	non0:	xret := "get" ( vthis, "0") with elab;
			goto [(xret = null) or (xret = undefined)] r0 rs;

	r0:		R := "";
			goto prep;

	rs:		xret := "i__toString" (xret) with elab;
			R := xret;

	prep:	k := 1;

	loop:	goto [k < len] head end;
	head:	R := R ++ sep;

			next := "";
			xret := "i__toString" (k) with elab;
			xret := "get" ( vthis, xret) with elab;

			goto [(xret = undefined) or (xret = null)] cc def;
	def:	xret := "i__toString" (xret) with elab;
			next := xret;

	cc:		R := R ++ next;
			k := k + 1;
			goto loop;


	end:	xret := R;
			goto rlab;

	xemp:	xret := "";

	rlab:	skip;
	elab:	skip
}
with
{
	ret: xret, rlab;
	err: xret, elab;
};

(* *** POP *** *)
proc AP_pop (xsc, vthis) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			goto [len = 0] zero nz;

	zero:	xret := "put" (vthis, "length", 0, true) with elab;
			xret := undefined;
			goto rlab;

	nz:		indx := "i__toString" (len - 1);
			elem := "get" ( vthis, indx) with elab;
			xret := "deleteProperty" (vthis, indx, true) with elab;
			xret := "put" (vthis, "length", (len - 1), true) with elab;
			xret := elem;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** PUSH *** *)
proc AP_push() {
			arguments := args;
			vthis := l-nth (arguments, 1);

			xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			n := 2;
			num := l-len (arguments);

	loop:	goto [n < num] add stop;

	add:	elem := l-nth (arguments, n);
			strn := "i__toString" (len);
			xret := "put" (vthis, strn, elem, true) with elab;
			n := n + 1;
			len := len + 1;
			goto loop;

	stop:	xret := "put" (vthis, "length", len, true) with elab;
			xret := len;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};


(* *** TOLOCALESTRING *** *)
proc AP_toLocaleString(xsc, vthis) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			sep := ",";
			k := 0;
			goto [len = 0] _empty fill;

	_empty:	xret := "";
			goto rlab;

	fill:	xret := "i__toString" (k) with elab;
			xret := "get" ( vthis, xret) with elab;
			goto [ (xret = undefined) or (xret = null) ] un def;

	un:		R := "";
			goto next;

	def:	xret := "i__toObject" (xret) with elab;
			eothis := xret;
			xret := "get" ( eothis, "toLocaleString") with elab;
			func := xret;

			xret := "i__isCallable" (func);
			goto [xret] call throw;

	call:	xsc := [func, "@scope"];
			fun := [func, "@call"];
			xret := fun (xsc, eothis) with elab;
			goto [xret = empty] undef setR;
	undef:	xret := undefined;
	setR:	goto [ (xret = undefined) or (xret = null) ] un deff;

			(* This is not specified, but how do you concatenate non-strings? *)
	deff:	xret := "i__toString" (xret) with elab;
			R := xret;

	next:	goto [k = 0] fe ne;
	ne:		R := S ++ R;
	fe:		k := k + 1;
			goto loop;

	loop:	goto [k < len] lp end;

	lp:		S := R ++ sep;
			goto fill;

	end:	xret := R;
	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** CONCAT *** *)
proc AP_concat() {
			arguments := args;
			vthis := l-nth (arguments, 1);

			xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			(* The resulting array *)
			xret := "Array_construct" () with elab;
			A := xret;

			(* We are starting from property "0" *)
			n := 0;

			(* Once the loop repeats, we will be
			   concatenating from the third argument.
			   First two are the scope and the this. *)
			idx := 2;

			(* Get the number of arguments *)
			num := l-len (arguments);

			(* We are starting with the this object *)
			elem := vthis;

			(* Indicator that we are in the first loop *)
			f := 0;
			goto cont;

	loop:	goto [idx < num] add end;

	add:	elem := l-nth (arguments, idx);
			f := 1;

	cont:	goto [typeOf (elem) = Obj] cls narr;
	cls:	c := [elem, "@class"];
			goto [c = "Array"] arr narr;

	arr:	k := 0;
			xret := "get" ( elem, "length") with elab;
			len := xret;

	lp:		goto [k < len] loop2 nnext;

	loop2:	xret := "i__toString" (k) with elab;
			p := xret;

			xret := "hasProperty" (elem, p) with elab;
			goto [xret] tt next;

	tt:		xret := "get" ( elem, p) with elab;
			se := xret;
			xret := "i__toString" (n) with elab;
			xret := "a__defineOwnProperty" (A, xret, {{ "d", se, true, true, true }}, false) with elab;

	next:	n := n + 1;
			k := k + 1;
			goto lp;

	nnext:	goto [f = 0] loop inc;
	inc:	idx := idx + 1;
			goto loop;

	narr:	xret := "i__toString" (n) with elab;
			xret := "a__defineOwnProperty" (A, xret, {{ "d", elem, true, true, true }}, false) with elab;
			n := n + 1;
			goto [f = 0] loop iinc;
	iinc:	idx := idx + 1;
			goto loop;

	end:	xret := A;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** REVERSE *** *)
proc AP_reverse(xsc, vthis) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			mid := m_floor (len / 2);
			lower := 0;

	loop:	goto [not (mid = lower)] rev end;

	rev:	upper := (len - lower) - 1;
			xret := "i__toString" (upper) with elab;
			upperP := xret;
			xret := "i__toString" (lower) with elab;
			lowerP := xret;
			xret := "get" ( vthis, lowerP) with elab;
			lowerV := xret;
			xret := "get" ( vthis, upperP) with elab;
			upperV := xret;

			xret := "hasProperty" (vthis, upperP) with elab;
			upperE := xret;
			xret := "hasProperty" (vthis, lowerP) with elab;
			lowerE := xret;

			goto [lowerE and upperE] tt el1;

	tt:		xret := "put" (vthis, lowerP, upperV, true) with elab;
			xret := "put" (vthis, upperP, lowerV, true) with elab;
			goto inc;

	el1:	goto [upperE] ft el2;

	ft:		xret := "put" (vthis, lowerP, upperV, true) with elab;
			xret := "deleteProperty" (vthis, upperP, true) with elab;
			goto inc;

	el2:	goto [lowerE] tf inc;

	tf:		xret := "deleteProperty" (vthis, lowerP, true) with elab;
			xret := "put" (vthis, upperP, lowerV, true) with elab;

	inc:	lower := lower + 1;
			goto loop;

	end:	xret := vthis;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** SHIFT *** *)
proc AP_shift(xsc, vthis) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			goto [len = 0] zero nz;

	zero:	xret := "put" (vthis, "length", 0, true) with elab;
			xret := undefined;
			goto rlab;

	nz:		xret := "get" ( vthis, "0") with elab;
			first := xret;

			k := 1;
	loop:	goto [k < len] less end;
	less:	xret := "i__toString" (k) with elab;
			from := xret;
			kk := k - 1;
			xret := "i__toString" (kk) with elab;
			to := xret;
			xret := "hasProperty" (vthis, from) with elab;
			goto [xret] t f;

	t:		xret := "get" ( vthis, from) with elab;
			xret := "put" (vthis, to, xret, true) with elab;
			goto inc;

	f:		xret := "deleteProperty" (vthis, to, true) with elab;
	inc:	k := k + 1;
			goto loop;

	end:	len := len - 1;
			xret := "i__toString" (len) with elab;
			xret := "deleteProperty" (vthis, xret, true) with elab;
			xret := "put" (vthis, "length", len, true) with elab;
			xret := first;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** SLICE *** *)
proc AP_slice(xsc, vthis, start, end) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "Array_construct" () with elab;
			A := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			xret := "i__toInteger" (start) with elab;
			rs := xret;

	if1:	goto [rs < 0] if1t if1f;
	if1t:	lrs := len + rs;
			goto [not (lrs < 0)] gr ls;
	gr:		k := lrs;
			goto if2;
	ls:		k := 0;
			goto if2;

	if1f:	goto [rs <= len] ls1 gr1;
	gr1:	k := len;
			goto if2;
	ls1:	k := rs;

	if2:	goto [end = undefined] if2t if2f;
	if2t:	re := len;
			goto if3;
	if2f:	xret := "i__toInteger" (end) with elab;
			re := xret;

	if3:	goto [re < 0] if3t if3f;

	if3t:	lre := len + re;
			goto [not (lre < 0)] gr2 ls2;
	gr2:	final := lre;
			goto setn;
	ls2:	final := 0;
			goto setn;

	if3f:	goto [re <= len] ls3 gr3;
	ls3:	final := re;
			goto setn;
	gr3:	final := len;

	setn:	n := 0;
	loop:	goto [k < final] next end;

	next:	xret := "i__toString" (k) with elab;
			pk := xret;

			xret := "hasProperty" (vthis, pk) with elab;
			kpres := xret;
			goto [kpres] tt ff;

	tt:		xret := "get" ( vthis, pk) with elab;
			kval := xret;
			xret := "i__toString" (n) with elab;
			strn := xret;
			xret := "a__defineOwnProperty" (A, strn, {{ "d", kval, true, true, true }}, false) with elab;

	ff:		k := k + 1;
			n := n + 1;
			goto loop;

	end:	xret := A;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** UNSHIFT *** *)
proc AP_unshift() {
			arguments := args;
			vthis := l-nth (arguments, 1);

			xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;
			k := len;

			num := l-len (arguments);
			argc := num - 2;

	loop1:	goto [not (k <= 0)] next1 end1;
	next1:	xret := k - 1;
			xret := "i__toString" (xret) with elab;
			from := xret;

			xret := k + argc;
			xret := xret - 1;
			xret := "i__toString" (xret) with elab;
			to := xret;

			xret := "hasProperty" (vthis, from) with elab;
			fromp := xret;

			goto [fromp] fpt fpf;

	fpt:	xret := "get" ( vthis, from) with elab;
			fromv := xret;
			xret := "put" (vthis, to, fromv, true) with elab;
			goto dec;

	fpf:	xret := "deleteProperty" (vthis, to, true) with elab;

	dec:	k := k - 1;
			goto loop1;

	end1:	j := 0;
			nm := 2;

	loop:	goto [nm < num] next end;
	next:	elem := l-nth(arguments, nm);
			xret := "i__toString" (j) with elab;
			strj := xret;
			xret := "put" (vthis, strj, elem, true) with elab;
			j := j + 1;
			nm := nm + 1;
			goto loop;

	end:	lac := len + argc;
			xret := "put" (vthis, "length", lac, true) with elab;
			xret := lac;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** SPLICE *** *)
proc AP_splice() {
			arguments := args;
			vthis := l-nth (arguments, 1);
			num := l-len (arguments);

			goto [num < 3] nstrt ystrt;
	nstrt:	start := undefined;
			goto dc;
	ystrt:	start := l-nth (arguments, 2);

	dc:		goto [num < 4] ndc ydc;
	ndc:	deleteCount := undefined;
			goto tobj;
	ydc:	deleteCount := l-nth (arguments, 3);

	tobj:	xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "Array_construct" () with elab;
			A := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			xret := "i__toInteger" (start) with elab;
			rs := xret;

			goto [rs < 0] ift iff;
	ift:	xret := "M_max" (empty, empty, len + rs, 0) with elab;
			goto sync;
    iff:	xret := "M_min" (empty, empty, rs, len) with elab;
	sync:	acs := xret;

			xret := "i__toInteger" (deleteCount) with elab;
			xret := "M_max" (empty, empty, xret, 0) with elab;
			xret := "M_min" (empty, empty, xret, len - acs) with elab;
			adc := xret;

			k := 0;
	loop1:	goto [k < adc] next1 end1;
	next1:	ask := acs + k;
			xret := "i__toString" (ask) with elab;
			from := xret;
			xret := "hasProperty" (vthis, from) with elab;
			fromp := xret;
			goto [fromp] fpt fpf;

	fpt:	xret := "get" ( vthis, from) with elab;
			fromv := xret;
			xret := "i__toString" (k) with elab;
			strk := xret;
			xret := "a__defineOwnProperty" (A, strk, {{ "d", fromv, true, true, true }}, false) with elab;

	fpf:	k := k + 1;
			goto loop1;

	end1:	num := l-len (arguments);
			xret := "M_max" (empty, empty, num - 4, 0) with elab;
			itemc := xret;
			ladcic := len - adc;
			ladcic := ladcic + itemc;

			goto [itemc < adc] less nless;

	less:	k := acs;
			ladc := len - adc;
	loop2:	goto [k < ladc] next2 end2;
	next2:	kadc := k + adc;
			xret := "i__toString" (kadc) with elab;
			from := xret;
			kic := k + itemc;
			xret := "i__toString" (kic) with elab;
			to := xret;
			xret := "hasProperty" (vthis, from) with elab;
			fromp := xret;
			goto [fromp] fptt fpff;

	fptt:	xret := "get" ( vthis, from) with elab;
			fromv := xret;
			xret := "put" (vthis, to, fromv, true) with elab;
			goto cont1;
	fpff:	xret := "deleteProperty" (vthis, to, true) with elab;
	cont1:	k := k + 1;
			goto loop2;

	end2:	k := len;

	loop3:	goto [not (k <= ladcic)] next3 end3;
	next3:	k1 := k - 1;
			xret := "i__toString" (k1) with elab;
			k1 := xret;
			xret := "deleteProperty" (vthis, k1, true) with elab;
			k := k - 1;
			goto loop3;

	nless:	goto [not (itemc <= adc)] more end3;

	more:	k := len - adc;
	loop4:	goto [not (k <= acs)] next4 end3;
	next4:	kadc1 := k + adc;
			kadc1 := kadc1 - 1;
			xret := "i__toString" (kadc1) with elab;
			from := xret;
			kic1 := k + itemc;
			kic1 := kic1 - 1;
			xret := "i__toString" (kic1) with elab;
			to := xret;
			xret := "hasProperty" (vthis, from) with elab;
			fromp := xret;
			goto [fromp] fpttt fpfff;
	fpttt:	xret := "get" ( vthis, from) with elab;
			fromv := xret;
			xret := "put" (vthis, to, fromv, true) with elab;
			goto dec;

	fpfff:	xret := "deleteProperty" (vthis, to, true) with elab;

	dec:	k := k - 1;
			goto loop4;

	end3:	k := acs;
			nm := 4;
	loop5:	goto [nm < num] next5 end5;

	next5:	elem := l-nth (arguments, nm);
			xret := "i__toString" (k) with elab;
			strk := xret;
			xret := "put" (vthis, strk, elem, true) with elab;
			k := k + 1;
			nm := nm + 1;
			goto loop5;

	end5:	xret := "put" (vthis, "length", ladcic, true) with elab;
			xret := A;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** INDEXOF *** *)
proc AP_indexOf() {
			arguments := args;
			vthis  := l-nth (arguments, 1);
			num := l-len (arguments);

			selem := undefined;
	        goto [num <= 2] tobj selem;
	selem:	selem := l-nth (arguments, 2);

	tobj:	xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			goto [len = 0] neg1 next;

	next:	goto [num <= 3] em nem;

	em:		n := 0;
			goto nlen;

	nem:	fi := l-nth (arguments, 3);
			xret := "i__toInteger" (fi) with elab;
			n := xret;

	nlen:	goto [(len <= n)] neg1 next2;

	next2:	goto [n < 0] lelse lif;

	lif:	k := m_abs n;
			goto loop;

	lelse:	k := m_abs n;
			k := len - k;
			goto [k < 0] zero loop;

	zero:	k := 0;

	loop:	goto [k < len] lp neg1;

	lp:		xret := "i__toString" (k) with elab;
			strk := xret;
			xret := "hasProperty" (vthis, strk) with elab;
			kpres := xret;

			goto [kpres] next3 end;

	next3:	xret := "get" ( vthis, strk) with elab;
			elemk := xret;

			xret := "i__strictEquality" (selem, elemk) with elab;
			goto [xret] r end;

	r:		xret := k;
			goto rlab;

	end:	k := k + 1;
			goto loop;

	neg1:	xret := -1;
	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** LASTINDEXOF *** *)
proc AP_lastIndexOf() {
			arguments := args;
			vthis  := l-nth (arguments, 1);
			num := l-len (arguments);

			selem := undefined;
	        goto [num <= 2] tobj selem;
	selem:	selem := l-nth (arguments, 2);

	tobj:	xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			goto [len = 0] neg1 next;

	next:	goto [num <= 3] em nem;

	em:		n := len - 1;
			goto nlen;

	nem:	fi := l-nth (arguments, 3);
			xret := "i__toInteger" (fi) with elab;
			n := xret;

	nlen:	goto [n < 0] lelse lif;
	lif:	len1 := len - 1;
			goto [n <= len1] ls gr;
	ls:		k := m_abs n;
			goto loop;
	gr:		k := len1;
			goto loop;

	lelse:	k := m_abs n;
			k := len - k;

	loop:	goto [not (k < 0)] lp neg1;
	lp:		xret := "i__toString" (k) with elab;
			strk := xret;
			xret := "hasProperty" (vthis, strk) with elab;
			kpres := xret;
			goto [kpres] tt ff;

	tt:		xret := "get" ( vthis, strk) with elab;
			elemk := xret;
			xret := "i__strictEquality" (selem, elemk) with elab;
			goto [xret] r ff;
	r:		xret := k;
			goto rlab;

	ff:		k := k - 1;
			goto loop;

	neg1:	xret := -1;

	rlab:	skip;
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** EVERY *** *)
proc AP_every() {
			arguments := args;
			vthis  := l-nth (arguments, 1);
			num := l-len (arguments);

			cbf := undefined;
	        goto [num <= 2] tobj cbf;
	cbf:	cbf := l-nth (arguments, 2);

	tobj:	xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			xret := "i__isCallable" (cbf);
			goto [xret] cont throw;

	cont:	goto [num <= 3] undef def;

	def:	t := l-nth (arguments, 3);
			goto setk;
	undef:	t := undefined;

	setk:	k := 0;
	loop:	goto [k < len] next end;

	next:	xret := "i__toString" (k) with elab;
			pk := xret;
			xret := "hasProperty" (vthis, pk) with elab;
			kpres := xret;
			goto [kpres] tt ff;

	tt:		xret := "get" ( vthis, pk) with elab;
			kval := xret;
			scp := [cbf, "@scope"];
			fun := [cbf, "@call"];
			xret := fun (scp, t, kval, k, vthis) with elab;
			tr := xret;
			xret := "i__toBoolean" (tr) with elab;
			goto [xret] ff retf;

	retf:	xret := false;
			goto rlab;

	ff:		k := k + 1;
			goto loop;

	end:	xret := true;

	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** SOME *** *)
proc AP_some() {
			arguments := args;
			vthis  := l-nth (arguments, 1);
			num := l-len (arguments);

			cbf := undefined;
	        goto [num <= 2] tobj cbf;
	cbf:	cbf := l-nth (arguments, 2);

	tobj:	xret := "i__toObject" (vthis) with elab;

			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			xret := "i__isCallable" (cbf);
			goto [xret] cont throw;

	cont:	goto [num <= 3] undef def;

	def:	t := l-nth (arguments, 3);
			goto setk;
	undef:	t := undefined;

	setk:	k := 0;
	loop:	goto [k < len] next end;

	next:	xret := "i__toString" (k) with elab;
			pk := xret;
			xret := "hasProperty" (vthis, pk) with elab;
			kpres := xret;
			goto [kpres] tt ff;

	tt:		xret := "get" ( vthis, pk) with elab;
			kval := xret;
			scp := [cbf, "@scope"];
			fun := [cbf, "@call"];
			xret := fun (scp, t, kval, k, vthis) with elab;
			tr := xret;
			xret := "i__toBoolean" (tr) with elab;
			goto [xret] rett ff;

	rett:	xret := true;
			goto rlab;

	ff:		k := k + 1;
			goto loop;

	end:	xret := false;

	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** FOREACH *** *)
proc AP_forEach() {
			arguments := args;
			vthis  := l-nth (arguments, 1);
			num := l-len (arguments);

			cbf := undefined;
	        goto [num <= 2] tobj cbf;
	cbf:	cbf := l-nth (arguments, 2);

	tobj:	xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			xret := "i__isCallable" (cbf);
			goto [xret] cont throw;

	cont:	goto [num <= 3] undef def;

	def:	t := l-nth (arguments, 3);
			goto setk;
	undef:	t := undefined;

	setk:	k := 0;
	loop:	goto [k < len] next end;

	next:	xret := "i__toString" (k) with elab;
			pk := xret;
			xret := "hasProperty" (vthis, pk) with elab;
			kpres := xret;
			goto [kpres] tt ff;

	tt:		xret := "get" ( vthis, pk) with elab;
			kval := xret;
			scp := [cbf, "@scope"];
			fun := [cbf, "@call"];
			xret := fun (scp, t, kval, k, vthis) with elab;

	ff:		k := k + 1;
			goto loop;

	end:	xret := undefined;

	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** MAP *** *)
proc AP_map() {
			arguments := args;
			vthis  := l-nth (arguments, 1);
			num := l-len (arguments);

			cbf := undefined;
	        goto [num <= 2] tobj cbf;
	cbf:	cbf := l-nth (arguments, 2);

	tobj:	xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			xret := "i__isCallable" (cbf);
			goto [xret] cont throw;

	cont:	goto [num <= 3] undef def;

	def:	t := l-nth (arguments, 3);
			goto seta;
	undef:	t := undefined;

	seta:	xret := "Array_construct" (empty, empty, len) with elab;
			A := xret;
			k := 0;
	loop:	goto [k < len] next end;

	next:	xret := "i__toString" (k) with elab;
			pk := xret;
			xret := "hasProperty" (vthis, pk) with elab;
			kpres := xret;
			goto [kpres] tt ff;

	tt:		xret := "get" ( vthis, pk) with elab;
			kval := xret;
			scp := [cbf, "@scope"];
			fun := [cbf, "@call"];
			xret := fun (scp, t, kval, k, vthis) with elab;
			mapv := xret;
			xret := "a__defineOwnProperty" (A, pk, {{ "d", mapv, true, true, true }}, false) with elab;

	ff:		k := k + 1;
			goto loop;

	end:	xret := A;
	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** FILTER *** *)
proc AP_filter() {
			arguments := args;
			vthis  := l-nth (arguments, 1);
			num := l-len (arguments);

			cbf := undefined;
	        goto [num <= 2] tobj cbf;
	cbf:	cbf := l-nth (arguments, 2);

	tobj:	xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			xret := "i__isCallable" (cbf);
			goto [xret] cont throw;

	cont:	goto [num <= 3] undef def;

	def:	t := l-nth (arguments, 3);
			goto seta;
	undef:	t := undefined;

	seta:	xret := "Array_construct" () with elab;
			A := xret;
			k := 0;
			to := 0;
	loop:	goto [k < len] next end;

	next:	xret := "i__toString" (k) with elab;
			pk := xret;
			xret := "hasProperty" (vthis, pk) with elab;
			kpres := xret;
			goto [kpres] tt ff;

	tt:		xret := "get" ( vthis, pk) with elab;
			kval := xret;
			scp := [cbf, "@scope"];
			fun := [cbf, "@call"];
			xret := fun (scp, t, kval, k, vthis) with elab;
			goto [xret = empty] udef sel;
	udef:	xret := undefined;

	sel:	sel := xret;
			xret := "i__toBoolean" (sel) with elab;
			goto [xret] rett ff;

	rett:	xret := "i__toString" (to) with elab;
			strt := xret;
			xret := "a__defineOwnProperty" (A, strt, {{ "d", kval, true, true, true }}, false) with elab;
			to := to + 1;

	ff:		k := k + 1;
			goto loop;

	end:	xret := A;
	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** REDUCE *** *)
proc AP_reduce() {
			arguments := args;
			vthis  := l-nth (arguments, 1);
			num := l-len (arguments);

			cbf := undefined;
	        goto [num <= 2] tobj cbf;
	cbf:	cbf := l-nth (arguments, 2);

	tobj:	xret := "i__toObject" (vthis) with elab;

			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			xret := "i__isCallable" (cbf);
			goto [xret] setk throw;

	setk:	k := 0;
			goto [num <= 3] lelse lif;

	lif:	acc := l-nth (arguments, 3);
			goto loop2;

	lelse:	goto [len = 0] throw cont;
	cont:	kpres := false;
	loop:	goto [kpres] end1 kf;
	kf:		goto [k < len] next1 end1;

	next1:	xret := "i__toString" (k) with elab;
			pk := xret;
			xret := "hasProperty" (vthis, pk) with elab;
			kpres := xret;
			goto [kpres] tt ff;

	tt:		xret := "get" ( vthis, pk) with elab;
			acc := xret;

	ff:		k := k + 1;
			goto loop;

	end1:	goto [kpres] loop2 throw;
	loop2:	goto [k < len] next2 end;

	next2:	xret := "i__toString" (k) with elab;
			pk := xret;
			xret := "hasProperty" (vthis, pk) with elab;
			kpres := xret;
			goto [kpres] t f;

	t:		xret := "get" ( vthis, pk) with elab;
			kval := xret;
			scp := [cbf, "@scope"];
			fun := [cbf, "@call"];
			xret := fun (scp, undefined, acc, kval, k, vthis) with elab;
			acc := xret;

	f:		k := k + 1;
			goto loop2;

	end:	xret := acc;
	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** REDUCERIGHT *** *)
proc AP_reduceRight() {
			arguments := args;
			vthis  := l-nth (arguments, 1);
			num := l-len (arguments);

			cbf := undefined;
	        goto [num <= 2] tobj cbf;
	cbf:	cbf := l-nth (arguments, 2);

	tobj:	xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

			xret := "i__isCallable" (cbf);
			goto [xret] setk throw;

	setk:	k := len - 1;
			goto [num <= 3] lelse lif;

	lif:	acc := l-nth (arguments, 3);
			goto loop2;

	lelse:	goto [len = 0] throw cont;
	cont:	kpres := false;
	loop:	goto [kpres] end1 kf;
	kf:		goto [not (k < 0)] next1 end1;

	next1:	xret := "i__toString" (k) with elab;
			pk := xret;
			xret := "hasProperty" (vthis, pk) with elab;
			kpres := xret;
			goto [kpres] tt ff;

	tt:		xret := "get" ( vthis, pk) with elab;
			acc := xret;

	ff:		k := k - 1;
			goto loop;

	end1:	goto [kpres] loop2 throw;
	loop2:	goto [not (k < 0)] next2 end;

	next2:	xret := "i__toString" (k) with elab;
			pk := xret;
			xret := "hasProperty" (vthis, pk) with elab;
			kpres := xret;
			goto [kpres] t f;

	t:		xret := "get" ( vthis, pk) with elab;
			kval := xret;
			scp := [cbf, "@scope"];
			fun := [cbf, "@call"];
			xret := fun (scp, undefined, acc, kval, k, vthis) with elab;
			acc := xret;

	f:		k := k - 1;
			goto loop2;
	end:	xret := acc;
	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** SORT *** *)
proc AP_sort(xsc, vthis, compfn) {
			xret := "i__toObject" (vthis) with elab;
			vthis := xret;

			xret := "get" ( vthis, "length") with elab;
			xret := "i__toUint32" (xret) with elab;
			len := xret;

	(* 4 special conditions for implementation defined sort could be checked, maybe TODO *)

	(* check if vthis is sparse *)
	cs:		i := 0;
	cslp:	goto [i < len] check done;

	check:	xret := "i__toString" (i) with elab;
			stri := xret;
			xret := "getOwnProperty" (vthis, stri) with elab;
			elem := xret;
			goto [elem = undefined] spt spf;
	spt:	spar := true;
			goto otw;

	spf:	i := i + 1;
			goto cslp;

	done:	spar := false;
	(* end of sparse check *)

	otw:	goto [len < 2] fin cont;

	cont:	xret := "Array_construct" () with elab;
			stack := xret;

			xret := "AP_push" (empty, stack, 0);
			len1 := len - 1;
			xret := "AP_push" (empty, stack, len1);

			size := 1;

	while1:	goto [not (size <= 0)] ltz fin;

	ltz:	xret := "AP_pop" (empty, stack);
			end := xret;
			xret := "i__toString" (end) with elab;
			strend := xret;
			xret := "AP_pop" (empty, stack);
			start := xret;

			size := size - 1;
			l := start;
			curr := start;

	while2:	goto [curr < end] next1 end1;

	next1:	xret := "a__sortCompare" (curr, end, compfn, vthis) with elab;
			goto [xret < 0] less nless;

	less:	xret := "i__toString" (l) with elab;
			strl := xret;
			xret := "i__toString" (curr) with elab;
			strcurr := xret;
			xret := "get" ( vthis, strcurr) with elab;
			tmp := xret;
			xret := "hasProperty" (vthis, strl) with elab;
			goto [xret] iina niina;

	iina:	(* swap l and current *)
			xret := "get" ( vthis, strl) with elab;
			xret := "put" (vthis, strcurr, xret, true) with elab;
			xret := "put" (vthis, strl, tmp, true) with elab;
			goto incl;

	niina:	xret := "put" (vthis, strl, tmp, true) with elab;
			xret := "deleteProperty" (vthis, strcurr, true) with elab;

	incl:	l := l + 1;

	nless:	curr := curr + 1;
			goto while2;

	end1:	goto [l < end] sw nsw;

	sw:		xret := "i__toString" (l) with elab;
			strl := xret;
			xret := "get" ( vthis, strend) with elab;
			el := xret;
			xret := "hasProperty" (vthis, strl) with elab;
			goto [xret] ina nina;

	ina:	xret := "get" ( vthis, strl) with elab;
			xret := "put" (vthis, strend, xret, true) with elab;
			xret := "put" (vthis, strl, el, true) with elab;
			goto nsw;

	nina:	xret := "hasProperty" (vthis, strend) with elab;
			goto [xret] del nsw;

	del:	xret := "put" (vthis, strl, el, true) with elab;
			xret := "deleteProperty" (vthis, strend, true) with elab;

	nsw:	ll := l + 1;
			goto [not (end <= ll)] more nmore;

	more:	xret := "AP_push" (empty, stack, ll);
			xret := "AP_push" (empty, stack, end);
			size := size + 1;

	nmore:	l := l - 1;
			goto [not (l <= start)] ifs while1;

	ifs:	xret := "AP_push" (empty, stack, start);
			xret := "AP_push" (empty, stack, l);
			size := size + 1;
			goto while1;

	fin:	xret := vthis;
	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};

(* *** SORTCOMPARE *** *)
proc a__sortCompare(j, k, compfn, vthis) {

			xret := "i__toString" (j) with elab;
			strj := xret;
			xret := "i__toString" (k) with elab;
			strk := xret;
			xret := "hasProperty" (vthis, strj) with elab;
			hasj := xret;
			xret := "hasProperty" (vthis, strk) with elab;
			hask := xret;

			goto [hasj] yesj noj;

	yesj:	goto [hask] cmp nok;

	nok:	xret := -1;
			goto rlab;

	noj:	goto [hask]	yesk nojk;

	yesk:	xret := 1;
			goto rlab;

	nojk:	xret := 0;
			goto rlab;

	cmp:	xret := "get" ( vthis, strj) with elab;
			x := xret;
			xret := "get" ( vthis, strk) with elab;
			y := xret;
			goto [(x = undefined) and (y = undefined)] nojk xx;
	xx:		goto [x = undefined] yesk yy;
	yy:		goto [y = undefined] nok cont;
	cont:	goto [compfn = undefined] cont1 lif;

	lif:	xret := "i__isCallable" (compfn);
			goto [xret] call throw;
	call:	scp := [compfn, "@scope"];
			fun := [compfn, "@call"];
			xret := fun (scp, undefined, x, y) with elab;
			goto rlab;

	cont1:	xret := "i__toString" (x) with elab;
			strx := xret;
			xret := "i__toString" (y) with elab;
			stry := xret;
			goto [strx <s stry] nok xy;
	xy:		goto [not (strx = stry)] yesk nojk;

	rlab:	skip;

	throw:	xret := "TypeError" ();
	elab:	skip
}
with
{
	ret: 	xret, rlab;
	err: 	xret, elab;
};
