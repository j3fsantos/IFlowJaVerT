%!TEX root = ../main.tex

JavaScript is the most widespread dynamic language: it is the de facto language for client-side Web applications (used by 94.8\% of websites \cite{JS948percent});
it is used for server-side scripting via Node.js; and it is even run on small embedded devices with limited 
memory. It is the most active language in both GitHub \cite{GithubActive} and StackOverflow \cite{SOActive}.
The dynamic nature of JavaScript and its complex semantics make it a difficult target for
program analysis, such as logic-based symbolic execution.  
We present \jilette, a symbolic framework for testing JavaScript code (ECMAScript 5, ES5~\cite{ecma}). 
%
\jilette is aimed at the general developer, only requiring its users to write simple tests to check their code. 


The standard approach for validating code is running it against 
human-made test batteries, which check that, given some concrete inputs, the code produces the expected
outputs. The main drawback of this approach is that tests are often
too incomplete. With \jilette, JS developers can write symbolic tests; instead of 
writing a test with concrete inputs, the developer can write a test with symbolic inputs,
stating the constraints that the outputs need to satisfy in the form of simple, intuitive 
first-order assertions over the inputs. If a test fails, \jilette provides a failing model with some 
concrete inputs that cause the test to fail, exposing bugs in the tested code. 
We highlight the capabilities of \jilette through examples that showcase
JS specific features, such as: prototype-based inheritance, 
the for-in statement, and JS arrays.


\jiette is the first symbolic execution tools that models the JS semantics precisely. 
It is trustworthy: 



\polish{We need a paragraph saying what is new... 
\begin{enumerate}
  \item \jilette follows the 
\end{enumerate}
}




\myparagraph{Architecture}
The core of \jilette consists of a symbolic interpreter for
\jsil~\cite{javert}, a simple intermediate goto language. 
We obtain this symbolic interpreter \emph{for free}, 
by implementing a concrete \jsil interpreter in Rosette~\cite{Rosette2,Rosette1},~a 
symbolic virtual machine that facilitates generation of solver-aided languages.
We design the concrete interpreter so that all of Rosette's natively supported solver-aided
features, such as advanced string and regular-expression reasoning, 
are lifted to the \jsil symbolic interpreter. 
In~\S\ref{sec:jsil:symb:exec}, we give a formalisation of the \jsil concrete and symbolic executions, linking them together with a {\em soundness result}. We also provide insights on how to correctly design the concrete \jsil interpreter in Rosette.


The second component that \jilette uses is \JSComp~\cite{javert}, 
a well-tested, standard-compliant compiler from JavaScript to \jsil. We extend
\JSComp with support for the non-strict mode of ES5, as well as
regular expressions and the entire \jsinline|String| built-in library.
\JSComp allows us to lift the \jsil symbolic execution to JavaScript by first compiling JavaScript code to \jsil code, and
then symbolically executing the compiled code in the 
\jsil symbolic interpreter. This process, described in \S\ref{symb:exec:comp},
involves extending JavaScript syntax and the \JSComp compiler to support symbolic values and 
constructs for reasoning about them. These constructs are intuitive
and allow the general developer to easily write assertions about the behaviour
of their program. 
Moreover, we adjust the \jsil symbolic interpreter so that the abstraction level 
of the generated \jsil code precisely matches the abstraction level of Rosette, 
 maximising the use of Rosette's native reasoning capabilities.


\myparagraphq{Why \jilette} 
\jilette is \emph{useful}: it has tangible applications. 
It can report bugs in JavaScript programs, producing concrete witnesses triggering the bugs. It can also be used as a helper tool for developers of logic-based functional correctness specifications of JavaScript code.
\jilette is \emph{approachable}: it can easily be used by a general JavaScript developer. The annotation burden of \jilette is minimal and the assertion language is simple and intuitive. \polish{Sweet spot?}
\jilette is \emph{trustworthy}: its components come with correctness guarantees. 
The correctness of the \JSComp compiler ensures full adherence to the real semantics of JavaScript. The \jilette symbolic execution engine is based on a sound symbolic
analysis for \jsil, guaranteeing the absence of false positives. \polish{Sentence about unification.}
Finally, \jilette is \emph{extensible}: its coverage can easily be extended in a modular way. This gives us the mechanism for supporting built-in libraries not covered by \JSComp, or adding support for standard-external runtime libraries, such as the DOM.