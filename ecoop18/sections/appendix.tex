%!TEX root = ../main.tex



\newtheorem{lemmax}{}
\newtheorem{temax}{}
\newtheorem{cormax}{}

\section{\jsil Syntax and Semantics}

\vspace*{-0.2cm}
\begin{figure}[!ht]
\begin{minipage}{\textwidth}
\begin{tabular}{lllll}
	 Numbers: $\jnumber \in \numbers$ &  Booleans: $\jbool \in \bools$ & \  \ Strings: $\jstring \in \strings$ & \  \ Locs: $\loc \in \locs$ & \  Vars: $\jvar \in \jvars$ \\[0.1cm]
	Types: $\ivltype \in \ivltypes$ & \multicolumn{4}{l}{Values: $\val \in \vals$ \defeq \ $\jnumber \mid \jbool \mid \jstring \mid  \jsundefined \mid \jsnull \mid \loc \mid \ivltype \mid \fid \mid \jsilempty$} \\[0.1cm]
\multicolumn{5}{l}{Expressions: $\jsilexpr \in \exprs$ \defeq \ $\val \mid \jvar \mid \ominus\ \jsilexpr \mid \jsilexpr \binop{} \jsilexpr $} \\[0.1cm]
	\multicolumn{5}{l}{Basic Commands: $\bcmd \in \bcmds$ \defeq\ $\jsilskip \mid \jvar := \jsilexpr  \mid \jvar := \jsilnew() \mid \jvar := [\jsilexpr, \jsilexpr] \mid [\jsilexpr, \jsilexpr] := \jsilexpr \mid$} \\[0.1cm]
	\multicolumn{5}{l}{\hspace{2.8cm} $\jsildelete(\jsilexpr, \jsilexpr) \mid \jvar := \hasfield(\jsilexpr, \jsilexpr) \mid \jvar := \getfields(\jsilexpr) \mid \assume(\jsilexpr) \mid \assert(\jsilexpr)$} \\[0.1cm]
	% Commands
	\multicolumn{5}{l}{Commands: $\ivlcmd \in \cmds$ \defeq \ $ \bcmd \mid \goto \ i \mid  \ifgoto{\jsilexpr}{i}{j} \mid \jsilcall{\jvar}{\jsilexpr}{\jvec{\jsilexpr}}{j}$} \\[0.1cm]
	\multicolumn{5}{l}{Procedures : $\proc \in \procset$ \defeq \ $\procedure{\fid}{\jvec{\jvar}}{\jvec{\ivlcmd}}$ \qquad Programs : $\prog \in \progs$ \ : \ $\fid \rightharpoonup \procset$}
 \end{tabular}
 \vspace*{-0.2cm}
 \caption{Syntax of the \jsil Language}
 \label{def:app:jsil-types}
 \end{minipage}
  \vspace*{-0.5cm}
 \end{figure}

\vspace*{-0.1cm}
\begin{figure}[ht!]
{\scriptsize
\begin{mathpar} 
%
\inferrule[Evaluation of expressions]{}{
\semexpr{\val}{\store} \semeq \val
\quad 
\semexpr{\jvar}{\store} \semeq \store(\jvar)
\quad 
\semexpr{\unoper\ \jexpr}{\store} \semeq \semop{\unoper} (\semexpr{\jexpr}{\store})
\quad 
\semexpr{\jexpr_1 \binoper \jexpr_2}{\store} \semeq \semop{\binoper}(\semexpr{\jexpr_1}{\store}, \semexpr{\jexpr_2}{\store})}
\\

\inferrule[\textsc{Skip}]{}
	{ \semtrans[][\top]{\heap, \store, \jsilskip}{\heap, \store}} 
 \qquad
%
\inferrule[\textsc{Object Creation}]
  { 
    \heap = \heap \dunion \hcell{\loc}{\protop}{\jsnull}
    \quad (\loc,-) \notin \domain (\heap)
  }{\semtrans[][\top]{\heap, \store, \jvar := \jsilnew()}{\heap, \store[\jvar \mapsto \loc]}}
\\
\vspace*{-0.1cm}
\inferrule[\textsc{Property Collection}]
  {
      \symbeval{\jsilexpr}{\store} =  \loc
      \quad
        \heap = \heap' \, \uplus \, \big((l, \jstring_i) \mapsto \val_i\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\heap')
  }{\semtrans[][\top]{\heap, \store, \jvar := \getfields(\jsilexpr)}{\heap, \store[\jvar \mapsto \jsilset{\jstring_0, ..., \jstring_n}]}} 
%
\qquad
 %
\inferrule[\textsc{Assignment}]
  {
      \symbeval{\jsilexpr}{\store} =  \val
      \quad
      \store' = \store[\jvar \mapsto \val]
  }{\semtrans[][\top]{\heap, \store, \jvar := \jsilexpr}{\heap, \store'}} 
\\
%
\inferrule[\textsc{Property Access}]
  { 
 	\symbeval{\jsilexpr_1}{\store} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\store} =  \jstring
        \quad
        \heap = - \dunion \hcell{\loc}{\jstring}{\val}
  }{ \semtrans[][\top]{\heap, \store, \jvar := [\jsilexpr_1, \jsilexpr_2]}{\heap,  \store[\jvar \mapsto \val]}}
 \and 
 \inferrule[\textsc{Property Deletion}]
  { 
        \symbeval{\jsilexpr_1}{\store} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\store} =  \jstring
        \quad
        \heap = \heap' \dunion \hcell{\loc}{\jstring}{-}
  }{\semtrans[][\top]{\heap, \store, \jsildelete(\jsilexpr_1, \jsilexpr_2)}{\heap', \store}}
 %
\\
%
\inferrule[\textsc{Property Assignment - Found}]
  {     \symbeval{\jsilexpr_1}{\store} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\store} =  \jstring
        \quad
        \symbeval{\jsilexpr_3}{\store} =  \val
       \\\\
        \heap = \heap' \dunion  \hcell{\loc}{\jstring}{-}
  }{\semtrans[][\top]{\heap, \store, [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3}{\heap' \dunion  \hcell{\loc}{\jstring}{\val}, \store}} 
 \and 
 \inferrule[\textsc{Property Assignment - Not Found}]
  {     \symbeval{\jsilexpr_1}{\store} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\store} =  \jstring
        \quad
        \symbeval{\jsilexpr_3}{\store} =  \val
       \\\\
        \heap = \heap' 
        \quad 
        (\loc, \jstring) \not\in \domain(\heap)
  }{\semtrans[][\top]{\heap, \store, [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3}{\heap \dunion  \hcell{\loc}{\jstring}{\val}, \store}} 
\\
%
\inferrule[\textsc{Member Check - True}]
  { 
      \symbeval{\jsilexpr_1}{\store} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\store} =  \jstring
       \quad 
   	(\loc, \jstring) \in \domain(\heap) 
  }{\semtrans[][\top]{\heap, \store,\jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)}{\heap, \store[\jvar \mapsto \jtrue]}}
  \and 
 \inferrule[\textsc{Member Check - False}]
  { 
      \symbeval{\jsilexpr_1}{\store} =  \loc
  	\quad 
        \symbeval{\jsilexpr_2}{\store} =  \jstring
       \quad 
   	(\loc, \jstring) \not\in \domain(\heap) 
  }{\semtrans[][\top]{\heap, \store,\jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)}{\heap, \store[\jvar \mapsto \jfalse]}}
%
\\
%
\inferrule[\textsc{Assume}]
  { 
      \symbeval{\jsilexpr}{\store} =  \jtrue
  }{\semtrans[][\top]{\heap, \store, \assume(\jsilexpr)}{\heap, \store}} 
\and
\inferrule[\textsc{Assert - True}]
  { 
      \symbeval{\jsilexpr}{\store} =  \jtrue
  }{\semtrans[][\top]{\heap, \store, \assert(\jsilexpr)}{\heap, \store}} 
\and
\inferrule[\textsc{Assert - False}]
  { 
      \symbeval{\jsilexpr}{\store} = \jfalse
  }{\semtrans[][\top][\bot]{\heap, \store, \assert(\jsilexpr)}{\heap, \store}} 
\end{mathpar}}
\vspace*{-0.6cm}
\caption{Execution for Basic Commands: {\scriptsize$\semtrans[][\mode][\mode']{\heap, \store, \bcmd}{\heap', \store'}$}\label{fig:app:sem:basic:commands}}
\end{figure}

\vspace*{-0.5cm}
\begin{figure}[ht!]
{\scriptsize
\begin{mathpar} 
\inferrule[\textsc{Basic Command}]
   { 
     \ccmd[\prog][\ctx]{i} = \bcmd 
     \quad
     \semtrans[][\top][\mode]{\heap, \store, \bcmd}{\heap', \store'} 
   }{\semtrans[\prog][\top][\mode]{\heap, \store, i}{\heap', \store', i+1}[C]}
%
   \qquad
%  %
%  \inferrule[\textsc{Basic Command - Fail}]
%   { 
%     \ccmd[\prog][\ctx]{i} = \bcmd 
%     \quad
%     \semtrans[\prog][\top][\bot]{\heap, \store, \bcmd}{\heap', \store'}
%   }{\semtrans[\prog][\top][\bot]{\heap, \store, i}{\heap', \store', i+1}[C]}
% %
%   \qquad
  %
  \inferrule[\textsc{Goto}]
   { \ccmd[\prog][\ctx]{i} = \goto \, j \quad}
   {\semtrans[\prog][\top]{\heap, \store, i}{\heap, \store, j}[C]}
  \\ 
  \inferrule[\textsc{Cond. Goto - True}]
   { \ccmd[\prog][\ctx]{i} =  \ifgoto{\jsilexpr}{j}{k} \quad
     \symbeval{\jsilexpr}{\store} =  \jtrue
   }
   {\semtrans[\prog][\top]{\heap, \store, i}{\heap, \store, j}[C]}
  \and 
    \inferrule[\textsc{Cond. Goto - False}]
   { \ccmd[\prog][\ctx]{i} =  \ifgoto{\jsilexpr}{j}{k} \quad
     \symbeval{\jsilexpr}{\store} =  \jfalse
   }
   {\semtrans[\prog][\top]{\heap, \store, i}{\heap, \store, k}[C]}
   \\
    \inferrule[\textsc{Procedure Call}]
   { 
    \ccmd[\prog][\ctx]{i} =   \jsilcall{\jvar}{\jsilexpr}{\jsilexpr_i \mid_{i = 0}^{n}}{j}
     \quad
    \symbeval{\jsilexpr}{\sstore} =  \pid' 
        \quad
     \args(\pid') = \jsillist{\jvar_1, ..., \jvar_{m}} 
      \quad
      \val_i = \symbeval{\jsilexpr_i}{\sstore} \mid_{i = 0}^{n} 
     \ 
      \val_i = \jsundefined \mid_{i = n+1}^{m}  
   }
   {\semtrans[\prog][\top]{\heap, \store, i}{\heap, [ \jvar_i \mapsto \val_i \mid_{i = 0}^{m}] , 0}[C][(\pid', \store, \jvar, i+1, j) :: \ctx]}
    \\ 
  \inferrule[\textsc{Normal Return}]
   {
       \ctx = (-, \store', \jvar, i, -) :: \ctx' 
       \quad 
       \store(\procretvar) = \val
   }  
   {\semtrans[\prog][\top]{\heap, \store, \procretlab}{\heap, \store'[\jvar \mapsto \val], i}[C][C']}
   \and 
     \inferrule[\textsc{Error Return}]
   {
       \ctx = (-, \store', \jvar, -, j) :: \ctx' 
       \quad 
       \store(\procerrvar) = \val
   }
   {\semtrans[\prog][\top]{\heap, \store, \procerrlab}{\heap, \store'[\jvar \mapsto \val], j}[C][C']}
 \end{mathpar}}
% \pmax{What happens when we exit from main, how do we stop? Basically, cmd returns nothing and we can't reduce?}
 \vspace*{-0.6cm}
\caption{Execution for Control Flow Commands: $\semtrans[\prog][\mode][\mode']{\heap, \store, i}{\heap', \store', j}[C][C']$}
\end{figure}
%

\begin{figure}[!h]
{\small
\begin{display}{Notation}
\begin{tabular}{r@{\quad}c@{\quad}l}
\textsc{Symbolic \jsil expressions}: & $\sexpr \in \sexprs$ & \defeq \;
$\val \mid \sstring \mid \snumber \mid \unoper\ \sexpr \mid \sexpr \binoper \sexpr$ \\
\textsc{Extended \jsil expressions}: & $\pvsexpr \in \pvsexprs$ & \defeq \,
$\val \mid \jvar \mid \sstring \mid \snumber \mid \unoper\ \pvsexpr \mid \pvsexpr \binoper \pvsexpr$
\end{tabular}
\end{display}}

{\scriptsize
\begin{mathpar} 
%
\inferrule[\textsc{Evaluation of extended \jsil expressions}]{}{
%
{\begin{array}{c}
\semexpr{\val}{\sstore} \semeq \val \\[2pt]
%
\semexpr{\xvar}{\sstore} \semeq \sstore(\xvar) \\[2pt]
%
\semexpr{\svar}{\sstore} \semeq \svar
\end{array}}
%
\qquad
%
\frac{\semexpr{\pvsexpr}{\sstore} = \val}
      {\semexpr{\unoper\ \pvsexpr}{\sstore} \semeq \semop{\unoper} \val}
%
\qquad
%
\frac{\semexpr{\pvsexpr}{\sstore} = \sexpr \not\in \vals}
       {\semexpr{\unoper\ \pvsexpr}{\sstore} \semeq \unoper \ \sexpr}
%
\qquad
\frac{ \val = \semop{\binoper}(\semexpr{\pvsexpr_1}{\sstore}, \semexpr{\pvsexpr_2}{\sstore})} 
       {\semexpr{\pvsexpr_1 \binoper \pvsexpr_2}{\sstore} \semeq \val}
 %
 \qquad
\frac{{\begin{array}{c}
	\semexpr{\pvsexpr_1}{\sstore} = \sexpr_1 
	  \quad 
	  \semexpr{\pvsexpr_2}{\sstore} = \sexpr_2
	  \\
	  \sexpr_1 \not\in \vals \ \vee \ \sexpr_2 \not\in \vals 
	  \end{array}}
	}
	{\semexpr{\pvsexpr_1 \binoper \pvsexpr_2}{\sstore} \semeq \sexpr_1 \, {\binoper} \, \sexpr_2}
}
%
\\\\
%
\inferrule[\textsc{Skip}]{}
	{ \symbtrans[][\top]{\sheap, \sstore, \jsilskip, \pc}{\sheap, \sstore, \pc}} 
 \and
%
\inferrule[\textsc{Object Creation}]
  { 
    (\loc,-) \notin \domain (\sheap) 
    \and
    \sheap' = \sheap \dunion \hcell{\loc}{\protop}{\jsnull}
    \and 
  }{\symbtrans[][\top]{\sheap, \sstore, \jvar := \jsilnew(), \pc}{\sheap', \sstore[\jvar \mapsto \loc], \pc}}
\\
\inferrule[\textsc{Assignment}]
  {
      \symbeval{\pvsexpr}{\sstore} =  \sexpr
      \quad
      \sstore' = \sstore[\jvar \mapsto \sexpr]
  }{\symbtrans[][\top]{\sheap, \sstore, \jvar := \pvsexpr, \pc}{\sheap, \sstore', \pc}} 
  %
  \and
  %
  \inferrule[\textsc{Property Collection}]
  {
      \symbeval{\pvsexpr}{\sstore} =  \loc
      \quad
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto - \big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
  }{\semtrans[][\top]{\heap, \store, \jvar := \getfields(\pvsexpr), \pc}{\heap, \store[\jvar \mapsto \jsilset{\sexprp_0, ..., \sexprp_n}],\pc}} 
%
\\
\inferrule[\textsc{Property Access}]
  { 
 	\symbeval{\pvsexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\pvsexpr_2}{\sstore} =  \sexpr_p
        \quad
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
        \\\\
        \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \left(\wedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \right)\big)
  }{ \symbtrans[][\top]{\sheap, \sstore, \jvar := [\pvsexpr_1, \pvsexpr_2], \pc}{\sheap,  \sstore[\jvar \mapsto \sexprv_k], \pc'}}
 %
\\
%
\inferrule[\textsc{Property Assignment - Found}]
  {     \symbeval{\pvsexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\pvsexpr_2}{\sstore} =  \sexpr_p
        \quad
        \symbeval{\pvsexpr_3}{\sstore} =  \sexpr_v
       \quad 
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
        \\
          \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \left( \wedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \right)\big)
         \quad
         \sheap'' = \sheap' \, \uplus \,  \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n \, \uplus \,  (l, \sexpr_p) \mapsto \sexpr_v
  }{\symbtrans[][\top]{\sheap, \sstore,  [\pvsexpr_1, \pvsexpr_2] := \pvsexpr_3, \pc}{\sheap'', \sstore, \pc'}} 
\\
%
\inferrule[\textsc{Property Assignment - Not Found}]
  {     \symbeval{\pvsexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\pvsexpr_2}{\sstore} =  \sexpr_p
        \quad
        \symbeval{\pvsexpr_3}{\sstore} =  \sexpr_v
       \quad 
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
        \\
          \pc' = \pc \ \wedge \, \left(\wedge_{i = 0}^n (\sexprp_i \neq \sexpr_p)\right)
         \quad
         \sheap'' = \sheap \, \uplus \,  (l, \sexpr_p) \mapsto \sexpr_v
  }{\symbtrans[][\top]{\sheap, \sstore, [\pvsexpr_1, \pvsexpr_2] := \pvsexpr_3, \pc}{\sheap'', \sstore, \pc'}}   
%
\\
%
\inferrule[\textsc{Property Deletion}]
  { 
        \symbeval{\pvsexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\pvsexpr_2}{\sstore} =  \sexpr_p
       \quad 
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
     \\ 
      \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \left(\wedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \right)\big)
     \quad 
      \sheap'' = \sheap' \, \uplus \,  \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n
   }{\symbtrans[][\top]{\sheap, \sstore, \jsildelete(\pvsexpr_1, \pvsexpr_2), \pc}{\sheap'', \sstore, \pc'}}
 \\
 %
\inferrule[\textsc{Member Check - True}]
  { 
      \symbeval{\pvsexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\pvsexpr_2}{\sstore} =  \sexpr_p
       \quad 
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
     \\ 
     \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \left(\wedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \right)\big)
  }{\symbtrans[][\top]{\sheap, \sstore, \jvar := \hasfield(\pvsexpr_1, \pvsexpr_2), \pc}{\sheap, \sstore[\jvar \mapsto \jtrue], \pc'}}
%
\\
%
\inferrule[\textsc{Member Check - False}]
  { 
      \symbeval{\pvsexpr_1}{\sstore} =  \loc
  	\quad 
        \symbeval{\pvsexpr_2}{\sstore} =  \sexpr_p
       \quad 
        \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n   
        \quad
        (l, -) \not\in \domain(\sheap')
        \quad 
        0 \leq k \leq n
     \quad
     \pc' = \pc \ \wedge \,  \left(\wedge_{i = 0}^n (\sexprp_i \neq \sexpr_p)\right) 
  }{\symbtrans[][\top]{\sheap, \sstore, \jvar := \hasfield(\pvsexpr_1, \pvsexpr_2), \pc}{\sheap, \sstore[\jvar \mapsto \jfalse], \pc'}}
\\
%
\inferrule[\textsc{Assert - True}]
  { 
      \symbeval{\pvsexpr}{\sstore} =  \sexpr
     \quad 
     \pc \vdash \sexpr 
  }{\symbtrans[][\top]{\sheap, \sstore, \assert(\pvsexpr), \pc}{\sheap, \sstore, \pc}} 
\quad
\inferrule[\textsc{Assert - False}]
  { 
      \symbeval{\pvsexpr}{\sstore} =  \sexpr
     \quad 
     (\pc \, \wedge \,  \neg\sexpr) \text{ satisfiable}
  }{\symbtrans[][\top][\bot]{\sheap, \sstore, \assert(\pvsexpr), \pc}{\sheap, \sstore,  \pc \wedge \neg\sexpr}}
  \quad
%
\inferrule[\textsc{Assume}]
  { 
      \symbeval{\pvsexpr}{\sstore} =  \sexpr
     \quad 
     \pc \vdash \sexpr 
  }{\symbtrans[][\top]{\sheap, \sstore, \assume(\pvsexpr), \pc}{\sheap, \sstore, \pc \land \sexpr}} 
\end{mathpar}}
\caption{Symbolic Semantics for \jsil Basic Commands: {$\symbtrans[][\mode][\mode']{\sheap, \sstore, \bcmd, \pc}{\sheap', \sstore', \pc'}$}\label{fig:app:symbexe:bcmds}}
\end{figure}
%\end{display}  
%
\begin{figure}[ht]
{\scriptsize
\begin{mathpar} 
\inferrule[\textsc{Basic Command}]
   { 
     \ccmd{i} = \bcmd 
     \quad
     \symbtrans[\prog][\mode][\mode']{\sheap, \sstore, \bcmd, \pc}{\sheap', \sstore', \pc'} 
   }{\symbtrans[\prog][\mode][\mode']{\sheap, \sstore, i, \pc}{\sheap', \sstore', i+1, \pc'}}
%
   \qquad
%  %
%  \inferrule[\textsc{Basic Command - Fail}]
%   { 
%     \ccmd{i} = \bcmd 
%     \quad
%     \symbtranserr{\sheap, \sstore, \bcmd, \pc}{}{\pc}
%   }{\symbtranserr{\sheap, \sstore, i, \pc}{}{\pc}}
% %
   \qquad
  %
  \inferrule[\textsc{Goto}]
   { \ccmd{i} = \goto \, j \quad}
   {\symbtrans[\prog][\top]{\sheap, \sstore, i, \pc}{\sheap, \sstore, j, \pc}}
  \\ 
  \inferrule[\textsc{Cond. Goto - True}]
   { \ccmd{i} =  \ifgoto{\pvsexpr}{j}{k} \quad
     \symbeval{\pvsexpr}{\sstore} =  \sexpr
   }
   {\symbtrans[\prog][\top]{\sheap, \sstore, i, \pc}{\sheap, \sstore, j,  \pc \, \wedge \, \sexpr}}
  \and 
    \inferrule[\textsc{Cond. Goto - False}]
   { \ccmd{i} =  \ifgoto{\pvsexpr}{j}{k} \quad
     \symbeval{\pvsexpr}{\sstore} =  \sexpr
   }
   {\symbtrans[\prog][\top]{\sheap, \sstore, i, \pc}{\sheap, \sstore, k, \pc \, \wedge \, \neg\sexpr}}
   \\
    \inferrule[\textsc{Procedure Call}]
   { 
    \ccmd{i} =   \jsilcall{\jvar}{\pvsexpr}{\pvsexpr_i \mid_{i = 0}^{n}}{j}
     \quad
    \symbeval{\pvsexpr}{\sstore} =  \pid' 
    \quad
      \symbeval{\pvsexpr_i}{\sstore} =  \sexpr_i \mid_{i = 0}^{n} 
     \quad
     \args(\pid') = \jsillist{\jvar_1, ..., \jvar_{m}} 
     \quad 
      \sexpr_i = \jsundefined \mid_{i = n+1}^{m}  
   }
   {\symbtrans[\prog][\top]{\sheap, \sstore, i, \pc}{\sheap, [ \jvar_i \mapsto \sexpr_i \mid_{i = 0}^{m}], 0, \pc}[\sctx][(\pid', \sstore, \jvar, i+1, j)::\sctx]}
    \\ 
  \inferrule[\textsc{Normal Return}]
   {
       \sctx = (-, \sstore', \jvar, i, -) :: \sctx' 
       \quad 
       \sstore(\procretvar) = \sexpr
   }  
   {\symbtrans[\prog][\top]{\sheap, \sstore, \procretlab, \pc}{\sheap, \sstore'[\jvar \mapsto \sexpr], i, \pc}[\sctx][\sctx']}
   \and 
     \inferrule[\textsc{Error Return}]
   {
       \sctx = (-, \sstore', \jvar, -, j) :: \sctx' 
       \quad 
       \sstore(\procerrvar) = \sexpr
   }  
   {\symbtrans[\prog][\top]{\sheap, \sstore, \procerrlab, \pc}{\sheap, \sstore'[\jvar \mapsto \sexpr], j, \pc}[\sctx][\sctx']}
 \end{mathpar}}
 \vspace*{-0.4cm}
\caption{Symbolic Semantics for \jsil Commands: {$\symbtrans[\prog][\mode][\mode']{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx']$}\label{fig:app:symbexe:cmds}}
\end{figure}

\begin{figure}[t!]
{\small

\textsc{Interpretation of Symbolic Expressions}
\vspace*{-0.1cm}
\begin{mathpar}
\semexpr{\val}{\senv} \semeq \val 
%
\qquad
%
\semexpr{\svar}{\senv} \semeq \senv(\svar)
\qquad
%
\semexpr{\unoper\ \sexpr}{\senv} \semeq \semop{\unoper} (\semexpr{\sexpr}{\senv})
\qquad 
\semexpr{\sexpr_1 \binoper \sexpr_2}{\senv} \semeq \semop{\binoper}(\semexpr{\sexpr_1}{\senv}, \semexpr{\sexpr_2}{\senv}) 
\end{mathpar}


\textsc{Interpretation of Extended Expressions}
\vspace*{-0.2cm}
\begin{mathpar}
{\begin{array}{c}
\semexpr{\val}{\senv} \semeq \val \\[2pt]
%
\semexpr{\xvar}{\senv} \semeq \xvar \\[2pt]
%
\semexpr{\svar}{\senv} \semeq \senv(\svar)
\end{array}}
\quad
%
\frac{\semexpr{\pvsexpr}{\senv} = \val}
      {\semexpr{\unoper\ \pvsexpr}{\senv} \semeq \semop{\unoper} \val}
%
\quad
%
\frac{\semexpr{\pvsexpr}{\senv} = \pvsexpr' \not\in \vals}
       {\semexpr{\unoper\ \pvsexpr}{\senv} \semeq \unoper \ \pvsexpr'}
%
\quad
\frac{ \val = \semop{\binoper}(\semexpr{\pvsexpr_1}{\senv}, \semexpr{\pvsexpr_2}{\sstore})} 
       {\semexpr{\pvsexpr_1 \binoper \pvsexpr_2}{\senv} \semeq \val}
 %
 \quad
\frac{{\begin{array}{c}
	\semexpr{\pvsexpr_1}{\senv} = \pvsexpr_1' 
	  \quad 
	  \semexpr{\pvsexpr_2}{\senv} = \pvsexpr_2'
	  \\
	  \pvsexpr_1' \not\in \vals \ \vee \ \pvsexpr_2' \not\in \vals 
	  \end{array}}
	}
	{\semexpr{\pvsexpr_1 \binoper \pvsexpr_2}{\senv} \semeq \pvsexpr_1' \, {\binoper} \, \pvsexpr_2'}
\end{mathpar}

\textsc{Interpretation of Symbolic Heaps}
\vspace*{-0.2cm}
\begin{mathpar}
 \semexpr{\hemp}{\senv} \semeq \hemp
\qquad
\semexpr{\hcell{\loc}{\sexpr_p}{\sexpr_v}}{\senv} \semeq  \hcell{\loc}{\semexpr{\sexpr_p}{\senv}}{\semexpr{\sexpr_v}{\senv}}
\qquad
\semexpr{\sheap_1 \dunion \sheap_2}{\senv} \semeq  \semexpr{\sheap_1}{\senv} \dunion \semexpr{\sheap_2}{\senv}
\end{mathpar}

\textsc{Interpretation of Symbolic Stores}
\vspace*{-0.2cm}
\begin{mathpar}
 \semexpr{\storeemp}{\senv} \semeq \storeemp
\qquad 
 \semexpr{(\jvar: \sexpr) \dunion \sstore}{\senv} \semeq (\jvar: \semexpr{\sexpr}{\senv}) \dunion \semexpr{\sstore}{\senv}
\end{mathpar}

\textsc{Interpretation of Symbolic Contexts}
\vspace*{-0.2cm}
\begin{mathpar}
\semexpr{\lstemp}{\senv} \semeq \lstemp
\qquad 
 \semexpr{(\pid, \sstore, \jvar, i, j) \lstcons \sctx}{\senv} \semeq (\pid, \semexpr{\sstore}{\senv}, \jvar, i, j) \lstcons \semexpr{\sctx}{\senv}
\end{mathpar}

\textsc{Interpretation of Basic Commands}
\vspace*{-0.1cm}
\begin{mathpar}
\semexpr{\jsilskip}{\senv} = \jsilskip
\qquad \semexpr{\jvar := \pvsexpr}{\senv} = \jvar := \semexpr{\pvsexpr}{\senv}
\qquad \semexpr{\jvar := \jsilnew()}{\senv} = \jvar := \jsilnew() \\
\semexpr{\jvar := [\pvsexpr_1, \pvsexpr_2]}{\senv} = \jvar := [\semexpr{\pvsexpr_1}{\senv}, \semexpr{\pvsexpr_2}{\senv}]
\qquad \semexpr{[\pvsexpr_1, \pvsexpr_2] := \pvsexpr_3}{\senv} = [\semexpr{\pvsexpr_1}{\senv}, \semexpr{\pvsexpr_2}{\senv}] := \semexpr{\pvsexpr_3}{\senv} \\
\semexpr{\jsildelete(\pvsexpr_1, \pvsexpr_2)}{\senv} = \jsildelete(\semexpr{\pvsexpr_1}{\senv}, \semexpr{\pvsexpr_2}{\senv})
\qquad \semexpr{\jvar := \hasfield(\pvsexpr_1, \pvsexpr_2)}{\senv} = \jvar := \hasfield(\semexpr{\pvsexpr_1}{\senv}, \semexpr{\pvsexpr_2}{\senv}) \\
\semexpr{\jvar := \getfields(\pvsexpr)}{\senv} = \jvar := \getfields(\semexpr{\pvsexpr}{\senv}) \\
\qquad \semexpr{\assume(\pvsexpr)}{\senv} = \assume(\semexpr{\pvsexpr}{\senv})
\qquad \semexpr{\assert(\pvsexpr)}{\senv} = \assert(\semexpr{\pvsexpr}{\senv})
\end{mathpar}

\textsc{Interpretation of Commands}
\vspace*{-0.1cm}
\begin{mathpar}
\semexpr{\bcmd}{\senv} = \semexpr{\bcmd}{\senv}
\qquad \semexpr{\goto \ i}{\senv} = \goto \ i
\qquad \semexpr{\ifgoto{\jsilexpr}{i}{j}}{\senv} = \ifgoto{\semexpr{\jsilexpr}{\senv}}{i}{j} \\
\semexpr{\jsilcall{\jvar}{\jsilexpr}{\jvec{\jsilexpr}}{j}}{\senv} = \jsilcall{\jvar}{\semexpr{\jsilexpr}{\senv}}{\semexpr{\jvec{\jsilexpr}}{\senv}}{j}
\end{mathpar}


\textsc{Interpretation of Procedures}: $\semexpr{\procedure{\fid}{\jvec{\jvar}}{\jvec{\ivlcmd}}}{\senv} = \procedure{\fid}{\jvec{\jvar}}{\semexpr{\jvec{\ivlcmd}}{\senv}}$ \\

\textsc{Interpretation of Programs}:
$\semexpr{\prog}{\senv} = \{\ (\fid, \semexpr{\prog(\fid)}{\senv}) \ \mid \ \fid \in \domain(\prog) \ \}$

}

\caption{Interpretation of extended expressions, symbolic heaps, symbolic stores, etc.\label{fig:symbolic:interp:full}}
\vspace{-0.5cm}
\end{figure}
%
%\begin{figure}[ht!]
%{\scriptsize
%\begin{mathpar} 
%\inferrule[\textsc{Basic Command}]
%   { 
%     \ccmd{i} = \bcmd 
%     \quad
%     \semtrans{\heap, \store, \bcmd}{\heap', \store'} 
%   }{\semtrans{\heap, \store, i}{\heap', \store', i+1}}
%%
%   \qquad
%  %
%  \inferrule[\textsc{Basic Command - Fail}]
%   { 
%     \ccmd{i} = \bcmd 
%     \quad
%     \semtranserr{\heap, \store, \bcmd} 
%   }{\semtranserr{\heap, \store, i}}
% %
%   \qquad
%  %
%  \inferrule[\textsc{Goto}]
%   { \ccmd{i} = \goto \, j \quad}
%   {\semtrans{\heap, \store, i}{\heap, \store, j}}
%  \\ 
%  \inferrule[\textsc{Cond. Goto - True}]
%   { \ccmd{i} =  \ifgoto{\jsilexpr}{j}{k} \quad
%     \symbeval{\jsilexpr}{\store} =  \jtrue
%   }
%   {\semtrans{\heap, \store, i}{\heap, \store, j}}
%  \and 
%    \inferrule[\textsc{Cond. Goto - False}]
%   { \ccmd{i} =  \ifgoto{\jsilexpr}{j}{k} \quad
%     \symbeval{\jsilexpr}{\store} =  \jfalse
%   }
%   {\semtrans{\heap, \store, i}{\heap, \store, k}}
%   \\
%    \inferrule[\textsc{Procedure Call}]
%   { 
%    \ccmd{i} = \jsilcall{\jvar}{\jsilexpr}{\jsilexpr_i \mid_{i = 0}^{n}}{j}
%     \quad
%    \symbeval{\jsilexpr}{\sstore} =  \pid' 
%        \quad
%     \args(\pid') = \jsillist{\jvar_1, ..., \jvar_{m}} 
%      \quad
%      \val_i = \symbeval{\jsilexpr_i}{\sstore} \mid_{i = 0}^{n} 
%     \ 
%      \val_i = \jsundefined \mid_{i = n+1}^{m}  
%   }
%   {\semtrans{\heap, \store, i}{\heap, [ \jvar_i \mapsto \val_i \mid_{i = 0}^{m}] , 0}[\ctx][(\pid', \store, \jvar, i+1, j) :: \ctx]}
%    \\ 
%  \inferrule[\textsc{Normal Return}]
%   {
%       \ctx = (-, \store', \jvar, i, -) :: \ctx' 
%       \quad 
%       \store(\procretvar) = \val
%   }  
%   {\semtrans{\heap, \store, \procretlab}{\heap, \store'[\jvar \mapsto \val], i}[C][C']}
%   \and 
%     \inferrule[\textsc{Error Return}]
%   {
%       \ctx = (-, \store', \jvar, -, j) :: \ctx' 
%       \quad 
%       \store(\procerrvar) = \val
%   }
%   {\semtrans{\heap, \store, \procerrlab}{\heap, \store'[\jvar \mapsto \val], j}[C][C']}
% \end{mathpar}}
% \vspace*{-0.4cm}
%\caption{Symbolic Execution for Control Flow Commands: $\semtrans[\prog]{\heap, \store, i}{\heap', \store', j}[C][C']$}
%\end{figure}

\newpage
\section{Proofs - Section~\ref{sec:jsil:symb:exec}}

\begin{lemma}{Some Properties of Interpretation and Evaluation.}
\begin{enumerate}
\item $\forall \ \pvsexpr, \senv.\ \svarsreallyqueen(\pvsexpr) \subseteq \domain(\senv) \implies \semexpr{\pvsexpr}{\senv} \in \exprs$.
\item $\forall \ \pvsexpr, \sstore, \senv.\ \semexpr{\semexpr{\pvsexpr}{\senv}}{\semexpr{\sstore}{\senv}} = \semexpr{\semexpr{\pvsexpr}{\sstore}}{\senv}$.
\end{enumerate}
\end{lemma}
\begin{proof}
By induction on the structure of the appropriate syntactic category.
\end{proof}

\begin{lemma}[Transparency for single-step executions]\label{lem:singlefix}
$\forall \, \heap, \store, i, \ctx, \mode, \heap', \store', i', \ctx', \mode' \, . \,$
$$
  \semtrans[\prog][\mode][\mode']{\heap, \store, i}{\heap', \store', i'}[\ctx][\ctx']
  \iff
  \symbtrans[\prog][\mode][\mode']{\heap, \store, i, \jtrue}{\heap', \store', i', \jtrue}[\ctx][\ctx'] 
$$
\end{lemma}

\begin{proof}
Given the rules of the concrete and symbolic JSIL semantics, we have that $\mode = \top$. 
The interesting case is when $\mode' = \bot$. Then, it must be that the rule applied on both sides of the equivalence is the \prooflab{Basic Command} rule. Moreover, the associated basic command rule must be \prooflab{Assert - False}. This means that, in the concrete semantics, we should have:

$$\inferrule[\textsc{Assert - False}]
  { 
      \symbeval{\jsilexpr}{\store} = \jfalse
  }{\semtrans[][\top][\bot]{\heap, \store, \assert(\jsilexpr)}{\heap, \store}}$$

\noindent whereas in the symbolic semantics, we should have:

$$\inferrule[\textsc{Assert - False}]
  { 
     (\jtrue \, \wedge \,  \neg\symbeval{\jsilexpr}{\store}) \text{ satisfiable}
  }{\symbtrans[][\top][\bot]{\heap, \store, \assert(\jsilexpr), \jtrue}{\heap, \store,  \jtrue \wedge \neg\symbeval{\jsilexpr}{\store}}}$$

\noindent for some concrete expression $\jsilexpr$. From this, in the left-to-right case, we observe that $\symbeval{\jsilexpr}{\store} = \jfalse$, that is, that its negation is $\neg\symbeval{\jsilexpr}{\store} = \jtrue$ and the symbolic \prooflab{Assert - False} rule can be applied to obtain the desired goal. In the right-to-left case, since $\jtrue \, \wedge \,  \neg\symbeval{\jsilexpr}{\store}$ is satisfiable and $\jsilexpr$ is concrete, it must be that $\neg\symbeval{\jsilexpr}{\store} = \jtrue$, that is, that $\symbeval{\jsilexpr}{\store} = \jfalse$. Given that, we can apply the concrete \prooflab{Assert - False} rule to obtain the desired goal.

\medskip
All remaining cases, for which $\mode' = \top$, follow directly from the definitions of the concrete and symbolic semantics and the fact that the heaps, stores, and call stacks are concrete.
\end{proof}

\begin{lemma}[Transparency for fixed-length executions]\label{lem:transfix}
$\forall \, k, \heap, \store, i, \ctx, \mode, \heap', \store', i', \ctx', \mode' \, . \,$
$$
  \semtranstrans[\prog][\mode][\mode']{\heap, \store, i}[k]{\heap', \store', i'}[\ctx][\ctx']
  \iff
  \symbtranstrans[\prog][\mode][\mode']{\heap, \store, i, \jtrue}[k]{\heap', \store', i', \jtrue}[\ctx][\ctx'] 
$$
\end{lemma}

\begin{proof}
By induction on $k$. The base case, when $k = 0$, amounts to reflexivity. Let us assume that $k = n$ and prove the claim for $k = n + 1$. We have the inductive hypothesis:

\begin{description}
\item[IH:] $\forall \, \heap, \store, i, \ctx, \mode, \heap', \store', i', \ctx', \mode' \, .$
	\vspace*{-0.3cm}
  $$\semtranstrans[\prog][\mode][\mode']{\heap, \store, i}[n]{\heap', \store', i'}[\ctx][\ctx']
  \iff
  \symbtranstrans[\prog][\mode][\mode']{\heap, \store, i, \jtrue}[n]{\heap', \store', i', \jtrue}[\ctx][\ctx'].$$
\end{description}
  
Let us prove the left-to-right direction for $k = n + 1$. By definition of $\rightarrow^k$, we have that $$\exists \ \heap'', \rho'', i'', \ctx'', \mode''. \; \semtranstrans[\prog][\mode][\mode'']{\heap, \store, i}[n]{\heap'', \store'', i''}[\ctx][\ctx''] \ \wedge \ \semtrans[\prog][\mode''][\mode']{\heap'', \store'', i''}{\heap', \store', i'}[\ctx''][\ctx'].$$

From this, by the IH, we obtain that $\symbtranstrans[\prog][\mode][\mode']{\heap, \store, i, \jtrue}[n]{\heap'', \store'', i'', \jtrue}[\ctx][\ctx'']$. Also, from Lemma \ref{lem:singlefix}, we obtain that $\symbtrans[\prog][\mode''][\mode']{\heap'', \store'', i', \jtrue}{\heap', \store', i', \jtrue}[\ctx''][\ctx']$, concluding the proof.

\medskip
The right-to-left direction is proven analogously.
\end{proof}

\begin{temax}{Theorem~\ref{teo:transparency} - Transparency.} 
$\forall \, \heap, \store, i, \ctx, \mode, \heap', \store', i', \ctx', \mode' \, . \,$
$$
  \semtranstrans[\prog][\mode][\mode']{\heap, \store, i}{\heap', \store', i'}[\ctx][\ctx']
  \iff
  \symbtranstrans[\prog][\mode][\mode']{\heap, \store, i, \jtrue}{\heap', \store', i', \jtrue}[\ctx][\ctx'] 
$$
\end{temax}

\begin{proof}
Directly from Lemma \ref{lem:transfix} and the definitions of $\rightarrow^*$ and $\leadsto^*$.
\end{proof}

\begin{lemma}[Soundness of symbolic execution for \jsil basic commands]\label{soundness:basic:commands}
$$
\begin{array}{l}
\forall \sheap, \sstore, \bcmd, \pc, \mode, \sheap', \sstore',  \pc', \mode', \heap, \store, \senv, \pc'' \, .\\
\quad \symbtrans[][\mode][\mode']{\sheap, \sstore, \bcmd, \pc}{\sheap', \sstore', \pc'}
   \wedge \ \pc'' \vdash \pc' \ \wedge \ 
      (\heap, \store, \senv) \in \smodels{\sheap, \sstore}{\pc''} 
             \ \wedge \ \svarsreallyqueen(\bcmd) \subseteq \domain(\senv) \\ \qquad 
      	  \implies \ \exists \heap', \store' \, . \, 
	 	 \semtrans[][\mode][\mode']{\heap, \store, \symbeval{\bcmd}{\senv}}{\heap', \store'}
		\, \wedge \, 
		(\heap', \store', \senv) \in \smodels{\sheap', \sstore'}{\pc''}
\end{array}
$$
\end{lemma}
\begin{proof}
We proceed by case analysis on $\symbtrans[][\mode][\mode']{\sheap, \sstore, \bcmd, \pc}{\sheap', \sstore', \pc'}$. 
Given the symbolic semantics for JSIL basic commands, we obtain that $\mode = \top$. 

\medskip
We first prove the cases for which $\mode' = \bot$. The only applicable rule is \prooflab{Assert - False}.
We conclude that  $\bcmd = \assert(\pvsexpr)$ for some extended expression $\pvsexpr$, and that
$\pc \ \wedge \  \neg\symbeval{\pvsexpr}{\sstore}$ is satisfiable and $\pc' = \pc \ \wedge \  \neg\symbeval{\pvsexpr}{\sstore}$. 
From $(\heap, \store, \senv) \in \smodels{\sheap, \sstore}{\pc''}$, we conclude that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. Since $\pc'' \vdash \pc'$,
we conclude that $\pc'' \vdash \neg\symbeval{\jsilexpr}{\sstore}$.
We let $\jsilexpr = \symbeval{\pvsexpr}{\senv}$ and note that $\symbeval{\bcmd}{\senv} = \jvar := \assert(\jsilexpr)$.
We now have to prove that we can apply the \prooflab{Assert - False} rule in the concrete state.
To this end, we have to show that: $\symbeval{\jsilexpr}{\store} = \jfalse$. 
Noting that
$
  \symbeval{\jsilexpr}{\store} = 
  \symbeval{\jsilexpr}{\symbeval{\sstore}{\senv}} = 
  \symbeval{\symbeval{\pvsexpr}{\senv}}{\symbeval{\sstore}{\senv}} 
         = \symbeval{\symbeval{\pvsexpr}{\sstore}}{\senv} 
$, we conclude (using $\senv \vdash \pc''$ and $\pc'' \vdash  \neg\symbeval{\sexpr}{\sstore}$) that 
$\symbeval{\jsilexpr}{\store} = \jfalse$, from which we obtain that $\heap' = \heap$ and $\store' = \store$, and the result follows. 

\medskip
Onward, we assume that $\mode' = \top$ and elide the modes from the rules.
Throughout the proof, we use the fact that $\symbeval{\bcmd}{\senv}$ is concrete for all $\senv$, such that $\svarsreallyqueen(\bcmd) \subseteq \domain(\senv)$.
\vspace{5pt}

\noindent\prooflab{Skip} 
We conclude that $\bcmd = \jsilskip$, and 
that $\sheap' = \sheap$, $\sstore' = \sstore$, and $\pc' = \pc$. 
By picking $\heap' = \heap$, $\store' = \store$, the result follows. 
\vspace{6pt}

\noindent\prooflab{Assignment} 
We conclude that $\bcmd = \jvar := \pvsexpr$, for some variable $\jvar$ and extended expression $\pvsexpr$, 
and that $\sheap' = \sheap$, $\sstore' = \sstore[\jvar \mapsto \symbeval{\pvsexpr}{\sstore}]$, and $\pc' = \pc$. 
From $(\heap, \store, \senv) \in \smodels{\sheap, \sstore}{\pc''}$, we conclude that $\senv \satisfies \pc''$,  $\heap = \semexpr{\sheap}{\senv}$ and $\store = \semexpr{\sstore}{\senv}$. 
Now, letting $\jsilexpr = \symbeval{\pvsexpr}{\senv}$, noting that $\symbeval{\bcmd}{\senv} = \jvar := \jsilexpr$, and noting that 
$$
 \semtrans{\heap, \store, \jvar := \jsilexpr}{\heap, \store[\jvar \mapsto \symbeval{\jsilexpr}{\store}]}
% \qquad 
 %\semexpr{\sstore[\jvar \mapsto \symbeval{\jsilexpr}{\store}]}{\senv} = \semexpr{\sstore}{\senv}[\jvar \mapsto \symbeval{\jsilexpr}{\store, \senv}]
$$
we pick $\heap' = \heap$ and $\store' =  \store[\jvar \mapsto \symbeval{\jsilexpr}{\store}]$. We 
now have to prove that $(\heap', \store', \senv) \in \smodels{\sheap', \sstore'}{\pc''}$.
Observing that: 
$$
\heap' =  \semexpr{\sheap}{\senv} = \semexpr{\sheap'}{\senv} 
\quad 
\store' = \semexpr{\sstore}{\senv}[\jvar \mapsto \symbeval{\jsilexpr}{\semexpr{\sstore}{\senv}}]
   = \semexpr{\sstore[\jvar \mapsto \symbeval{\sexpr}{\store}]}{\senv} 
   = \semexpr{\sstore'}{\senv}
$$
%
the result follows. 
\vspace{6pt}

\noindent\prooflab{Object Creation}
We conclude that $\bcmd = \jvar := \jsilnew()$, for some variable $\jvar$, and that
$\sheap' = \sheap \dunion \hcell{\loc}{\protop}{\jsnull}$, $\sstore' = \sstore[\jvar \mapsto \loc]$, and $\pc' = \pc$, 
 where  $(\loc,-) \notin \domain (\sheap)$. 
 From $(\heap, \store, \senv) \in \smodels{\sheap, \sstore}{\pc''}$, we conclude that  $\senv \vdash \pc''$, $\heap = \semexpr{\sheap}{\senv}$ and $\store = \semexpr{\sstore}{\senv}$. 
Noting that $\symbeval{\bcmd}{\senv} = \bcmd$, and also that 
$$
\semtrans{\heap, \store, \jvar := \jsilnew()}{\heap \dunion \hcell{\loc}{\protop}{\jsnull}, \store[\jvar \mapsto \loc]}
$$
where: $(\loc,-) \notin \domain (\heap)$, we pick $\heap' = \semexpr{\sheap}{\senv} \dunion \hcell{\loc}{\protop}{\jsnull}$ 
and $\store' = \semexpr{\sstore}{\senv}[\jvar \mapsto \loc]$. 
We now have to prove that $(\heap', \store', \senv) \in \smodels{\sheap', \sstore'}{\pc''}$.
Noting that: 
$$
\begin{array}{l}
\heap' = \semexpr{\sheap}{\senv} \dunion \hcell{\loc}{\protop}{\jsnull} = \semexpr{\sheap \dunion \hcell{\loc}{\protop}{\jsnull}}{\senv}   
     = \semexpr{\sheap'}{\senv}  \\
%
\store' = \semexpr{\sstore}{\senv}[\jvar \mapsto \loc] = \semexpr{\sstore}{\senv}[\jvar \mapsto \symbeval{\loc}{\senv}] = 
      \semexpr{\sstore[\jvar \mapsto \loc]}{\senv} = \semexpr{\sstore'}{\senv} 
\end{array}
$$
the result follows. 
\vspace{6pt}

\noindent\prooflab{Property Access}
We conclude that $\bcmd = \jvar := [\pvsexpr_1, \pvsexpr_2]$, for some variable $\jvar$, and extended expressions $\pvsexpr_1$ and $\pvsexpr_2$, 
and that $\sheap' = \sheap$, $\sstore' = \sstore[\jvar \mapsto \sexprv_k]$, and: 
 $$\pc' =  \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \big)$$
 where:
 $\symbeval{\pvsexpr_1}{\sstore} =  \loc$, $\symbeval{\pvsexpr_2}{\sstore} =  \sexpr_p$, 
 $\sheap = \sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n$, 
 $(l, -) \not\in \domain(\sheap')$, and $0 \leq k \leq n$. 
%
From $(\heap, \store, \senv) \in \smodels{\sheap, \sstore}{\pc''}$, we conclude that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. 
We let $\jsilexpr_1 = \symbeval{\pvsexpr_1}{\senv}$ and $\jsilexpr_2 = \symbeval{\pvsexpr_2}{\senv}$, and note that $\symbeval{\bcmd}{\senv} = \jvar := [\jsilexpr_1, \jsilexpr_2]$.
We now have to prove that we can apply the \prooflab{Property Access} rule in the concrete state.
To this end, we have to show that there is a concrete heap $\heap''$ such that:
$\heap = \heap'' \dunion \hcell{\symbeval{\jsilexpr_1}{\store}}{\symbeval{\jsilexpr_2}{\store}}{\symbeval{\sexprv_k}{\senv}}$. 
Note that: 
$$
\begin{array}{l}
%
\senv \vdash \pc'' \ \wedge \ \pc'' \vdash \pc' \ \wedge \ \pc' \vdash \sexprp_k = \sexpr_p \implies \senv \vdash \sexprp_k = \sexpr_p \\
%
 \symbeval{\jsilexpr_1}{\store} = \symbeval{\jsilexpr_1}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_1}{\senv}}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_1}{\sstore}}{\senv} 
    = \symbeval{\loc}{\senv} = \loc \\ 
 %
  \symbeval{\jsilexpr_2}{\store}  = \symbeval{\jsilexpr_2}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\pvsexpr_2}{\senv}}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_2}{\sstore}}{\senv}
   =  \symbeval{\sexpr_p}{\senv} = \symbeval{\sexprp_k}{\senv}  \text{ (because $\senv \vdash \sexprp_k = \sexpr_p$)} \\
 %
 \heap = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n}{\senv} 
       =  \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion \semexpr{(l, \sexprp_k) \mapsto \sexprv_k}{\senv} \\
         \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (l, \semexpr{\sexprp_k}{\senv}) \mapsto \semexpr{\sexprv_k}{\senv}  \\ 
         \qquad =  \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \semexpr{\sexprv_k}{\senv}
\end{array}
$$
We can now apply the \prooflab{Property Access} rule of \jsil semantics, concluding: 
$$
   \semtrans{\heap, \store, \jvar := [\jsilexpr_1, \jsilexpr_2]}{\heap,  \store[\jvar \mapsto \semexpr{\sexprv_k}{\senv}]}
$$
meaning that: $\heap' = \heap$ and $\store' = \store[\jvar \mapsto \semexpr{\sexprv_k}{\senv}]$.
We have now to prove that $(\heap', \store', \senv) \in \smodels{\sheap', \sstore'}{\pc''}$.
Observe that: 
$$
\begin{array}{l}
\heap' = \heap = \semexpr{\sheap}{\senv}   = \semexpr{\sheap'}{\senv}  \text{ (because $\heap' = \heap$ and $ \sheap = \sheap'$)}
\\
 \store' =  \semexpr{\sstore}{\senv}[\jvar \mapsto \symbeval{\sexprv_k}{\senv}] 
    =  \semexpr{\sstore[\jvar \mapsto \sexprv_k]}{\senv} 
    =  \semexpr{\sstore'}{\senv}
\end{array}
$$
 which concludes the proof. 
\vspace{6pt}

\noindent\prooflab{Property Deletion}
We conclude that $\bcmd = \jsildelete(\pvsexpr_1, \pvsexpr_2)$, for some expressions $\pvsexpr_1$ and $\pvsexpr_2$
and that: 
$$
\begin{array}{l}
\sheap' = \sheap'' \, \uplus \,  \big((\loc, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n
\\ 
\sstore' = \sstore
\\ 
 \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \big)
\end{array}
$$
where $\loc = \symbeval{\pvsexpr_1}{\sstore}$ and $\sexpr_p = \symbeval{\pvsexpr_2}{\sstore}$.
From $(\heap, \store, \senv) \in \smodels{\sheap, \sstore}{\pc''}$, we conclude that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. We let $\jsilexpr_1 = \symbeval{\pvsexpr_1}{\senv}$ and 
$\jsilexpr_2 = \symbeval{\pvsexpr_2}{\senv}$, and note that $\symbeval{\bcmd}{\senv} = \jsildelete(\jsilexpr_1, \jsilexpr_2)$.
Now, we have to prove that we can apply the \prooflab{Property Deletion} rule in the concrete state.
To this end, we have to show that:
$\heap = \heap' \dunion \hcell{\symbeval{\jsilexpr_1}{\store}}{\symbeval{\jsilexpr_2}{\store}}{-}$. 
Note that: 
$$
\begin{array}{l}
%
\senv \vdash \pc'' \ \wedge \ \pc'' \vdash \pc' \ \wedge \ \pc' \vdash \sexprp_k = \sexpr_p \implies \senv \vdash \sexprp_k = \sexpr_p \\
%
 \symbeval{\jsilexpr_1}{\store} = \symbeval{\jsilexpr_1}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_1}{\senv}}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_1}{\sstore}}{\senv} 
    = \symbeval{\loc}{\senv} = \loc \\ 
 %
  \symbeval{\jsilexpr_2}{\store}  = \symbeval{\jsilexpr_2}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\pvsexpr_2}{\senv}}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_2}{\sstore}}{\senv}
   =  \symbeval{\sexpr_p}{\senv} = \symbeval{\sexprp_k}{\senv}  \text{ (because $$ and $\senv \vdash \sexprp_k = \sexpr_p$)} \\
 %
 \heap = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n}{\senv} 
       =  \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion \semexpr{(l, \sexprp_k) \mapsto \sexprv_k}{\senv} \\
         \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (l, \semexpr{\sexprp_k}{\senv}) \mapsto \semexpr{\sexprv_k}{\senv}  \\ 
         \qquad =  \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \semexpr{\sexprv_k}{\senv} \\ 
         \qquad = \semexpr{\sheap'}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto -
\end{array}
$$
We can now apply the \prooflab{Property Deletion} rule of the \jsil semantics, concluding: 
$$
   \semtrans{\heap, \store, \jsildelete(\jsilexpr_1, \jsilexpr_2)}{\semexpr{\sheap'}{\senv},  \store}
$$
meaning that: $\heap' = \semexpr{\sheap'}{\senv}$ and $\store' = \store$.
Now, we have to prove that $(\heap', \store', \senv) \in \smodels{\sheap', \sstore'}{\pc''}$.
Noting that $\heap' = \semexpr{\sheap'}{\senv}$ and $\store' = \store = \semexpr{\sstore}{\senv} = \semexpr{\sstore'}{\senv}$, 
the result follows. 
\vspace{6pt}

\noindent\prooflab{Property Assignment - Found}
We conclude that  $\bcmd = [\pvsexpr_1, \pvsexpr_2] := \pvsexpr_3$ for some extended expressions $\sexpr_1$, $\sexpr_2$, 
and $\pvsexpr_3$, and that: 
$$
\begin{array}{l}
  \sheap =  \sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n    \\
  %
  \sheap' = \sheap'' \, \uplus \,  \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n \, \uplus \,  (l, \sexpr_p) \mapsto \sexpr_v  \\
  %
  \sstore' = \sstore \\ 
  %
  \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p)
\end{array}
$$ 
where $\symbeval{\pvsexpr_1}{\sstore} =  \loc$, $\symbeval{\pvsexpr_2}{\sstore} =  \sexpr_p$, 
$\symbeval{\pvsexpr_3}{\sstore} =  \sexpr_v$.
From $(\heap, \store, \senv) \in \smodels{\sheap, \sstore}{\pc'}$, we conclude that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. 
We let $\jsilexpr_1 = \symbeval{\pvsexpr_1}{\senv}$, 
$\jsilexpr_2 = \symbeval{\pvsexpr_2}{\senv}$, and $\jsilexpr_3 = \symbeval{\pvsexpr_3}{\senv}$, and note that $\symbeval{\bcmd}{\senv} = [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3$.
Now, we have to prove that we can apply the \prooflab{Property Assignment - Found} rule in the concrete state.
To this end, we have to show that there is a concrete heap $\heap''$ such that:
$\heap = \heap'' \dunion \hcell{\symbeval{\jsilexpr_1}{\store}}{\symbeval{\jsilexpr_2}{\store}}{-}$. 
Note that: 
$$
\begin{array}{l}
%
\senv \vdash \pc'' \ \wedge \ \pc'' \vdash \pc' \ \wedge \ \pc' \vdash \sexprp_k = \sexpr_p \implies \senv \vdash \sexprp_k = \sexpr_p \\
%
 \symbeval{\jsilexpr_1}{\store} = \symbeval{\jsilexpr_1}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_1}{\senv}}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_1}{\sstore}}{\senv} 
    = \symbeval{\loc}{\senv} = \loc \\ 
 %
  \symbeval{\jsilexpr_2}{\store}  = \symbeval{\jsilexpr_2}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\pvsexpr_2}{\senv}}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_2}{\sstore}}{\senv}
   =  \symbeval{\sexpr_p}{\senv} = \symbeval{\sexprp_k}{\senv}  \text{ (because $\senv \vdash \sexprp_k = \sexpr_p$)} \\
 %
  \symbeval{\jsilexpr_3}{\store}  = \symbeval{\jsilexpr_3}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\pvsexpr_3}{\senv}}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_3}{\sstore}}{\senv}
   =  \symbeval{\sexpr_v}{\senv} \\
 %
 \heap = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n}{\senv} 
       =  \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion \semexpr{(l, \sexprp_k) \mapsto \sexprv_k}{\senv} \\
         \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (l, \semexpr{\sexprp_k}{\senv}) \mapsto \semexpr{\sexprv_k}{\senv}  \\ 
         \qquad =  \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \semexpr{\sexprv_k}{\senv} \\ 
\end{array}
$$
We can now apply the \prooflab{Property Assignment - Found} rule of \jsil semantics, concluding: 
$$
   \semtrans{\heap, \store, [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3}
     {\semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \symbeval{\jsilexpr_3}{\store},  \store}
$$
meaning that: 
$\heap' = \symbeval{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \symbeval{\jsilexpr_3}{\store}$ and 
$\store' = \store$.
Now we have to prove that $(\heap', \store', \senv) \in \smodels{\sheap', \sstore'}{\pc''}$.
Noting that:
$$
\begin{array}{l}
\heap' = \symbeval{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \symbeval{\jsilexpr_3}{\store} \\ 
  \qquad = \symbeval{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n}{\senv} \dunion (\loc, \symbeval{\sexpr_p}{\senv}) \mapsto \symbeval{\sexpr_v}{\senv}  \\
    \qquad = \symbeval{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i \neq k}^n \dunion (\loc, \sexpr_p) \mapsto \sexpr_v}{\senv}  \\
    \qquad = \symbeval{\sheap'}{\senv} \\[2pt]
 %
 \store' = \store = \symbeval{\sstore}{\senv} = \symbeval{\sstore'}{\senv} 
\end{array}
$$
the result follows. 
\vspace{6pt}

\noindent\prooflab{Property Assignment - Not Found}
We conclude that  $\bcmd = [\pvsexpr_1, \pvsexpr_2] := \pvsexpr_3$ for some extended expressions $\pvsexpr_1$, $\pvsexpr_2$, 
and $\pvsexpr_3$, and that: 
$$
\begin{array}{l}
  \sheap =   \sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n     \\
  %
  \sheap' =  \sheap \, \uplus \,  (l, \sexpr_p) \mapsto \sexpr_v  \\
  %
  \sstore' = \sstore \\ 
  %
    \pc' = \pc \ \wedge \, \bigwedge_{i = 0}^n (\sexprp_i \neq \sexpr_p)
\end{array}
$$ 
where: $\symbeval{\pvsexpr_1}{\sstore} =  \loc$, $\symbeval{\pvsexpr_2}{\sstore} =  \sexpr_p$, 
$\symbeval{\pvsexpr_3}{\sstore} =  \sexpr_v$,  $(\loc, -) \not\in \domain(\sheap'')$, 
and $0 \leq k \leq n$. 
From $(\heap, \store, \senv) \in \smodels{\sheap, \sstore}{\pc'}$, we conclude that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. 
We let $\jsilexpr_1 = \symbeval{\pvsexpr_1}{\senv}$, 
$\jsilexpr_2 = \symbeval{\pvsexpr_2}{\senv}$, and $\jsilexpr_3 = \symbeval{\pvsexpr_3}{\senv}$, and note that $\symbeval{\bcmd}{\senv} = [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3$.
We now have to prove that we can apply the \prooflab{Property Assignment - Found} rule in the concrete state.
To this end, we have to show that:
$(\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \not\in \domain(\heap)$. 
Note that: 
$$
\begin{array}{l}
%
\senv \vdash \pc'' \ \wedge \ \pc'' \vdash \pc' \ \wedge \ \forall_{0 \leq i \leq n}  \, \pc' \vdash \sexprp_i \neq \sexpr_p  
      \implies \forall_{0 \leq i \leq n}  \, \senv \vdash \sexprp_i \neq \sexpr_p  \\
%
 \symbeval{\jsilexpr_1}{\store} = \symbeval{\jsilexpr_1}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_1}{\senv}}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_1}{\sstore}}{\senv} 
    = \symbeval{\loc}{\senv} = \loc \\ 
 %
  \symbeval{\jsilexpr_2}{\store}  = \symbeval{\jsilexpr_2}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\pvsexpr_2}{\senv}}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_2}{\sstore}}{\senv}
   =  \symbeval{\sexpr_p}{\senv} \\
 %
  \symbeval{\jsilexpr_3}{\store}  = \symbeval{\jsilexpr_3}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\pvsexpr_3}{\senv}}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_3}{\sstore}}{\senv}
   =  \symbeval{\sexpr_v}{\senv} \\
 %
 \heap = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n}{\senv} 
     = \semexpr{\sheap''}{\senv} \dunion \biguplus_{0 \leq i \leq n} ((l, \symbeval{\sexprp_i}{\senv}) \mapsto \symbeval{\sexprv_i}{\senv})
\end{array}
$$
From  $(\loc, -) \not\in \domain(\sheap'')$, we conclude that $(\loc, -) \not\in \domain(\semexpr{\sheap''}{\senv})$. 
Since  for $0 \leq i \leq n$, it holds that $\senv \vdash \senv \vdash \sexprp_i \neq \sexpr_p$, 
we additionally conclude that: 
$$
  \forall_{0 \leq i \leq n}  \, \symbeval{\sexprp_i}{\senv} \neq \symbeval{\sexpr_p}{\senv} 
$$
Recalling that $\symbeval{\jsilexpr_2}{\store} = \symbeval{\sexpr_p}{\senv}$, we conclude that  
$
  \forall_{0 \leq i \leq n}  \, \symbeval{\sexprp_i}{\senv} \neq \symbeval{\jsilexpr_2}{\store}
$, from which it follows (together with $(\loc, -) \not\in \domain(\semexpr{\sheap''}{\senv})$) that 
$(\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \not\in \domain(\heap)$.
We can now apply the \prooflab{Property Assignment - Not Found} rule of \jsil semantics, concluding: 
$$
   \semtrans{\heap, \store, [\jsilexpr_1, \jsilexpr_2] := \jsilexpr_3}
     {\heap \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \symbeval{\jsilexpr_3}{\store},  \store}
$$
meaning that $\heap' = \heap \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \symbeval{\jsilexpr_3}{\store}$ 
and $\store' = \store$. 
%
Now, we have to prove that $(\heap', \store', \senv) \in \smodels{\sheap', \sstore'}{\pc''}$.
Noting that:
$$
\begin{array}{l}
\heap' = \symbeval{\sheap}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto \symbeval{\jsilexpr_3}{\store} \\ 
  \qquad = \symbeval{\sheap}{\senv} \dunion (\loc, \symbeval{\sexpr_p}{\senv}) \mapsto \symbeval{\sexpr_v}{\senv}  \\
    \qquad = \symbeval{\sheap \dunion (\loc, \sexpr_p) \mapsto \sexpr_v}{\senv}  \\
    \qquad = \symbeval{\sheap'}{\senv} \\[2pt]
 %
 \store' = \store = \symbeval{\sstore}{\senv} = \symbeval{\sstore'}{\senv} 
\end{array}
$$
the result follows. 
\vspace{6pt}



\noindent\prooflab{Member Check - True}
We conclude that  $\bcmd = \jvar := \hasfield(\pvsexpr_1, \pvsexpr_2)$ for some variable $\jvar$ and expressions $\pvsexpr_1$ and $\pvsexpr_2$, and that: 
$$
\begin{array}{l}
  \sheap =   \sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n     \\
  %
  \sheap' =  \sheap \\
  %
  \sstore' = \sstore[\jvar \mapsto \jtrue] \\ 
  %
    \pc' = \pc \ \wedge \, \big( (\sexprp_k = \sexpr_p) \ \wedge \bigwedge_{i = 0, i \neq k}^n (\sexprp_i \neq \sexpr_p) \big)
\end{array}
$$ 
where $\symbeval{\pvsexpr_1}{\sstore} =  \loc$, $\symbeval{\pvsexpr_2}{\sstore} =  \sexpr_p$, 
$(\loc, -) \not\in \domain(\sheap'')$, and $0 \leq k \leq n$. 
%
From $(\heap, \store, \senv) \in \smodels{\sheap, \sstore}{\pc''}$, we conclude that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. 
We let $\jsilexpr_1 = \symbeval{\pvsexpr_1}{\senv}$ and  
$\jsilexpr_2 = \symbeval{\pvsexpr_2}{\senv}$, and note that $\symbeval{\bcmd}{\senv} = \jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)$.
Now we have to prove that we can apply the \prooflab{Member Check - True} rule in the concrete state.
To this end, we have to show that:
$\heap = \heap'' \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto -$, for 
some concrete heap $\heap''$. 
Note that: 
$$
\begin{array}{l}
%
\senv \vdash \pc'' \ \wedge \ \pc'' \vdash \pc' \ \wedge \ \pc' \vdash \sexprp_k = \sexpr_p \implies \senv \vdash \sexprp_k = \sexpr_p \\
%
 \symbeval{\jsilexpr_1}{\store} = \symbeval{\jsilexpr_1}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_1}{\senv}}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_1}{\sstore}}{\senv} 
    = \symbeval{\loc}{\senv} = \loc \\ 
 %
  \symbeval{\jsilexpr_2}{\store}  = \symbeval{\jsilexpr_2}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\pvsexpr_2}{\senv}}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_2}{\sstore}}{\senv}
   =  \symbeval{\sexpr_p}{\senv} \\
 %
 \heap = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n}{\senv} \\
    \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i\neq k}^n \dunion (l, \sexprp_k) \mapsto \sexprv_k}{\senv} \\
    \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i\neq k}^n}{\senv} \dunion \semexpr{(l, \sexprp_k) \mapsto \sexprv_k}{\senv} \\
    \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i\neq k}^n}{\senv} \dunion (l, \semexpr{\sexprp_k}{\senv}) \mapsto \semexpr{\sexprv_k}{\senv} \\ 
     \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i\neq k}^n}{\senv} \dunion (l, \semexpr{\sexpr_p}{\senv}) \mapsto \semexpr{\sexprv_k}{\senv}
      			\text{ (using $\senv \vdash \sexprp_k = \sexpr_p$)} \\ 
     \qquad = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0, i\neq k}^n}{\senv} \dunion (\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \mapsto - \\
\end{array}
$$
We can now apply the \prooflab{Member Check - True} rule of \jsil semantics, concluding that:  
$$
   \semtrans{\heap, \store, \jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)}{\heap,  \store[\jvar \mapsto \jtrue]}
$$
which means that $\heap' = \heap$ and $\store' = \store[\jvar \mapsto \jtrue]$. 
%
We now have to prove that $(\heap', \store', \senv) \in \smodels{\sheap', \sstore'}{\pc''}$.
Noting that:
$$
\begin{array}{l}
\heap' = \heap = \semexpr{\sheap}{\senv} = \semexpr{\sheap'}{\senv} \\
 %
 \store' = \store[\jvar \mapsto \jtrue] = \symbeval{\sstore}{\senv}[\jvar \mapsto \jtrue]  = \symbeval{\sstore[\jvar \mapsto \jtrue]}{\senv} = \symbeval{\sstore'}{\senv} 
\end{array}
$$
the result follows. 
\vspace{6pt}


\noindent\prooflab{Member Check - False}
We conclude that  $\bcmd = \jvar := \hasfield(\pvsexpr_1, \pvsexpr_2)$ for some variable $\jvar$ and expressions $\pvsexpr_1$ and $\pvsexpr_2$, and that: 
$$
\begin{array}{l}
  \sheap =  \sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n      \\
  %
  \sheap' =  \sheap \\
  %
  \sstore' = \sstore[\jvar \mapsto \jfalse] \\ 
  %
     \pc' = \pc \ \wedge \,  \bigwedge_{i = 0}^n (\sexprp_i \neq \sexpr_p) 
\end{array}
$$ 
where $\symbeval{\pvsexpr_1}{\sstore} =  \loc$, $\symbeval{\pvsexpr_2}{\sstore} =  \sexpr_p$, 
$(\loc, -) \not\in \domain(\sheap'')$, and $0 \leq k \leq n$. 
%
From $(\heap, \store, \senv) \in \smodels{\sheap, \sstore}{\pc'}$, we conclude that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. 
We let $\jsilexpr_1 = \symbeval{\pvsexpr_1}{\senv}$ and  
$\jsilexpr_2 = \symbeval{\pvsexpr_2}{\senv}$, and note that $\symbeval{\bcmd}{\senv} = \jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)$.
We now have to prove that we can apply the \prooflab{Member Check - False} rule in the concrete state.
To this end, we have to show that: $(\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \not\in \domain(\heap)$. 
Note that: 
$$
\begin{array}{l}
%
\senv \vdash \pc'' \ \wedge \ \pc'' \vdash \pc' \ \wedge \ \forall_{0 \leq i \leq n}  \, \pc' \vdash \sexprp_i \neq \sexpr_p  
      \implies \forall_{0 \leq i \leq n}  \, \senv \vdash \sexprp_i \neq \sexpr_p  \\
%
 \symbeval{\jsilexpr_1}{\store} = \symbeval{\jsilexpr_1}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_1}{\senv}}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_1}{\sstore}}{\senv} 
    = \symbeval{\loc}{\senv} = \loc \\ 
 %
  \symbeval{\jsilexpr_2}{\store}  = \symbeval{\jsilexpr_2}{\semexpr{\sstore}{\senv}} =  \symbeval{\symbeval{\pvsexpr_2}{\senv}}{\symbeval{\sstore}{\senv}} = \symbeval{\symbeval{\pvsexpr_2}{\sstore}}{\senv}
   =  \symbeval{\sexpr_p}{\senv} \\
 %
 \heap = \semexpr{\sheap'' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n}{\senv} \\
    \qquad = \semexpr{\sheap''}{\senv} \dunion \biguplus_{0 \leq i \leq n} (l, \semexpr{\sexprp_i}{\senv}) \mapsto \semexpr{\sexprv_i}{\senv}
\end{array}
$$
Since $(\loc, -) \not\in \domain(\sheap'')$, we conclude that $(\loc, -) \not\in \semexpr{\sheap''}{\senv}$. 
%
Since for all ${0 \leq i \leq n}$, it holds that $\senv \vdash \sexprp_i \neq \sexpr_p$, we additionally conclude that: 
$$
  \forall_{0 \leq i \leq n}  \, \symbeval{\sexprp_i}{\senv} \neq \symbeval{\sexpr_p}{\senv} 
$$
Recalling that $\symbeval{\jsilexpr_2}{\store} = \symbeval{\sexpr_p}{\senv}$, we conclude that  
$
  \forall_{0 \leq i \leq n}  \, \symbeval{\sexprp_i}{\senv} \neq \symbeval{\jsilexpr_2}{\store}
$, from which it follows (together with $(\loc, -) \not\in \domain(\semexpr{\sheap''}{\senv})$) that 
$(\symbeval{\jsilexpr_1}{\store}, \symbeval{\jsilexpr_2}{\store}) \not\in \domain(\heap)$.
%
We can now apply the \prooflab{Member Check - False} rule of \jsil semantics, concluding: 
$$
   \semtrans{\heap, \store, \jvar := \hasfield(\jsilexpr_1, \jsilexpr_2)}{\heap,  \store[\jvar \mapsto \jfalse]}
$$
meaning that $\heap' = \heap$ and $\store' = \store[\jvar \mapsto \jfalse]$. 
%
Now we have to prove that $(\heap', \store', \senv) \in \smodels{\sheap', \sstore'}{\pc''}$.
Noting that:
$$
\begin{array}{l}
\heap' = \heap = \semexpr{\sheap}{\senv} = \semexpr{\sheap'}{\senv} \\
 %
 \store' = \store[\jvar \mapsto \jfalse] = \symbeval{\sstore}{\senv}[\jvar \mapsto \jfalse]] = \symbeval{\sstore[\jvar \mapsto \jfalse]}{\senv} = \symbeval{\sstore'}{\senv} 
\end{array}
$$
the result follows. 
\vspace{6pt}


\noindent\prooflab{Assert - True}
We conclude that  $\bcmd = \assert(\pvsexpr)$ for some extended expression $\pvsexpr$, and that: 
$$
  \sheap' = \sheap 
  \quad
  \sstore' =  \sstore 
  \quad
  \pc' = \pc
  \quad
  \pc \vdash  \symbeval{\sexpr}{\sstore}
$$ 
From $(\heap, \store, \senv) \in \smodels{\sheap, \sstore}{\pc''}$, we conclude that $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and 
$\senv \vdash \pc''$. Because $\pc'' \vdash \pc' = \pc$, we conclude that $\senv \vdash \pc$. 
We let $\jsilexpr = \symbeval{\pvsexpr}{\senv}$, and note that $\symbeval{\bcmd}{\senv} = \jvar := \assert(\jsilexpr)$.
We now have to prove that we can apply the \prooflab{Assert - True} rule in the concrete state.
To this end, we have to show that: $\symbeval{\jsilexpr}{\store} = \jtrue$. 
Noting that:
$
  \symbeval{\jsilexpr}{\store} = \symbeval{\jsilexpr}{\symbeval{\sstore}{\senv}} 
         = \symbeval{\symbeval{\pvsexpr}{\sstore}}{\senv} 
$, we conclude (using $\senv \vdash \pc$ and $\pc \vdash  \symbeval{\pvsexpr}{\sstore}$) that 
$\symbeval{\jsilexpr}{\store} = \jtrue$. 
We can now apply the \prooflab{Assert - True} rule of \jsil semantics, concluding: 
$$
   \semtrans{\heap, \store, \assert(\jsilexpr)}{\heap,  \store}
$$
meaning that $\heap' = \heap$ and $\store' = \store$. 
%
Now we have to prove that $(\heap', \store', \senv) \in \smodels{\sheap', \sstore'}{\pc''}$.
Noting that:
$$
\begin{array}{l}
\heap' = \heap = \semexpr{\sheap}{\senv} = \semexpr{\sheap'}{\senv}
 %
 \quad 
 %
 \store' = \store = \symbeval{\sstore}{\senv} = \symbeval{\sstore}{\senv} = \symbeval{\sstore'}{\senv} 
\end{array}
$$
the result follows. The case for the \prooflab{Assume} rule is analogous, noting that if $\senv \vdash \pc \ \wedge \ \sexpr$, then $\senv \vdash \pc$ and $\senv \vdash \sexpr$.
\end{proof}

\begin{lemma}[Soundness of \jsil symbolic execution - Single Step]\label{lemma:soundness:single:step}
$$
\begin{array}{l}
 \forall \, 
	\prog,
	\sheap, \sstore, i, \pc, \sctx, \mode,
	\sheap', \sstore', i', \pc', \sctx', \mode',
	\heap, \store, \ctx,
	\senv, \pc''. \\ 
\quad \symbtrans[\prog][\mode][\mode']{\sheap, \sstore, i, \pc}{\sheap', \sstore', i', \pc'}[\sctx][\sctx'] 
   \, \wedge \, \pc'' \vdash \pc' \, \wedge \,
      (\heap, \store, \ctx, \senv) \in \smodels{\sheap, \sstore, \sctx}{\pc''} \, \wedge \, 
      \svarsreallyqueen(\prog) \subseteq \domain(\senv) 
      \\ \qquad
      	 \implies \ \exists \heap', \store', \ctx'. \, 
	 	 \semtrans[\symbeval{\prog}{\senv}][\mode][\mode']{\heap, \store, i}{\heap', \store', i'}[\ctx][\ctx']
		\, \wedge \, 
		(\heap', \store', \ctx', \senv) \in \smodels{\sheap', \sstore', \sctx'}{\pc''}  
\end{array}
$$
\end{lemma}

%
\begin{proof}
We proceed by case analysis on $\symbtrans{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx']$. Given the symbolic semantics for JSIL commands, we obtain that $\mode = \top$.  Throughout the proof, we use the following facts:
 
\begin{description}
\item [{[F1]}] If $\ccmd[\prog][\sctx]{i} = \cmd$ and $\svarsreallyqueen(\prog) \subseteq \domain(\senv)$, then it holds that $\symbeval{\prog}{\senv}$, $\symbeval{\sctx}{\senv}$, and $\symbeval{\cmd}{\senv}$ are concrete, and $\ccmd[\symbeval{\prog}{\senv}][\symbeval{\sctx}{\senv}]{i} = \symbeval{\cmd}{\senv}$.
\item [{[F2]}] If $(\heap, \store, \ctx, \senv) \in \smodels{\sheap, \sstore, \sctx}{\pc}$, then it holds that $\heap = \symbeval{\sheap}{\senv}$, $\store = \symbeval{\sstore}{\senv}$, $\ctx = \symbeval{\sctx}{\senv}$, $\senv \vdash \pc$, and also that $(\heap, \store, \senv) \in \smodels{\sheap, \sstore}{\pc}$
\end{description}

\medskip
We first prove the cases for which $\mode' = \bot$. The only applicable rule is \prooflab{Basic Command}. We conclude that $\ccmd[\prog][\sctx]{i} = \bcmd$ for some basic command $\bcmd$,  
$\symbtrans[][\top][\bot]{\sheap, \sstore, \bcmd, \pc}{\sheap, \sstore, \pc'}$, 
$\sctx' = \sctx$, and $j = i + 1$. 
Since $\svarsreallyqueen(\prog) \subseteq \domain(\senv)$, we conclude that $\svarsreallyqueen(\bcmd) \subseteq \domain(\senv)$.
Applying Lemma~\ref{soundness:basic:commands} to: 
$$ 
\symbtrans[][\top][\bot]{\sheap, \sstore, \bcmd, \pc}{\sheap, \sstore, \pc'} 
\qquad 
(\heap, \store) \in \smodels{\sheap, \sstore}{\pc''}\ \fact{1}
\qquad 
\pc'' \vdash \pc'
\qquad
\svarsreallyqueen(\bcmd) \subseteq \domain(\senv)
$$
we conclude that there is a concrete heap $\heap'$ and store $\store'$ such 
that: 
$$
\semtrans[][\top][\bot]{\heap, \store, \symbeval{\bcmd}{\senv}}{\heap', \store'}
\qquad 
(\heap', \store') \in \smodels{\sheap, \sstore}{\pc''}  
$$
From the concrete semantics of JSIL basic commands, we obtain that $\heap = \heap'$ and $\store = \store'$. 
Using \fact{1} and $\semtrans[][\top][\bot]{\heap, \store, \symbeval{\bcmd}{\senv}}{\heap, \store}$, 
we can apply the \prooflab{Basic Command} rule of \jsil semantics to conclude 
that: $\semtrans[\symbeval{\prog}{\senv}][\top][\bot]{\heap, \store, i}{\heap, \store, i+1}[\ctx][\ctx']$. Since $\heap' = \heap$, $\store' = \store$, $\sheap' = \sheap$, $\sstore' = \sstore$, $\sctx' = \sctx$, from \fact{1} we obtain that $\ctx' = \ctx$ and, from that, we obtain that $
(\heap', \store', \ctx', \senv) \in \smodels{\sheap', \sstore', \sctx'}{\pc''}$, concluding the proof.

\vspace{5pt}
Onward, we assume that $\mode' = \top$ and elide the modes from the rules.

\vspace{5pt}
\noindent\prooflab{Basic Command} 
We conclude that $\ccmd[\prog][\sctx]{i} = \bcmd$ for some basic command $\bcmd$,  
$\symbtrans{\sheap, \sstore, \bcmd, \pc}{\sheap', \sstore', \pc'}$, 
$\sctx' = \sctx$, and $j = i + 1$. 
Since $\svarsreallyqueen(\prog) \subseteq \domain(\senv)$, we conclude that $\svarsreallyqueen(\bcmd) \subseteq \domain(\senv)$.
Applying Lemma~\ref{soundness:basic:commands} to: 
$$ 
\symbtrans{\sheap, \sstore, \bcmd, \pc}{\sheap', \sstore', \pc'} 
\qquad 
(\heap, \store) \in \smodels{\sheap, \sstore}{\pc''}\ \fact{1}
\qquad 
\pc'' \vdash \pc'
\qquad
\svarsreallyqueen(\bcmd) \subseteq \domain(\senv)
$$
we conclude that there is a concrete heap $\heap'$ and store $\store'$ such 
that: 
$$
\semtrans{\heap, \store, \symbeval{\bcmd}{\senv}}{\heap', \store'}
\qquad 
(\heap', \store') \in \smodels{\sheap', \sstore'}{\pc}  
$$
Using \fact{1} and $\semtrans{\heap, \store, \symbeval{\bcmd}{\senv}}{\heap', \store'}$, 
we can apply the \prooflab{Basic Command} rule of \jsil semantics to conclude 
that: $\semtrans[\symbeval{\prog}{\senv}]{\heap, \store, i}{\heap', \store', i+1}[\ctx][\ctx']$. 
From $\sctx' = \sctx$, $(\heap', \store', \senv) \in \smodels{\sheap', \sstore'}{\pc''}$, 
and $(\heap, \store, \ctx, \senv) \in \smodels{\sheap, \sstore, \sctx}{\pc''}$, it follows
that $(\heap', \store', \ctx', \senv) \in \smodels{\sheap, \sstore, \sctx}{\pc''}$, 
which concludes the proof. 
\vspace{6pt}


\noindent\prooflab{Goto} 
We conclude that $\ccmd[\prog][\sctx]{i} = \goto \, k$ for some program index $k$ and 
that $\symbtrans{\sheap, \sstore, i, \pc}{\sheap, \sstore, k, \pc}[\sctx][\sctx]$, 
meaning that $\sheap' = \sheap$, $\sstore' = \sstore$, $\sctx' = \sctx$, $j = k$, 
and $\pc' = \pc$. 
Given \fact{1}, we conclude that 
$\semtrans[\symbeval{\prog}{\senv}]{\heap, \store, i}{\heap, \store, k}[\ctx][\ctx]$. 
Noting that: 
$$
(\heap', \store', \ctx',\senv) = (\heap, \store, \ctx,\senv) \in \smodels{\sheap, \sstore, \sctx}{\pc''}  = \smodels{\sheap', \sstore', \sctx'}{\pc''}
$$
the result follows. 
\vspace{6pt}


\noindent\prooflab{Cond. Goto - True} 
We conclude that $\ccmd[\prog][\sctx]{i} = \ifgoto{\sexpr}{k_1}{k_2}$ for some extended expression 
$\pvsexpr$ and indexes $k_1$ and $k_2$ and 
that $\symbtrans{\sheap, \sstore, i, \pc}{\sheap, \sstore, k_1, \pc \, \wedge \, \semexpr{\sexpr}{\sstore}}[\sctx][\sctx]$, 
meaning that $\sheap' = \sheap$, $\sstore' = \sstore$, $\sctx' = \sctx$, $j = k$, 
and $\pc' = \pc \, \wedge \, \semexpr{\pvsexpr}{\sstore}$. 
%Since $(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''}$, we conclude that there is a symbolic environment $\senv$ such that: $\senv \vdash \pc''$, $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and $\ctx = \semexpr{\sctx}{\senv}$.
Given $\pc'' \vdash \pc'$ and \fact{2}, we conclude that $\senv \vdash \pc'$. 
From  $\senv \vdash \pc' = (\pc \ \wedge \ \semexpr{\pvsexpr}{\sstore})$, it follows that $\senv \vdash \semexpr{\pvsexpr}{\sstore}$, 
implying that $\symbeval{\semexpr{\pvsexpr}{\sstore}}{\senv} = \jtrue$. 
Letting $\jsilexpr = \symbeval{\pvsexpr}{\senv}$, from \fact{1}, we obtain that $\ccmd[\symbeval{\prog}{\senv}][\symbeval{\sctx}{\senv}]{i} = \ifgoto{\jsilexpr}{k_1}{k_2}$.
Noting that: 
$$
\semexpr{\jsilexpr}{\store} 
    = \semexpr{\jsilexpr}{\semexpr{\sstore}{\senv}} 
    = \semexpr{\symbeval{\pvsexpr}{\senv}}{\semexpr{\sstore}{\senv}} 
    = \semexpr{\semexpr{\pvsexpr}{\sstore}}{\senv} 
    = \jtrue
$$
we conclude that $\semtrans[\symbeval{\prog}{\senv}]{\heap, \store, i}{\heap, \store, k_1}[\ctx][\ctx]$. 
Noting that: 
$$
(\heap', \store', \ctx', \senv) = (\heap, \store, \ctx, \senv) \in \smodels{\sheap, \sstore, \sctx}{\pc''}  = \smodels{\sheap', \sstore', \sctx'}{\pc''}
$$
the result follows. The \prooflab{Cond. Goto - False} case is analogous.
\vspace{6pt}

\noindent\prooflab{Procedure Call} 
We conclude that $\ccmd[\prog][\sctx]{i} =   \jsilcall{\jvar}{\pvsexpr}{\pvsexpr_i |_{i = 0}^{n}}{j}$
for some variable $\jvar$, extended expressions $\pvsexpr$, $\pvsexpr_0$, ..., $\pvsexpr_n$, and 
index $j$, and $\symbtrans{\sheap, \sstore, i, \pc}{\sheap, \sstore', 0, \pc}[\sctx][\sctx']$
where: 
$$
\begin{array}{l}
\sheap' = \sheap
%
\qquad
% 
\sstore' = [ \jvar_i \mapsto \sexpr_i \mid_{i = 0}^{m}] 
%
\qquad 
%
\ctx' = ((\pid', \sstore, \jvar, i+1, j)::\sctx
\\
%
\pid' = \symbeval{\pvsexpr}{\sstore}
%
\qquad 
%
\jsillist{\jvar_1, ..., \jvar_{m}} = \args(\pid')
%
\qquad
%
\sexpr_i = \left\lbrace{\begin{array}{ll}
\symbeval{\pvsexpr_i}{\sstore} & \text{if } 0 \leq i \leq n \\
\jsundefined                            & \text{otherwise}
\end{array}}\right.
\end{array}
$$

Letting $\jsilexpr = \symbeval{\pvsexpr}{\senv}$, $\jsilexpr_i|_{i=0}^n = \symbeval{\pvsexpr_i}{\senv}$, $\jsilexpr_i'|_{i=0}^m = \left\lbrace{\begin{array}{ll}
\jsilexpr_i & \text{if } 0 \leq i \leq n \\
\jsundefined                            & \text{otherwise}
\end{array}}\right.$, and given \fact{1}, we obtain that $\ccmd[\symbeval{\prog}{\senv}][\symbeval{\sctx}{\senv}]{i} = \jsilcall{\jvar}{\jsilexpr}{\jsilexpr_i |_{i = 0}^{n}}{j}$.
%Since $(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''}$, we conclude that there is a symbolic environment $\senv$ such that: $\senv \vdash \pc''$,  $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and $\ctx = \semexpr{\sctx}{\senv}$.
Given \fact{2}, and noting that: 
$$
%\begin{array}{l}
\semexpr{\jsilexpr}{\store} = \semexpr{\jsilexpr}{\semexpr{\sstore}{\senv}} 
    = \semexpr{\symbeval{\pvsexpr}{\senv}}{\semexpr{\sstore}{\senv}} 
    = \semexpr{\semexpr{\pvsexpr}{\sstore}}{\senv} 
    = \pid'   
 \qquad
\semexpr{\jsilexpr_i'}{\store} = \semexpr{\jsilexpr_i'}{\semexpr{\sstore}{\senv}}
%    = \semexpr{\symbeval{\sexpr_i}{\senv}}{\semexpr{\sstore}{\senv}} 
%    = \semexpr{\semexpr{\sexpr_i}{\sstore}}{\senv}
    = \semexpr{\sexpr_i}{\senv}
%\end{array}
$$
we conclude that 
$\semtrans[\symbeval{\prog}{\senv}]{\heap, \store, i}{\heap, [ \jvar_i \mapsto \semexpr{\jsilexpr_i'}{\store} \mid_{i = 0}^{m}] , 0}[\ctx][(\pid', \store, \jvar, i+1, j) :: \ctx]$. 
From: 
$$
\begin{array}{l}
\heap' = \heap = \semexpr{\sheap}{\senv} = \semexpr{\sheap'}{\senv} \\
%
\store' =  [ \jvar_i \mapsto \semexpr{\jsilexpr_i'}{\store} \mid_{i = 0}^{m}] = 
\semexpr{[ \jvar_i \mapsto \sexpr_i \mid_{i = 0}^{m}]}{\senv} = \semexpr{\sstore'}{\senv} \\
%
\ctx' = (\pid', \store, \jvar, i+1, j) :: \ctx = (\pid', \semexpr{\sstore}{\senv}, \jvar, i+1, j) :: \semexpr{\sctx}{\senv} = \semexpr{\sctx'}{\senv} 
\end{array}
$$
the result follows. 
\vspace{6pt}


\noindent\prooflab{Normal Return} 
We have that $i =  \procretlab$, and 
$$\symbtrans[\prog]{\sheap, \sstore, \procretlab, \pc}{\sheap, \sstore'[\jvar \mapsto \sexpr], i, \pc}[\sctx][\sctx']$$
where: 
$\sctx = (-, \sstore', \jvar, i, -) :: \sctx'$ and $\sexpr = \sstore(\procretvar)$. 
%Since $(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''}$ and $\pc' = \pc$, we conclude that there is a symbolic environment $\senv$ such that: $\senv \vdash \pc''$, $\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, and $\ctx = \semexpr{\sctx}{\senv}$.
From $\ctx = \semexpr{\sctx}{\senv}$ (obtained from \fact{1}) and $\sctx = (-, \sstore', \jvar, i, -) :: \sctx'$, we conclude 
that: $\ctx =  (-, \semexpr{\sstore'}{\senv}, \jvar, i, -) :: \semexpr{\sctx'}{\senv}$.
Hence, from \fact{2} and $i =  \procretlab$, 
we conclude that: $\semtrans[\symbeval{\prog}{\senv}]{\heap, \store, \procretlab}{\heap, \semexpr{\sstore'}{\senv}[\jvar \mapsto \val], i}[C][\semexpr{\sctx'}{\senv}]$, 
where $\val =  \store(\procretvar) = \semexpr{\sstore}{\senv}(\procretvar)$.
Noting that: 
$$ 
 \begin{array}{l}
  \heap' = \heap = \semexpr{\sheap}{\senv} = \semexpr{\sheap'}{\senv} \\ 
  %
  \store' = \semexpr{\sstore'}{\senv}[\jvar \mapsto \val] = 
       \semexpr{\sstore'}{\senv}[\jvar \mapsto \semexpr{\sstore}{\senv}(\procretvar)] = 
        \semexpr{\sstore'}{\senv}[\jvar \mapsto \semexpr{\sstore(\procretvar)}{\senv}] = \\
       \qquad  \semexpr{\sstore'[\jvar \mapsto \sstore(\procretvar)]}{\senv}  = 
       \semexpr{\sstore'[\jvar \mapsto \sexpr]}{\senv}  \\ 
 %
 \ctx' = \semexpr{\sctx'}{\senv} 
\end{array}
$$
the result follows. The \prooflab{Error Return} case is analogous.
\vspace{6pt}

%\noindent\prooflab{Error Return} 
%We conclude that $i =  \procerrlab$, and 
%$$\symbtrans{\sheap, \sstore, \procerrlab, \pc}{\sheap, \sstore''[\jvar \mapsto \sexpr], j, \pc}[\sctx][\sctx']$$
%where: 
%$\sctx = (-, \sstore'', \jvar, -, j) :: \sctx''$ and $\sexpr = \sstore(\procerrvar)$. 
%Since $(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''}$ and $\pc' = \pc$, we conclude that 
%there is a symbolic environment $\senv$ such that: $\senv \vdash \pc$, 
%$\heap = \semexpr{\sheap}{\senv}$, $\store = \semexpr{\sstore}{\senv}$, 
%and $\ctx = \semexpr{\sctx}{\senv}$.
%From $\ctx = \semexpr{\sctx}{\senv}$ and $\sctx = (-, \sstore'', \jvar, -, j) :: \sctx''$, we conclude 
%that: $\ctx =  (-, \semexpr{\sstore''}{\senv}, \jvar, -, j) :: \semexpr{\sctx''}{\senv}$.
%Hence, since $i =  \procerrlab$, 
%we conclude that: $\semtrans{\heap, \store, \procerrlab}{\heap, \semexpr{\sstore''}{\senv}[\jvar \mapsto \val], i}[C][\semexpr{\sctx''}{\senv}]$, 
%where $\val =  \store(\procerrvar) = \semexpr{\sstore}{\senv}(\procerrvar)$.
%Noting that: 
%$$ 
% \begin{array}{l}
%  \heap' = \heap = \semexpr{\sheap}{\senv} = \semexpr{\sheap'}{\senv} \\ 
%  %
%  \store' = \semexpr{\sstore''}{\senv}[\jvar \mapsto \val] = 
%       \semexpr{\sstore''}{\senv}[\jvar \mapsto \semexpr{\sstore}{\senv}(\procerrvar)] = 
%        \semexpr{\sstore''}{\senv}[\jvar \mapsto \semexpr{\sstore(\procerrvar)}{\senv}] = \\
%       \qquad  \semexpr{\sstore''[\jvar \mapsto \sstore(\procerrvar)]}{\senv}  = 
%       \semexpr{\sstore''[\jvar \mapsto \sexpr]}{\senv}  = 
%       \semexpr{\sstore'}{\senv}  \\ 
% %
% \ctx' = \semexpr{\sctx''}{\senv} = \semexpr{\sctx'}{\senv} 
%\end{array}
%$$
%the result follows. 
\end{proof}

\begin{lemma}[Monotonicity of Path Condition]\label{lemma:pc:monotonocity}
$$
\begin{array}{l}
\forall \, \prog, \sheap, \sstore,  i, \pc, \mode, j, \sctx, \sheap', \sstore', j, \sctx', \pc', \mode' \, . \,  \\ 
\qquad \symbtranstrans[\prog][\mode][\mode']{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx']  
   \implies \pc' \vdash \pc
\end{array}
$$
\end{lemma}
\begin{proof}
By induction on the length of the symbolic trace $\symbtranstrans[\prog][\mode][\mode']{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx']$.
The proof becomes trivial once we've observed that one step of the symbolic execution either does not change the path condition or further constrains it through conjunction), i.e.,~the path condition is never relaxed by the symbolic execution. Therefore, all models of $\pc'$ must also be the models of $\pc$.
\end{proof}


\begin{lemma}[Soundness of the \jsil symbolic execution]\label{lemma:full:soundness}
$$
\begin{array}{l}
\forall \, \prog, 
	\sheap, \sstore, i, \pc, \sctx, \mode,
	\sheap', \sstore', j, \pc', \sctx', \mode', 
	\pc'', \heap, \store, \ctx, \senv \, . \,  \\ 
%
\quad \symbtranstrans[\prog][\mode][\mode']{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx'] 
   \ \wedge \  \pc'' \vdash \pc' \ \wedge \ 
      (\heap, \store, \ctx, \senv) \in \smodels{\sheap, \sstore, \sctx}{\pc''}  
              \\ \quad \quad
      	 \ \implies \exists \heap', \store', \ctx' \, . \, 
	 	 \semtranstrans[\symbeval{\prog}{\senv}][\mode][\mode']{\heap, \store, i}{\heap', \store', j}[\ctx][\ctx']
		\, \wedge \, 
		(\heap', \store', \ctx') \in \smodels{\sheap', \sstore', \sctx'}{\pc''}  
\end{array}
$$
\end{lemma}
\begin{proof}
Suppose $\symbtranstrans[\prog][\mode][\mode']{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx']$ (\hyp{1}) 
and $(\heap, \store, \ctx, \senv) \in \smodels{\sheap, \sstore, \sctx}{\pc''}$~(\hyp{2}). 
We have to prove that there is a concrete heap $\heap'$, store $\store'$, and context 
$\ctx'$ such that $\semtranstrans[\symbeval{\prog}{\senv}][\mode][\mode']{\heap, \store, i}{\heap', \store', j}[\ctx][\ctx']$
and $(\heap', \store', \ctx', \senv) \in \smodels{\sheap', \sstore', \sctx'}{\pc''}$. 
We proceed by induction on the length of the symbolic trace 
$$\symbtranstrans{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx'].$$ 
Suppose the symbolic trace has length $n$. 
\vspace{6pt}

\noindent \prooflab{Base Case} $n = 0$. It follows that $\sheap' = \sheap$, $\sstore' = \sstore$, 
$\sctx' = \sctx$, $\pc' = \pc$, and $j = i$. Noting that 
$\semtranstrans{\heap, \store, i}{\heap, \store, i}[\ctx][\ctx]$
and 
$(\heap, \store, \ctx) \in \smodels{\sheap, \sstore, \sctx}{\pc''} = \smodels{\sheap', \sstore', \sctx'}{\pc''}$, 
the result follows. 
\vspace{6pt}

\noindent \prooflab{Inductive Case} $n = m + 1$. It follows that there is a symbolic heap $\sheap''$, 
store $\sstore''$, context $\sctx''$, mode $\mode''$, and path condition $\pc'''$ such that: 
$$
\symbtranstrans[\prog][\mode][\mode'']{\sheap, \sstore, i, \pc}{\sheap'', \sstore'', k, \pc'''}[\sctx][\sctx''] \ (\ieq{1})
\qquad 
\symbtrans[\prog][\mode''][\mode']{\sheap'', \sstore'', k, \pc'''}{\sheap', \sstore', j, \pc'}[\sctx''][\sctx'] \ (\ieq{2})
$$
%From \ieq{1} and \ieq{2}, it follows that $\mode = \mode'' = \top$. 
Applying Lemma~\ref{lemma:pc:monotonocity} to \ieq{2}, we conclude that $\pc' \vdash \pc'''$ (\ieq{3}), 
from which it follows (recalling that $\pc'' \vdash \pc'$) that $\pc'' \vdash \pc'''$ (\ieq{4}).
%
Applying the induction hypothesis to \ieq{1}, \hyp{2}, and \ieq{4}, and, we conclude that 
there is a heap $\heap''$, store $\store''$, and context $\ctx''$, such that: 
$$
 \semtranstrans[\symbeval{\prog}{\senv}][\mode][\mode'']{\heap, \store, i}{\heap'', \store'', k}[\ctx][\ctx''] \ (\ieq{5})
 \quad 
(\heap'', \store'', \ctx'', \senv) \in \smodels{\sheap'', \sstore'', \sctx''}{\pc''}  \ (\ieq{6})
$$
Applying Lemma~\ref{lemma:soundness:single:step} to \ieq{2}, \ieq{6}, 
and $\pc'' \vdash \pc'$, we conclude that there is 
a heap $\heap'$, store $\store'$, and context $\ctx'$, such that: 
$$
 \semtrans[\symbeval{\prog}{\senv}][\mode''][\mode']{\heap'', \store'', k}{\heap', \store', j}[\ctx''][\ctx'] \ (\ieq{7})
 \quad 
(\heap', \store', \ctx', \senv) \in \smodels{\sheap', \sstore', \sctx'}{\pc''} \ (\ieq{8})
$$
Combining \ieq{5} and \ieq{7}, we conclude that $\semtranstrans[\symbeval{\prog}{\senv}][\mode][\mode'']{\heap, \store, i}{\heap', \store', j}[\ctx][\ctx']$ (\ieq{9}). Finally,  
equations \ieq{8} and \ieq{9} conclude the proof. 
\end{proof}



\begin{temax}[Theorem~\ref{teo:soundness:jsil:symb:exe} - Soundness of the \jsil symbolic execution]
$$
\begin{array}{l}
\forall \, \prog, 
	\sheap, \sstore, i, \pc, \sctx, \mode, 
	\sheap', \sstore', i', \pc', \sctx', \mode', 
	\heap, \store, \ctx, \senv \, . \,  \\  
\quad \symbtranstrans[\prog][\mode][\mode']{\sheap, \sstore, i, \pc}{\sheap', \sstore', i', \pc'}[\sctx][\sctx'] 
   \ \wedge \ 
      (\heap, \store, \ctx, \senv) \in \smodels{\sheap, \sstore, \sctx}{\pc'} \\ \quad \quad
      	 \ \Rightarrow \ \exists \heap', \store', \ctx' \, . \, 
	 	 \semtranstrans[\symbeval{\prog}{\senv}][\mode][\mode']{\heap, \store, i}{\heap', \store', i'}[\ctx][\ctx']
		\, \wedge \, 
		(\heap', \store', \ctx') \in \smodels{\sheap', \sstore', \sctx'}{\pc'}  
\end{array}
$$
\end{temax}
\begin{proof}
Immediate, from Lemma~\ref{lemma:full:soundness}, noting that $\pc' \vdash \pc'$. 
\end{proof}


\begin{cormax}[Corollary~\ref{bug:finding} - Bug-finding]
$$
\begin{array}{l}
\forall \, \prog, \sheap, \sstore, i, \pc, \sctx, \sheap', \sstore', j, \pc', \sctx' \, . \, \\  
 \quad \symbtranstrans[\prog][\top][\bot]{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx']  \\ 
   \qquad \implies 
     \exists \heap, \store, \ctx, \senv \, . \, (\heap, \store, \ctx, \senv) \in \smodels{\sheap, \sstore, \sctx}{\pc'} \ \wedge \ \semtranstrans[\symbeval{\prog}{\senv}][\top][\bot]{\heap, \store, i}{\_, \_, \_}[\ctx][\_]. 
\end{array}
$$
\end{cormax}
\begin{proof}
We suppose that $\symbtranstrans[\prog][\top][\bot]{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx']$, and will first show that $\pc'$ is satisfiable. Given the symbolic execution rules, the last rule that was applied in the symbolic execution of $\symbtranstrans[\prog][\top][\bot]{\sheap, \sstore, i, \pc}{\sheap', \sstore', j, \pc'}[\sctx][\sctx']$ is the \prooflab{Basic Command} rule combined with an \prooflab{Assert - False} rule: 

{\footnotesize 
$$
  \inferrule[\textsc{Basic Command}]
   { 
     \ccmd{j-1} = \assert(\pvsexpr) 
     \\\\
     \symbtrans[\prog][\top][\bot]{\sheap', \sstore', \assert(\pvsexpr), \pc''}{\sheap', \sstore', \pc'} 
   }{\symbtrans[\prog][\top][\bot]{\sheap', \sstore', j-1, \pc''}{\sheap', \sstore', j, \pc'}}
   \qquad
\inferrule[\textsc{Assert - False}]
  { 
     \pc' = \pc'' \wedge  \neg\symbeval{\pvsexpr}{\store} \qquad \pc' \text{is satisfiable}
  }{\symbtrans[][\top][\bot]{\sheap', \sstore', \assert(\pvsexpr), \pc''}{\sheap', \sstore',  \pc'}}$$}

\noindent Therefore, $\pc'$ is satisfiable. Now, since $\pc'$ is satisfiable, we conclude that there exist a concrete heap $\heap$, store $\store$, context $\ctx$, and symbolic environment $\senv$, such that $(\heap, \store, \ctx, \senv) \in \smodels{\sheap, \sstore, \sctx}{\pc'}$. Then, using Theorem \ref{teo:soundness:jsil:symb:exe}, we obtain the desired goal.
\end{proof}

\begin{cormax}[Corollary~\ref{corollary:verification} - Verification]
$$
\begin{array}{l}
\forall \, \prog, \sheap, \sheap_1, ..., \sheap_n, \sstore, \sstore_1, ..., \sstore_n, \sctx, \sctx_1, ..., \sctx_n, i, j_1, ..., j_n, \pc, \pc_1, ..., \pc_n, \mode, \mode_1, ..., \mode_n \, . \,  \\
   \wedge_{k=1}^n \left(\symbtranstrans[\prog][\mode][\mode_k]{\sheap, \sstore, i, \pc}{\sheap_k, \sstore_k, j_k, \pc_k}[\sctx][\sctx_k]\mid_{k = 1}^n\right) 
      \ \wedge \ \pc \vdash \bigvee_{k=1}^n \pc_k \\ 
       \quad \Rightarrow \left(
         \forall \heap, \store, \ctx, \senv \, . \, (\heap, \store, \ctx, \senv) \in \smodels{\sheap, \sstore, \sctx}{\pc} \right. \\
           \qquad \left. \Rightarrow \exists k, \heap', \store', \ctx' \, . \, 
                  \semtranstrans[\symbeval{\prog}{\senv}][\mode][\mode_k]{\heap, \store, i}{\heap', \store', j_k}[\ctx][\ctx'] \ \wedge \ 
                  (\heap', \store', \ctx', \senv) \in \smodels{\sheap_k, \sstore_k, \sctx_k}{\pc_k} \right)
\end{array}
$$
\end{cormax}

\begin{proof}
Suppose that $(\heap, \store, \ctx, \senv) \in \smodels{\sheap, \sstore, \sctx}{\pc}$. Then, since $\pc \vdash \bigvee_{k=1}^n \pc_k$, 
we conclude that there exists $k$, $1 \leq k \leq n$, such that:
 $(\heap, \store, \ctx, \senv) \in \smodels{\sheap, \sstore, \sctx}{\pc_k}$. 
 Observing that $\symbtranstrans[\prog][\mode][\mode']{\sheap, \sstore, i, \pc}{\sheap_k, \sstore_k, j_k, \pc_k}[\sctx][\sctx_k]$, we can 
 apply Theorem~\ref{teo:soundness:jsil:symb:exe} to conclude the result. 
 \end{proof}
 
 \newpage
 
 
 
 
 
 
 
 \section{Proofs of Section~\ref{sec:specs}}
 

 \begin{lemma}[CA-Unification: Success] 
\label{successful:unification}
$$
\begin{array}{l}
\cellunification{\sheap, \cell \lstcons \cells}{\sheap_f, \cells'}{\pc} \ \implies \
%
%\unification{\sheap, \sstore, \pc}{\cell}{} = \uyes{\sheap_f} 
     \exists \sheap' . \, \sheap = \sheap' \dunion \sheap_f  \, \wedge \, 
		\smodels{\sheap', \sstore}{\pc} \subseteq \sepmodels{\cell}
\end{array}
$$
 \end{lemma}
 \begin{proof}
%
We conclude from the hypothesis that $\cell = (\loc,\sexprp)\pointsto \sexprv$ (\ieq{1}), 
$\sheap = \sheap_f \dunion ((l, \sexprp') \mapsto \sexprv')$ (\ieq{2}), and 
$\pc \vdash \sexprp = \sexprp' \ \wedge \ \sexprv = \sexprv'$ (\ieq{3}). 
We pick $\sheap' = (l, \sexprp') \mapsto \sexprv')$ (\ieq{4}). 
We have to prove that for all symbolic environments 
$\senv$ such that $\senv \satisfies \pc$, it holds that: 
$$
\begin{array}{l}
(\symbeval{\sheap'}{\senv}, \symbeval{\sstore}{\senv}) \in \sepmodels{(\loc, \sexprp))\pointsto \sexprv} \\
   %
   \qquad \iff (\symbeval{((l, \sexprp') \mapsto \sexprv')}{\senv}, \symbeval{\sstore}{\senv}) \in \sepmodels{(\loc, \sexprp))\pointsto \sexprv} \\
   % 
   \qquad \iff  (l, \symbeval{\sexprp'}{\senv}) \mapsto \symbeval{\sexprv'}{\senv}, -, \senv \satisfies (\loc, \sexprp))\pointsto \sexprv \\
   %
   \qquad \iff \symbeval{\sexprp'}{\senv} = \symbeval{\sexprp}{\senv} \, \wedge \ \symbeval{\sexprv'}{\senv} = \symbeval{\sexprv}{\senv} \\
   %
   \qquad \iff \jtrue \text{ (because } \senv \satisfies \pc = \sexprp = \sexprp' \ \wedge \ \sexprv = \sexprv' \text{)}
\end{array}
$$
\end{proof}
 
\begin{lemma}[CA-Unification: Uniqueness of Solutions] 
$$
\begin{array}{l}
\cellunification{\sheap, \cell \lstcons \cells}{\sheap_f, \cells}{\pc} \, \implies \,
	 \neg\exists \sheap'', \sheap_f' . \, \sheap_f = \sheap'' \dunion \sheap_f' \, \wedge \, 
                \smodels{\sheap'', \sstore}{\pc} \subseteq \sepmodels{\cell}
\end{array}
$$
\end{lemma}
\begin{proof}
We prove the result by \emph{contradiction}, there are two symbolic heaps $\sheap''$ and $\sheap_f'$ such that
$\sheap_f = \sheap'' \dunion \sheap_f'$~(\ieq{1}) and $\smodels{\sheap'', \sstore}{\pc} \subseteq \sepmodels{\cell}$ (\ieq{2}). 
 Applying Lemma~\ref{successful:unification} to the hypothesis, we conclude that there is a 
 we conclude that there is a symbolic heap $\sheap'$ such that: $\sheap = \sheap' \dunion \sheap_f$ (\ieq{3}) and 
 $\smodels{\sheap', \sstore}{\pc} \subseteq \sepmodels{\cell}$ (\ieq{4}). 
 %
 Combining \ieq{1} and \ieq{3}, we conclude that: $\sheap = \sheap' \dunion \sheap'' \dunion \sheap_f'$ (\ieq{5}). 
Letting $\cell = (\loc, \sexprp) \mapsto \sexprv$, we conclude, from \ieq{2} and \ieq{4}, that for symbolic 
environments $\senv \satisfies \pc$, it holds that: 
$$
(\symbeval{\sheap'}{\senv}, \symbeval{\sstore}{\senv}) \in \sepmodels{(\loc, \sexprp)\pointsto \sexprv} 
\qquad 
(\symbeval{\sheap''}{\senv}, \symbeval{\sstore}{\senv}) \in \sepmodels{(\loc, \sexprp) \pointsto \sexprv}
$$
Let us pick an arbitrary $\senv$ satisfying $\pc$. It must be the case that: 
$$
\begin{array}{l}
\sheap' = (\symbeval{\loc}{\store, \senv}, \symbeval{\sexprp}{\store, \senv}) \mapsto \symbeval{\sexprv}{\store, \senv} 
 =  (\loc, \symbeval{\sexprp)}{\senv}) \mapsto \symbeval{\sexprv}{\senv}
 = \sheap'' \text{ (\ieq{6})}
\end{array}
$$
Observe that \ieq{6} contradicts \ieq{5}, from which the result follows.
 \end{proof}


\begin{lemma}[CA-Unification:  Failure]\label{ca:unification:failure} 
$$
\begin{array}{l}
\cellunificationx{\sheap, \cell \lstcons -}{\uno{\pc'}}{\pc} \, \implies \, \\ 
	\qquad  \big(\forall \sheap', \sheap_f . \, \sheap = \sheap' \dunion \sheap_f \implies 
                \smodels{\sheap', \sstore}{\pc \, \wedge \, \pc'} \cap \sepmodels{\cell} = \emptyset \big)
\end{array}
$$
 \end{lemma}
 \begin{proof}
Suppose $\cellunificationx{\sheap, \cell \lstcons -}{\uno{\pc'}}{\pc}$ (\hyp{1}) and 
$\sheap = \sheap' \dunion \sheap_f$ (\hyp{2}), for $\sheap' = (\loc', \sexprp') \mapsto \sexprv'$. 
We have to show that: $\smodels{\sheap', \sstore}{\pc \, \wedge \, \pc'} \cap \sepmodels{\cell} = \emptyset$.
We proceed by \emph{contradiction} assuming that there is a symbolic environment 
$\senv \satisfies \pc \, \wedge \, \pc'$ (\ieq{1}) such that $\sheap, -, \senv \satisfies \cell$ (\ieq{2}). 
Given that $\cell = (\loc, \sexprp) \mapsto \sexprv$ for some location $\loc$ and 
symbolic expressions $\sexprp$ and $\sexprv$, we conclude that: 
$$
\begin{array}{l}
\symbeval{\sheap'}{\senv}, -, \senv \satisfies (\loc, \sexprp) \mapsto \sexprv \\ 
\qquad \iff \big((\loc', \symbeval{\sexprp'}{\senv}) \mapsto \symbeval{\sexprv'}{\senv} \big), -, \senv \satisfies (\loc, \sexprp) \mapsto \sexprv \\ 
\qquad \iff \big((\loc', \symbeval{\sexprp'}{\senv}) \mapsto \symbeval{\sexprv'}{\senv} \big) = (\loc, \symbeval{\sexprp}{\senv}) \mapsto \symbeval{\sexprv}{\senv} \\
\qquad \iff \loc' = \loc \, \wedge \, \symbeval{\sexprp'}{\senv} = \symbeval{\sexprp}{\senv} \, \wedge \, \symbeval{\sexprv'}{\senv} = \symbeval{\sexprv}{\senv} \text{ (\ieq{3})}
\end{array}
$$
Observing that $\loc = \loc'$, we conclude, from the definition of $\rightarrow_{\cal CU}$, that: 
$\pc' \vdash \sexprp' \neq \sexprp \, \vee \, \sexprv' \neq \sexprv$ (\ieq{4}). 
From Equations \ieq{1} and \ieq{4}, we conclude that: 
$\symbeval{\sexprp'}{\senv} \neq \symbeval{\sexprp}{\senv} \, \vee \, \symbeval{\sexprv'}{\senv} \neq \symbeval{\sexprv}{\senv}$ (\ieq{5}). 
Observe that \ieq{5} contradicts \ieq{3}, from which the result follows.
\end{proof}
 
 
\begin{lemma}[Iterated Cell Unification]
\label{lemma:iter:cell:unification}
$$
\begin{array}{l}
  \cellunificationiter{\sheap, \cells}{\sheap_f,  \cells'}{\pc} \, \wedge \, \cells = \cells'' \lstconcat \cells'  \\ 
       \qquad \implies
             \exists \sheap' . \, \sheap = \sheap' \dunion \sheap_f  \, \wedge \, 
		\smodels{\sheap', \sstore}{\pc} \subseteq \sepmodels{\cells''}
 \end{array}
$$
\end{lemma}
\begin{proof}
We proceed by induction on the length of the derivation
$\cellunificationiter{\sheap, \cells}{\sheap_f,  \cells'}{\sstore, \pc, \subst}$. 
We assume that $\cells$ has at least one element. 
\vspace{6pt}

\noindent\prooflab{Base Case} The base case corresponds to a derivation of length $0$.
We conclude that  $\cells = \cells''$, $\cells' = \lemp$, $\sheap = \sheap_f$, and $\sheap' = \hemp$. 
Noting that $\hemp, \sstore, - \satisfies \lemp$, the result follows. 
\vspace{6pt}

\noindent\prooflab{Recursive Case} We assume a derivation of length $n=k+1$. 
We conclude that: $\cells'' = \cell \lstcons \cells'''$ (\ieq{1}) for some $\cells'''$. It follows 
that $\cellunification{\sheap, (\cell \lstcons \cells''') \lstconcat \cells'}{\sheap_f',  (\cells''' \lstconcat \cells')}{\pc}$ (\ieq{2}) and 
$\cellunificationiter{\sheap_f',  (\cells''' \lstconcat \cells')}{\sheap_f,  \cells'}{\pc}$  (\ieq{3}).
Applying Lemma~\ref{successful:unification} to \ieq{2}, we conclude that 
there is a symbolic heap $\sheap''$ such that: 
$$
 \sheap = \sheap'' \dunion \sheap_f' \text{ (\ieq{4})}
  \qquad 
  \smodels{\sheap'', \sstore}{\pc} \subseteq \sepmodels{\cell}  \text{ (\ieq{5})}
$$
Applying the induction hypothesis to \ieq{3}, we conclude that there is a symbolic heap 
$\sheap'''$ such that: 
$$
  \sheap_f' = \sheap''' \dunion \sheap_f  \text{ (\ieq{6})}
  \qquad 
  \smodels{\sheap''', \sstore}{\pc} \subseteq \sepmodels{\cells'''}  \text{ (\ieq{7})}
$$
If we pick $\sheap' = \sheap'' \dunion \sheap'''$, it follows that: 
$$
\begin{array}{l}
   \sheap'' \dunion \sheap''' \dunion \sheap_f = \sheap'' \dunion \sheap_f' = \sheap  \text{ from \ieq{4} and \ieq{6}}\\
  % 
   \smodels{\sheap'' \dunion \sheap''', \sstore}{\pc} \subseteq \sepmodels{\cell \lstcons \cells'''} = \sepmodels{\cells''} \text{ from \ieq{6} and \ieq{8}}
\end{array}
$$
which concludes the result. 		
\end{proof}

\begin{lemma}[Separation Constraints]\label{sanity}
For $\pc = \sanity{\efs}$, $\pvars(\efs) = \emptyset$, and $\aslocs(\efs) = \emptyset$, 
it holds that: 
$\senv \satisfies \pc  \ \iff \ \exists \iheap \, . \, \iheap, -, \senv \satisfies \efs$.
\end{lemma}
\begin{proof}
We proceed by induction on the size of $\eflocs(\efs)$. 
\vspace{6pt}

\noindent\prooflab{Base Case}  $\lstsize{\eflocs(\efs)} = 0$. We conclude that $\pc = \jtrue$ 
and $\efs \equiv \lemp$. We rewrite the equivalence as follows: 
$
 \senv \satisfies \jtrue  \iff  \exists \iheap \, . \, \iheap, -, \senv \satisfies \lemp
$,
from which the result follows (it suffices to pick $\iheap = \hemp$). 
\vspace{6pt}

\noindent\prooflab{Inductive Case}  $\lstsize{\eflocs(\efs)} = k+1$. We conclude that 
$\eflocs(\efs) = \{ \loc \} \dunion L$. We can therefore conclude that: 
$$
\begin{array}{l}
\efs = \efproj{\efs}{L} \sep \ \efproj{\efs}{\loc} \text{ (\ieq{1})}
%
\\
%
\pc = \pc_{\loc} \, \wedge \, \pc' \text{ (\ieq{2})}
%
\\ 
%
 \efproj{\efs}{\loc} = \emptyfields{\loc}{\sexpr_d} \sep  \oast_{i = 0}^{n} \, \big((l, \sexprp_i) \mapsto \none\big) \text{ (\ieq{3})}
%
\\ 
\pc_{\loc} = (\wedge_{0 \leq i, j \leq n, i \neq j} \sexprp_i \neq \sexprp_j)
		       \, \wedge \,  \big(\{  \sexprp_i \mid_{i = 0}^n \} \subseteq \sexpr_d \big) \text{ (\ieq{4})}
\end{array}
$$
where $\pc' = \sanity{\efproj{\efs}{L}}$. It follows from the hypothesis 
that $\pvars(\efproj{\efs}{L}) = \emptyset$, and $\aslocs(\efproj{\efs}{L}) = \emptyset$.
Hence, applying the \underline{inductive hypothesis} to $\sanity{\efproj{\efs}{L}}$, 
we conclude that: 
$$
  \senv \satisfies \pc' \ \iff \ 
       \exists \iheap \, . \, \iheap, -, \senv \satisfies \efproj{\efs}{L} \text{ (\ieq{5})}
$$
We now consider both directions of the equivalence separately. 
\begin{itemize}
	\item \prooflab{Left-to-Right} We assume that $\senv \satisfies \pc$ (\ieq{6}). We conclude from \ieq{2}
	 that $\senv \satisfies \pc'$ (\ieq{7}), from which it follows, with \ieq{5},  that there is an 
	 instrumented heap $\iheap$ such that: $\iheap, -, \senv \satisfies \efproj{\efs}{L}$ (\ieq{8}). 
	From \ieq{6} and \ieq{2}, we conclude that  $\senv \satisfies \pc_{\loc}$ (\ieq{9}), from which 
	it follows that $\iheap', -, \senv \satisfies \efproj{\efs}{\loc}$ (\ieq{10}) for: 
	$$
	  \iheap' =   \biguplus_{i = 0}^{n} \, \big((l, \symbeval{\sexprp_i}{\senv}) \mapsto  \none \big) 
	       \dunion \biguplus_{\jstring \not\in \symbeval{\sexpr_d}{\senv}} \big((l, \jstring) \mapsto \none \big) 
	$$ %\emptyfields{\loc}{\sexpr_d}
	Because the concrete locations in $\efproj{\efs}{\loc}$ do 
	not overlap with those in $\efproj{\efs}{L}$, we conclude, from \ieq{8} and \ieq{10}, that 
	$\iheap \disjoint \iheap'$ and $\iheap \dunion \iheap' \satisfies \efs$. 
	\vspace{4pt}
	
	\item \prooflab{Right-to-Left} We assume that there is an instrumented heap $\iheap$ such that 
	         $\iheap, -, \senv \satisfies \efs$ (\ieq{11}), from which it follows that there are two 
	         disjoint instrumented heaps $\iheap'$ and $\iheap''$ such that: 
		$\iheap = \iheap' \dunion \iheap''$ (\ieq{12}), $\iheap', -, \senv \satisfies \efproj{\efs}{\loc}$ (\ieq{13}), 
		and $\iheap'', -, \senv \satisfies \efproj{\efs}{L}$ (\ieq{14}). 
		From \ieq{5} and \ieq{14}, we conclude that:  $ \senv \satisfies \pc'$ (\ieq{15}). 
		From \ieq{13}, we conclude that: 
		$$
		   \forall_{0 \leq i, j \leq n, i \neq j} \symbeval{\sexprp_i}{\senv} \neq \symbeval{\sexprp_j}{\senv} \ \wedge \
		         \{ \symbeval{\sexprp_i}{\senv} \mid_{i=0}^n \} \subseteq \symbeval{\sexpr_d}{\senv} \text{ (\ieq{16})}
  		$$
		From \ieq{16}, we conclude that $\senv \satisfies \pc_{\loc}$ (\ieq{17}). From \ieq{2}, \ieq{15} and \ieq{17}, 
		we conclude that $\senv \satisfies \pc$. 
\end{itemize}


\end{proof}


\begin{lemma}[Negative Resource Unification]\label{lemma:negative:resource}
$$
\begin{array}{l}
  (\heap, \store) \in \smodels{\sheap, \sstore}{\pc} \, \wedge \, \pc \vdash \unificationef{\sheap}{\efs} \, \wedge \,  \sanity{\efs} \\
  \qquad 
      \implies \forall \senv \, . \, \senv \satisfies \pc  \implies \exists \iheap . \, \iheap, \store, \senv \satisfies \efs \, \wedge \, \heap \disjoint \iheap
\end{array}
$$
\end{lemma}
\begin{proof}
We have to show that given a symbolic environment $\senv$ such that $\senv \satisfies \pc$ (\ieq{1}), 
we can construct an instrumented heap $\iheap$ such that $\iheap, \store, \senv \satisfies \efs$ and 
$\heap \disjoint \iheap$. 
Using Lemma~\ref{sanity}, we conclude that there is an instrumented heap $\iheap$ such 
that $\iheap, \sstore, \senv \satisfies \efs$ (\ieq{2}). We now have to prove that $\heap \disjoint \iheap$.
We proceed by induction on the size of $\efs$.  
\vspace{6pt}

\noindent\prooflab{Base Case} We conclude that $\efs = \emptyset$; hence, we conclude, from 
\ieq{2}, that $\iheap = \hemp$ and the result holds. 
\vspace{6pt}

\noindent\prooflab{Inductive Case} We conclude that $\efs = \efa \dunion \efs'$ (\ieq{3}). 
We conclude, from \ieq{2}, that there are two disjoint instrumented heap $\iheap'$ and $\iheap''$ 
such that $\iheap', \sstore, \senv \satisfies \efa$ (\ieq{4}) and  $\iheap'', \sstore, \senv \satisfies \efs'$ (\ieq{5}). 
%
We conclude, from the definition 
of $\unificationef{\sheap}{\efs}$, that: $\unificationef{\sheap}{\efs} \vdash \unificationef{\sheap}{\efs'}$ (\ieq{6}).
From \ieq{6} and the hypothesis, it follows that $\pc \vdash \unificationef{\sheap}{\efs'}$ (\ieq{7}). 
Applying the \underline{induction hypothesis} to $\pc \vdash \unificationef{\sheap}{\efs'} \, \wedge \,  \sanity{\efs}$, 
$(\heap, \store) \in \smodels{\sheap, \sstore}{\pc}$, $\senv \satisfies \pc$, and 
$\iheap'', \sstore, \senv \satisfies \efs'$, we conclude that: $\iheap'' \disjoint \heap$ (\ieq{8}). 
Now we have to prove that $\iheap' \disjoint \heap$. 
We proceed by case analysis on $\efa$.  
\begin{itemize}
   \item $\efa = (\loc,\sexprp)\pointsto \none$ for some location $\loc$ and symbolic expression $\sexprp$. 
   	    There are two cases to consider: \dtag{i} $\loc \not\in \eflocs(\sheap)$, in which case 
	    it immediately holds that $\heap \disjoint \iheap'$ and \dtag{ii} $\loc \in \eflocs(\sheap)$. 
	    Let us now prove the result for \dtag{ii}. 
	    It follows from $\efa = (\loc,\sexprp)\pointsto \none$ that $\iheap' = (\loc, \symbeval{\sexprp}{\senv}) \mapsto \none$ (\ieq{9}). 
	    From \ieq{3}, and the definition of $\unificationef{\sheap}{\efs}$, 
	    we conclude that: 
	    $$
	       \unificationef{\sheap}{\efs} \vdash \unificationefl{\sheap}{(\loc,\sexprp)\pointsto \none} = \sexprp \not\in \{  \sexprp_i \mid_{i = 0}^n \} \text{ (\ieq{10})} 
	    $$
	    for $\sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n$ and $(l, -) \not\in \domain(\sheap')$. 
	    From the hypothesis, \ieq{1}, and \ieq{10}, we conclude $\senv \satisfies   \sexprp \not\in \{  \sexprp_i \mid_{i = 0}^n \}$ (\ieq{11}), 
	    from which it follows that $(\loc, \symbeval{\sexprp}{\senv}) \not\in \domain(\symbeval{\sheap}{\senv}) = \domain(\heap)$ (\ieq{12}). 
	    From \ieq{9} and \ieq{12}, we conclude $\heap \disjoint \iheap'$. 
	    \vspace{4pt}
	    
  \item $\efa = \emptyfields{\loc}{\sexpr_d}$ for some location $\loc$ and symbolic expression $\sexpr_d$. 
           There are two cases to consider: \dtag{i} $\loc \not\in \eflocs(\sheap)$, in which case 
	    it immediately holds that $\heap \disjoint \iheap'$ and \dtag{ii} $\loc \in \eflocs(\sheap)$. 
	    Let us now prove the result for \dtag{ii}. 
	    It follows from $\efa = \emptyfields{\loc}{\sexpr_d}$ that $\iheap' = \uplus_{\jstring \not\in \symbeval{\sexpr_d}{\senv}}\big((\loc, \jstring) \mapsto \none\big)$ (\ieq{13}). 
            From \ieq{3}, and the definition of $\unificationef{\sheap}{\efs}$, 
	    we conclude that: 
	    $$
	       \unificationef{\sheap}{\efs} \vdash \unificationefl{\sheap}{\emptyfields{\loc}{\sexpr_d}} =  \{ \sexprp_i \mid_{i = 0}^n \} \subseteq \sexpr_d \text{ (\ieq{14})} 
	    $$
	    for $\sheap = \sheap' \dunion  \big((l, \sexprp_i) \mapsto \sexprv_i\big)\mid_{i = 0}^n$ and $(l, -) \not\in \domain(\sheap')$. 
	    From the hypothesis, \ieq{1}, and \ieq{14}, we conclude $\senv \satisfies \{ \sexprp_i \mid_{i = 0}^n \} \subseteq \sexpr_d$ (\ieq{15}), 
	    from which it follows that $\domain(\symbeval{\sheap}{\senv}) = \domain(\heap) \subseteq \{ (\loc, \jstring) \mid \jstring \in \symbeval{\sexpr_d}{\senv} \}$ (\ieq{16}). 
	    From \ieq{13}, we conclude that: $\domain(\iheap') \cap \{ (\loc, \jstring) \mid \jstring \in  \symbeval{\sexpr_d}{\senv} \} = \emptyset$ (\ieq{17}).
	    From \ieq{16} and \ieq{17}, it follows that $\domain(\iheap') \cap \domain(\heap) = \emptyset$. 
\end{itemize}
\end{proof}

\begin{lemma}[Expressions and store evaluation]\label{lemma:expr:storev}
$$
\forall \lexpr, \sstore, \senv, \store.\ \symbeval{\sstore}{\senv} = \store \implies \symbeval{\lexpr}{\store, \senv} = \symbeval{\symbeval{\lexpr}{\sstore}}{\emptystore, \senv}.
$$
\end{lemma}
\begin{proof}
By induction on the structure of $\lexpr$. 
The only case we will show is for $\lexpr = \jvar$, the remaining cases are straightforward. 
We need to prove that:
$$
\begin{array}{cl}
\forall \sstore, \senv, \store.\ \symbeval{\sstore}{\senv} = \store \implies \symbeval{\jvar}{\store, \senv} = \symbeval{\symbeval{\jvar}{\sstore}}{\emptystore, \senv}, & \text{i.e.} \\
\forall \sstore, \senv, \store.\ \symbeval{\sstore}{\senv} = \store \implies \store(\jvar) = \symbeval{\sstore(\jvar)}{\emptystore, \senv}, & \text{i.e.} \\
\forall \sstore, \senv.\ (\symbeval{\sstore}{\senv})(\jvar) = \symbeval{\sstore(\jvar)}{\emptystore, \senv}, & \text{i.e.} \\
\forall \sstore, \senv.\ (\symbeval{\sstore(\jvar)}{\senv}) = \symbeval{\sstore(\jvar)}{\emptystore, \senv}, & 
\end{array}
$$
\noindent which trivially holds.
\end{proof}

%  $\quad \lexpr \triangleq$ & $\lit \mid \jvar \mid \svar \mid \unoper\ \lexpr \mid \lexpr \binoper \lexpr$ &   \text{ Logical Expressions} \\[3pt]

\begin{lemma}[Symbolic Store and Satisfiability]\label{lemma:symb:store:sat}
$$
\forall P, \iheap, \sstore, \senv. \;
\iheap, \semexpr{\sstore}{\senv}, \senv \satisfies P
\iff 
\iheap, \semexpr{\emptystore}{\senv}, \senv \satisfies \symbeval{P}{\sstore}.
$$
\end{lemma}
\begin{proof}
By induction on the structure of $P$. The base cases $\jtrue$, $\jfalse$, and $\lemp$ are straightforward, as they contain no program variables and for them, we have that $\symbeval{P}{\sstore} = P$. The cases in which we can apply the induction hypothesis, namely $\neg P$ $P_1 \wedge P_2$, $P_1 \vee P_2$, $\exists \svar. P$, and $P_1 \sep P_2$, follow immediately from the definitions and the appropriate induction hypotheses. Let us now do the case when $P \equiv \lexpr_1 = \lexpr_2$ (the case when $P \equiv \lexpr_1 \leq \lexpr_2$ is analogous). We have to prove that:
$$
\iheap, \semexpr{\sstore}{\senv}, \senv \satisfies \lexpr_1 = \lexpr_2
\iff 
\iheap, \semexpr{\emptystore}{\senv}, \senv \satisfies \symbeval{\lexpr_1}{\sstore} = \symbeval{\lexpr_2}{\sstore}.
$$
By unfolding the satisfiability relation, this becomes:
$$
\iheap = \hemp \, \wedge \, \semexpr{\lexpr_1}{\semexpr{\sstore}{\senv}, \senv} = \semexpr{\lexpr_2}{\semexpr{\sstore}{\senv}, \senv}
\iff 
\iheap = \hemp \, \wedge \, \semexpr{\symbeval{\lexpr_1}{\sstore}}{\emptystore, \senv} = \semexpr{\symbeval{\lexpr_2}{\sstore}}{\emptystore, \senv},
$$
which holds directly, given Lemma \ref{lemma:symb:store:sat}.

We will also prove the case when $P \equiv (\lexpr_1,\lexpr_2)\pointsto \lexpr_3$ (the case when $P \equiv\emptyfields{\lexpr_1}{\lexpr_2}$ is analogous). We have to prove that:
$$
\iheap, \semexpr{\sstore}{\senv}, \senv \satisfies (\lexpr_1,\lexpr_2) \pointsto \lexpr_3
\iff 
\iheap, \semexpr{\emptystore}{\senv}, \senv \satisfies (\symbeval{\lexpr_1}{\sstore},\symbeval{\lexpr_2}{\sstore})\pointsto \symbeval{\lexpr_3}{\sstore}).
$$
By unfolding the satisfiability relation, this becomes:
$$
\iheap = \hcell{\symbeval{\lexpr_1}{\semexpr{\sstore}{\senv}, \senv}}{\symbeval{\lexpr_2}{\semexpr{\sstore}{\senv}, \senv}}{\symbeval{\lexpr_3}{\semexpr{\sstore}{\senv}, \senv}}
\iff 
\iheap = \hcell{\symbeval{\symbeval{\lexpr_1}{\sstore}}{\emptystore, \senv}}{\symbeval{\symbeval{\lexpr_1}{\sstore}}{\emptystore, \senv}}{\symbeval{\symbeval{\lexpr_1}{\sstore}}{\emptystore, \senv}}
$$
which, again, holds directly, given Lemma \ref{lemma:symb:store:sat}.
\end{proof}


\begin{lemma}[Symbolic Store and Entailment, Extended Models]\label{lemma:symb:store:extmod}
We define extended models in the following way: 
$$
\begin{array}{l}
\smodelsext{\sheap, \sstore}{\pc} = \left\{ (\heap, \store, \senv) \mid \semexpr{\sheap}{\senv} = \heap \, \wedge \, \semexpr{\sstore}{\senv} = \store \, \wedge \,  \senv \satisfies \pc  \right\}; \\
\sepmodelsext{P} = \left\{ (\heap, \store, \senv) \mid \exists \iheap \, . \,  \heap = \deabstract{\iheap} \ \wedge \ \iheap, \store, \senv \satisfies P  \right\}.
\end{array}
$$
Given this definition, it holds that
$$
\smodelsext{\sheap, \sstore}{\pc} \subseteq \sepmodelsext{P} 
    \iff 
    \smodelsext{\sheap, \emptystore}{\pc} \subseteq \sepmodelsext{\symbeval{P}{\sstore}}.
$$
\end{lemma}

\begin{proof}
After unfolding the definitions, we obtain:
$$\begin{array}{l}
\forall P, \sheap, \sstore, \senv. \\
\qquad \left( \senv \satisfies \pc \implies
\exists \iheap. \,  \semexpr{\sheap}{\senv} = \deabstract{\iheap} \ \wedge \ \iheap, \semexpr{\sstore}{\senv}, \senv \satisfies P \right)
\\
\qquad \qquad \iff \\
\qquad \left( \senv \satisfies \pc \implies
\exists \iheap,\,  \semexpr{\sheap}{\senv} = \deabstract{\iheap} \ \wedge \ \iheap, \semexpr{\emptystore}{\senv}, \senv \satisfies \symbeval{P}{\sstore} \right).
\end{array}$$
We will prove the left-to-right direction (the right-to-left direction is analogous). We have two hypotheses: $\senv \satisfies \pc \implies
\exists \iheap. \,  \semexpr{\sheap}{\senv} = \deabstract{\iheap} \ \wedge \ \iheap, \semexpr{\sstore}{\senv}, \senv \satisfies P$ (\hyp{1}); and $\senv \satisfies \pc$ (\hyp{2}). Our goal is $\exists \iheap,\,  \semexpr{\sheap}{\senv} = \deabstract{\iheap} \ \wedge \ \iheap, \semexpr{\emptystore}{\senv}, \senv \satisfies \symbeval{P}{\sstore}$ (\goal{1}). From (\hyp{2}) and (\hyp{1}), we obtain $\iheap$, such that $\semexpr{\sheap}{\senv} = \deabstract{\iheap} \ \wedge \ \iheap, \semexpr{\sstore}{\senv}, \senv \satisfies P$ (\ieq{1}). From (\ieq{1}) and Lemma \ref{lemma:symb:store:sat}, we obtain that $\semexpr{\sheap}{\senv} = \deabstract{\iheap} \ \wedge \ \iheap, \semexpr{\emptystore}{\senv}, \senv \satisfies \symbeval{P}{\sstore}$, which gives us the witness for the goal (\goal{1}), namely $\iheap$. 
\end{proof}

\begin{lemma}[Connecting Models and Extended Models]\label{lemma:connect:models}
$$
\begin{array}{l}
\forall \sheap, \sstore, \senv, \pc, \heap, \store. \; (\heap, \store, \senv) \in \smodelsext{\sheap, \sstore}{\pc} \implies (\heap, \store) \in \smodels{\sheap, \sstore}{\pc}; \\
\forall \sheap, \sstore, \pc, \heap, \store. \; (\heap, \store) \in \smodels{\sheap, \sstore}{\pc} \iff \exists \senv. \; (\heap, \store, \senv) \in \smodelsext{\sheap, \sstore}{\pc}
\\
\forall P, \heap, \store, \senv. \; (\heap, \store, \senv) \in \sepmodelsext{P} \implies (\heap, \store) \in \sepmodels{P}; \\
\forall P, \heap, \store. \; (\heap, \store) \in \sepmodels{P} \iff \exists \senv. \; (\heap, \store, \senv) \in \sepmodelsext{P}.
\end{array}
$$
\end{lemma}
\begin{proof}
Directly from the appropriate definitions.
\end{proof}

\begin{lemma}[Symbolic Store and Entailment]\label{lemma:symb:store}
$$
\smodels{\sheap, \sstore}{\pc} \subseteq \sepmodels{P} 
    \iff 
    \smodels{\sheap, \emptystore}{\pc} \subseteq \sepmodels{\symbeval{P}{\sstore}} 
$$
\end{lemma}
\begin{proof}
We will prove that $\smodels{\sheap, \sstore}{\pc} \subseteq \sepmodels{P} \iff \smodelsext{\sheap, \sstore}{\pc} \subseteq \sepmodelsext{P} $. Then, from that and Lemma \ref{lemma:symb:store:extmod}, the desired goal directly holds.


%Unfolding the definitions, we obtain:
%$$\begin{array}{l}
%\forall P, \sheap, \sstore. \\
%\qquad
%\left( \forall \heap, \store. \ (\heap, \store) \in \smodels{\sheap, \sstore}{\pc} \implies (\heap, \store) \in \sepmodels{P}  \right)
%\\
%\qquad \qquad \iff \\
%\qquad \left( 
%\forall \heap, \store. \ (\heap, \store) \in \smodels{\sheap, \emptystore}{\pc} \implies (\heap, \store) \in \sepmodels{\symbeval{P}{\sstore}}
%\right).
%\end{array}$$
%Let us prove the left-to-right direction. We have two hypotheses: $\forall \heap, \store. \ (\heap, \store) \in \smodels{\sheap, \sstore}{\pc} \implies (\heap, \store) \in \sepmodels{P}$ (\hyp{1}); and $(\heap, \store) \in \smodels{\sheap, \emptystore}{\pc}$ (\hyp{2}). Our goal is: $(\heap, \store) \in \sepmodels{\symbeval{P}{\sstore}}$ (\goal{1}).
\end{proof}







\newpage

\begin{proof}
By induction on the structure of $P$. The base cases $\jtrue$, $\jfalse$, and $\lemp$ are straightforward, as they contain no program variables and for them, we have that $\symbeval{P}{\sstore} = P$. The cases in which we can apply the induction hypothesis, namely $\neg P$ $P_1 \wedge P_2$, $P_1 \vee P_2$, and $P_1 \sep P_2$, follow immediately from the definitions and the appropriate induction hypotheses.

Let us now do the case when $P \equiv \lexpr_1 = \lexpr_2$ (the case when $P \equiv \lexpr_1 \leq \lexpr_2$ is analogous). We have to prove that:
$$\begin{array}{l}
\forall \sheap, \sstore, \heap, \store. \ (\exists \senv. \,  \semexpr{\sheap}{\senv} = \heap \, \wedge \, \semexpr{\sstore}{\senv} = \store \, \wedge \,  \senv \satisfies \pc) \implies
(\exists \iheap, \senv. \,  \heap = \deabstract{\iheap} \ \wedge \ \iheap, \store, \senv \satisfies \lexpr_1 = \lexpr_2 )
\\
\qquad \qquad \iff \\
\forall \sheap, \sstore, \heap, \store. \ (\exists \senv. \,  \semexpr{\sheap}{\senv} = \heap \, \wedge \, \semexpr{\emptystore}{\senv} = \store \, \wedge \,  \senv \satisfies \pc) \implies
(\exists \iheap, \senv. \,  \heap = \deabstract{\iheap} \ \wedge \ \iheap, \store, \senv \satisfies \symbeval{\lexpr_1}{\sstore} = \symbeval{\lexpr_2}{\sstore} ).
\end{array}$$
Given the satisfiability relation for SL-assertions, we have that $\sheap = \heap = \iheap = \hemp$ in both implications and also $\store = \emptystore$ in the implication below:
$$\begin{array}{l}
\forall \sstore, \store. \ (\exists \senv \, . \, \semexpr{\sstore}{\senv} = \store \, \wedge \,  \senv \satisfies \pc) \implies
(\exists \senv. \, \hemp, \store, \senv \satisfies \lexpr_1 = \lexpr_2 )
\\
\qquad \qquad \iff \\
\forall \sstore. \ (\exists \senv \, . \, \senv \satisfies \pc) \implies
(\exists \senv \, . \,  \hemp, \emptystore, \senv \satisfies \symbeval{\lexpr_1}{\sstore} = \symbeval{\lexpr_2}{\sstore}).
\end{array}$$

Let us first do the left-to-right implication. The hypotheses we have are:
$\forall \sstore, \store. \ (\exists \senv \, . \, \semexpr{\sstore}{\senv} = \store \, \wedge \,  \senv \satisfies \pc) \implies
(\exists \senv. \, \hemp, \store, \senv \satisfies \lexpr_1 = \lexpr_2 )$ (\hyp{1}) and 
$\exists \senv \, . \, \senv \satisfies \pc$ (\hyp{2}), whereas our goal is 
$\exists \senv \, . \,  \hemp, \emptystore, \senv \satisfies \symbeval{\lexpr_1}{\sstore} = \symbeval{\lexpr_2}{\sstore}$ (\goal{1}), and $\sstore$ is arbitrary.
From (\hyp{2}), we obtain an $\senv$, such that $\senv \satisfies \pc$. We instantiate (\hyp{1}) with $\sstore$, $\semexpr{\sstore}{\senv}$, and $\senv$, obtaining $\senv'$ such that
$\hemp, \semexpr{\sstore}{\senv}, \senv' \satisfies \lexpr_1 = \lexpr_2$, which
means that $\symbeval{\lexpr_1}{\semexpr{\sstore}{\senv}, \senv'} = \symbeval{\lexpr_2}{\semexpr{\sstore}{\senv}, \senv'}$.
We claim that the witness for the goal (\goal{1}) is $\senv'$, i.e.~that $\hemp, \emptystore, \senv' \satisfies \symbeval{\lexpr_1}{\sstore} = \symbeval{\lexpr_2}{\sstore}$, i.e.~that
$\symbeval{\symbeval{\lexpr_1}{\sstore}}{\emptystore, \senv'} = \symbeval{\symbeval{\lexpr_2}{\sstore}}{\emptystore, \senv'}$. Using the previous lemma, this is equivalent to
$\symbeval{\lexpr_1}{\semexpr{\sstore}{\senv'}, \senv'} = \symbeval{\lexpr_2}{\semexpr{\sstore}{\senv'}, \senv'}$.


Next, cell assertion.

Next, empty fields.
\end{proof}

%$\quad \lexpr \triangleq$ & $\lit \mid \jvar \mid \svar \mid \unoper\ \lexpr \mid \lexpr \binoper \lexpr$ &   \text{ Logical Expressions} \\[3pt]
%  %%%%
%  $\quad P\triangleq$ & $\jtrue \mid \jfalse \mid  \neg P \mid P \land P \mid P \lor P  \mid \lexpr = \lexpr \mid \lexpr \leq \lexpr$ & \text{ {Pure Assertions}} \\
%                                  & \hspace*{0.41cm} $\mid \lemp \mid (\lexpr, \lexpr)\pointsto \lexpr \mid \exists \svar. P
%                                  \mid P \sep P  \mid \emptyfields{\lexpr}{\lexpr} $ &  \text{ Spatial Assertions} 

\begin{temax}[Theorem~\ref{teo:unification:soundness} - Soundness of Unification]
$\forall P, \cells, \efs, \pfs',  \sheap, \sstore, \pc, \subst \, .$
$$
\begin{array}{l}
\symbeval{\subst(P)}{\sstore} \equiv (\emptyset, \cells, \efs, \pfs')\implies\unificationfull{\sheap, \pc}{\cells, \efs, \pfs'}{} \
    \implies \smodels{\sheap, \sstore}{\pc} \subseteq \sepmodels{P}   
\end{array}
$$ 
\end{temax}
\begin{proof}
It must be the case that: 
$$
\begin{array}{l}
\cellunificationiter{\sheap, \cells}{\hemp, []}{\pc} \text{ (\ieq{1})} \\
%
\pc \vdash \pfs' \ \wedge \ \sanity{\efs} \ \wedge \  \unificationef{\sheap}{\efs} \text{ (\ieq{2})}
\end{array}
$$

\begin{enumerate}

\item We start by proving that $\smodels{\sheap, \sstore}{\pc} \subseteq \sepmodels{\cell \, \wedge \, \pc}$. 
Applying the Iterated-Cell-Unification Lemma (Lemma~\ref{lemma:iter:cell:unification}) to \ieq{1}, 
we conclude that: 
$$
  \smodels{\sheap, \sstore}{\pc} \subseteq \sepmodels{\cells} \text{ (\ieq{2})}
$$  
From \ieq{2}, noting that $\smodels{\sheap, \sstore}{\pc} \subseteq \sepmodels{\pc}$, 
we conclude that: 
$$
\smodels{\sheap, \sstore}{\pc} \subseteq \sepmodels{\cells \wedge \pc} \text{ (\ieq{3})}
$$  

\item We will now prove that  $\smodels{\sheap, \sstore}{\pc} \subseteq \sepmodels{\cells \sep \efs}$. 
To this end, let us assume that $(\heap, \store) \in \smodels{\sheap, \sstore}{\pc}$ (\ieq{4}). 
From \ieq{4}, we conclude that there is a symbolic environment $\senv$ such that $\senv \satisfies \pc$ (\ieq{5}), 
$\heap = \symbeval{\sheap}{\senv}$ (\ieq{6}), and $\store = \symbeval{\sstore}{\senv}$ (\ieq{6}).
We will now prove that there is an instrumented heap $\iheap$  and $\senv'$ such 
that: $\iheap, \store, \senv' \satisfies \cells \sep \efs$ and $\deabstract{\iheap} = \heap$. 
From \ieq{3} and \ieq{4}, we conclude that there is a symbolic environment $\senv'$ and 
an instrumented heap $\iheap$ such that: $\iheap, \store, \senv' \satisfies \subst(\cells) \sep \pc$ (\ieq{7}). 
From \ieq{7}, it follows that: $\iheap, \store, \senv' \satisfies \cells$ (\ieq{8}) and $\senv' \satisfies \pc$ (\ieq{9}).
Applying Lemma~\ref{lemma:negative:resource} to \ieq{2}, \ieq{4}, and \ieq{9}, we conclude that 
there is an instrumented heap $\iheap'$ such that: $\iheap', -, \senv' \satisfies \efs$ (\ieq{10}) 
and $\heap \disjoint \iheap'$ (\ieq{11}). 
Since $\cells$ does not have a negative footprint, we conclude that $\domain(\iheap) = \domain(\heap)$ (\ieq{12}). 
From \ieq{11} and \ieq{12}, $\iheap \disjoint \iheap'$ (\ieq{13}). 
From \ieq{8}, \ieq{10}, and \ieq{13}, it follows that: 
$
\iheap \dunion \iheap', \store, \senv' \satisfies \cells \sep \efs \text{ (\ieq{14})}
$  
which concludes the proof that: $\smodels{\sheap, \sstore}{\pc} \subseteq \sepmodels{\cells \sep \efs}$ (\ieq{15}). 
\vspace{4pt}

\item From \ieq{15}, we conclude that $\smodels{\sheap, \sstore}{\pc} \subseteq \sepmodels{\cells \sep \efs \, \wedge \, \pc}$ (\ieq{16}). 
From \ieq{2} and \ieq{16}, we conclude that: 
$$
  \smodels{\sheap, \sstore}{\pc} \subseteq \sepmodels{\cells \sep \efs}  
  %
  \qquad 
  %
   \smodels{\sheap, \sstore}{\pc} \subseteq \sepmodels{\pfs'}  
$$
from which it follows that: 
$$ 
 \begin{array}{lcl}
  \smodels{\sheap, \sstore}{\pc} 
           & \subseteq & 
             \sepmodels{\cells \sep \efs} \ \cap \ \sepmodels{\pfs'}  = 
             \sepmodels{\cells \sep \efs \, \wedge \, \pfs'} \text{ (\ieq{17})}
 \end{array}
$$ 
Applying Lemma~\ref{lemma:symb:store} to \ieq{17}, we conclude that 
$\smodels{\sheap, \sstore}{\pc} \subseteq \sepmodels{\subst(P)}$ (\ieq{18}).
Observing that the domain of $\subst$ coincides with the logical variables existentially quantified ($\domain(\subst) = L$), 
it follows: $\smodels{\sheap, \sstore}{\pc}  \subseteq \sepmodels{P}$, which concludes the proof. 
\end{enumerate}
\end{proof}


\begin{lemma}[No double unification]
\label{lemma:no:double:unification}
$$
  \sheap, \pc \satisfies \cell_1 \, \wedge \, \sheap, \pc \satisfies \cell_2 
    \implies 
        \sepmodels{\cell_1 \sep \cell_2 \sep \pc} = \emptyset$$  
for $\pvars(\efs) = \emptyset$ and $\aslocs(\efs) = \emptyset$.
\end{lemma}
\begin{proof}
Given that $\pvars(\efs) = \emptyset$ and $\aslocs(\efs) = \emptyset$,
we can assume that there are symbolic expressions $\sexprp$, 
$\sexprp_1$, $\sexprp_2$, $\sexprv_1$, $\sexprv$, and $\sexprv_2$ 
and a concrete location $\loc$, such that: 
$$
\sheap = (\loc, \sexprp) \mapsto \sexprv \text{ (\ieq{1})}
\qquad
\cell_1 = (\loc, \sexprp_1) \mapsto \sexprv_1 \text{ (\ieq{2})}
\qquad 
\cell_2 = (\loc, \sexprp_2) \mapsto \sexprv_2 \text{ (\ieq{3})}
$$
From \ieq{2} and \ieq{3}, we conclude that: 
$\pc \vdash \sexprp_1 = \sexprp_2 \, \wedge \, \sexprv_1 = \sexprv_2$ (\ieq{4}), 
from which the result follows immediately. 
\end{proof}


\begin{lemma}[Separation Constraints: Failure]
$$
  \forall \efs \, . \, \pvars(\efs) = \emptyset \implies  
  	\forall \iheap, \senv, \efs \, . \, 
		\senv \satisfies \neg \sanity{\efs} \implies \iheap, \senv \not\satisfies \efs
$$
\end{lemma}
\begin{proof}
Assuming that $\pvars(\efs) = \emptyset$ (\hyp{1}) and $\senv \satisfies \neg \sanity{\efs}$ (\hyp{2}), 
we have to prove that $\iheap, \senv \not\satisfies \efs$ for an arbitrary instrumented heap $\iheap$. 
Given that: 
$$
\begin{array}{ll}
\senv  \satisfies \neg \sanity{\efs} 
	& \iff \senv \satisfies \neg \big(\bigwedge_{\loc \in \eflocs(\efs)}\sanityl{\efs}{\loc} \big) \\
	%
	& \iff \senv \satisfies  \bigvee_{\loc \in \eflocs(\efs)} \neg \sanityl{\efs}{\loc} 
	
\end{array}
$$
we conclude that there is a concrete location $\loc \in \eflocs(\efs)$ such that 
$\senv \satisfies  \neg \sanityl{\efs}{\loc}$ (\ieq{1}).
From \ieq{1}, we conclude that: 
$$
\begin{array}{l}
 \senv \satisfies \neg\big((\wedge_{0 \leq i, j \leq n, i \neq j} \sexprp_i \neq \sexprp_j)  \, \wedge \,  (\wedge_{0 \leq i \leq n} \sexprp_i \in \sexpr_d)\big) \\
    \iff \senv \satisfies (\vee_{0 \leq i, j \leq n, i \neq j} \sexprp_i = \sexprp_j) \, \vee \, (\vee_{0 \leq i \leq n} \sexprp_i \not\in \sexpr_d)\big)
\end{array}
$$
where: $\efproj{\efs}{\loc} = \emptyfields{\loc}{\sexpr_d} \sep  \oast_{i = 0}^{n} \, \big((l, \sexprp_i) \mapsto \none \big)$. 
From the above, we conclude that either: \dtag{1} there are two integers $i$ and $j$ such that $i \neq j$ and $\senv \satisfies \sexprp_i = \sexprp_j$ 
or \dtag{1} there is an integer $i$ such that $\senv \satisfies \sexprp_i \not\in \sexpr_d$. We proceed by case analysis. 
\begin{itemize}
   \item Suppose that $\senv \satisfies \sexprp_i = \sexprp_j$, we conclude that there is no 
            instrumented heap $\iheap$, such that $\iheap, \senv \satisfies (l, \sexprp_i) \mapsto \none \sep (l, \sexprp_j) \mapsto \none$, 
            from which it follows that there is no instrumented heap $\iheap$, such that $\iheap, \senv \satisfies \efs$, 
            which concludes the result. 
%
  \item Suppose that $\senv \satisfies \sexprp_i \not\in \sexpr_d$, we conclude that there is no 
            instrumented heap $\iheap$, such that $\iheap, \senv \satisfies \emptyfields{\loc}{\sexpr_d} \sep (l, \sexprp_i) \mapsto \none$, 
            from which it follows that there is no instrumented heap $\iheap$, such that $\iheap, \senv \satisfies \efs$, 
            which concludes the result.
\end{itemize}
\end{proof}




\begin{lemma}[Separation Constraints: Failure]
$$
\begin{array}{l}
  \forall \heap, \store, \senv, \pc, \sheap, \sstore, \efs \, . \\
        \qquad (\heap, \store, \senv) \in \smodels{\sheap, \sstore}{\pc}
           \, \wedge \, \senv \satisfies \neg \unificationef{\sheap}{\efs} 
           \, \wedge \, \symbeval{\sheap}{\senv} \disjoint \iheap 
              \implies \iheap, \senv \not\satisfies \efs
\end{array}
$$
\end{lemma}
\begin{proof}
We assume that: 
$(\heap, \store, \senv) \in \smodels{\sheap, \sstore}{\pc}$ (\hyp{1}), 
$\senv \satisfies \neg \unificationef{\sheap}{\efs}$ (\hyp{2}), and
$\symbeval{\sheap}{\senv} \disjoint \iheap$ (\hyp{3}); and we have to prove that 
$\iheap, \senv \not\satisfies \efs$. 
We prove the result by contradiction, assuming that $\iheap, \senv \satisfies \efs$ (\hyp{4}). 
Expanding \hyp{2}, we obtain: 
$$
\begin{array}{lll}
  \senv \satisfies \neg \unificationef{\sheap}{\efs}  &  \iff & \senv \satisfies \neg \bigwedge_{\efa \in \efs}  \unificationefl{\sheap}{\efa} \\ 
  % 
  & \iff & \senv \satisfies \bigvee_{\efa \in \efs}  \neg\unificationefl{\sheap}{\efa} \\
  %
  & \iff & \exists_{\efa \in \efs} \, \senv \satisfies \neg\unificationefl{\sheap}{\efa}
\end{array}
$$
Hence, we conclude that there is an NR-assertion $\efa \in \efs$ such that $\senv \satisfies \neg\unificationefl{\sheap}{\efa}$ (\ieq{1}). 
We proceed by case analysis on $\efa$. 
\begin{itemize}
   \item $\efa = \emptyfields{\loc}{\sexpr_d}$ (\ieq{2}) for some concrete location $\loc$ and symbolic expression $\sexpr_d$. 
            It follows from \ieq{1} and \ieq{2} that: 
            $\sheap = \sheap' \dunion  \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n$ (\ieq{3}), $l \notin \hlocs{\sheap'}$ (\ieq{4}), 
            and $\senv \satisfies \{ \sexprp_i \mid_{i = 0}^n \} \not\subseteq \sexpr_d$ (\ieq{5}). 
            From \hyp{4} and \ieq{2}, it follows that $\{ (\loc, \jstring) \mid \jstring \not\in \symbeval{\sexpr_d}{\senv} \} \subseteq \domain(\iheap)$ (\ieq{6}).
            From \ieq{3} and \ieq{4}, we conclude that: $\{ (\loc, \symbeval{\sexprp_i}{\senv}) \mid_{i=0}^n \} \subseteq \domain(\symbeval{\sheap}{\senv})$ (\ieq{7}).               
            From \ieq{5}-\ieq{7}, we conclude that $\domain(\symbeval{\sheap}{\senv}) \cap \domain(\iheap) \neq \emptyset$, which contradicts \hyp{3}.
            
  \item $\efa = (\loc,\sexprp)\pointsto \none$ (\ieq{8}) for some concrete location $\loc$ and symbolic expression $\sexprp$. 
            It follows from \ieq{1} and \ieq{2} that: 
            $\sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n$ (\ieq{9}), 
            $l \notin \hlocs{\sheap'}$ (\ieq{10}), and 
            $\senv \satisfies  \neg\wedge_{0 \leq i \leq n} \sexprp \neq \sexprp_i$ (\ieq{11}). 
           We conclude that there is an $i$ such that: $\senv \satisfies \sexprp = \sexprp_i$ (\ieq{12}). 
           From \hyp{4} and \ieq{8}, it follows that $(\loc, \symbeval{\sexprp}{\senv}) \in \domain(\iheap)$ (\ieq{13}). 
           From \ieq{9}, it follows that $(\loc, \symbeval{\sexprp_i}{\senv}) \in \domain(\symbeval{\sheap}{\senv})$ (\ieq{14}). 
           From \ieq{12}-\ieq{14}, we conclude that $\domain(\symbeval{\sheap}{\senv}) \cap \domain(\iheap) \neq \emptyset$, which contradicts \hyp{3}.
\end{itemize}


\end{proof}


%\inferrule[\textsc{NR-None Cell}]
%	{  
%	   \sheap = \sheap' \, \uplus \, \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n   
%	   \\\\
%	    l \notin \hlocs{\sheap'}
%	    \quad 
%	    \pc = \wedge_{0 \leq i \leq n} \sexprp \neq \sexprp_i 
%	 }{ \unificationefl{\sheap}{(\loc,\sexprp)\pointsto \none} =  \pc  }
%\qquad
%\inferrule[\textsc{NR-Empty Fields}]
%	{  
%	    \sheap = \sheap' \dunion  \big((l, \sexprp_i) \mapsto -\big)\mid_{i = 0}^n   
%	    \\\\
%	     l \notin \hlocs{\sheap'}
%	     \quad 
%	    \pc = \{ \sexprp_i \mid_{i = 0}^n \} \subseteq \sexpr_d 
%	}{ \unificationefl{\sheap}{\emptyfields{\loc}{\sexpr_d}}{} =  \pc  } 
%%

%
%\inferrule[\textsc{NR-Unification}]
%	{}{ \unificationef{\sheap}{\efs} =  \bigwedge_{\efa \in \efs}  \unificationefl{\sheap}{\efa}} 
%\\



\begin{lemma}[Counter Models for Failed Grounded Entailement]
$$
\unificationfullfail{\sheap, \pc}{\cells, \efs, \pfs'}{}{\pc''} 
%
 \implies \smodels{\sheap}{\pc \, \wedge \, \pc''} \cap \sepmodels{\cells \sep \efs \sep \pc'} = \emptyset
 $$
\end{lemma}
\begin{proof}
There are three possible causes of failure: a cell unification failure, a pure entailment failure, 
and an extra resource failure. We proceed by case analysis on the cause of failure. 
\vspace{6pt}
\begin{itemize}
    \item \prooflab{Cell unification failure} We conclude that there is a cell assertion $\cell$ 
              and a symbolic heap $\sheap_f$ such that:  
              $\cellunificationiter{\sheap, \cells}{\sheap_f, \cell \lstcons \cells''}{\pc}$ (\ieq{1}) 
              and $\cellunificationx{\sheap_f, \cell}{\uno{\pc''}}{\pc}$ (\ieq{2}), and  
              $\cells = \cells' \lstconcat (\cell \lstcons \cells'')$ (\ieq{3}). Applying Lemma~\ref{lemma:iter:cell:unification}
              to \ieq{1} and \ieq{3}, we conclude that there is a symbolic heap $\sheap'$ such that $\sheap = \sheap' \dunion \sheap_f$ (\ieq{4})
              and $\smodels{\sheap'}{\pc} \subseteq \sepmodels{\cells'}$ (\ieq{5}). 
              Applying Lemma~\ref{ca:unification:failure} to \ieq{2}, we conclude that: 
              $$
              	\forall \sheap'', \sheap_f' . \, \sheap_f = \sheap'' \dunion \sheap_f' \implies 
                     \smodels{\sheap''}{\pc \, \wedge \, \pc'} \cap \sepmodels{\cell} = \emptyset \text{ (\ieq{6})}
              $$
              Equation \ieq{6} tells us that there is no way to unify $\sheap_f$ against $\cell$. However, to 
              establish the result, one needs to prove that there is no way to unify $\sheap$ against $\cell$. 
              Put formally, we need to prove that: 
              $$
              	\forall \sheap'', \sheap_f' . \, \sheap = \sheap'' \dunion \sheap_f' \implies 
                     \big(\smodels{\sheap'', \sstore}{\pc \, \wedge \, \pc'} \cap \sepmodels{\cell} = \emptyset 
                     	\, \vee \, 
	              \sepmodels{\cells \sep \pc} = \emptyset \big)
              $$
              Observing that 
              $\smodels{\sheap'', \sstore}{\pc \, \wedge \, \pc'} \cap \sepmodels{\cells}  =   
                  \smodels{\sheap'', \sstore}{\pc \, \wedge \, \pc'} \cap \sepmodels{\cells \sep (\pc \, \wedge \, \pc')}$, 
              we rewrite the implication above as follows: 
              $$
              	\forall \sheap'', \sheap_f' . \, \sheap = \sheap'' \dunion \sheap_f' \implies 
                     \smodels{\sheap'', \sstore}{\pc \, \wedge \, \pc'} \cap \sepmodels{\cells  \sep (\pc \, \wedge \, \pc')} = \emptyset   
              $$      
              %
              We prove the above by contradiction. Let us assume that there are two symbolic heaps 
              $\sheap''$ and $\sheap_f'$ such that: $\sheap = \sheap'' \dunion \sheap_f'$ (\ieq{7})
              and $(\smodels{\sheap'', \sstore}{\pc \, \wedge \, \pc'} \cap \sepmodels{\cell \sep (\pc \, \wedge \, \pc')} \neq \emptyset) 
                   \vee  \sepmodels{\cells \sep \pc} = \emptyset \big)$ (\ieq{8}). 
              We have two cases to consider: either $\sheap''$ is part of $\sheap'$ or it is part of 
              $\sheap_f$. We prove the two cases separately. 
              \begin{itemize}
                 \item If $\sheap''$ is part of $\sheap'$, it means that $\sheap'', \pc \satisfies \cell$ and there is a cell $\cell'$, 
                         such that $\sheap'', \pc \satisfies \cell'$. Using Lemma~\ref{lemma:no:double:unification}, 
                         we conclude that $\sepmodels{\cell \sep \cell' \sep \pc} = \emptyset$, from 
                         which it follows that $\sepmodels{\cells  \sep (\pc \, \wedge \, \pc')} = \emptyset$, 
                         obtaining a contradiction with \ieq{8}. 
                  \item If $\sheap''$ is part of $\sheap_f$,  we immediately get a contradiction with \ieq{6}.
              \end{itemize}
              Having established that: 
                $$
              	\forall \sheap'', \sheap_f' . \, \sheap = \sheap'' \dunion \sheap_f' \implies 
                     \big(
                        \smodels{\sheap'', \sstore}{\pc \, \wedge \, \pc'} \cap \sepmodels{\cells  \sep (\pc \, \wedge \, \pc')} = \emptyset
                      \big) \, \vee \, \sepmodels{\cells} = \emptyset  \text{ (\ieq{9})}
              $$ 
              the result follows immediately. 
        	      \vspace{6pt}
	      
          \item \prooflab{Extra Resource Failure} We conclude that
                   $\cellunificationiter{\sheap, \cells}{\sheap_f, []}{\pc}$ and $\sheap_f \neq \hemp$. Observing that 
                   the size of the symbolic heap is smaller than the number of cells against which it needs to be unified, 
                   we conclude the result. 
                   \vspace{6pt}
                        
          \item \prooflab{Pure Entailment Failure} We conclude that: 
                   $$
                   \cellunificationiter{\sheap, \cells}{\hemp, []}{\pc} \text{ (\ieq{10})}
                   \qquad 
                   \pc'' = \neg(\pc' \, \wedge \, \unificationef{\sheap}{\efs} \wedge \, \sanity{\efs}) \text{ (\ieq{11})} 
                   $$ 
                 
\end{itemize}
\end{proof} 




%  \cellunificationiter{\sheap, \cells}{\hemp, []}{\pc}
%	   \\\\
%	   \pc'' = \unificationef{\sheap}{\efs} \wedge \, \sanity{\efs}
%	   \quad
%             \pc \not\vdash \pfs' \, \wedge \, \pc''
%	}{\unificationfullfail{\sheap, \pc}{\cells, \efs, \pfs'}{}{\neg(\pc'  \, \wedge \, \pc'')}} 


