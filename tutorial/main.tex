\documentclass{article}

\let\proof\relax
\let\endproof\relax

\pagestyle{plain}

\usepackage{amsmath}

\usepackage{fullpage}
\usepackage{listings}
\usepackage{hyperref}

\usepackage[table]{xcolor}

\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{xspace}
\usepackage{amssymb,amsfonts,amsthm,latexsym,wasysym,mathrsfs,textcomp,stmaryrd}
\usepackage{mathpartir}
\usepackage{url}
\usepackage{gdshojs}

\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkblue}{rgb}{0,0.2,0.7}
\definecolor{dkgreen}{rgb}{0,0.4,0}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}
\definecolor{dkred}{rgb}{0.6,0,0}
\definecolor{talkred}{rgb}{0.69,.20,0.22}
\definecolor{talkblue}{rgb}{0.04,0.40,0.80}
\definecolor{talkgreen}{rgb}{0.34,.81,0.10}
\definecolor{oldtalkblue}{rgb}{0.22,.20,0.69}
\definecolor{greenish}{rgb}{.0,.65,.0}

\usepackage{tikz}
\usetikzlibrary{calc,positioning,arrows,shapes,decorations.pathmorphing}
\newcommand{\runpic}{\includegraphics[width=0.06\picwidth]{running.pdf}}
\newcommand{\tickpic}{\resizebox{0.06\picwidth}{!}{\(\color{greenish} \checkmark \)}}
\tikzset{
  box/.style = {rectangle, draw=black,align=center,font=\scriptsize},
  sbox/.style = {rectangle,draw=black,align=left,font=\scriptsize,text width=1.7cm},
  p/.style = {-latex},
  dp/.style = {latex-latex},
  sz/.style n args={2}{minimum width=#2, minimum height=#1},
  m/.style = {midway,inner sep=0pt,fill=white},
  ll/.style = {font=\scriptsize,anchor=south west}
}

\usepackage{lstjs}
\usepackage{lstjsivl}

% to define my language

%JavaScript - pretty
\definecolor{SkyBlue}{rgb}{0.20,0.39,0.64}
\definecolor{Plum}{rgb}{0.46,0.31,0.48}
\definecolor{Chocolate}{rgb}{0.75,0.49,0.07}
\definecolor{Aluminium5}{rgb}{0.33,0.34,0.32}
\definecolor{DarkGreen}{rgb}{0.2,0.5,0.2}

\lstdefinelanguage{JavaScript}{
  morekeywords=[1]{typeof, new, true, false, catch,
    function, return, null, catch, switch, var,
    if, in, while, do, else, case, break, continue},
  morekeywords=[2]{class, export, boolean, throw, implements, import, this},
  numbers=left,
  numbersep=4pt,
  numberstyle=\tiny\color{dkblue},
  columns=fullflexible,
  sensitive=false,
  comment=[l]{//},
  captionpos=b,   
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  basicstyle=\scriptsize\texttt,
  identifierstyle=\ttfamily\color{Aluminium5},
  keywordstyle=[1]\ttfamily\color{Plum},
  keywordstyle=[2]\ttfamily\color{SkyBlue},
  stringstyle=\ttfamily\color{DarkGreen},
  commentstyle=\ttfamily
}[keywords,comments,strings]

\usepackage{macros_js}

\newcommand{\jsil}{JSIL\xspace}
\newcommand{\jsverify}{JSVerify\xspace}
\newcommand{\polish}[1]{{\color{red}#1}}

\newcounter{main}
\setcounter{main}{1}

\lstnewenvironment{lstjs}{\lstset{language=JavaScript,basicstyle=\fontsize{8}{8}\ttfamily,escapeinside={~}{~}}}{}
\def\jsinline{\lstinline[language=JavaScript, basicstyle=\small]}

%\overfullrule=5pt

\newcommand{\alltests}{21301\xspace}

\newcommand{\stricttests}{10469\xspace}
\newcommand{\semdifftests}{345\xspace}
\newcommand{\nonimpltests}{1297\xspace}
\newcommand{\implbreaktests}{30\xspace}
\newcommand{\ourtests}{9160\xspace}

\newcommand{\apptests}{8797\xspace}

\newcommand{\ourpass}{8797\xspace}
\newcommand{\ourfail}{0\xspace}
\newcommand{\ourpercent}{100\%\xspace}

\usepackage{tikz}

\newcommand{\JSComp}{JS-2-JSIL\xspace}
\newcommand{\jsillogic}{\jsil logic\xspace}


\begin{document}

\title{JavaScript verification with JaVerT: more examples}
\author{Anonymous authors}

\maketitle

%\tableofcontents

\section{Overview}

We have further examples in addition to the priority queue example of the paper. One of them is a pedagogical counter example on systematically, abstractly handling function closures and is presented in detail in Section \ref{sec:closures}. Another is a simple key-value map, shown in Section \ref{sec:kvmap}, where the main point is dynamic property access. To illustrate set reasoning, we verify operations on binary search trees, whereas for list reasoning, we verify an insertion sort algorithm.\footnote{These two examples we have in common with KJS, so we can compare. On a machine with an Intel Core i7-4960X CPU 3.60GHz and DDR3 RAM 64GB, KJS takes 35.7 seconds in total to verify the correctness of the algorithms associated with BST trees, and 44.8 seconds to verify correctness of the insertion sort algorithm. On a machine with an Intel Core i7-4980HQ CPU 2.80 GHz and DDR3 RAM 16GB, which is approximately 30\% less powerful than the one used for KJS, JaVerT verifies the same BST algorithms in 8.5 seconds, and the insertion sort algorithm in 3.0 seconds.} The table below contains the statistics for these examples.

\begin{table}[!h]
	\centering
    \rowcolors{2}{SkyBlue!20}{white}
    \begin{tabular}{|lcccc|}
    \hline
      \rowcolor{SkyBlue!40}
      {\bfseries Example} & {\bfseries JS lines} & {\bfseries JSIL lines} & {\bfseries Verified specs} & {\bfseries Time(s)} \\
      \hline
      % Supposed parser failures, parsing, string/number casts
      Priority queue		&  40 &  912 &  10 & 9.2 \\
      Counter				&  19 &  412 &   4 & 3.9 \\ 
      Key-value map			&  21 &  470 &  22 & 4.7 \\
      BST					&  70 & 1033 &   6 & 8.5 \\
      Insertion sort		&  24 &  418 &   3 & 3.0 \\
      JS Internal functions & N/A & 1048 & 186 & 5.1 \\
      \hline
   \end{tabular}
  \caption{Verification statistics for the examples}
  \label{tab:stats}
\end{table}

These examples and all JavaScript programs in general heavily rely on the JavaScript internal functions. We list in the table also the breakdown for all of the internal functions that we have implemented in JSIL, axiomatically specified in JSIL Logic, and verified using JSIL Verify.

\newpage
\section{Function Closures: Counter}
\label{sec:closures}

JavaScript supports nested functions and function closures, meaning that one function literal can be declared within another and that functions can refer to variables that are defined in the enclosing scope. 
The relationships between the scope chains of such functions can become fairly complex and there are several challenges that the specification of function closures has to tackle. We illustrate these with the following example:

\begin{figure}[!h]
\centering
\begin{minipage}{0.75\textwidth}
\begin{lstjs}[firstnumber=1]
var make_counter = function () {
   var count = 0;

   var getCounter = function () { return count };
   var incCounter = function () { count++ };
   var decCounter = function () { count-- };

   return { getCounter: getCounter, incCounter: incCounter, decCounter: decCounter }
}

var counter_1 = make_counter();
var counter_2 = make_counter();

counter_1.incCounter();
counter_1.incCounter();

counter_2.incCounter();

var count = counter_1.getCounter() + counter_2.getCounter()
\end{lstjs}
\end{minipage}
\caption{Example: Function closures}
\label{fig:fc}
\end{figure}

The purpose of the function \jsinline|make_counter| is to provide an encapsulated counter. JavaScript has no native mechanism for providing encapsulation and encapsulation is usually simulated using function closures. One declares the resources that one wishes to keep private (in our case, the variable \jsinline|count|) inside the closure, and exposes only the interface for manipulating those resources (in our case, the functions \jsinline|getCounter|, \jsinline|incCounter|, and \jsinline|decCounter|) outside the closure. In our case, this is sufficient to achieve full encapsulation---there is no way for the programmer to access the counter directly outside \jsinline|make_counter|; in the general case, encapsulation cannot be guaranteed. In the rest of the program, we use \jsinline|make_counter| to create two counters, we increase the first one twice, the second one once, and assign their sum to the variable \jsinline|count|.

Let us specify this program. The \jsinline|getCounter|, \jsinline|incCounter|, and \jsinline|decCounter| functions are easy---we only need to be able to talk about the variable \jsinline|count|, which we do using the \jsinline|scope| assertion:

\bigskip
\begin{minipage}{0.36\textwidth}
\begin{lstjs}[firstnumber=1]
/**
  @id getCounter

  @pre (
    scope(count : #c) * 
    types(#c : $$number_type)
  )
  
  @post (
    scope(count : #c) * (ret == #c)
  )
*/

var getCounter = function () 
  { return count; }
\end{lstjs}
\end{minipage}
\begin{minipage}{0.33\textwidth}
\begin{lstjs}[firstnumber=1]
/**
  @id incCounter

  @pre (
    scope(count : #c) * 
    types(#c : $$number_type)
  )
  
  @post (
    scope(count : #c + 1)
  )
*/

var incCounter = function () 
  { count++ };
\end{lstjs}
\end{minipage}
\begin{minipage}{0.3\textwidth}
\begin{lstjs}[firstnumber=1]
/**
  @id decCounter

  @pre (
    scope(count : #c) * 
    types(#c : $$number_type)
  )
  
  @post (
    scope(count : #c - 1)
  )
*/

var decCounter = function () 
  { count-- };
\end{lstjs}
\end{minipage}

\bigskip
The more intricate part is specifying \jsinline|make_counter|. The precondition is easy, it is \jsinline|emp|, and for the postcondition we need to capture the object that is returned (denoted by \jsinline|c|) and all the associated resources. For starters, it is a standard JavaScript object that has three properties: \jsinline|getCounter|, \jsinline|incCounter|, and \jsinline|decCounter|.

\begin{lstjs}
standardObject(c) * 
dataField(c, "getCounter", #gc) * dataField(c, "incCounter", #ic) * dataField(c, "decCounter", #dc)
\end{lstjs}

Next, we need to state that the values of these properties correspond to the appropriate function objects:

\begin{lstjs}
fun_obj(getCounter, #gc, #gc_sc) * fun_obj(incCounter, #ic, #ic_sc) * fun_obj(decCounter, #dc, #dc_sc)
\end{lstjs}

The last bit of information that we need to capture is the one related to the closure---we need to express that the three functions all have the same variable \jsinline|count| in their scope and that its value is equal to zero. This is done by using our \jsinline|closure| abstraction:

\begin{lstjs}
closure(count: 0; getCounter: #gc_sc, incCounter: #ic_sc, decCounter: #dc_sc)
\end{lstjs}

This assertion states that the variable \jsinline|count| has value \jsinline|0| in the scope chains of \jsinline|getCounter|, \jsinline|incCounter|, and \jsinline|decCounter| (denoted by \jsinline|#gc_sc|, \jsinline|#ic_sc|, and \jsinline|#dc_sc|), and that these particular instances of these three functions were created in the same execution of \jsinline|make_counter|, i.e.~that they share the same function closure.

\begin{display}{Under the hood}
\ \ \begin{minipage}{0.97\textwidth}
The \jsinline|closure| abstraction can be unfolded to show the built-in assertions that are behind it:
\begin{lstjs}
closure(v1: #v1, ..., vm: #vm; f1: #f1_sc, ..., fn: #fn_sc) :
  sc_scope(f1, v1: #v1, #f1_sc) * ... * sc_scope(f1, vm: #vm, #f1_sc) *
  o_chains(f1: #f1_sc, f2: #f2_sc) * ... o_chains(f1: #f1_sc, fn: #fn_sc) * 
  o_chains(f2: #f2_sc, f3: #f3_sc) * ... o_chains(f2: #f2_sc, fn: #fn_sc) * 
   ...
  o_chains(fn-1: #fn-1_sc, fn: #fn_sc) 
\end{lstjs}

The \jsinline|sc_scope| assertion is a generalisation of the \jsinline|scope| assertion, where \jsinline|sc_scope(f, v: #v, #f_sc)| means that the variable \jsinline|v| has value \jsinline|#v| in the scope chain \jsinline|#f_sc| of the function \jsinline|f|. Recall that \jsinline|scope(v : #v)| means that the variable \jsinline|v| has value \jsinline|#v| in the scope chain of the function being specified and the name of the function and its scope chain are left implicit. 

The assertion \jsinline|o_chains(f: #f_sc, g: #g_sc)|, on the other hand, is a pure assertion that states that the scope chains of the functions \jsinline|f| and \jsinline|g|, denoted by \jsinline|#f_sc| and \jsinline|#g_sc|, maximally overlap, i.e.~that \jsinline|f| and \jsinline|g| were created in the same execution of the innermost enclosing function.

\end{minipage}
\end{display}



As we will be using \jsinline|make_counter| to create multiple counters, it makes sense to bring these assertions together into an abstraction that captures what it means to be a counter. Its parameters should only reflect the information necessary to reason about the counter: its location and its value. In this way, we successfully abstract all of the details about the function closure.

\medskip
\begin{lstjs}
pred counter(c, c_val) :
  standardObject(c) * 
  dataField(c, "getCounter", #gc) * 
  dataField(c, "incCounter", #ic) * 
  dataField(c, "decCounter", #dc) *
  fun_obj(getCounter, #gc, #gc_sc) * 
  fun_obj(incCounter, #ic, #ic_sc) *
  fun_obj(decCounter, #dc, #dc_sc) *
  closure(count: c_val; getCounter: #gc_sc, incCounter: #ic_sc, decCounter: #dc_sc) *
  types(c_val : $$number_type)
\end{lstjs}

\medskip
With this abstraction, the specification of \jsinline|make_counter| becomes quite compact:

\medskip
\begin{lstjs}[firstnumber=1]
/**
  @id makeCounter

  @pre (emp)
  
  @post (counter(ret, 0))
*/
var make_counter = function () {
   var count = 0;

   var getCounter = function () { return count };
   var incCounter = function () { count++ };
   var decCounter = function () { count-- };

   return { getCounter: getCounter, incCounter: incCounter, decCounter: decCounter }
}
\end{lstjs}

\medskip
Finally, we can specify the top-level code:
\begin{lstjs}[firstnumber=1]
/**
 @toprequires (emp)
 @topensures (
   scope(make_counter: #mc) *
   fun_obj(makeCounter, #mc, #mc_proto) *
   scope(counter_1: #c1) * counter(#c1, 2) *
   scope(counter_2: #c2) * counter(#c2, 1) *
   scope(count : 3)
 )
*/

var make_counter = function () {
   var count = 0;

   var getCounter = function () { return count };
   var incCounter = function () { count++ };
   var decCounter = function () { count-- };

   return { getCounter: getCounter, incCounter: incCounter, decCounter: decCounter }
}

var counter_1 = make_counter();
var counter_2 = make_counter();

counter_1.incCounter();
counter_1.incCounter();

counter_2.incCounter();

var count = counter_1.getCounter() + counter_2.getCounter()
\end{lstjs}

The specification states that we start from an empty precondition, and finish with: the variable \jsinline|make_counter|, holding the function object corresponding to the \jsinline|make_counter| function; the variables \jsinline|counter_1| and \jsinline|counter_2|, holding counters whose values are, respectively, \jsinline|2| and \jsinline|1|; and the variable \jsinline|count|, whose value is \jsinline|3|.








\section{Dynamic Property Access: Key-Value Map}
\label{sec:kvmap}
\hspace*{-0.5cm}
\begin{minipage}{0.98\textwidth}
\begin{lstjs}
/**	
  @pred validKey(key) : isNamedProperty(key) * (! (key == "hasOwnProperty"));
		
  @pred invalidKey(key) : 
    types (key : $$boolean_type), types (key : $$number_type), types (key : $$string_type) * (key == "hasOwnProperty");
  
  @pred Map(m, contents, mp) :
    ObjectWithProto(m, mp) * types(mp : $$object_type) * 
    dataField(m, "_contents", contents) * standardObject(contents) *
    ((contents, "hasOwnProperty") -> None) * ((m, "get") -> None) * ((m, "put") -> None);
  	
  @pred MapProto(mp) :
    standardObject(mp) * ((mp, "_contents") -> None) *
    dataField(mp, "get", #get_loc) * fun_obj(mapGet, #get_loc, #get_proto, #get_sc) *
    dataField(mp, "put", #put_loc) * fun_obj(mapPut, #put_loc, #put_proto, #put_sc);
*/

/** 
  @id isValidKey
	
  @pre  ((key == #key) * validKey(#key)) 										@post (ret == $$t)
  @pre ((key == #key) * invalidKey(#key))									@post (ret == $$f)
*/
function isValidKey(key) { return (typeof(key) === "string" && key !== "hasOwnProperty") }

/** @id  map

  @pre (ObjectWithProto(this, #mp) * MapProto(#mp) *
    ((this, "_contents") -> None) * ((this, "get") -> None) * ((this, "put") -> None))
  @post (Map(this, #contents, #hp) * MapProto(#mp))
*/
function Map () { this._contents = {}; }

/** 
  @id mapGet

  @pre (Map(this, #contents, #mp) * MapProto(#mp) * (key == #key) * validKey(#key) * dataField(#contents, #key, #v))
  @post (Map(this, #contents, #mp) * MapProto(#mp) * dataField(#contents, #key, #v) * (ret == #v))

  @pre (Map(this, #contents, #mp) * MapProto(#mp) * (key == #key) * validKey(#key) * emptyField(#contents, #key))
  @post (Map(this, #contents, #mp) * MapProto(#mp) * emptyField(#contents, #key) * (ret == $$null))

  @pre ((key == #key) * invalidKey(#key))
  @posterr (ErrorObjectWithMessage(err, "Invalid Key"))
*/
Map.prototype.get = function getValue (key) {  
  if (isValidKey(key)) { 
    if (this._contents.hasOwnProperty(key)) { return this._contents[key] } else { return null } 
  } else { throw new Error("Invalid Key") } 
}

/** 
  @id mapPut

  @pre (Map(this, #contents, #mp) * MapProto(#mp) *
    (key == #key) * validKey(#key) * (value == #value) * emptyField(#contents, #key))
  @post (Map(this, #contents, #mp) * MapProto(#mp) * dataField(#contents, #key, #value))

  @pre (Map(this, #contents, #mp) * MapProto(#mp) *
    (key == #key) * validKey(#key) * (value == #value) * dataFieldGeneral(#contents, #key, #oV, $$t, #e, #c))
  @post (Map(this, #contents, #mp) * MapProto(#mp) * dataFieldGeneral(#contents, #key, #value, $$t, #e, #c))

  @pre (Map(this, #contents, #mp) * MapProto(#mp) *
    (key == #key) * validKey(#key) * (value == #value) * dataFieldGeneral(#contents, #key, #oV, $$f, #e, #c))
  @posterr (Map(this, #contents, #mp) * MapProto(#mp) * dataFieldGeneral(#contents, #key, #oV, $$f, #e, #c) * 
    isTypeError(err))

  @pre ((key == #key) * invalidKey(#key))
  @posterr (ErrorObjectWithMessage(err, "Invalid Key"))
*/
Map.prototype.put = function (key, value) {
   if (isValidKey(key)) { this._contents[key] = value } else throw new Error("Invalid Key")
} 
\end{lstjs}
\end{minipage}

We illustrate our handling of dynamic property access by appealing to the example of a key-value map implementation in JavaScript, shown and specified in full on the previous page. A map is an object whose property \jsinline|_contents| holds an object that serves as the actual map---its property names (which are strings) are the map keys and their values (which are arbitrary) are the map values. We provide functionalities for retrieving and setting the value of a given key (\jsinline|get| and \jsinline|put|), both of which we store in \jsinline|Map.prototype|.

This example draws several parallels with the priority queue example of the paper. However, reasoning about contents of a map has an additional layer of complexity. While node objects always have the static \jsinline|pri|, \jsinline|val|, and \jsinline|next| properties inside node,  the objects representing the contents of maps may have arbitrary properties. This is seen in the specifications of \jsinline|get| and \jsinline|put| functions; more specifically, in the abstractions \jsinline|dataField(#contents, #key)| and \jsinline|emptyField(#contents, #key)|, where the value of \jsinline|#key| is not staticall known. JSIL Verify was designed to handle dynamic property access and has no problems reasoning about it, as indicated by the time required to verify all of the specifications shown in Table \ref{tab:stats}.

This example illustrates the common practice of testing if an object has an own property using the built-in function \jsinline|hasOwnProperty|, which lives in \jsinline|Object.prototype|. Specifying this example reveals a potential flaw in such programs, that has to do with prototype safety. Namely, the hashtable can override \jsinline|hasOwnProperty| by having the key \jsinline|"hasOwnProperty"| itself, and again, the specifications have to account for that. Our ad-hoc solution is to exclude the string \jsinline|hasOwnProperty| from the set of valid keys. There are different ways in which this can be handle more elegantly, but these are not the point of this example.

\begin{display}{Further work}
\ \ \begin{minipage}{0.97\textwidth}
This specification can be written more abstractly. We could have a \jsinline|Map| abstraction capturing the property names currently in the map, together with their values. This abstraction, together with similar abstractions that would allow us to reason about, for example, the JavaScript \jsinline|for-in| construct, are part of our immediate further work.
\end{minipage}
\end{display}

\end{document}